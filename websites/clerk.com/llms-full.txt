---
title: '`<ClerkLoaded>`'
description: The `<ClerkLoaded>` component guarantees that the Clerk object has loaded and will be available under `window.Clerk`. This allows you to wrap child components to access the Clerk object without the need to check it exists.
---

The `<ClerkLoaded>` component guarantees that the Clerk object has loaded and will be available under `window.Clerk`. This allows you to wrap child components to access the `Clerk` object without the need to check it exists.

## Usage

It's not recommended to wrap the entire app in the `<ClerkLoaded>` component; instead, only wrap the components that need access to the `Clerk` object.

<Tabs items={["Next.js", "React", "Remix", "Expo"]}>
  <Tab>
    <Tabs items={["App Router", "Pages Router"]}>
      <Tab>
        ```tsx {{ filename: 'app/page.tsx' }}
        import { ClerkLoaded } from '@clerk/nextjs'

        export default function Page() {
          return (
            <ClerkLoaded>
              <p>Clerk has loaded</p>
              <MyCustomSignInFlow />
            </ClerkLoaded>
          )
        }
        ```
      </Tab>

      <Tab>
        ```tsx {{ filename: 'pages/index.tsx' }}
        import { ClerkLoaded } from '@clerk/nextjs'

        export default function Page() {
          return (
            <ClerkLoaded>
              <p>Clerk has loaded</p>
              <MyCustomSignInFlow />
            </ClerkLoaded>
          )
        }
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab>
    ```tsx {{ filename: 'example.tsx' }}
    import { ClerkLoaded } from '@clerk/clerk-react'

    declare global {
      interface Window {
        Clerk: any
      }
    }

    export default function Example() {
      return (
        <ClerkLoaded>
          <p>Clerk has loaded</p>
        </ClerkLoaded>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'routes/index.tsx' }}
    import { ClerkLoaded } from '@clerk/remix'

    declare global {
      interface Window {
        Clerk: any
      }
    }

    export default function Index() {
      return (
        <div>
          <ClerkLoaded>
            <p>Clerk has loaded</p>
          </ClerkLoaded>
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/index.tsx' }}
    import { ClerkLoaded } from '@clerk/clerk-expo'
    import { Text, View } from 'react-native'

    export default function Screen() {
      return (
        <View>
          <ClerkLoaded>
            <Text>Clerk has loaded</Text>
          </ClerkLoaded>
        </View>
      )
    }
    ```
  </Tab>
</Tabs>

---
title: '`<ClerkLoading>`'
description: The `<ClerkLoading>` renders its children while Clerk is loading, and is helpful for showing a custom loading state.
---

The `<ClerkLoading>` renders its children while Clerk is loading, and is helpful for showing a custom loading state.

## Usage

It's not recommended to wrap the entire app in the `<ClerkLoading>` component; instead, only wrap the components that need access to the `Clerk` object.

<Tabs items={["Next.js", "React", "Remix", "Expo"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: 'app/page.tsx' }}
      import { ClerkLoaded, ClerkLoading } from '@clerk/nextjs'

      declare global {
        interface Window {
          Clerk: any
        }
      }

      export default function Page() {
        return (
          <>
            <ClerkLoading>
              <p>Clerk is loading...</p>
            </ClerkLoading>
            <ClerkLoaded>
              <p>Clerk has loaded</p>
            </ClerkLoaded>
          </>
        )
      }
      ```

      ```tsx {{ filename: 'pages/index.tsx' }}
      import { ClerkLoaded, ClerkLoading } from '@clerk/nextjs'

      declare global {
        interface Window {
          Clerk: any
        }
      }

      export default function Page() {
        return (
          <>
            <ClerkLoading>
              <p>Clerk is loading</p>
            </ClerkLoading>
            <ClerkLoaded>
              <p>Clerk has loaded</p>
            </ClerkLoaded>
          </>
        )
      }
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    ```tsx {{ filename: 'example.tsx' }}
    import { ClerkLoaded, ClerkLoading } from '@clerk/clerk-react'

    declare global {
      interface Window {
        Clerk: any
      }
    }

    export default function Example() {
      return (
        <>
          <ClerkLoading>
            <p>Clerk is loading</p>
          </ClerkLoading>
          <ClerkLoaded>
            <p>Clerk has loaded</p>
          </ClerkLoaded>
        </>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'routes/index.tsx' }}
    import { ClerkLoading, ClerkLoaded } from '@clerk/remix'

    declare global {
      interface Window {
        Clerk: any
      }
    }

    export default function Index() {
      return (
        <>
          <ClerkLoading>
            <p>Clerk is loading</p>
          </ClerkLoading>
          <ClerkLoaded>
            <p>Clerk has loaded</p>
          </ClerkLoaded>
        </>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/index.tsx' }}
    import { ClerkLoading, ClerkLoaded } from '@clerk/clerk-expo'
    import { Text, View } from 'react-native'

    declare global {
      interface Window {
        Clerk: any
      }
    }

    export default function Screen() {
      return (
        <View>
          <ClerkLoading>
            <Text>Clerk is loading</Text>
          </ClerkLoading>
          <ClerkLoaded>
            <Text>Clerk has loaded</Text>
          </ClerkLoaded>
        </View>
      )
    }
    ```
  </Tab>
</Tabs>

---
title: '`<ClerkProvider>`'
description: The <ClerkProvider> component provides session and user context to Clerk's hooks and components.
---

The `<ClerkProvider>` component is required to integrate Clerk into your React application, providing session and user context to Clerk's hooks and components.

The recommended approach is to wrap your entire app with `<ClerkProvider>` at the entry point to make authentication globally accessible. If you only need authentication for specific routes or pieces of your application, render `<ClerkProvider>` deeper in the component tree. This allows you to implement Clerk's functionality precisely where required without impacting the rest of your app.

## Usage

<Tabs items={["Next.js", "React", "Expo", "React Router", "Tanstack React Start"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: 'app/layout.tsx' }}
      import React from 'react'
      import { ClerkProvider } from '@clerk/nextjs'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <ClerkProvider>
            <html lang="en">
              <body>{children}</body>
            </html>
          </ClerkProvider>
        )
      }
      ```

      ```tsx {{ filename: '_app.tsx' }}
      import { ClerkProvider } from '@clerk/nextjs'
      import type { AppProps } from 'next/app'

      function MyApp({ Component, pageProps }: AppProps) {
        return (
          <ClerkProvider {...pageProps}>
            <Component {...pageProps} />
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    ```tsx {{ filename: 'index.tsx' }}
    import React from 'react'
    import ReactDOM from 'react-dom/client'
    import App from './App.tsx'
    import { ClerkProvider } from '@clerk/clerk-react'

    // Import your Publishable Key
    const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

    if (!PUBLISHABLE_KEY) {
      throw new Error('Add your Clerk Publishable Key to the .env file')
    }

    ReactDOM.createRoot(document.getElementById('root')!).render(
      <React.StrictMode>
        <ClerkProvider publishableKey={PUBLISHABLE_KEY} afterSignOutUrl="/">
          <App />
        </ClerkProvider>
      </React.StrictMode>,
    )
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/_layout.tsx' }}
    import { ClerkProvider } from '@clerk/clerk-expo'
    import { Slot } from 'expo-router'

    export default function Layout() {
      return (
        <ClerkProvider>
          <Slot />
        </ClerkProvider>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/root.tsx' }}
    // Other imports

    import { ClerkProvider, SignedIn, SignedOut, UserButton, SignInButton } from '@clerk/react-router'

    export default function App({ loaderData }: Route.ComponentProps) {
      return (
        <ClerkProvider
          loaderData={loaderData}
          signUpFallbackRedirectUrl="/"
          signInFallbackRedirectUrl="/"
        >
          <header className="flex items-center justify-center py-8 px-4">
            <SignedOut>
              <SignInButton />
            </SignedOut>
            <SignedIn>
              <UserButton />
            </SignedIn>
          </header>
          <main>
            <Outlet />
          </main>
        </ClerkProvider>
      )
    }

    // Rest of the root.tsx code
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/routes/__root.tsx', ins: [4, 18, 29] }}
    import { Outlet, createRootRoute } from '@tanstack/react-router'
    import { Meta, Scripts } from '@tanstack/react-start'
    import * as React from 'react'
    import { ClerkProvider } from '@clerk/tanstack-react-start'

    export const Route = createRootRoute({
      component: () => {
        return (
          <RootDocument>
            <Outlet />
          </RootDocument>
        )
      },
    })

    function RootDocument({ children }: { children: React.ReactNode }) {
      return (
        <ClerkProvider>
          <html>
            <head>
              <Meta />
            </head>
            <body>
              {children}
              <Scripts />
            </body>
          </html>
        </ClerkProvider>
      )
    }
    ```
  </Tab>
</Tabs>

## Properties

<Include src="_partials/clerk-provider/properties" />

---
title: '`<CreateOrganization />` component'
description: Clerk's <CreateOrganization /> component is used to render an organization creation UI that allows users to create brand new organizations within your application.
---

![The \<CreateOrganization /> component renders an organization creation UI that allows users to create brand new organizations within your application.](/docs/images/ui-components/create-organization.png){{ style: { maxWidth: '492px' } }}

The `<CreateOrganization />` component is used to render an organization creation UI that allows users to create brand new organizations in your application.

## Properties

All props are optional.

<Properties>
  - `appearance`
  - <code>[Appearance](/docs/customization/overview) | undefined</code>

  Optional object to style your components. Will only affect [Clerk components](/docs/components/overview) and not [Account Portal](/docs/account-portal/overview) pages.

  ---

  - `afterCreateOrganizationUrl`
  - `string`

  Full URL or path to navigate to after creating a new organization.

  ---

  - `routing`
  - `'hash' | 'path'`

  The [routing](/docs/guides/routing) strategy for your pages.  Defaults to `'path'` for frameworks that handle routing, such as Next.js and Remix. Defaults to `hash` for all other SDK's, such as React.

  ---

  - `path`
  - `string`

  The path where the component is mounted on when `routing` is set to `path`. It is ignored in hash-based routing. For example: `/create-organization`.

  ---

  - `skipInvitationScreen`
  - `boolean`

  Hides the screen for sending invitations after an organization is created. When left undefined, Clerk will automatically hide the screen if the number of max allowed members is equal to 1

  ---

  - `hideSlug`
  - `boolean`

  Hides the optional slug field in the organization creation screen.

  ---

  - `fallback?`
  - `ReactNode`

  An optional element to be rendered while the component is mounting.
</Properties>

## Usage with frameworks

The following example includes a basic implementation of the `<CreateOrganization />` component. You can use this as a starting point for your own implementation.

<Tabs items={["Next.js", "React", "Astro", "Remix", "Tanstack React Start", "Vue"]}>
  <Tab>
    ```jsx {{ filename: 'app/create-organization/[[...create-organization]]/page.tsx' }}
    import { CreateOrganization } from '@clerk/nextjs'

    export default function CreateOrganizationPage() {
      return <CreateOrganization />
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'create-organization.tsx' }}
    import { CreateOrganization } from '@clerk/clerk-react'

    export default function CreateOrganizationPage() {
      return <CreateOrganization />
    }
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: '/pages/create-organization.astro' }}
    ---
    import { CreateOrganization } from '@clerk/astro/components'
    ---

    <CreateOrganization />
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: '/route/create-organization/$.tsx' }}
    import { CreateOrganization } from '@clerk/remix'

    export default function CreateOrganizationPage() {
      return <CreateOrganization />
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/routes/create-organization.tsx' }}
    import { CreateOrganization } from '@clerk/tanstack-react-start'
    import { createFileRoute } from '@tanstack/react-router'

    export const Route = createFileRoute('/create-organization')({
      component: CreateOrganization,
    })

    function CreateOrganization() {
      return <CreateOrganization />
    }
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'create-organization.vue' }}
    <script setup lang="ts">
    import { CreateOrganization } from '@clerk/vue'
    </script>

    <template>
      <CreateOrganization />
    </template>
    ```
  </Tab>
</Tabs>

## Usage with JavaScript

The following methods available on an instance of the [`Clerk`](/docs/references/javascript/clerk) class are used to render and control the `<CreateOrganization />` component:

- [`mountCreateOrganization`](#mount-create-organization)
- [`unmountCreateOrganization`](#unmount-create-organization)
- [`openCreateOrganization`](#open-create-organization)
- [`closeCreateOrganization`](#close-create-organization)

The following examples assume that you have followed the [quickstart](/docs/quickstarts/javascript) in order to add Clerk to your JavaScript application.

### <code>mountCreate<wbr />Organization()</code>

Render the `<CreateOrganization />` component to an HTML `<div>` element.

```typescript
function mountCreateOrganization(node: HTMLDivElement, props?: CreateOrganizationProps): void
```

### <code>mountCreate<wbr />Organization()</code> params

<Properties>
  - `node`
  - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

  The `<div>` element used to render in the `<CreateOrganization />` component

  ---

  - `props?`
  - [`CreateOrganizationProps`](#properties)

  The properties to pass to the `<CreateOrganization />` component
</Properties>

#### `mountCreateOrganization()` usage

```js {{ filename: 'main.js', mark: [15] }}
import { Clerk } from '@clerk/clerk-js'

// Initialize Clerk with your Clerk Publishable Key
const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

const clerk = new Clerk(clerkPubKey)
await clerk.load()

document.getElementById('app').innerHTML = `
  <div id="create-organization"></div>
`

const createOrgDiv = document.getElementById('create-organization')

clerk.mountCreateOrganization(createOrgDiv)
```

### <code>unmountCreate<wbr />Organization()</code>

Unmount and run cleanup on an existing `<CreateOrganization />` component instance.

```typescript
function unmountCreateOrganization(node: HTMLDivElement): void
```

#### `unmountCreateOrganization()` params

<Properties>
  - `node`
  - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

  The container `<div>` element with a rendered `<CreateOrganization />` component instance
</Properties>

#### `unmountCreateOrganization()` usage

```js {{ filename: 'main.js', mark: [19] }}
import { Clerk } from '@clerk/clerk-js'

// Initialize Clerk with your Clerk Publishable Key
const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

const clerk = new Clerk(clerkPubKey)
await clerk.load()

document.getElementById('app').innerHTML = `
  <div id="create-organization"></div>
`

const createOrgDiv = document.getElementById('create-organization')

clerk.mountCreateOrganization(createOrgDiv)

// ...

clerk.unmountCreateOrganization(createOrgDiv)
```

### `openCreateOrganization()`

Opens the `<CreateOrganization />` component as an overlay at the root of your HTML `body` element.

```typescript
function openCreateOrganization(props?: CreateOrganizationProps): void
```

#### `openCreateOrganization()` params

<Properties>
  - `props?`
  - [`CreateOrganizationProps`](#properties)

  The properties to pass to the `<CreateOrganization />` component
</Properties>

#### `openCreateOrganization()` usage

```js {{ filename: 'main.js', mark: [15] }}
import { Clerk } from '@clerk/clerk-js'

// Initialize Clerk with your Clerk Publishable Key
const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

const clerk = new Clerk(clerkPubKey)
await clerk.load()

document.getElementById('app').innerHTML = `
  <div id="create-organization"></div>
`

const createOrgDiv = document.getElementById('create-organization')

clerk.openCreateOrganization(createOrgDiv)
```

### `closeCreateOrganization()`

Closes the organization profile overlay.

```typescript
function closeCreateOrganization(): void
```

#### `closeCreateOrganization()` usage

```js {{ filename: 'main.js', mark: [19] }}
import { Clerk } from '@clerk/clerk-js'

// Initialize Clerk with your Clerk Publishable Key
const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

const clerk = new Clerk(clerkPubKey)
await clerk.load()

document.getElementById('app').innerHTML = `
  <div id="create-organization"></div>
`

const createOrgDiv = document.getElementById('create-organization')

clerk.openCreateOrganization(createOrgDiv)

// ...

clerk.closeCreateOrganization(createOrgDiv)
```

## Customization

To learn about how to customize Clerk components, see the [customization documentation](/docs/customization/overview).

---
title: '`<GoogleOneTap />` component'
description: Clerk's <GoogleOneTap /> component renders a UI for authenticating users with Google's One Tap API.
---

> [!IMPORTANT]
> To use Google One Tap with Clerk, you must [enable Google as a social connection in the Clerk Dashboard](/docs/authentication/social-connections/google#configure-for-your-production-instance) and make sure to use custom credentials.

The `<GoogleOneTap />` component renders the [Google One Tap](https://developers.google.com/identity/gsi/web/guides/features) UI so that users can use a single button to sign-up or sign-in to your Clerk application with their Google accounts.

By default, this component will redirect users back to the page where the authentication flow started. However, you can override this with [force redirect URL props](#google-one-tap-props) or [force redirect URL environment variables](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects).

## `GoogleOneTapProps`

<Properties>
  - `cancelOnTapOutside?`
  - `boolean`

  If `true`, the One Tap prompt closes automatically if the user clicks outside of the prompt. Default: `true`.

  ---

  - `itpSupport?`
  - `boolean`

  If `true`, enables the [ITP-specific UX](https://developers.google.com/identity/gsi/web/guides/itp) when One Tap is rendered on ITP browsers such as Chrome on iOS, Safari, and FireFox. Default: `true`.

  ---

  - `fedCmSupport?`
  - `boolean`

  If `true`, enables Google One Tap to use [the FedCM API](https://developers.google.com/privacy-sandbox/3pcd/fedcm) to sign users in. See Google's docs on [best practices when disabling FedCM support](https://developers.google.com/identity/gsi/web/guides/display-google-one-tap#do_not_cover_google_one_tap). Default: `true`

  ---

  - `signInForceRedirectUrl?`
  - `string`

  Useful if you want to redirect to a path specific to Google One Tap users. If provided, this URL will **always** be redirected to after the user signs in, overriding any [`<ClerkProvider>` redirect URL props](/docs/components/clerk-provider#properties) or [redirect URL environment variables](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects).

  ---

  - `signUpForceRedirectUrl?`
  - `string`

  Useful if you want to redirect to a path specific to Google One Tap users. If provided, this URL will **always** be redirected to after the user signs up, overriding any [`<ClerkProvider>` redirect URL props](/docs/components/clerk-provider#properties) or [redirect URL environment variables](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects).
</Properties>

## Usage with frameworks

The following example includes basic implementation of the `<GoogleOneTap />` component. You can use this as a starting point for your own implementation.

> [!NOTE]
> `<GoogleOneTap>` does not render if the user is already signed into your Clerk application, so there's no need to manually check if a user is signed in yourself before rendering it.

<Tabs items={["Next.js", "React", "Astro", "Remix", "Tanstack React Start", "Vue"]}>
  <Tab>
    ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx' }}
    import { GoogleOneTap } from '@clerk/nextjs'

    export default function Page() {
      return <GoogleOneTap />
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'src/sign-in.tsx' }}
    import { GoogleOneTap } from '@clerk/clerk-react'

    const SignInPage = () => <GoogleOneTap />

    export default SignInPage
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: 'pages/sign-in.astro' }}
    ---
    import { GoogleOneTap } from '@clerk/astro/components'
    ---

    <GoogleOneTap />
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'app/routes/sign-in/$.tsx' }}
    import { GoogleOneTap } from '@clerk/remix'

    export default function Page() {
      return <GoogleOneTap />
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/routes/sign-in.tsx' }}
    import { GoogleOneTap } from '@clerk/tanstack-react-start'
    import { createFileRoute } from '@tanstack/react-router'

    export const Route = createFileRoute('/sign-in')({
      component: SignIn,
    })

    function SignIn() {
      return <GoogleOneTap />
    }
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'sign-in.vue' }}
    <script setup lang="ts">
    import { GoogleOneTap } from '@clerk/vue'
    </script>

    <template>
      <GoogleOneTap />
    </template>
    ```
  </Tab>
</Tabs>

## Usage with JavaScript

The methods in this section are available on instances of the [`Clerk`](/docs/references/javascript/clerk) class and are used to render and control the `<GoogleOneTap />` component.

> [!NOTE]
> The examples in this section assume you have completed the [JavaScript quickstart](/docs/quickstarts/javascript) to set up the ClerkJS SDK in your project.

### `openGoogleOneTap()`

Opens the `<GoogleOneTap />` component.

```typescript
function openGoogleOneTap(params: GoogleOneTapProps): void
```

- See [`GoogleOneTapProps`](#google-one-tap-props)

#### `openGoogleOneTap()` usage

```js {{ filename: 'main.js', mark: [[9, 14]] }}
import { Clerk } from '@clerk/clerk-js'

// Initialize Clerk with your Clerk Publishable Key
const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

const clerk = new Clerk(clerkPubKey)
await clerk.load()

const params = {
  cancelOnTapOutside: false,
  itpSupport: false,
  fedCmSupport: false,
}
clerk.openGoogleOneTap(params)
```

### `closeGoogleOneTap()`

Closes the `<GoogleOneTap />` component.

```typescript
function closeGoogleOneTap(): void
```

#### `closeGoogleOneTap()` usage

```js {{ filename: 'main.js', mark: [18] }}
import { Clerk } from '@clerk/clerk-js'

// Initialize Clerk with your Clerk Publishable Key
const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

const clerk = new Clerk(clerkPubKey)
await clerk.load()

const params = {
  cancelOnTapOutside: false,
  itpSupport: false,
  fedCmSupport: false,
}
clerk.openGoogleOneTap(params)

// Do something else

clerk.closeGoogleOneTap()
```

### `authenticateWithGoogleOneTap()`

Authenticates the user with a token generated from Google identity services. Also sets the user's current session to active.

```typescript
function authenticateWithGoogleOneTap(
  props?: AuthenticateWithGoogleOneTapParams,
): Promise<SignInResource | SignUpResource>
```

#### `AuthenticateWithGoogleOneTapParams`

<Properties>
  - `token?`
  - `string`

  A Google authentication token from Google identity services.
</Properties>

#### `authenticateWithGoogleOneTap()` usage

```js {{ filename: 'main.js', mark: [[9, 17]] }}
import { Clerk } from '@clerk/clerk-js'

// Initialize Clerk with your Clerk Publishable Key
const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

const clerk = new Clerk(clerkPubKey)
await clerk.load()

// Optionally, you can set redirect URLs.
const customUrls = {
  signInUrl: '/sign-in',
  signUpUrl: '/sign-up',
}
// Initiate the authentication flow.
const signInOrUp = await clerk.authenticateWithGoogleOneTap({ token: 'xxxx' })
// Set the session as active, and handle any navigation or redirects
await clerk.handleGoogleOneTapCallback(signInOrUp, customUrls)
```

### `handleGoogleOneTapCallback()`

Completes a Google One Tap redirection flow started by [`authenticateWithGoogleOneTap()`](#authenticate-with-google-one-tap). Also calls [`Clerk.setActive()`](/docs/references/javascript/clerk#set-active) and performs a custom navigation if given a custom navigation function.

```typescript
function handleGoogleOneTapCallback(
  signInOrUp: SignInResource | SignUpResource,
  params: HandleOAuthCallbackParams,
  customNavigate?: (to: string) => Promise<unknown>,
): Promise<unknown>
```

See [`authenticateWithGoogleOneTap()` usage](#authenticate-with-google-one-tap-usage) for an example of how to use `handleGoogleOneTapCallback()`.

#### `handleGoogleOneTapCallback()` params

<Properties>
  - `signInOrUp`
  - <code>[SignInResource](/docs/references/javascript/sign-in) | [SignUpResource](/docs/references/javascript/sign-up)</code>

  The `SignIn` or `SignUp` object returned from `authenticateWithGoogleOneTap()`.

  ---

  - `params`
  - [`HandleOAuthCallbackParams`](/docs/references/javascript/clerk#handle-o-auth-callback-params)

  An object containing redirect URLs. Useful if you want to set URLs specific to Google One Tap. Otherwise, consider using [environment variables](/docs/deployments/clerk-environment-variables) to set redirect URLs.

  ---

  - `customNavigate?`
  - `(to: string) => Promise<unknown>`

  A function that overrides Clerk's default navigation behavior, allowing custom handling of navigation during sign-up and sign-in flows.
</Properties>

## Limitations

- If your application will use the Google API on behalf of your users, the `<GoogleOneTap>` component is not recommended, as Google does not provide Clerk with an access or refresh token that you can use.
- Users with the 1Password browser extension may not be able to render the Google One Tap UI. They must disable this extension.
- When testing in development, if you select the `X` button to close the Google One Tap UI, you may encounter [a cooldown](https://developers.google.com/identity/gsi/web/guides/features#exponential_cooldown) that prevents you from rendering it again for a period of time. To bypass the cooldown, remove the `g_state` cookie.

---
title: '`<OrganizationList />` component'
description: Clerk's <OrganizationList /> component is used to display organization related memberships, invitations, and suggestions for the user.
---

![The \<OrganizationList /> component displays organization-related memberships and automatic invitations and suggestions for the user.](/docs/images/ui-components/organization-list.png){{ style: { maxWidth: '460px' } }}

The `<OrganizationList />` component displays organization-related memberships and automatic [invitations](/docs/organizations/verified-domains#automatic-invitations) and [suggestions](/docs/organizations/verified-domains#automatic-suggestions) for the user.

## Properties

The `<OrganizationList />` component accepts the following properties, all of which are **optional**:

<Properties>
  - `afterCreateOrganizationUrl`
  - <code>((org: [Organization][org-ref]) => string) | string</code>

  The full URL or path to navigate to after creating a new organization.

  ---

  - `afterSelectOrganizationUrl`
  - <code>((org: [Organization][org-ref]) => string) | string</code>

  The full URL or path to navigate to after selecting an organization. Defaults to `undefined`.

  ---

  - `afterSelectPersonalUrl`
  - <code>((org: [Organization][org-ref]) => string) | string</code>

  The full URL or path to navigate to after selecting the personal account. Defaults to `undefined`.

  ---

  - `appearance`
  - <code>[Appearance](/docs/customization/overview) | undefined</code>

  Optional object to style your components. Will only affect [Clerk components](/docs/components/overview) and not [Account Portal](/docs/account-portal/overview) pages.

  ---

  - `fallback?`
  - `ReactNode`

  An optional element to be rendered while the component is mounting.

  ---

  - `hidePersonal`
  - `boolean`

  A boolean that controls whether `<OrganizationList />` will include the user's personal account in the organization list. Setting this to `true` will hide the personal account option, and users will only be able to switch between organizations. Defaults to `false`.

  ---

  - `hideSlug`
  - `boolean`

  A boolean that controls whether the optional slug field in the organization creation screen is hidden. Defaults to `false`.

  ---

  - `skipInvitationScreen`
  - `boolean | undefined`

  A boolean that controls whether the screen for sending invitations after an organization is created is hidden. When `undefined`, Clerk will automatically hide the screen if the number of max allowed members is equal to 1. Defaults to `false`.
</Properties>

## Usage with frameworks

<Tabs items={["Next.js", "React", "Astro", "Remix", "Tanstack React Start", "Vue"]}>
  <Tab>
    ```jsx {{ filename: 'app/organizations/page.tsx' }}
    import { OrganizationList } from '@clerk/nextjs'

    export default function OrganizationListPage() {
      return (
        <OrganizationList
          afterCreateOrganizationUrl="/organization/:slug"
          afterSelectPersonalUrl="/user/:id"
          afterSelectOrganizationUrl="/organization/:slug"
        />
      )
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'organizations.tsx' }}
    import { OrganizationList } from '@clerk/clerk-react'

    export default function OrganizationListPage() {
      return (
        <OrganizationList
          afterCreateOrganizationUrl={(org) => `/organization/${org.slug}`}
          afterSelectPersonalUrl={(user) => `/user/${user.id}`}
          afterSelectOrganizationUrl={(org) => `/organization/${org.slug}`}
        />
      )
    }
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: '/pages/organizations.astro' }}
    ---
    import { OrganizationList } from '@clerk/astro/components'
    ---

    <OrganizationList
      afterCreateOrganizationUrl="/organization/:slug"
      afterSelectPersonalUrl="/user/:id"
      afterSelectOrganizationUrl="/organization/:slug"
    />
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: '/route/organizations.tsx' }}
    import { OrganizationList } from '@clerk/remix'

    export default function OrganizationListPage() {
      return (
        <OrganizationList
          afterCreateOrganizationUrl={(org) => `/organization/${org.slug}`}
          afterSelectPersonalUrl={(user) => `/user/${user.id}`}
          afterSelectOrganizationUrl={(org) => `/organization/${org.slug}`}
        />
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/routes/organizations.tsx' }}
    import { OrganizationList } from '@clerk/tanstack-react-start'
    import { createFileRoute } from '@tanstack/react-router'

    export const Route = createFileRoute('/organizations')({
      component: OrganizationList,
    })

    function OrganizationList() {
      return (
        <OrganizationList
          afterCreateOrganizationUrl={(org) => `/organization/${org.slug}`}
          afterSelectPersonalUrl={(user) => `/user/${user.id}`}
          afterSelectOrganizationUrl={(org) => `/organization/${org.slug}`}
        />
      )
    }
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'organizations.vue' }}
    <script setup lang="ts">
    import { OrganizationList } from '@clerk/vue'
    </script>

    <template>
      <OrganizationList
        :after-create-organization-url="(org) => `/organization/${org.slug}`"
        :after-select-personal-url="(org) => `/organization/${org.slug}`"
        :after-select-organization-url="(org) => `/organization/${org.slug}`"
      />
    </template>
    ```
  </Tab>
</Tabs>

<If sdk="js-frontend">
  ## Usage with JavaScript

  The following methods available on an instance of the [`Clerk`](/docs/references/javascript/clerk) class are used to render and control the `<OrganizationList />` component:

  - [`mountOrganizationList()`](#mount-organization-list)
  - [`unmountOrganizationList()`](#unmount-organization-list)

  The following examples assume that you have followed the [quickstart](/docs/quickstarts/javascript) in order to add Clerk to your JavaScript application.

  ## `mountOrganizationList()`

  Render the `<OrganizationList />` component to an HTML `<div>` element.

  ```typescript
  function mountOrganizationList(node: HTMLDivElement, props?: OrganizationListProps): void
  ```

  ### `mountOrganizationList()` params

  <Properties>
    - `node`
    - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

    The `<div>` element used to render in the `<OrganizationList />` component

    ---

    - `props?`
    - [`OrganizationListProps`](#properties)

    The properties to pass to the `<OrganizationList />` component
  </Properties>

  ### `mountOrganizationList()` usage

  ```js {{ filename: 'main.js', mark: [15] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  document.getElementById('app').innerHTML = `
    <div id="organization-list"></div>
  `

  const orgListDiv = document.getElementById('organization-list')

  clerk.mountOrganizationList(orgListDiv)
  ```

  ## `unmountOrganizationList()`

  Unmount and run cleanup on an existing `<OrganizationList />` component instance.

  ```typescript
  function unmountOrganizationList(node: HTMLDivElement): void
  ```

  ### `unmountOrganizationList()` params

  <Properties>
    - `node`
    - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

    The container `<div>` element with a rendered `<OrganizationList />` component instance
  </Properties>

  ### `unmountOrganizationList()` usage

  ```js {{ filename: 'main.js', mark: [19] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  document.getElementById('app').innerHTML = `
    <div id="organization-list"></div>
  `

  const orgListDiv = document.getElementById('organization-list')

  clerk.mountOrganizationList(orgListDiv)

  // ...

  clerk.unmountOrganizationList(orgListDiv)
  ```
</If>

## Force organizations

If you would like to prohibit people from using their personal accounts and force them to be part of an organization, the `hidePersonal` property forces your user to join or create an organization in order to continue. For more information on how to hide personal accounts and force organizations, see the [dedicated guide](/docs/organizations/force-organizations).

```tsx {{ filename: 'organization-portal.tsx' }}
export default function OrganizationListPage() {
  return (
    <OrganizationList
      hidePersonal={true}
      // ...
    />
  )
}
```

## Customization

To learn about how to customize Clerk components, see the [customization documentation](/docs/customization/overview).

[org-ref]: /docs/references/javascript/organization

---
title: '`<OrganizationProfile />` component'
description: Clerk's <OrganizationProfile /> component is used to render a beautiful, full-featured organization management UI that allows users to manage their organization profile and security settings.
---

![The \<OrganizationProfile /> component allows users to manage their organization membership and security settings.](/docs/images/ui-components/organization-profile.png)

The `<OrganizationProfile />` component allows users to manage their organization membership and security settings.

This component's **General** tab displays the organization's information and the **Leave organization** button. Admins will be able to see the **Update profile** button, **Verified domains** section, and **Delete organization** button.

The **Members** tab shows the organization's members along with their join dates and roles. Admins will have the ability to invite a member, change a member's role, or remove them from the organization. Admins will have tabs within the **Members** tab to view the organization's [invitations](/docs/organizations/overview#organization-invitations) and [requests](/docs/organizations/verified-domains#membership-requests).

## Properties

The `<OrganizationProfile />` component accepts the following properties, all of which are **optional**:

<Properties>
  - `appearance`
  - <code>[Appearance](/docs/customization/overview) | undefined</code>

  Optional object to style your components. Will only affect [Clerk components](/docs/components/overview) and not [Account Portal](/docs/account-portal/overview) pages.

  ---

  - `afterLeaveOrganizationUrl`
  - `string`

  The full URL or path to navigate to after leaving an organization.

  ---

  - `customPages`
  - `CustomPages[]`

  An array of custom pages to add to the organization profile. Only available for the [JavaScript SDK](/docs/references/javascript/overview). To add custom pages with React-based SDK's, see the [dedicated guide](/docs/customization/organization-profile).

  ---

  - `fallback?`
  - `ReactNode`

  An optional element to be rendered while the component is mounting.

  ---

  - `path`
  - `string`

  The path where the component is mounted on when `routing` is set to `path`. It is ignored in hash- and virtual-based routing.<br />For example: `/organization-profile`.

  ---

  - `routing`
  - `'hash' | 'path'`

  The [routing](/docs/guides/routing) strategy for your pages. <br />Defaults to `'path'` for frameworks that handle routing, such as Next.js and Remix. Defaults to `hash` for all other SDK's, such as React.
</Properties>

## Usage with frameworks

<Tabs items={["Next.js", "React", "Astro", "Remix", "Tanstack React Start", "Vue"]}>
  <Tab>
    The `<OrganizationProfile />` component must embedded using the [Next.js optional catch-all route](https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#optional-catch-all-routes) in order for the routing to work.

    ```jsx {{ filename: 'app/organization-profile/[[...organization-profile]]/page.tsx' }}
    import { OrganizationProfile } from '@clerk/nextjs'

    export default function OrganizationProfilePage() {
      return <OrganizationProfile />
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'organization-profile.tsx' }}
    import { OrganizationProfile } from '@clerk/clerk-react'

    export default function OrganizationProfilePage() {
      return <OrganizationProfile />
    }
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: '/pages/organization-profile.astro' }}
    ---
    import { OrganizationProfile } from '@clerk/astro/components'
    ---

    <OrganizationProfile />
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: '/pages/organization-profile/$.tsx' }}
    import { OrganizationProfile } from '@clerk/remix'

    export default function OrganizationProfilePage() {
      return <OrganizationProfile />
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/routes/organization-profile.tsx' }}
    import { OrganizationProfile } from '@clerk/tanstack-react-start'
    import { createFileRoute } from '@tanstack/react-router'

    export const Route = createFileRoute('/organization-profile')({
      component: OrganizationProfile,
    })

    function OrganizationProfile() {
      return <OrganizationProfile />
    }
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'organization-profile.vue' }}
    <script setup lang="ts">
    import { OrganizationProfile } from '@clerk/vue'
    </script>

    <template>
      <OrganizationProfile />
    </template>
    ```
  </Tab>
</Tabs>

<If sdk="js-frontend">
  ## Usage with JavaScript

  The following methods available on an instance of the [`Clerk`](/docs/references/javascript/clerk) class are used to render and control the `<OrganizationProfile />` component:

  - [`mountOrganizationProfile()`](#mount-organization-profile)
  - [`unmountOrganizationProfile()`](#unmount-organization-profile)
  - [`openOrganizationProfile()`](#open-organization-profile)
  - [`closeOrganizationProfile()`](#close-organization-profile)

  The following examples assume that you have followed the [quickstart](/docs/quickstarts/javascript) in order to add Clerk to your JavaScript application.

  ### <code>mountOrganization<wbr />Profile()</code>

  Render the `<OrganizationProfile />` component to an HTML `<div>` element.

  ```typescript
  function mountOrganizationProfile(node: HTMLDivElement, props?: OrganizationProfileProps): void
  ```

  #### `mountOrganizationProfile()` params

  <Properties>
    - `node`
    - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

    The `<div>` element used to render in the `<OrganizationProfile />` component

    ---

    - `props?`
    - [`OrganizationProfileProps`](#properties)

    The properties to pass to the `<OrganizationProfile />` component
  </Properties>

  #### `mountOrganizationProfile()` usage

  ```js {{ filename: 'main.js', mark: [15] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  document.getElementById('app').innerHTML = `
    <div id="organization-profile"></div>
  `

  const orgProfileDiv = document.getElementById('organization-profile')

  clerk.mountOrganizationProfile(orgProfileDiv)
  ```

  ### <code>unmountOrganization<wbr />Profile()</code>

  Unmount and run cleanup on an existing `<OrganizationProfile />` component instance.

  ```typescript
  function unmountOrganizationProfile(node: HTMLDivElement): void
  ```

  #### `unmountOrganizationProfile()` params

  <Properties>
    - `node`
    - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

    The container `<div>` element with a rendered `<OrganizationProfile />` component instance.
  </Properties>

  #### `unmountOrganizationProfile()` usage

  ```js {{ filename: 'main.js', mark: [19] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  document.getElementById('app').innerHTML = `
    <div id="organization-profile"></div>
  `

  const orgProfileDiv = document.getElementById('organization-profile')

  clerk.mountOrganizationProfile(orgProfileDiv)

  // ...

  clerk.unmountOrganizationProfile(orgProfileDiv)
  ```

  ### `openOrganizationProfile()`

  Opens the `<OrganizationProfile />` component as an overlay at the root of your HTML `body` element.

  ```typescript
  function openOrganizationProfile(props?: OrganizationProfileProps): void
  ```

  #### `openOrganizationProfile()` params

  <Properties>
    - `props?`
    - [`OrganizationProfileProps`](#properties)

    The properties to pass to the `<OrganizationProfile />` component
  </Properties>

  #### `openOrganizationProfile()` usage

  ```js {{ filename: 'main.js', mark: [15] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  document.getElementById('app').innerHTML = `
    <div id="organization-profile"></div>
  `

  const orgProfileDiv = document.getElementById('organization-profile')

  clerk.openOrganizationProfile(orgProfileDiv)
  ```

  ### `closeOrganizationProfile()`

  Closes the organization profile overlay.

  ```typescript
  function closeOrganizationProfile(): void
  ```

  #### `closeOrganizationProfile()` usage

  ```js {{ filename: 'main.js', mark: [15] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  document.getElementById('app').innerHTML = `
    <div id="organization-profile"></div>
  `

  const orgProfileDiv = document.getElementById('organization-profile')

  clerk.closeOrganizationProfile(orgProfileDiv)
  ```
</If>

## Customization

To learn about how to customize Clerk components, see the [customization documentation](/docs/customization/overview).

In addition, you also can add custom pages and links to the `<OrganizationProfile />` navigation sidenav. For more information, refer to the [Custom Pages](/docs/customization/organization-profile) documentation.

---
title: '`<OrganizationSwitcher />` component'
description: Clerk's <OrganizationSwitcher /> component is used to enable the ability to switch between available organizations the user may be part of in your application.
---

![The \<OrganizationSwitcher /> component allows a user to switch between their account types - their personal account and their joined organizations.](/docs/images/ui-components/organization-switcher.png){{ style: { maxWidth: '436px' } }}

The `<OrganizationSwitcher />` component allows a user to switch between their account types - their personal account and their joined organizations. This component is useful for applications that have a multi-tenant architecture, where users can be part of multiple organizations. It handles all organization-related flows, including full organization management for admins. Learn more about [organizations](/docs/organizations/overview).

If you would like to learn how to hide a user's personal account in order to enforce an organization-centric application, see the [dedicated guide](/docs/organizations/force-organizations).

## Properties

The `<OrganizationSwitcher />` component accepts the following properties, all of which are **optional**:

<Properties>
  - `afterCreateOrganizationUrl`
  - `string`

  The full URL or path to navigate to after creating a new organization.

  ---

  - `afterLeaveOrganizationUrl`
  - `string`

  The full URL or path to navigate to after the user leaves the currently active organization.

  ---

  - `afterSelectOrganizationUrl`
  - `string`

  The full URL or path to navigate to after a successful organization switch.

  ---

  - `appearance`
  - <code>[Appearance](/docs/customization/overview) | undefined</code>

  Optional object to style your components. Will only affect [Clerk components](/docs/components/overview) and not [Account Portal](/docs/account-portal/overview) pages.

  ---

  - `createOrganizationMode`
  - `'modal' | 'navigation'`

  A boolean that controls whether clicking the "Create organization" button will cause the [`<CreateOrganization />`][createorg-ref] component to open as a modal, or if the browser will navigate to the `createOrganizationUrl` where `<CreateOrganization />` is mounted as a page. Defaults to: `'modal'`.

  ---

  - `createOrganizationUrl`
  - `string`

  The full URL or path where the `<CreateOrganization />`][createorg-ref] component is mounted.

  ---

  - `defaultOpen`
  - `boolean`

  A boolean that controls the default state of the `<OrganizationSwitcher />` component.

  ---

  - `fallback?`
  - `ReactNode`

  An optional element to be rendered while the component is mounting.

  ---

  - `hidePersonal`
  - `boolean`

  A boolean that controls whether `<OrganizationSwitcher />` will include the user's personal account in the organization list. Setting this to `true` will hide the personal account option, and users will only be able to switch between organizations. Defaults to `false`.

  ---

  - `hideSlug`
  - `boolean`

  A boolean that controls whether the optional slug field in the organization creation screen is hidden.

  ---

  - `organizationProfileMode`
  - `'modal' | 'navigation'`

  A boolean that controls whether clicking the **Manage organization** button will cause the [`<OrganizationProfile />`][orgprofile-ref] component to open as a modal, or if the browser will navigate to the `organizationProfileUrl` where `<OrganizationProfile />` is mounted as a page. Defaults to: `'modal'`.

  ---

  - `organizationProfileProps`
  - `object`

  Specify options for the underlying [`<OrganizationProfile />`][orgprofile-ref] component. For example: `{appearance: {...}}`

  ---

  - `organizationProfileUrl`
  - `string`

  The full URL or path where the [`<OrganizationProfile />`][orgprofile-ref] component is mounted.
</Properties>

## Usage with frameworks

<Tabs items={["Next.js", "React", "Astro", "Remix", "Tanstack React Start", "Vue"]}>
  <Tab>
    ```jsx {{ filename: 'app/organization-switcher/[[...organization-switcher]]/page.tsx' }}
    import { OrganizationSwitcher } from '@clerk/nextjs'

    export default function OrganizationSwitcherPage() {
      return <OrganizationSwitcher />
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'organization-switcher.tsx' }}
    import { OrganizationSwitcher } from '@clerk/clerk-react'

    export default function OrganizationSwitcherPage() {
      return <OrganizationSwitcher />
    }
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: '/pages/organization-switcher.astro' }}
    ---
    import { OrganizationSwitcher } from '@clerk/astro/components'
    ---

    <OrganizationSwitcher />
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: '/pages/organization-switcher/$.tsx' }}
    import { OrganizationSwitcher } from '@clerk/remix'

    export default function OrganizationSwitcherPage() {
      return <OrganizationSwitcher />
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/routes/organization-switcher.tsx' }}
    import { OrganizationSwitcher } from '@clerk/tanstack-react-start'
    import { createFileRoute } from '@tanstack/react-router'

    export const Route = createFileRoute('/organization-switcher')({
      component: OrganizationSwitcher,
    })

    function OrganizationSwitcher() {
      return <OrganizationSwitcher />
    }
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'organization-switcher.vue' }}
    <script setup lang="ts">
    import { OrganizationSwitcher } from '@clerk/vue'
    </script>

    <template>
      <OrganizationSwitcher />
    </template>
    ```
  </Tab>
</Tabs>

<If sdk="js-frontend">
  ## Usage with JavaScript

  The following methods available on an instance of the [`Clerk`](/docs/references/javascript/clerk) class are used to render and control the `<OrganizationSwitcher />` component:

  - [`mountOrganizationSwitcher()`](#mount-organization-switcher)
  - [`unmountOrganizationSwitcher()`](#unmount-organization-switcher)

  The following examples assume that you have followed the [quickstart](/docs/quickstarts/javascript) in order to add Clerk to your JavaScript application.

  ## `mountOrganizationSwitcher()`

  Render the `<OrganizationSwitcher />` component to an HTML `<div>` element.

  ```typescript
  function mountOrganizationSwitcher(node: HTMLDivElement, props?: OrganizationSwitcherProps): void
  ```

  ### <code>mountOrganization<wbr />Switcher()</code> params

  <Properties>
    - `node`
    - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

    The `<div>` element used to render in the `<OrganizationSwitcher />` component

    ---

    - `props?`
    - [`OrganizationSwitcherProps`](#properties)

    The properties to pass to the `<OrganizationSwitcher />` component
  </Properties>

  ### <code>mountOrganization<wbr />Switcher()</code> usage

  ```js {{ filename: 'main.js', mark: [15] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  document.getElementById('app').innerHTML = `
    <div id="organization-switcher"></div>
  `

  const orgSwitcherDiv = document.getElementById('organization-switcher')

  clerk.mountOrganizationSwitcher(orgSwitcherDiv)
  ```

  ## <code>unmountOrganization<wbr />Switcher()</code>

  Unmount and run cleanup on an existing `<OrganizationSwitcher />` component instance.

  ```typescript
  function unmountOrganizationSwitcher(node: HTMLDivElement): void
  ```

  ### <code>unmountOrganization<wbr />Switcher()</code> params

  <Properties>
    - `node`
    - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

    The container `<div>` element with a rendered `<OrganizationSwitcher />` component instance
  </Properties>

  ### <code>unmountOrganization<wbr />Switcher()</code> usage

  ```js {{ filename: 'main.js', mark: [19] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  document.getElementById('app').innerHTML = `
    <div id="organization-switcher"></div>
  `

  const orgSwitcherDiv = document.getElementById('organization-switcher')

  clerk.mountOrganizationSwitcher(orgSwitcherDiv)

  // ...

  clerk.unmountOrganizationSwitcher(orgSwitcherDiv)
  ```
</If>

## Customization

To learn about how to customize Clerk components, see the [customization documentation](/docs/customization/overview).

[createorg-ref]: /docs/components/organization/create-organization

[orgprofile-ref]: /docs/components/organization/organization-profile

---
title: '`<Protect>`'
description: The Protect component is used for authorization. It only renders its children when the current user has the specified permission or role in the organization.
---

The `<Protect>` component is used for authorization. It only renders its children when the current user has the specified [permission or role](/docs/organizations/roles-permissions) in the organization.

## Properties

<Properties>
  - `condition?`
  - `has => boolean`

  Optional conditional logic that renders the children if it returns `true`.

  ---

  - `fallback?`
  - `JSX`

  An optional snippet of JSX to show when a user doesn't have the `role` or `permission` to access the protected content.

  ---

  - `permission?`
  - `string`

  Optional string corresponding to a Role's Permission in the format `org:<resource>:<action>`

  ---

  - `role?`
  - `string`

  Optional string corresponding to an Organization's Role in the format `org:<role>`
</Properties>

> [!WARNING]
> `<Protect>` can only accept `permission` _or_ `role`, not both. The recommended approach is to use `permission`.

## Usage

To limit who is able to see the content that `<Protect>` renders, you can pass either the `permission` or `role` prop. The recommended approach is to use `permission` because this lets you modify roles without breaking your application. Permissions can be assigned to different roles with ease.

If you do not pass either prop, `<Protect>` will render its children if the user is signed in, regardless of their role or its permissions.

For more complex authorization logic, [pass conditional logic to the `condition` prop](#render-content-conditionally).

### Render content by permissions

The children of the following component will only be visible to users with roles that have the `org:invoices:create` permission.

<Tabs items={["Next.js", "React", "Astro", "Expo", "Vue"]}>
  <Tab>
    ```jsx
    import { Protect } from '@clerk/nextjs'

    export default function ProtectPage() {
      return (
        <Protect
          permission="org:invoices:create"
          fallback={<p>You do not have the permissions to create an invoice.</p>}
        >
          {children}
        </Protect>
      )
    }
    ```
  </Tab>

  <Tab>
    ```jsx
    import { Protect } from '@clerk/clerk-react'

    export default function ProtectPage() {
      return (
        <Protect
          permission="org:invoices:create"
          fallback={<p>You do not have the permissions to create an invoice.</p>}
        >
          {children}
        </Protect>
      )
    }
    ```
  </Tab>

  <Tab>
    ```astro
    ---
    import { Protect } from '@clerk/astro/components'
    ---

    <Protect permission="org:invoices:create">
      <p slot="fallback">You do not have the permissions to create an invoice.</p>
      <slot />
    </Protect>
    ```
  </Tab>

  <Tab>
    ```jsx
    import { Protect } from '@clerk/clerk-expo'
    import { Text } from 'react-native'

    export default function Screen() {
      return (
        <Protect
          permission="org:invoices:create"
          fallback={<Text>You do not have the permissions to create an invoice.</Text>}
        >
          <Text>Users with permission org:invoices:create can see this.</Text>
        </Protect>
      )
    }
    ```
  </Tab>

  <Tab>
    ```vue
    <script setup lang="ts">
    import { Protect } from '@clerk/vue'
    </script>

    <template>
      <Protect permission="org:invoices:create">
        <template #fallback>
          <p>You do not have the permissions to create an invoice.</p>
        </template>
        <slot />
      </Protect>
    </template>
    ```
  </Tab>
</Tabs>

### Render content by role

While authorization by `permission` is **recommended**, for convenience, `<Protect>` allows a `role` prop to be passed. The children of the following component will only be visible to users with the `org:billing` role.

<Tabs items={["Next.js", "React", "Astro", "Vue", "Expo"]}>
  <Tab>
    ```jsx
    import { Protect } from '@clerk/nextjs'

    export default function ProtectPage() {
      return (
        <Protect
          role="org:billing"
          fallback={<p>Only a member of the Billing department can access this content.</p>}
        >
          {children}
        </Protect>
      )
    }
    ```
  </Tab>

  <Tab>
    ```jsx
    import { Protect } from '@clerk/clerk-react'

    export default function ProtectPage() {
      return (
        <Protect
          role="org:billing"
          fallback={<p>Only a member of the Billing department can access this content.</p>}
        >
          {children}
        </Protect>
      )
    }
    ```
  </Tab>

  <Tab>
    ```astro
    ---
    import { Protect } from '@clerk/astro/components'
    ---

    <Protect role="org:billing">
      <p slot="fallback">Only a member of the Billing department can access this content.</p>
      <slot />
    </Protect>
    ```
  </Tab>

  <Tab>
    ```vue
    <script setup lang="ts">
    import { Protect } from '@clerk/vue'
    </script>

    <template>
      <Protect role="org:billing">
        <template #fallback>
          <p>Only a member of the Billing department can access this content.</p>
        </template>
        <slot />
      </Protect>
    </template>
    ```
  </Tab>

  <Tab>
    ```jsx
    import { Protect } from '@clerk/clerk-expo'
    import { Text } from 'react-native'

    export default function Screen() {
      return (
        <Protect
          permission="org:billing"
          fallback={<Text>Only a member of the Billing department can access this content.</Text>}
        >
          <Text>Users with role org:billing can see this.</Text>
        </Protect>
      )
    }
    ```
  </Tab>
</Tabs>

### Render content conditionally

The following example uses `<Protect>`'s `condition` prop to conditionally render its children if the user has the correct role.

<Tabs items={["Next.js", "Astro", "Vue", "Expo"]}>
  <Tab>
    ```tsx {{ filename: 'app/dashboard/settings/layout.tsx' }}
    import type { PropsWithChildren } from 'react'
    import { Protect } from '@clerk/nextjs'

    export default function SettingsLayout(props: PropsWithChildren) {
      return (
        <Protect
          condition={(has) => has({ role: 'org:admin' }) || has({ role: 'org:billing_manager' })}
          fallback={<p>Only an Admin or Billing Manager can access this content.</p>}
        >
          {props.children}
        </Protect>
      )
    }
    ```
  </Tab>

  <Tab>
    ```astro
    ---
    import { Protect } from '@clerk/astro/components'
    ---

    <Protect condition={(has) => has({ role: 'org:admin' }) || has({ role: 'org:billing_manager' })}>
      <p slot="fallback">Only an Admin or Billing Manager can access this content.</p>
      <slot />
    </Protect>
    ```
  </Tab>

  <Tab>
    ```vue
    <script setup>
    import { Protect } from '@clerk/vue'
    </script>

    <template>
      <Protect :condition="(has) => has({ role: 'org:admin' }) || has({ role: 'org:billing_manager' })">
        <template #fallback>
          <p>Only an Admin or Billing Manager can access this content.</p>
        </template>
        <p>Visible content.</p>
      </Protect>
    </template>
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/dashboard/settings/_layout.tsx' }}
    import { Slot } from 'expo-router'
    import { Protect } from '@clerk/clerk-expo'
    import { Text } from 'react-native'

    export default function SettingsLayout() {
      return (
        <Protect
          condition={(has) => has({ role: 'org:admin' }) || has({ role: 'org:billing_manager' })}
          fallback={<Text>Only an Admin or Billing Manager can access this content.</Text>}
        >
          <Slot />
        </Protect>
      )
    }
    ```
  </Tab>
</Tabs>

---
title: '`<RedirectToCreateOrganization />` (deprecated)'
description: The <RedirectToCreateOrganization /> component will navigate to the user profile URL which has been configured in your application instance. The behavior will be just like a server-side (3xx) redirect, and will override the current location in the history stack.
---

> [!WARNING]
> This feature is deprecated. Please use the [`redirectToCreateOrganization()` method](/docs/references/javascript/clerk#redirect-to-create-organization) instead.

The `<RedirectToCreateOrganization />` component will navigate to the create organization flow which has been configured in your application instance. The behavior will be just like a server-side (3xx) redirect, and will override the current location in the history stack.

## Usage

<Tabs items={["Next.js", "React", "Remix"]}>
  <Tab>
    ```tsx {{ filename: 'pages/_app.tsx' }}
    import { ClerkProvider, SignedIn, SignedOut, RedirectToCreateOrganization } from '@clerk/nextjs'
    import { AppProps } from 'next/app'

    function MyApp({ Component, pageProps }: AppProps) {
      return (
        <ClerkProvider {...pageProps}>
          <SignedIn>
            <RedirectToCreateOrganization />
          </SignedIn>
          <SignedOut>You need to sign in to create an organization.</SignedOut>
        </ClerkProvider>
      )
    }

    export default MyApp
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'pages/privatepage.tsx' }}
    import {
      ClerkProvider,
      SignedIn,
      SignedOut,
      RedirectToCreateOrganization,
    } from '@clerk/clerk-react'

    function PrivatePage() {
      return (
        <ClerkProvider publishableKey={`{{pub_key}}`}>
          <SignedIn>
            <RedirectToCreateOrganization />
          </SignedIn>
          <SignedOut>You need to sign in to create an organization.</SignedOut>
        </ClerkProvider>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'routes/index.tsx' }}
    import { SignedIn, SignedOut, RedirectToCreateOrganization } from '@clerk/remix'

    export default function Index() {
      return (
        <div>
          <SignedIn>
            <RedirectToCreateOrganization />
          </SignedIn>
          <SignedOut>
            <p>You need to sign in to create an organization.</p>
          </SignedOut>
        </div>
      )
    }
    ```
  </Tab>
</Tabs>

---
title: '`<RedirectToOrganizationProfile/>` (deprecated)'
description: The <RedirectToOrganizationProfile /> component will navigate to the organization profile URL which has been configured in your application instance. The behavior will be just like a server-side (3xx) redirect, and will override the current location in the history stack.
---

> [!WARNING]
> This feature is deprecated. Please use the [`redirectToOrganizationProfile()` method](/docs/references/javascript/clerk#redirect-to-organization-profile) instead.

The `<RedirectToOrganizationProfile />` component will navigate to the organization profile URL which has been configured in your application instance. The behavior will be just like a server-side (3xx) redirect, and will override the current location in the history stack.

## Usage

<Tabs items={["Next.js", "React", "Remix"]}>
  <Tab>
    ```tsx {{ filename: 'pages/_app.tsx' }}
    import { ClerkProvider, SignedIn, SignedOut, RedirectToOrganizationProfile } from '@clerk/nextjs'
    import { AppProps } from 'next/app'

    function MyApp({ Component, pageProps }: AppProps) {
      return (
        <ClerkProvider {...pageProps}>
          <SignedIn>
            <RedirectToOrganizationProfile />
          </SignedIn>
          <SignedOut>You need to sign in to view your organization profile.</SignedOut>
        </ClerkProvider>
      )
    }

    export default MyApp
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'pages/privatepage.tsx' }}
    import {
      ClerkProvider,
      SignedIn,
      SignedOut,
      RedirectToOrganizationProfile,
    } from '@clerk/clerk-react'

    function PrivatePage() {
      return (
        <ClerkProvider publishableKey={`{{pub_key}}`}>
          <SignedIn>
            <RedirectToOrganizationProfile />
          </SignedIn>
          <SignedOut>You need to sign in to view your organization profile.</SignedOut>
        </ClerkProvider>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'routes/index.tsx' }}
    import { SignedIn, SignedOut, RedirectToOrganizationProfile } from '@clerk/remix'

    export default function Index() {
      return (
        <div>
          <SignedIn>
            <RedirectToOrganizationProfile />
          </SignedIn>
          <SignedOut>
            <p>You need to sign in to view your organization profile.</p>
          </SignedOut>
        </div>
      )
    }
    ```
  </Tab>
</Tabs>

---
title: '`<RedirectToSignIn />`'
description: The <RedirectToSignIn /> component will navigate to the sign in URL which has been configured in your application instance. The behavior will be just like a server-side (3xx) redirect, and will override the current location in the history stack.
---

The `<RedirectToSignIn />` component will navigate to the sign in URL which has been configured in your application instance. The behavior will be just like a server-side (3xx) redirect, and will override the current location in the history stack.

## Usage

<Tabs items={["Next.js", "React", "Remix"]}>
  <CodeBlockTabs options={["App Router", "Pages Router"]}>
    <Tab>
      ```tsx {{ filename: 'app/layout.tsx' }}
      import { ClerkProvider, SignedIn, SignedOut, RedirectToSignIn } from '@clerk/nextjs'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <html>
            <body>
              <ClerkProvider>
                <SignedIn>{children}</SignedIn>
                <SignedOut>
                  <RedirectToSignIn />
                </SignedOut>
              </ClerkProvider>
            </body>
          </html>
        )
      }
      ```
    </Tab>

    <Tab>
      ```tsx {{ filename: 'pages/_app.tsx' }}
      import { ClerkProvider, SignedIn, SignedOut, RedirectToSignIn } from '@clerk/nextjs'
      import { AppProps } from 'next/app'

      function MyApp({ Component, pageProps }: AppProps) {
        return (
          <ClerkProvider>
            <SignedIn>
              <Component {...pageProps} />
            </SignedIn>
            <SignedOut>
              <RedirectToSignIn />
            </SignedOut>
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </Tab>
  </CodeBlockTabs>

  <Tab>
    ```tsx {{ filename: 'pages/privatepage.tsx' }}
    import {
      ClerkProvider,
      SignedIn,
      SignedOut,
      RedirectToSignIn,
      UserButton,
    } from '@clerk/clerk-react'

    // Import your Publishable Key
    const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

    if (!PUBLISHABLE_KEY) {
      throw new Error('Add your Clerk Publishable Key to the .env file')
    }

    function PrivatePage() {
      return (
        <ClerkProvider publishableKey={PUBLISHABLE_KEY}>
          <SignedIn>
            <UserButton />
          </SignedIn>
          <SignedOut>
            <RedirectToSignIn />
          </SignedOut>
        </ClerkProvider>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'routes/index.tsx' }}
    import { SignedIn, SignedOut, RedirectToSignIn, UserButton } from '@clerk/remix'

    export default function Index() {
      return (
        <div>
          <SignedIn>
            <UserButton />
          </SignedIn>
          <SignedOut>
            <RedirectToSignIn />
          </SignedOut>
        </div>
      )
    }
    ```
  </Tab>
</Tabs>

## Properties

<Properties>
  - `signInFallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs in, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signInForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs in. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `initialValues`
  - [`SignInInitialValues`](/docs/references/javascript/types/sign-in-initial-values)

  The values used to prefill the sign-in fields with.
</Properties>

---
title: '`<RedirectToSignUp />`'
description: The <RedirectToSignUp /> component will navigate to the sign up URL which has been configured in your application instance. The behavior will be just like a server-side (3xx) redirect, and will override the current location in the history stack.
---

The `<RedirectToSignUp />` component will navigate to the sign up URL which has been configured in your application instance. The behavior will be just like a server-side (3xx) redirect, and will override the current location in the history stack.

## Usage

<Tabs items={["Next.js", "React", "Remix"]}>
  <CodeBlockTabs options={["App Router", "Pages Router"]}>
    <Tab>
      ```tsx {{ filename: 'app/layout.tsx' }}
      import { ClerkProvider, SignedIn, SignedOut, RedirectToSignUp } from '@clerk/nextjs'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <html>
            <body>
              <ClerkProvider>
                <SignedIn>{children}</SignedIn>
                <SignedOut>
                  <RedirectToSignUp />
                </SignedOut>
              </ClerkProvider>
            </body>
          </html>
        )
      }
      ```
    </Tab>

    <Tab>
      ```tsx {{ filename: 'pages/_app.tsx' }}
      import { ClerkProvider, SignedIn, SignedOut, RedirectToSignUp } from '@clerk/nextjs'
      import { AppProps } from 'next/app'

      function MyApp({ Component, pageProps }: AppProps) {
        return (
          <ClerkProvider>
            <SignedIn>
              <Component {...pageProps} />
            </SignedIn>
            <SignedOut>
              <RedirectToSignUp />
            </SignedOut>
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </Tab>
  </CodeBlockTabs>

  <Tab>
    ```tsx {{ filename: 'pages/privatepage.tsx' }}
    import {
      ClerkProvider,
      SignedIn,
      SignedOut,
      RedirectToSignUp,
      UserButton,
    } from '@clerk/clerk-react'

    // Import your Publishable Key
    const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

    if (!PUBLISHABLE_KEY) {
      throw new Error('Add your Clerk Publishable Key to the .env file')
    }

    function PrivatePage() {
      return (
        <ClerkProvider publishableKey={PUBLISHABLE_KEY}>
          <SignedIn>
            <UserButton />
          </SignedIn>
          <SignedOut>
            <RedirectToSignUp />
          </SignedOut>
        </ClerkProvider>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'routes/index.tsx' }}
    import { SignedIn, SignedOut, RedirectToSignUp, UserButton } from '@clerk/remix'

    export default function Index() {
      return (
        <div>
          <SignedIn>
            <UserButton />
          </SignedIn>
          <SignedOut>
            <RedirectToSignUp />
          </SignedOut>
        </div>
      )
    }
    ```
  </Tab>
</Tabs>

## Properties

<Properties>
  - `signUpFallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs up, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs up. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `initialValues`
  - [`SignUpInitialValues`](/docs/references/javascript/types/sign-up-initial-values)

  The values used to prefill the sign-up fields with.
</Properties>

---
title: '`<RedirectToUserProfile />` (deprecated)'
description: The <RedirectToUserProfile /> component will navigate to the user profile URL which has been configured in your application instance. The behavior will be just like a server-side (3xx) redirect, and will override the current location in the history stack.
---

> [!WARNING]
> This feature is deprecated. Please use the [`redirectToUserProfile()` method](/docs/references/javascript/clerk#redirect-to-user-profile) instead.

The `<RedirectToUserProfile />` component will navigate to the Account Portal User Profile URL which has been configured in your application instance. The behavior will be just like a server-side (3xx) redirect, and will override the current location in the history stack.

To find your User Profile URL:

1. In the Clerk Dashboard, navigate to the [**Account Portal**](https://dashboard.clerk.com/last-active?path=account-portal) page.
1. Under **User profile**, select the **Visit** icon.

## Usage

<Tabs items={["Next.js", "React", "Remix"]}>
  <Tab>
    ```tsx {{ filename: 'pages/_app.tsx' }}
    import { ClerkProvider, SignedIn, SignedOut, RedirectToUserProfile } from '@clerk/nextjs'
    import { AppProps } from 'next/app'

    function MyApp({ Component, pageProps }: AppProps) {
      return (
        <ClerkProvider {...pageProps}>
          <SignedIn>
            <RedirectToUserProfile />
          </SignedIn>
          <SignedOut>
            <p>You need to sign in to view your user profile.</p>
          </SignedOut>
        </ClerkProvider>
      )
    }

    export default MyApp
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'pages/privatepage.tsx' }}
    import { ClerkProvider, SignedIn, SignedOut, RedirectToUserProfile } from '@clerk/clerk-react'

    // Import your Publishable Key
    const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

    if (!PUBLISHABLE_KEY) {
      throw new Error('Add your Clerk Publishable Key to the .env file')
    }

    function PrivatePage() {
      return (
        <ClerkProvider publishableKey={PUBLISHABLE_KEY}>
          <SignedIn>
            <RedirectToUserProfile />
          </SignedIn>
          <SignedOut>
            <p>You need to sign in to view your user profile.</p>
          </SignedOut>
        </ClerkProvider>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'routes/index.tsx' }}
    import { SignedIn, SignedOut, RedirectToUserProfile } from '@clerk/remix'

    export default function Index() {
      return (
        <div>
          <SignedIn>
            <RedirectToUserProfile />
          </SignedIn>
          <SignedOut>
            <p>You need to sign in to view your user profile.</p>
          </SignedOut>
        </div>
      )
    }
    ```
  </Tab>
</Tabs>

---
title: '`<SignedIn>`'
description: Conditionally render content only when a user is signed in.
---

## Overview

The `<SignedIn>` component offers authentication checks as a cross-cutting concern. Any children components wrapped by a `<SignedIn>` component will be rendered only if there's a User with an active Session signed in your application.

## Usage

<Tabs items={["Next.js", "React", "Astro", "Expo", "Remix", "Tanstack React Start", "Vue"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: 'app/page.tsx' }}
      import React from 'react'
      import { ClerkProvider, SignedIn } from '@clerk/nextjs'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <ClerkProvider>
            <html lang="en">
              <body>
                <header>
                  <SignedIn>
                    <div>You are signed in</div>
                  </SignedIn>
                  <p>This content is always visible.</p>
                </header>
                {children}
              </body>
            </html>
          </ClerkProvider>
        )
      }
      ```

      ```tsx {{ filename: 'app.tsx' }}
      import '@/styles/globals.css'
      import { ClerkProvider, SignedIn } from '@clerk/nextjs'
      import { AppProps } from 'next/app'

      function MyApp({ Component, pageProps }: AppProps) {
        return (
          <ClerkProvider {...pageProps}>
            <SignedIn>
              <div>You are signed in</div>
            </SignedIn>
            <p>This content is always visible.</p>
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app.tsx' }}
    import { SignedIn, ClerkProvider } from '@clerk/clerk-react'

    // Import your Publishable Key
    const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

    if (!PUBLISHABLE_KEY) {
      throw new Error('Add your Clerk Publishable Key to the .env file')
    }

    function Page() {
      return (
        <ClerkProvider publishableKey={PUBLISHABLE_KEY}>
          <SignedIn>
            <div>This content is visible only to signed in users.</div>
          </SignedIn>
          <p>This content is always visible.</p>
        </ClerkProvider>
      )
    }
    ```

    ### Usage with React Router

    ```tsx {{ filename: 'app.tsx' }}
    import { Routes, Route } from 'react-router'
    import { ClerkProvider, SignedIn } from '@clerk/clerk-react'

    // Import your Publishable Key
    const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

    if (!PUBLISHABLE_KEY) {
      throw new Error('Add your Clerk Publishable Key to the .env file')
    }

    function App() {
      return (
        <ClerkProvider publishableKey={PUBLISHABLE_KEY}>
          <Routes>
            <Route path="/" element={<div>This page is publicly accessible.</div>} />
            <Route
              path="/private"
              element={
                <SignedIn>
                  <div>This content is accessible only to signed in users.</div>
                </SignedIn>
              }
            />
          </Routes>
        </ClerkProvider>
      )
    }
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: 'index.astro' }}
    ---
    import { SignedIn } from '@clerk/astro/components'
    ---

    <SignedIn>
      <div>You are signed in</div>
    </SignedIn>
    <p>This content is always visible.</p>
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/index.tsx' }}
    import { SignedIn } from '@clerk/clerk-expo'
    import { Text, View } from 'react-native'

    export default function Screen() {
      return (
        <View>
          <SignedIn>
            <Text>You are signed in</Text>
          </SignedIn>
          <Text>This content is always visible.</Text>
        </View>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'routes/index.tsx' }}
    import { SignedIn, UserButton } from '@clerk/remix'

    export default function Index() {
      return (
        <div>
          <SignedIn>
            <p>You are signed in</p>
          </SignedIn>
          <p>Always visible</p>
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/routes/index.tsx' }}
    import { SignedIn } from '@clerk/tanstack-react-start'
    import { createFileRoute } from '@tanstack/react-router'

    export const Route = createFileRoute('/')({
      component: Home,
    })

    function Home() {
      return (
        <div>
          <SignedIn>
            <p>You are signed in</p>
          </SignedIn>
          <p>Always visible</p>
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'App.vue' }}
    <script setup lang="ts">
    import { SignedIn } from '@clerk/vue'
    </script>

    <template>
      <SignedIn>
        <div>You are signed in</div>
      </SignedIn>
      <p>This content is always visible.</p>
    </template>
    ```
  </Tab>
</Tabs>

---
title: '`<SignedOut>`'
description: Conditionally render content only when a user is signed out.
---

The `<SignedOut>` component offers authentication checks as a cross-cutting concern. Any child nodes wrapped by a `<SignedOut>` component will be rendered only if there's no User signed in to your application.

## Usage

<Tabs items={["Next.js", "React", "Astro", "Expo", "Remix", "Tanstack React Start", "Vue"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: 'app/page.tsx' }}
      import React from 'react'
      import { ClerkProvider, SignedOut } from '@clerk/nextjs'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <ClerkProvider>
            <html lang="en">
              <body>
                <header>
                  <SignedOut>
                    <p>You are signed out.</p>
                  </SignedOut>
                  <p>This content is always visible.</p>
                </header>
                {children}
              </body>
            </html>
          </ClerkProvider>
        )
      }
      ```

      ```tsx {{ filename: 'app.tsx' }}
      import '@/styles/globals.css'
      import { ClerkProvider, RedirectToSignIn, SignedOut } from '@clerk/nextjs'
      import { AppProps } from 'next/app'

      function MyApp({ Component, pageProps }: AppProps) {
        return (
          <ClerkProvider {...pageProps}>
            <SignedOut>
              <p>You are signed out.</p>
            </SignedOut>
            <p>This content is always visible.</p>
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app.tsx' }}
    import { SignedOut, ClerkProvider } from '@clerk/clerk-react'

    // Import your Publishable Key
    const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

    if (!PUBLISHABLE_KEY) {
      throw new Error('Add your Clerk Publishable Key to the .env file')
    }

    function Page() {
      return (
        <ClerkProvider publishableKey={PUBLISHABLE_KEY}>
          <SignedOut>
            <p>You are signed out.</p>
          </SignedOut>
          <p>This content is always visible.</p>
        </ClerkProvider>
      )
    }
    ```

    ### Usage with React Router

    ```tsx {{ filename: 'app.tsx' }}
    import { Routes, Route } from 'react-router'
    import { ClerkProvider, SignedOut } from '@clerk/clerk-react'

    function App() {
      return (
        <ClerkProvider publishableKey={`{{pub_key}}`}>
          <Routes>
            <Route path="/" element={<p>This page is publicly accessible.</p>} />
            <Route
              path="/public"
              element={
                <SignedOut>
                  <p>You are signed out.</p>
                </SignedOut>
              }
            />
          </Routes>
        </ClerkProvider>
      )
    }
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: 'index.astro' }}
    ---
    import { SignedOut } from '@clerk/astro/components'
    ---

    <SignedOut>
      <div>You are signed out</div>
    </SignedOut>
    <p>This content is always visible.</p>
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/index.tsx' }}
    import { SignedOut } from '@clerk/clerk-expo'
    import { Text, View } from 'react-native'

    export default function Screen() {
      return (
        <View>
          <SignedOut>
            <Text>You are signed out</Text>
          </SignedOut>
          <Text>This content is always visible.</Text>
        </View>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'routes/index.tsx' }}
    import { SignedOut } from '@clerk/remix'

    export default function Index() {
      return (
        <div>
          <SignedOut>
            <p>You are signed out.</p>
          </SignedOut>
          <p>This content is always visible.</p>
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/routes/index.tsx' }}
    import { SignedOut } from '@clerk/tanstack-react-start'
    import { createFileRoute } from '@tanstack/react-router'

    export const Route = createFileRoute('/')({
      component: Home,
    })

    function Home() {
      return (
        <div>
          <SignedOut>
            <p>You are signed out.</p>
          </SignedOut>
          <p>This content is always visible.</p>
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'App.vue' }}
    <script setup lang="ts">
    import { SignedOut } from '@clerk/vue'
    </script>

    <template>
      <SignedOut>
        <div>You are signed out</div>
      </SignedOut>
      <p>This content is always visible.</p>
    </template>
    ```
  </Tab>
</Tabs>

---
title: '`<SignIn />` component'
description: Clerk's <SignIn /> component renders a UI for signing in users.
---

![The \<SignIn /> component renders a UI for signing in users.](/docs/images/ui-components/sign-in.png){{ style: { maxWidth: '460px' } }}

The `<SignIn />` component renders a UI to allow users to sign in or sign up by default. The functionality of the `<SignIn />` component is controlled by the instance settings you specify in the [Clerk Dashboard](https://dashboard.clerk.com), such as [sign-in and sign-up options](/docs/authentication/configuration/sign-up-sign-in-options) and [social connections](/docs/authentication/social-connections/oauth). You can further customize your `<SignIn />` component by passing additional [properties](#properties) at the time of rendering.

> [!NOTE]
> The `<SignUp/>` and `<SignIn/>` components cannot render when a user is already signed in, unless the application allows multiple sessions. If a user is already signed in and the application only allows a single session, Clerk will redirect the user to the Home URL instead.

## Properties

All props are optional.

<Properties>
  - `appearance`
  - <code>[Appearance](/docs/customization/overview) | undefined</code>

  Optional object to style your components. Will only affect [Clerk components](/docs/components/overview) and not [Account Portal](/docs/account-portal/overview) pages.

  ---

  - `fallback`
  - `ReactNode`

  An optional element to be rendered while the component is mounting.

  ---

  - `fallbackRedirectUrl`
  - `string`

  The fallback URL to redirect to after the user signs in, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `forceRedirectUrl`
  - `string`

  If provided, this URL will always be redirected to after the user signs in. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `initialValues`
  - [`SignInInitialValues`](/docs/references/javascript/types/sign-in-initial-values)

  The values used to prefill the sign-in fields with.

  ---

  - `oauthFlow`
  - `"redirect" | "popup" | "auto"`

  Determines how OAuth authentication is performed. Accepts the following properties:

  - `"redirect"`: Redirect to the OAuth provider on the current page.
  - `"popup"`: Open a popup window.
  - `"auto"`: Choose the best method based on whether the current domain typically requires the `"popup"` flow to correctly perform authentication.

  Defaults to `"auto"`.

  ---

  - `path`
  - `string`

  The path where the component is mounted on when `routing` is set to `path`. It is ignored in hash-based routing. For example: `/sign-in`.

  ---

  - `routing`
  - `'hash' | 'path'`

  The [routing](/docs/guides/routing) strategy for your pages. Defaults to `'path'` for frameworks that handle routing, such as Next.js and Remix. Defaults to `hash` for all other SDK's, such as React.

  ---

  - `signUpFallbackRedirectUrl`
  - `string`

  The fallback URL to redirect to after the user signs up, if there's no `redirect_url` in the path already. Used for the 'Don't have an account? Sign up' link that's rendered. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpForceRedirectUrl`
  - `string`

  If provided, this URL will always used as the redirect destination after the user signs up. Used for the 'Don't have an account? Sign up' link that's rendered. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpUrl`
  - `string`

  The full URL or path to the sign-up page. Used for the 'Don't have an account? Sign up' link that's rendered. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `transferable`
  - `boolean`

  Indicates whether or not sign in attempts are transferable to the sign up flow. Defaults to `true`. When set to `false`, prevents opaque sign ups when a user attempts to sign in via OAuth with an email that doesn't exist.

  ---

  - `waitlistUrl`
  - `string`

  Full URL or path to the waitlist page. Use this property to provide the target of the 'Waitlist' link that's rendered. If `undefined`, will redirect to the [Account Portal waitlist page](/docs/account-portal/overview#waitlist). If you've passed the `waitlistUrl` prop to the [`<ClerkProvider>`](/docs/components/clerk-provider) component, it will infer from that, and you can omit this prop.

  ---

  - `withSignUp`
  - `boolean`

  Opt into sign-in-or-up flow by setting this prop to `true`. When `true`, if a user does not exist, they will be prompted to sign up. If a user exists, they will be prompted to sign in. Defaults to `true` if the `CLERK_SIGN_UP_URL` environment variable is set. Otherwise, defaults to `false`.
</Properties>

## Usage with frameworks

The following example includes basic implementation of the `<SignIn />` component. You can use this as a starting point for your own implementation.

<Tabs items={["Next.js", "Astro", "Expo", "React", "React Router", "Remix", "Tanstack React Start", "Vue"]}>
  <Tab>
    The following example demonstrates how you can use the `<SignIn />` component on a public page.

    If you would like to create a dedicated `/sign-in` page in your Next.js application, there are a few requirements you must follow. See the [dedicated guide](/docs/references/nextjs/custom-sign-in-or-up-page) for more information.

    ```tsx {{ filename: 'app/page.tsx' }}
    'use client'

    import { SignIn, useUser } from '@clerk/nextjs'

    export default function Home() {
      const { user } = useUser()

      if (!user) return <SignIn />

      return <div>Welcome!</div>
    }
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: 'pages/sign-in.astro' }}
    ---
    import { SignIn } from '@clerk/astro/components'
    ---

    <SignIn />
    ```
  </Tab>

  <Tab>
    If you would like to create a dedicated `/sign-in` page in your Expo Web application, there are a few requirements you must follow. See the [dedicated guide](/docs/references/expo/web-support/custom-sign-in-or-up-page) for more information.

    ```tsx {{ filename: '/app/sign-in.web.tsx' }}
    import { SignIn } from '@clerk/clerk-expo/web'

    export default function SignInPage() {
      return <SignIn />
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'src/sign-in.tsx' }}
    import { SignIn } from '@clerk/clerk-react'

    const SignInPage = () => <SignIn />

    export default SignInPage
    ```
  </Tab>

  <Tab>
    If you would like to create a dedicated `/sign-in` page in your React Router application, there are a few requirements you must follow. See the [dedicated guide](/docs/references/react-router/custom-sign-in-or-up-page) for more information.

    ```tsx {{ filename: 'app/routes/sign-in.tsx' }}
    import { SignIn } from '@clerk/react-router'

    export default function SignInPage() {
      return <SignIn />
    }
    ```
  </Tab>

  <Tab>
    If you would like to create a dedicated `/sign-in` page in your Remix application, there are a few requirements you must follow. See the [dedicated guide](/docs/references/remix/custom-sign-in-or-up-page) for more information.

    ```tsx {{ filename: 'app/routes/sign-in/$.tsx' }}
    import { SignIn } from '@clerk/remix'

    export default function SignInPage() {
      return <SignIn />
    }
    ```
  </Tab>

  <Tab>
    If you would like to create a dedicated `/sign-in` page in your TanStack React Start application, there are a few requirements you must follow. See the [dedicated guide](/docs/references/tanstack-react-start/custom-sign-in-or-up-page) for more information.

    ```tsx {{ filename: 'app/routes/sign-in.tsx' }}
    import { SignIn } from '@clerk/tanstack-react-start'
    import { createFileRoute } from '@tanstack/react-router'

    export const Route = createFileRoute('/sign-in')({
      component: SignIn,
    })

    function SignIn() {
      return <SignIn />
    }
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'sign-in.vue' }}
    <script setup lang="ts">
    import { SignIn } from '@clerk/vue'
    </script>

    <template>
      <SignIn />
    </template>
    ```
  </Tab>
</Tabs>

<If sdk="js-frontend">
  ## Usage with JavaScript

  The following methods available on an instance of the [`Clerk`](/docs/references/javascript/clerk) class are used to render and control the `<SignIn />` component:

  - [`mountSignIn()`](#mount-sign-in)
  - [`unmountSignIn()`](#unmount-sign-in)
  - [`openSignIn()`](#open-sign-in)
  - [`closeSignIn()`](#close-sign-in)

  The following examples assume that you have followed the [quickstart](/docs/quickstarts/javascript) in order to add Clerk to your JavaScript application.

  ### `mountSignIn()`

  Render the `<SignIn />` component to an HTML `<div>` element.

  ```typescript
  function mountSignIn(node: HTMLDivElement, props?: SignInProps): void
  ```

  #### `mountSignIn()` params

  <Properties>
    - `node`
    - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

    The container `<div>` element used to render in the `<SignIn />` component

    ---

    - `props?`
    - [`SignInProps`](#properties)

    The properties to pass to the `<SignIn />` component
  </Properties>

  #### `mountSignIn()` usage

  ```js {{ filename: 'main.js', mark: [15] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  document.getElementById('app').innerHTML = `
    <div id="sign-in"></div>
  `

  const signInDiv = document.getElementById('sign-in')

  clerk.mountSignIn(signInDiv)
  ```

  ### `unmountSignIn()`

  Unmount and run cleanup on an existing `<SignIn />` component instance.

  ```typescript
  function unmountSignIn(node: HTMLDivElement): void
  ```

  #### `unmountSignIn()` params

  <Properties>
    - `node`
    - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

    The container `<div>` element with a rendered `<SignIn />` component instance
  </Properties>

  #### `unmountSignIn()` usage

  ```js {{ filename: 'index.js', mark: [19] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  document.getElementById('app').innerHTML = `
    <div id="sign-in"></div>
  `

  const signInDiv = document.getElementById('sign-in')

  clerk.mountSignIn(signInDiv)

  // ...

  clerk.unmountSignIn(signInDiv)
  ```

  ### `openSignIn()`

  Opens the `<SignIn />` component as an overlay at the root of your HTML `body` element.

  ```typescript
  function openSignIn(props?: SignInProps): void
  ```

  #### `openSignIn()` params

  <Properties>
    - `props?`
    - [`SignInProps`](#properties)

    The properties to pass to the `<SignIn />` component.
  </Properties>

  #### `openSignIn()` usage

  ```js {{ filename: 'main.js', mark: [9] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  clerk.openSignIn()
  ```

  ### `closeSignIn()`

  Closes the sign in overlay.

  ```typescript
  function closeSignIn(): void
  ```

  #### `closeSignIn()` usage

  ```js {{ filename: 'index.js', mark: [13] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  clerk.openSignIn()

  // ...

  clerk.closeSignIn()
  ```
</If>

## Customization

To learn about how to customize Clerk components, see the [customization documentation](/docs/customization/overview).

If Clerk's prebuilt components don't meet your specific needs or if you require more control over the logic, you can rebuild the existing Clerk flows using the Clerk API. For more information, see the [custom flow guides](/docs/custom-flows/overview).

---
title: '`<SignInButton>`'
description: The <SignInButton> component is a button that links to the sign-in page or displays the sign-in modal.
---

The `<SignInButton>` component is a button that links to the sign-in page or displays the sign-in modal.

## Properties

<Properties>
  - `asChild?`
  - `boolean`

  **For Astro only:** If `true`, the `<SignInButton>` component will render its children as a child of the component.

  ---

  - `forceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs in. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `fallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs in, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `oauthFlow`
  - `"redirect" | "popup" | "auto"`

  Determines how OAuth authentication is performed. Accepts the following properties:

  - `"redirect"`: Redirect to the OAuth provider on the current page.
  - `"popup"`: Open a popup window.
  - `"auto"`: Choose the best method based on whether the current domain typically requires the `"popup"` flow to correctly perform authentication.

  Defaults to `"auto"`.

  ---

  - `signUpForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs up. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpFallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs up, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `mode?`
  - `'redirect' | 'modal'`

  Determines what happens when a user clicks on the `<SignInButton>`. Setting this to `'redirect'` will redirect the user to the sign-in route. Setting this to `'modal'` will open a modal on the current route. Defaults to `'redirect'`.

  ---

  - `children?`
  - `React.ReactNode`

  Children you want to wrap the `<SignInButton>` in.

  ---

  - `initialValues`
  - [`SignInInitialValues`](/docs/references/javascript/types/sign-in-initial-values)

  The values used to prefill the sign-in fields with.
</Properties>

## Usage

### Basic usage

<Tabs items={["Next.js", "React", "Astro", "Remix", "Tanstack React Start", "Vue"]}>
  <Tab>
    ```jsx {{ filename: 'app/page.tsx' }}
    import { SignInButton } from '@clerk/nextjs'

    export default function Home() {
      return <SignInButton />
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'src/sign-in.tsx' }}
    import { SignInButton } from '@clerk/clerk-react'

    const SignInPage = () => <SignInButton />

    export default SignInPage
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: 'pages/sign-in.astro' }}
    ---
    import { SignInButton } from '@clerk/astro/components'
    ---

    <SignInButton />
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'app/routes/sign-in/$.tsx' }}
    import { SignInButton } from '@clerk/remix'

    export default function SignInPage() {
      return <SignInButton />
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/routes/sign-in.tsx' }}
    import { SignInButton } from '@clerk/tanstack-react-start'
    import { createFileRoute } from '@tanstack/react-router'

    export const Route = createFileRoute('/sign-in')({
      component: SignIn,
    })

    function SignIn() {
      return <SignInButton />
    }
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'example.vue' }}
    <script setup>
    import { SignInButton } from '@clerk/vue'
    </script>

    <template>
      <SignInButton />
    </template>
    ```
  </Tab>
</Tabs>

### Custom usage

You can create a custom button by wrapping your own button, or button text, in the `<SignInButton>` component.

<Tabs items={["Next.js", "React", "Remix", "Astro", "Vue"]}>
  <Tab>
    ```jsx {{ filename: 'pages/index.js' }}
    import { SignInButton } from '@clerk/nextjs'

    export default function Home() {
      return (
        <SignInButton>
          <button>Custom sign in button</button>
        </SignInButton>
      )
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'example.js' }}
    import { SignInButton } from '@clerk/clerk-react'

    export default function Example() {
      return (
        <SignInButton>
          <button>Custom sign in button</button>
        </SignInButton>
      )
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'pages/index.js' }}
    import { SignInButton } from '@clerk/remix'

    export default function Home() {
      return (
        <SignInButton>
          <button>Custom sign in button</button>
        </SignInButton>
      )
    }
    ```
  </Tab>

  <Tab>
    You must pass the `asChild` prop to the `<SignInButton>` component if you are passing children to it.

    ```astro {{ filename: 'pages/index.astro' }}
    ---
    import { SignInButton } from '@clerk/astro/components'
    ---

    <SignInButton asChild>
      <button>Custom sign in button</button>
    </SignInButton>
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'example.vue' }}
    <script setup>
    import { SignInButton } from '@clerk/vue'
    </script>

    <template>
      <SignInButton>
        <button>Custom sign in button</button>
      </SignInButton>
    </template>
    ```
  </Tab>
</Tabs>

---
title: '`<SignInWithMetamaskButton>`'
description: The `<SignInWithMetamaskButton>` component is used to complete a one-click, cryptographically-secure sign-in flow using MetaMask.
---

The `<SignInWithMetamaskButton>` component is used to complete a one-click, cryptographically-secure sign-in flow using MetaMask.

## Usage

### Basic usage

<CodeBlockTabs options={["Next.js", "React", "Remix", "Vue"]}>
  ```jsx {{ filename: 'app/page.tsx' }}
  import { SignInWithMetamaskButton } from '@clerk/nextjs'

  export default function Home() {
    return <SignInWithMetamaskButton />
  }
  ```

  ```jsx {{ filename: 'example.js' }}
  import { SignInWithMetamaskButton } from '@clerk/clerk-react'

  export default function Example() {
    return <SignInWithMetamaskButton />
  }
  ```

  ```jsx {{ filename: 'pages/index.js' }}
  import { SignInWithMetamaskButton } from '@clerk/remix'

  export default function Home() {
    return <SignInWithMetamaskButton />
  }
  ```

  ```vue {{ filename: 'example.vue' }}
  <script setup>
  import { SignInWithMetamaskButton } from '@clerk/vue'
  </script>

  <template>
    <SignInWithMetamaskButton />
  </template>
  ```
</CodeBlockTabs>

### Custom usage

In some cases, you will want to use your own button, or button text. You can do that by wrapping your button in the `<SignInWithMetamaskButton>` component.

<CodeBlockTabs options={["Next.js", "React", "Remix", "Vue"]}>
  ```jsx {{ filename: 'pages/index.js' }}
  import { SignInWithMetamaskButton } from '@clerk/nextjs'

  export default function Home() {
    return (
      <SignInWithMetamaskButton mode="modal">
        <button>Custom sign in button</button>
      </SignInWithMetamaskButton>
    )
  }
  ```

  ```jsx {{ filename: 'example.js' }}
  import { SignInWithMetamaskButton } from '@clerk/clerk-react'

  export default function Example() {
    return (
      <SignInWithMetamaskButton mode="modal">
        <button>Custom sign in button</button>
      </SignInWithMetamaskButton>
    )
  }
  ```

  ```jsx {{ filename: 'pages/index.js' }}
  import { SignInWithMetamaskButton } from '@clerk/remix'

  export default function Home() {
    return (
      <SignInWithMetamaskButton mode="modal">
        <button>Custom sign in button</button>
      </SignInWithMetamaskButton>
    )
  }
  ```

  ```vue {{ filename: 'example.vue' }}
  <script setup>
  import { SignInWithMetamaskButton } from '@clerk/vue'
  </script>

  <template>
    <SignInWithMetamaskButton mode="modal">
      <button>Custom sign in button</button>
    </SignInWithMetamaskButton>
  </template>
  ```
</CodeBlockTabs>

---
title: '`<SignOutButton>`'
description: The `<SignOutButton>` component is a button that signs a user out.
---

The `<SignOutButton>` component is a button that signs a user out. By default, it is a `<button>` tag that says **Sign Out**, but it is completely customizable by passing children.

## Properties

<Properties>
  - `asChild?`
  - `boolean`

  **For Astro only:** If `true`, the `<SignOutButton>` component will render its children as a child of the component.

  ---

  - `redirectUrl?`
  - `string`

  The full URL or path to navigate after successful sign-out.

  ---

  - `signOutOptions?`
  - [`SignOutOptions`](#sign-out-options)

  Options for signing out. Includes `sessionId` which if passed, signs the user out of a specific session. Useful for multi-session applications.

  ---

  - `children?`
  - `React.ReactNode`

  Children you want to wrap the `<SignOutButton>` in.
</Properties>

### `SignOutOptions`

The type of the `signOutOptions` prop for the `<SignOutButton>` component is defined as follows:

<Properties>
  - `sessionId?`
  - `string`

  The ID of a specific session to sign out of. Useful for multi-session applications.

  ---

  - `redirectUrl?`
  - `string`

  The full URL or path to navigate after successful sign-out.
</Properties>

## Usage

### Basic usage

<Tabs items={["Next.js", "React", "Astro", "Remix", "Tanstack React Start", "Vue"]}>
  <Tab>
    ```jsx {{ filename: 'app/page.tsx' }}
    import { SignOutButton } from '@clerk/nextjs'

    export default function Home() {
      return <SignOutButton />
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'src/sign-out.tsx' }}
    import { SignOutButton } from '@clerk/clerk-react'

    const SignOutPage = () => <SignOutButton />

    export default SignOutPage
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: 'pages/sign-out.astro' }}
    ---
    import { SignOutButton } from '@clerk/astro/components'
    ---

    <SignOutButton />
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'app/routes/sign-out.tsx' }}
    import { SignOutButton } from '@clerk/remix'

    export default function SignOutPage() {
      return <SignOutButton />
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/routes/sign-out.tsx' }}
    import { SignOutButton } from '@clerk/tanstack-react-start'
    import { createFileRoute } from '@tanstack/react-router'

    export const Route = createFileRoute('/sign-out')({
      component: SignOut,
    })

    function SignOut() {
      return <SignOutButton />
    }
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'sign-out.vue' }}
    <script setup>
    import { SignOutButton } from '@clerk/vue'
    </script>

    <template>
      <SignOutButton />
    </template>
    ```
  </Tab>
</Tabs>

### Custom usage

You can create a custom button by wrapping your own button, or button text, in the `<SignOutButton>` component.

<Tabs items={["Next.js", "React", "Remix", "Astro", "Vue"]}>
  <Tab>
    ```jsx {{ filename: 'app/page.js' }}
    import { SignOutButton } from '@clerk/nextjs'

    export default function Home() {
      return (
        <SignOutButton>
          <button>Custom sign out button</button>
        </SignOutButton>
      )
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'example.js' }}
    import { SignOutButton } from '@clerk/clerk-react'

    export default function Example() {
      return (
        <SignOutButton>
          <button>Custom sign out button</button>
        </SignOutButton>
      )
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'pages/index.js' }}
    import { SignOutButton } from '@clerk/remix'

    export default function Home() {
      return (
        <SignOutButton>
          <button>Custom sign out button</button>
        </SignOutButton>
      )
    }
    ```
  </Tab>

  <Tab>
    You must pass the `asChild` prop to the `<SignOutButton>` component if you are passing children to it.

    ```astro {{ filename: 'pages/index.astro' }}
    ---
    import { SignOutButton } from '@clerk/astro/components'
    ---

    <SignOutButton asChild>
      <button>Custom sign out button</button>
    </SignOutButton>
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'example.vue' }}
    <script setup>
    import { SignOutButton } from '@clerk/vue'
    </script>

    <template>
      <SignOutButton>
        <button>Custom sign out button</button>
      </SignOutButton>
    </template>
    ```
  </Tab>
</Tabs>

### Multi-session usage

#### Sign out of all sessions

Clicking the `<SignOutButton>` component signs the user out of all sessions. This is the default behavior.

#### Sign out of a specific session

You can sign out of a specific session by passing in a `sessionId` to the `signOutOptions` prop. This is useful for signing a single account out of a multi-session (multiple account) application.

In the following example, the `sessionId` is retrieved from the [`useAuth()`](/docs/hooks/use-auth) hook. If the user is not signed in, the `sessionId` will be `null`, and the user is shown the [`<SignInButton>`](/docs/components/unstyled/sign-in-button) component. If the user is signed in, the user is shown the `<SignOutButton>` component, which when clicked, signs the user out of that specific session.

<Tabs items={["Next.js", "React", "Remix", "Vue"]}>
  <Tab>
    ```tsx {{ filename: 'app/page.tsx' }}
    'use client'

    import { SignInButton, SignOutButton, useAuth } from '@clerk/nextjs'

    export default function Home() {
      const { sessionId } = useAuth()

      if (!sessionId) {
        return <SignInButton />
      }

      return <SignOutButton signOutOptions={{ sessionId }} />
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'example.js' }}
    import { SignInButton, SignOutButton, useAuth } from '@clerk/clerk-react'

    export default function Home() {
      const { sessionId } = useAuth()

      if (!sessionId) {
        return <SignInButton />
      }

      return <SignOutButton signOutOptions={{ sessionId }} />
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'pages/index.js' }}
    import { SignInButton, SignOutButton, useAuth } from '@clerk/remix'

    export default function Home() {
      const { sessionId } = useAuth()

      if (!sessionId) {
        return <SignInButton />
      }

      return <SignOutButton signOutOptions={{ sessionId }} />
    }
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'example.vue' }}
    <script setup>
    import { SignInButton, SignOutButton, useAuth } from '@clerk/vue'

    const { sessionId } = useAuth()
    </script>

    <template>
      <SignInButton v-if="!sessionId" />
      <SignOutButton v-else :sign-out-options="{ sessionId }" />
    </template>
    ```
  </Tab>
</Tabs>

---
title: '`<SignUp />` component'
description: Clerk's <SignUp /> component renders a UI for signing up users.
---

![The \<SignUp /> component renders a UI for signing up users.](/docs/images/ui-components/sign-up.png){{ style: { maxWidth: '460px' } }}

The `<SignUp />` component renders a UI for signing up users. The functionality of the `<SignUp />` component is controlled by the instance settings you specify in the [Clerk Dashboard](https://dashboard.clerk.com), such as [sign-in and sign-up options](/docs/authentication/configuration/sign-up-sign-in-options) and [social connections](/docs/authentication/social-connections/oauth). You can further customize your `<SignUp />` component by passing additional [properties](#properties) at the time of rendering.

> [!NOTE]
> The `<SignUp/>` and `<SignIn/>` components cannot render when a user is already signed in, unless the application allows multiple sessions. If a user is already signed in and the application only allows a single session, Clerk will redirect the user to the Home URL instead.

## Properties

All props are optional.

<Properties>
  - `appearance`
  - <code>[Appearance](/docs/customization/overview) | undefined</code>

  Optional object to style your components. Will only affect [Clerk components](/docs/components/overview) and not [Account Portal](/docs/account-portal/overview) pages.

  ---

  - `fallback`
  - `ReactNode`

  An optional element to be rendered while the component is mounting.

  ---

  - `fallbackRedirectUrl`
  - `string`

  The fallback URL to redirect to after the user signs up, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `forceRedirectUrl`
  - `string`

  If provided, this URL will always be used as the redirect destination after the user signs up. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `initialValues`
  - [`SignUpInitialValues`](/docs/references/javascript/types/sign-up-initial-values)

  The values used to prefill the sign-up fields with.

  ---

  - `oauthFlow`
  - `"redirect" | "popup" | "auto"`

  Determines how OAuth authentication is performed. Accepts the following properties:

  - `"redirect"`: Redirect to the OAuth provider on the current page.
  - `"popup"`: Open a popup window.
  - `"auto"`: Choose the best method based on whether the current domain typically requires the `"popup"` flow to correctly perform authentication.

  Defaults to `"auto"`.

  ---

  - `path`
  - `string`

  The path where the component is mounted on when `routing` is set to `path`. It is ignored in hash-based routing. For example: `/sign-up`.

  ---

  - `routing`
  - `'hash' | 'path'`

  The [routing](/docs/guides/routing) strategy for your pages.  Defaults to `'path'` for frameworks that handle routing, such as Next.js and Remix. Defaults to `hash` for all other SDK's, such as React.

  ---

  - `signInFallbackRedirectUrl`
  - `string`

  The fallback URL to redirect to after the user signs in, if there's no `redirect_url` in the path already. Used for the 'Already have an account? Sign in' link that's rendered.  Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signInForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs in. Used for the 'Already have an account? Sign in' link that's rendered. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signInUrl`
  - `string`

  The full URL or path to the sign-in page. Used for the 'Already have an account? Sign in' link that's rendered. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `unsafeMetadata`
  - [`SignUpUnsafeMetadata`](/docs/references/javascript/types/metadata#sign-up-unsafe-metadata)

  Metadata that can be read and set from the frontend and the backend. Once the sign-up is complete, the value of this field will be automatically copied to the created user's unsafe metadata (`User.unsafeMetadata`). One common use case is to collect custom information about the user during the sign-up process and store it in this property. Read more about [unsafe metadata](/docs/users/metadata#unsafe-metadata).
</Properties>

## Usage with frameworks

The following example includes basic implementation of the `<SignUp />` component. You can use this as a starting point for your own implementation.

<Tabs items={["Next.js", "Astro", "React", "React Router","Remix", "Tanstack React Start", "Vue"]}>
  <Tab>
    The following example demonstrates how you can use the `<SignUp />` component on a public page.

    If you would like to create a dedicated `/sign-up` page in your Next.js application, there are a few requirements you must follow. See the [dedicated guide](/docs/references/nextjs/custom-sign-up-page) for more information.

    ```tsx {{ filename: 'app/page.tsx' }}
    'use client'

    import { SignUp, useUser } from '@clerk/nextjs'

    export default function Home() {
      const { user } = useUser()

      if (!user) return <SignUp />

      return <div>Welcome!</div>
    }
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: 'pages/sign-up.astro' }}
    ---
    import { SignUp } from '@clerk/astro/components'
    ---

    <SignUp />
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'src/sign-up.tsx' }}
    import { SignUp } from '@clerk/clerk-react'

    const SignUpPage = () => <SignUp />

    export default SignUpPage
    ```
  </Tab>

  <Tab>
    If you would like to create a dedicated `/sign-up` page in your React Router application, there are a few requirements you must follow. See the [dedicated guide](/docs/references/react-router/custom-sign-up-page) for more information.

    ```tsx {{ filename: 'app/routes/sign-up.tsx' }}
    import { SignUp } from '@clerk/react-router'

    export default function SignUpPage() {
      return <SignUp />
    }
    ```
  </Tab>

  <Tab>
    If you would like to create a dedicated `/sign-up` page in your Remix application, there are a few requirements you must follow. See the [dedicated guide](/docs/references/remix/custom-sign-up-page) for more information.

    ```jsx {{ filename: 'app/routes/sign-up/$.tsx' }}
    import { SignUp } from '@clerk/remix'

    export default function SignUpPage() {
      return <SignUp />
    }
    ```
  </Tab>

  <Tab>
    If you would like to create a dedicated `/sign-up` page in your Tanstack React Start application, there are a few requirements you must follow. See the [dedicated guide](/docs/references/tanstack-react-start/custom-sign-up-page) for more information.

    ```tsx {{ filename: 'app/routes/sign-up.tsx' }}
    import { SignUp } from '@clerk/tanstack-react-start'
    import { createFileRoute } from '@tanstack/react-router'

    export const Route = createFileRoute('/sign-up')({
      component: SignUp,
    })

    function SignUp() {
      return <SignUp />
    }
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'sign-up.vue' }}
    <script setup lang="ts">
    import { SignUp } from '@clerk/vue'
    </script>

    <template>
      <SignUp />
    </template>
    ```
  </Tab>
</Tabs>

<If sdk="js-frontend">
  ## Usage with JavaScript

  The following methods available on an instance of the [`Clerk`](/docs/references/javascript/clerk) class are used to render and control the `<SignUp />` component:

  - [`mountSignUp()`](#mount-sign-up)
  - [`unmountSignUp()`](#unmount-sign-up)
  - [`openSignUp()`](#open-sign-up)
  - [`closeSignUp()`](#close-sign-up)

  The following examples assume that you have followed the [quickstart](/docs/quickstarts/javascript) in order to add Clerk to your JavaScript application.

  ### `mountSignUp()`

  Render the `<SignUp />` component to an HTML `<div>` element.

  ```typescript
  function mountSignUp(node: HTMLDivElement, props?: SignUpProps): void
  ```

  #### `mountSignUp()` params

  <Properties>
    - `node `
    - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

    The `<div>` element used to render in the `<SignUp />` component

    ---

    - `props?`
    - [`SignUpProps`](#properties)

    The properties to pass to the `<SignUp />` component.
  </Properties>

  #### `mountSignUp()` usage

  ```typescript {{ filename: 'main.ts', mark: [15] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  document.getElementById('app').innerHTML = `
    <div id="sign-up"></div>
  `

  const signUpDiv = document.getElementById('sign-up')

  clerk.mountSignUp(signUpDiv)
  ```

  ### `unmountSignUp()`

  Unmount and run cleanup on an existing `<SignUp />` component instance.

  ```typescript
  function unmountSignUp(node: HTMLDivElement): void
  ```

  #### `unmountSignUp()` params

  <Properties>
    - `node `
    - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

    The container `<div>` element with a rendered `<SignUp />` component instance
  </Properties>

  #### `unmountSignUp()` usage

  ```typescript {{ filename: 'main.ts', mark: [19] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  document.getElementById('app').innerHTML = `
    <div id="sign-up"></div>
  `

  const signUpDiv = document.getElementById('sign-up')

  clerk.mountSignUp(signUpDiv)

  // ...

  clerk.unmountSignUp(signUpDiv)
  ```

  ### `openSignUp()`

  Opens the `<SignUp />` component as an overlay at the root of your HTML `body` element.

  ```typescript
  function openSignUp(props?: SignUpProps): void
  ```

  #### `openSignUp()` params

  <Properties>
    - `props?`
    - [`SignUpProps`](#properties)

    The properties to pass to the `<SignUp />` component
  </Properties>

  #### `openSignUp()` usage

  ```js {{ filename: 'main.js', mark: [9] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  clerk.openSignUp()
  ```

  ### `closeSignUp()`

  Closes the sign up overlay.

  ```typescript
  function closeSignUp(): void
  ```

  #### `closeSignUp()` usage

  ```js {{ filename: 'main.js', mark: [13] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  clerk.openSignUp()

  // ...

  clerk.closeSignUp()
  ```
</If>

## Customization

To learn about how to customize Clerk components, see the [customization documentation](/docs/customization/overview).

If Clerk's prebuilt components don't meet your specific needs or if you require more control over the logic, you can rebuild the existing Clerk flows using the Clerk API. For more information, see the [custom flow guides](/docs/custom-flows/overview).

---
title: '`<SignUpButton>`'
description: The <SignUpButton> component is a button that links to the sign-up page or displays the sign-up modal.
---

The `<SignUpButton>` component is a button that links to the sign-up page or displays the sign-up modal.

## Properties

<Properties>
  - `asChild?`
  - `boolean`

  **For Astro only:** If `true`, the `<SignUpButton>` component will render its children as a child of the component.

  ---

  - `forceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs up. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `fallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs up, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `oauthFlow`
  - `"redirect" | "popup" | "auto"`

  Determines how OAuth authentication is performed. Accepts the following properties:

  - `"redirect"`: Redirect to the OAuth provider on the current page.
  - `"popup"`: Open a popup window.
  - `"auto"`: Choose the best method based on whether the current domain typically requires the `"popup"` flow to correctly perform authentication.

  Defaults to `"auto"`.

  ---

  - `signInForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs in. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signInFallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs in, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `mode?`
  - `'redirect' | 'modal'`

  Determines what happens when a user clicks on the `<SignUpButton>`. Setting this to `'redirect'` will redirect the user to the sign-up route. Setting this to `'modal'` will open a modal on the current route. Defaults to `'redirect'`

  ---

  - `children?`
  - `React.ReactNode`

  Children you want to wrap the `<SignUpButton>` in.

  ---

  - `initialValues`
  - [`SignUpInitialValues`](/docs/references/javascript/types/sign-up-initial-values)

  The values used to prefill the sign-up fields with.

  ---

  - `unsafeMetadata`
  - [`SignUpUnsafeMetadata`](/docs/references/javascript/types/metadata#sign-up-unsafe-metadata)

  Metadata that can be read and set from the frontend and the backend. Once the sign-up is complete, the value of this field will be automatically copied to the created user's unsafe metadata (`User.unsafeMetadata`). One common use case is to collect custom information about the user during the sign-up process and store it in this property. Read more about [unsafe metadata](/docs/users/metadata#unsafe-metadata).
</Properties>

## Usage

### Basic usage

<Tabs items={["Next.js", "React", "Astro", "Remix", "Tanstack React Start", "Vue"]}>
  <Tab>
    ```jsx {{ filename: 'app/page.tsx' }}
    import { SignUpButton } from '@clerk/nextjs'

    export default function Home() {
      return <SignUpButton />
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'src/sign-up.tsx' }}
    import { SignUpButton } from '@clerk/clerk-react'

    const SignUpPage = () => <SignUpButton />

    export default SignUpPage
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: 'pages/sign-up.astro' }}
    ---
    import { SignUpButton } from '@clerk/astro/components'
    ---

    <SignUpButton />
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'app/routes/sign-up/$.tsx' }}
    import { SignUpButton } from '@clerk/remix'

    export default function SignUpPage() {
      return <SignUpButton />
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/routes/sign-up.tsx' }}
    import { SignUpButton } from '@clerk/tanstack-react-start'
    import { createFileRoute } from '@tanstack/react-router'

    export const Route = createFileRoute('/sign-up')({
      component: SignUp,
    })

    function SignUp() {
      return <SignUpButton />
    }
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'src/App.vue' }}
    <script setup>
    import { SignUpButton } from '@clerk/vue'
    </script>

    <template>
      <SignUpButton />
    </template>
    ```
  </Tab>
</Tabs>

### Custom usage

You can create a custom button by wrapping your own button, or button text, in the `<SignUpButton>` component.

<Tabs items={["Next.js", "React", "Remix", "Astro", "Vue"]}>
  <Tab>
    ```jsx {{ filename: 'app/page.tsx' }}
    import { SignUpButton } from '@clerk/nextjs'

    export default function Home() {
      return (
        <SignUpButton>
          <button>Custom sign up button</button>
        </SignUpButton>
      )
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'src/App.jsx' }}
    import { SignUpButton } from '@clerk/clerk-react'

    export default function Example() {
      return (
        <SignUpButton>
          <button>Custom sign up button</button>
        </SignUpButton>
      )
    }
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: 'app/routes/_index.tsx' }}
    import { SignUpButton } from '@clerk/remix'

    export default function Home() {
      return (
        <SignUpButton>
          <button>Custom sign up button</button>
        </SignUpButton>
      )
    }
    ```
  </Tab>

  <Tab>
    You must pass the `asChild` prop to the `<SignUpButton>` component if you are passing children to it.

    ```astro {{ filename: 'src/pages/index.astro' }}
    ---
    import { SignUpButton } from '@clerk/astro/components'
    ---

    <SignUpButton asChild>
      <button>Custom sign up button</button>
    </SignUpButton>
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'src/App.vue' }}
    <script setup>
    import { SignUpButton } from '@clerk/vue'
    </script>

    <template>
      <SignUpButton>
        <button>Custom sign up button</button>
      </SignUpButton>
    </template>
    ```
  </Tab>
</Tabs>

---
title: '`<UserButton />` component'
description: Clerk's <UserButton /> component is used to render the familiar user button UI popularized by Google.
search:
  rank: 1
---

![The \<UserButton /> component renders the familiar user button UI popularized by Google.](/docs/images/ui-components/user-button.png){{ style: { maxWidth: '436px' } }}

The `<UserButton />` component renders the familiar user button UI popularized by Google. When selected, it opens a dropdown menu with options to manage account settings and sign out. The "Manage account" option launches the [`<UserProfile />`](/docs/components/user/user-profile) component, providing access to profile and security settings.

For users that have [multi-session](/docs/authentication/configuration/session-options#multi-session-applications) enabled, the `<UserButton />` also allows users to sign into multiple accounts at once and instantly switch between them without the need for a full page reload. Learn more [here](/docs/authentication/configuration/session-options#multi-session-applications).

## Properties

The `<UserButton />` component accepts the following properties, all of which are **optional**:

<Properties>
  - `afterMultiSessionSingleSignOutUrl` (deprecated)
  - `string`

  **Deprecated. Move `afterMultiSessionSingleSignOutUrl` to [`<ClerkProvider />`](/docs/components/clerk-provider).** The full URL or path to navigate to after signing out from a currently active account in a multi-session app.

  ---

  - `afterSignOutUrl` (deprecated)
  - `string`

  **Deprecated. Move `afterSignOutUrl` to [`<ClerkProvider />`](/docs/components/clerk-provider).** The full URL or path to navigate to after a successful sign-out.

  ---

  - `afterSwitchSessionUrl`
  - `string`

  The full URL or path to navigate to after a successful account change in a multi-session app.

  ---

  - `appearance`
  - <code>[Appearance](/docs/customization/overview) | undefined</code>

  Optional object to style your components. Will only affect [Clerk components](/docs/components/overview) and not [Account Portal](/docs/account-portal/overview) pages.

  ---

  - `defaultOpen`
  - `boolean`

  Controls whether the `<UserButton />` should open by default during the first render.

  ---

  - `showName`
  - `boolean`

  Controls if the user name is displayed next to the user image button.

  ---

  - `signInUrl`
  - `string`

  The full URL or path to navigate to when the **Add another account** button is clicked. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `userProfileMode`
  - `'modal' | 'navigation'`

  Controls whether selecting the **Manage your account** button will cause the [`<UserProfile />`](/docs/components/user/user-profile) component to open as a modal, or if the browser will navigate to the `userProfileUrl` where `<UserProfile />` is mounted as a page. Defaults to: `'modal'`.

  ---

  - `userProfileProps`
  - `object`

  Specify options for the underlying [`<UserProfile />`](/docs/components/user/user-profile) component. For example: `{additionalOAuthScopes: {google: ['foo', 'bar'], github: ['qux']}}`.

  ---

  - `userProfileUrl`
  - `string`

  The full URL or path leading to the user management interface.

  ---

  - `fallback?`
  - `ReactNode`

  An optional element to be rendered while the component is mounting.
</Properties>

## Usage with frameworks

In the following example, `<UserButton />` is mounted inside a header component, which is a common pattern on many websites and applications. When the user is signed in, they will see their avatar and be able to open the popup menu.

<Tabs items={["Next.js", "React", "Astro", "Remix", "Tanstack React Start", "Vue"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: 'layout.tsx', mark: [8] }}
      import { ClerkProvider, SignedIn, SignedOut, SignInButton, UserButton } from '@clerk/nextjs'

      function Header() {
        return (
          <header style={{ display: 'flex', justifyContent: 'space-between', padding: 20 }}>
            <h1>My App</h1>
            <SignedIn>
              <UserButton />
            </SignedIn>
            <SignedOut>
              <SignInButton />
            </SignedOut>
          </header>
        )
      }

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <html lang="en">
            <ClerkProvider>
              <Header />
              {children}
            </ClerkProvider>
          </html>
        )
      }
      ```

      ```jsx {{ filename: 'userButtonExample.tsx', mark: [8] }}
      import { ClerkProvider, SignedIn, SignedOut, SignInButton, UserButton } from '@clerk/nextjs'

      function Header() {
        return (
          <header style={{ display: 'flex', justifyContent: 'space-between', padding: 20 }}>
            <h1>My App</h1>
            <SignedIn>
              <UserButton />
            </SignedIn>
            <SignedOut>
              <SignInButton />
            </SignedOut>
          </header>
        )
      }

      function MyApp({ pageProps }) {
        return (
          <ClerkProvider {...pageProps}>
            <Header />
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    ```tsx {{ filename: 'src/App.tsx' }}
    import { SignedIn, UserButton, SignInButton, SignedOut } from '@clerk/clerk-react'

    export default function App() {
      return (
        <header>
          <SignedIn>
            <UserButton />
          </SignedIn>
          <SignedOut>
            <SignInButton />
          </SignedOut>
        </header>
      )
    }
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: 'pages/index.astro' }}
    ---
    import { SignedIn, UserButton, SignInButton, SignedOut } from '@clerk/astro/components'
    ---

    <SignedIn>
      <UserButton />
    </SignedIn>
    <SignedOut>
      <SignInButton />
    </SignedOut>
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'router/index.tsx' }}
    import { SignedIn, UserButton, SignInButton, SignedOut } from '@clerk/remix'
    import { getAuth } from '@clerk/remix/ssr.server'
    import { LoaderFunction, redirect } from '@remix-run/node'

    export const loader: LoaderFunction = async (args) => {
      const { userId } = await getAuth(args)

      if (!userId) {
        return redirect('/sign-in')
      }

      return {
        props: {
          userId,
        },
      }
    }

    export default function Index() {
      return (
        <header>
          <SignedIn>
            <UserButton />
          </SignedIn>
          <SignedOut>
            <SignInButton />
          </SignedOut>
        </header>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/routes/index.tsx' }}
    import { SignedIn, UserButton, SignInButton, SignedOut } from '@clerk/tanstack-react-start'
    import { createFileRoute } from '@tanstack/react-router'

    export const Route = createFileRoute('/')({
      component: Home,
    })

    function Home() {
      return (
        <header>
          <SignedIn>
            <UserButton />
          </SignedIn>
          <SignedOut>
            <SignInButton />
          </SignedOut>
        </header>
      )
    }
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'header.vue' }}
    <script setup>
    import { SignedIn, UserButton, SignInButton, SignedOut } from '@clerk/vue'
    </script>

    <template>
      <header>
        <SignedIn>
          <UserButton />
        </SignedIn>
        <SignedOut>
          <SignInButton />
        </SignedOut>
      </header>
    </template>
    ```
  </Tab>
</Tabs>

<If sdk="js-frontend">
  ## Usage with JavaScript

  The following methods available on an instance of the [`Clerk`](/docs/references/javascript/clerk) class are used to render and control the `<UserButton />` component:

  - [`mountUserButton()`](#mount-user-button)
  - [`unmountUserButton()`](#unmount-user-button)

  The following examples assume that you have followed the [quickstart](/docs/quickstarts/javascript) in order to add Clerk to your JavaScript application.

  ### `mountUserButton()`

  Render the `<UserButton />` component to an HTML `<div>` element.

  ```typescript
  function mountUserButton(node: HTMLDivElement, props?: UserButtonProps): void
  ```

  #### `mountUserButton()` params

  <Properties>
    - `node`
    - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

    The `<div>` element used to render in the `<UserButton />` component

    ---

    - `props?`
    - [`UserButtonProps`](#properties)

    The properties to pass to the `<UserButton />` component
  </Properties>

  #### `mountUserButton()` usage

  ```js {{ filename: 'main.js', mark: [15] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  document.getElementById('app').innerHTML = `
    <div id="user-button"></div>
  `

  const userbuttonDiv = document.getElementById('user-button')

  clerk.mountUserButton(userbuttonDiv)
  ```

  ### `unmountUserButton()`

  Unmount and run cleanup on an existing `<UserButton />` component instance.

  ```typescript
  function unmountUserButton(node: HTMLDivElement): void
  ```

  #### `unmountUserButton()` params

  <Properties>
    - `node`
    - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

    The container `<div>` element with a rendered `<UserButton />` component instance.
  </Properties>

  #### `unmountUserButton()` usage

  ```js {{ filename: 'main.js', mark: [19] }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(clerkPubKey)
  await clerk.load()

  document.getElementById('app').innerHTML = `
    <div id="user-button"></div>
  `

  const userButtonDiv = document.getElementById('user-button')

  clerk.mountUserButton(userButtonDiv)

  // ...

  clerk.unmountUserButton(userButtonDiv)
  ```
</If>

## Customization

To learn about how to customize Clerk components, see the [customization documentation](/docs/customization/overview).

You can also [add custom actions and links to the `<UserButton />` menu](/docs/customization/user-button).

---
title: '`<UserProfile />` component'
description: Clerk's <UserProfile /> component is used to render a beautiful, full-featured account management UI that allows users to manage their profile and security settings.
---

![The \<UserProfile /> component renders a full-featured account management UI that allows users to manage their profile and security settings.](/docs/images/ui-components/user-profile.png){{ style: { maxWidth: '100%' } }}

The `<UserProfile />` component is used to render a beautiful, full-featured account management UI that allows users to manage their profile and security settings.

## Properties

All props are optional.

<Properties>
  - `appearance`
  - <code>[Appearance](/docs/customization/overview) | undefined</code>

  Optional object to style your components. Will only affect [Clerk components](/docs/components/overview) and not [Account Portal](/docs/account-portal/overview) pages.

  ---

  - `routing`
  - `'hash' | 'path'`

  The [routing](/docs/guides/routing) strategy for your pages. Defaults to `'path'` for frameworks that handle routing, such as Next.js and Remix. Defaults to `hash` for all other SDK's, such as React.

  ---

  - `path`
  - `string`

  The path where the component is mounted on when `routing` is set to `path`. It is ignored in hash-based routing. For example: `/user-profile`.

  ---

  - `additionalOAuthScopes`
  - `object`

  Specify additional scopes per OAuth provider that your users would like to provide if not already approved.  For example: `{google: ['foo', 'bar'], github: ['qux']}`.

  ---

  - `customPages`
  - <code>[CustomPage](/docs/references/javascript/types/custom-page)\[]</code>

  An array of custom pages to add to the user profile. Only available for the [JavaScript SDK](/docs/references/javascript/overview). To add custom pages with React-based SDK's, see the [dedicated guide](/docs/customization/user-profile).

  ---

  - `fallback?`
  - `ReactNode`

  An optional element to be rendered while the component is mounting.
</Properties>

## Usage with frameworks

<Tabs items={["Next.js", "React", "Astro", "Remix", "Tanstack React Start", "Vue"]}>
  <Tab>
    The `<UserProfile />` component must embedded using the [Next.js optional catch-all route](https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#optional-catch-all-routes) in order for the routing to work.

    ```jsx {{ filename: 'app/user-profile/[[...user-profile]]/page.tsx' }}
    import { UserProfile } from '@clerk/nextjs'

    const UserProfilePage = () => <UserProfile />

    export default UserProfilePage
    ```
  </Tab>

  <Tab>
    ```jsx {{ filename: '/user-profile.tsx' }}
    import { UserProfile } from '@clerk/clerk-react'

    const UserProfilePage = () => <UserProfile />

    export default UserProfilePage
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: 'pages/user.astro' }}
    ---
    import { UserProfile } from '@clerk/astro/components'
    ---

    <UserProfile />
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'routes/user/$.tsx' }}
    import { UserProfile } from '@clerk/remix'

    export default function UserProfilePage() {
      return <UserProfile />
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/routes/user-profile.tsx' }}
    import { UserProfile } from '@clerk/tanstack-react-start'
    import { createFileRoute } from '@tanstack/react-router'

    export const Route = createFileRoute('/user-profile')({
      component: UserProfile,
    })

    function UserProfile() {
      return <UserProfile />
    }
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'user.vue' }}
    <script setup>
    import { UserProfile } from '@clerk/vue'
    </script>

    <template>
      <UserProfile />
    </template>
    ```
  </Tab>
</Tabs>

## Usage with JavaScript

The following methods available on an instance of the [`Clerk`](/docs/references/javascript/clerk) class are used to render and control the `<UserProfile />` component:

- [`mountUserProfile()`](#mount-user-profile)
- [`unmountUserProfile()`](#unmount-user-profile)
- [`openUserProfile()`](#open-user-profile)
- [`closeUserProfile()`](#close-user-profile)

The following examples assume that you have followed the [quickstart](/docs/quickstarts/javascript) in order to add Clerk to your JavaScript application.

### `mountUserProfile()`

Render the `<UserProfile />` component to an HTML `<div>` element.

```typescript
function mountUserProfile(node: HTMLDivElement, props?: UserProfileProps): void
```

#### `mountUserProfile()` params

<Properties>
  - `node`
  - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

  The `<div>` element used to render in the `<UserProfile />` component

  ---

  - `props?`
  - [`UserProfileProps`](#properties)

  The properties to pass to the `<UserProfile />` component
</Properties>

#### `mountUserProfile()` usage

```js {{ filename: 'main.js', mark: [15] }}
import { Clerk } from '@clerk/clerk-js'

// Initialize Clerk with your Clerk Publishable Key
const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

const clerk = new Clerk(clerkPubKey)
await clerk.load()

document.getElementById('app').innerHTML = `
  <div id="user-profile"></div>
`

const userProfileDiv = document.getElementById('user-profile')

clerk.mountUserProfile(userProfileDiv)
```

### `unmountUserProfile()`

Unmount and run cleanup on an existing `<UserProfile />` component instance.

```typescript
function unmountUserProfile(node: HTMLDivElement): void
```

#### `unmountUserProfile()` params

<Properties>
  - `node`
  - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

  The container `<div>` element with a rendered `<UserProfile />` component instance.
</Properties>

#### `unmountUserProfile()` usage

```js {{ filename: 'main.js', mark: [19] }}
import { Clerk } from '@clerk/clerk-js'

// Initialize Clerk with your Clerk Publishable Key
const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

const clerk = new Clerk(clerkPubKey)
await clerk.load()

document.getElementById('app').innerHTML = `
  <div id="user-profile"></div>
`

const userProfileDiv = document.getElementById('user-profile')

clerk.mountUserProfile(userProfileDiv)

// ...

clerk.unmountUserProfile(userProfileDiv)
```

### `openUserProfile()`

Opens the `<UserProfile />` component as an overlay at the root of your HTML `body` element.

```typescript
function openUserProfile(props?: UserProfileProps): void
```

#### `openUserProfile()` params

<Properties>
  - `props?`
  - [`UserProfileProps`](#properties)

  The properties to pass to the `<UserProfile />` component
</Properties>

#### `openUserProfile()` usage

```js {{ filename: 'main.js', mark: [15] }}
import { Clerk } from '@clerk/clerk-js'

// Initialize Clerk with your Clerk Publishable Key
const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

const clerk = new Clerk(clerkPubKey)
await clerk.load()

document.getElementById('app').innerHTML = `
  <div id="user-profile"></div>
`

const userProfileDiv = document.getElementById('user-profile')

clerk.openUserProfile(userProfileDiv)
```

### `closeUserProfile()`

Closes the user profile overlay.

```typescript
function closeUserProfile(): void
```

#### `closeUserProfile()` usage

```js {{ filename: 'main.js', mark: [15] }}
import { Clerk } from '@clerk/clerk-js'

// Initialize Clerk with your Clerk Publishable Key
const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

const clerk = new Clerk(clerkPubKey)
await clerk.load()

document.getElementById('app').innerHTML = `
  <div id="user-profile"></div>
`

const userProfileDiv = document.getElementById('user-profile')

clerk.closeUserProfile(userProfileDiv)
```

## Customization

To learn about how to customize Clerk components, see the [customization documentation](/docs/customization/overview).

In addition, you also can add custom pages and links to the `<UserProfile />` navigation sidenav. For more information, refer to the [Custom Pages documentation](/docs/customization/user-profile).

---
title: '`<Waitlist />` component'
description: The <Waitlist /> component renders a waitlist form that allows users to join for early access to your application.
---

![The \<Waitlist /> component renders a form that allows users to join for early access to your app.](/docs/images/ui-components/waitlist.png){{ style: { maxWidth: '460px' } }}

In **Waitlist** mode, users can register their interest in your app by joining a waitlist. This mode is ideal for apps in early development stages or those wanting to generate interest before launch. [Learn more about additional features available in **Waitlist** mode](/docs/authentication/configuration/restrictions#waitlist).

The `<Waitlist />` component renders a form that allows users to join for early access to your app.

> [!NOTE]
> If you're using Next.js, the`<Waitlist />` component is available in `@clerk/nextjs@6.2.0` and above.

## Enable Waitlist mode

Before using the `<Waitlist />` component, you must enable **Waitlist** mode in the Clerk Dashboard:

1. In the Clerk Dashboard, navigate to the [**Restrictions**](https://dashboard.clerk.com/last-active?path=user-authentication/restrictions) page.
1. Under the **Sign-up modes** section, enable **Waitlist**.

## Properties

All props are optional.

<Properties>
  - `afterJoinWaitlistUrl`
  - `string`

  The full URL or path to navigate to after joining the waitlist.

  ---

  - `appearance`
  - <code>[Appearance](/docs/customization/overview) | undefined</code>

  Optional object to style your components. Will only affect [Clerk components](/docs/components/overview) and not [Account Portal](/docs/account-portal/overview) pages.

  ---

  - `fallback?`
  - `ReactNode`

  An optional element to be rendered while the component is mounting.

  ---

  - `signInUrl`
  - `string`

  The full URL or path to the sign in page. Used for the 'Already have an account? Sign in' link that's rendered. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.
</Properties>

## Usage with frameworks

> [!WARNING]
> Before using the `<Waitlist />` component, you must provide the `waitlistUrl` prop either in the [`<ClerkProvider>`](/docs/components/clerk-provider#properties) or [`<SignIn />`](/docs/components/authentication/sign-in#properties) component to ensure proper functionality.

The following example includes a basic implementation of the `<Waitlist />` component. You can use this as a starting point for your own implementation.

<Tabs items={["Next.js", "React", "Astro", "Tanstack React Start", "Vue"]}>
  <Tab>
    ```tsx {{ filename: 'app/waitlist/[[...waitlist]]/page.tsx' }}
    import { Waitlist } from '@clerk/nextjs'

    export default function WaitlistPage() {
      return <Waitlist />
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'src/waitlist.tsx' }}
    import { Waitlist } from '@clerk/clerk-react'

    export default function WaitlistPage() {
      return <Waitlist />
    }
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: 'pages/waitlist.astro' }}
    ---
    import { Waitlist as WaitlistAstro } from '@clerk/astro/components'
    ---

    <WaitlistAstro />
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/routes/waitlist.tsx' }}
    import { Waitlist } from '@clerk/tanstack-react-start'
    import { createFileRoute } from '@tanstack/react-router'

    export const Route = createFileRoute('/waitlist')({
      component: Waitlist,
    })

    function WaitlistPage() {
      return <Waitlist />
    }
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'waitlist.vue' }}
    <script setup lang="ts">
    import { Waitlist } from '@clerk/vue'
    </script>

    <template>
      <Waitlist />
    </template>
    ```
  </Tab>
</Tabs>

## Usage with JavaScript

The following methods available on an instance of the [`Clerk`](/docs/references/javascript/clerk) class are used to render and control the `<Waitlist />` component:

- [`mountWaitlist()`](#mount-waitlist)
- [`unmountWaitlist()`](#unmount-waitlist)
- [`openWaitlist()`](#open-waitlist)
- [`closeWaitlist()`](#close-waitlist)

The following examples assume that you followed the [quickstart](/docs/quickstarts/javascript) to add Clerk to your JavaScript app.

### <code>mount<wbr />Waitlist()</code>

Render the `<Waitlist />` component to an HTML `<div>` element.

```typescript
function mountWaitlist(node: HTMLDivElement, props?: WaitlistProps): void
```

### <code>mount<wbr />Waitlist()</code> params

<Properties>
  - `node`
  - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

  The `<div>` element used to render in the `<Waitlist />` component

  ---

  - `props?`
  - [`WaitlistProps`](#properties)

  The properties to pass to the `<Waitlist />` component
</Properties>

#### `mountWaitlist()` usage

```js {{ filename: 'main.js', mark: [13] }}
import { Clerk } from '@clerk/clerk-js'

// Initialize Clerk with your Clerk Publishable Key
const clerk = new Clerk('{{pub_key}}')
await clerk.load()

document.getElementById('app').innerHTML = `
  <div id="waitlist"></div>
`

const waitlistDiv = document.getElementById('waitlist')

clerk.mountWaitlist(waitlistDiv)
```

### <code>unmount<wbr />Waitlist()</code>

Unmount and run cleanup on an existing `<Waitlist />` component instance.

```typescript
function unmountWaitlist(node: HTMLDivElement): void
```

#### `unmountWaitlist()` params

<Properties>
  - `node`
  - [`HTMLDivElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)

  The container `<div>` element with a rendered `<Waitlist />` component instance
</Properties>

#### `unmountWaitlist()` usage

```js {{ filename: 'main.js', mark: [17] }}
import { Clerk } from '@clerk/clerk-js'

// Initialize Clerk with your Clerk Publishable Key
const clerk = new Clerk('{{pub_key}}')
await clerk.load()

document.getElementById('app').innerHTML = `
  <div id="waitlist"></div>
`

const waitlistDiv = document.getElementById('waitlist')

clerk.mountWaitlist(waitlistDiv)

// ...

clerk.unmountWaitlist(waitlistDiv)
```

### `openWaitlist()`

Opens the `<Waitlist />` component as an overlay at the root of your HTML `body` element.

```typescript
function openWaitlist(props?: WaitlistProps): void
```

#### `openWaitlist()` params

<Properties>
  - `props?`
  - [`WaitlistProps`](#properties)

  The properties to pass to the `<Waitlist />` component
</Properties>

#### `openWaitlist()` usage

```js {{ filename: 'main.js', mark: [13] }}
import { Clerk } from '@clerk/clerk-js'

// Initialize Clerk with your Clerk Publishable Key
const clerk = new Clerk('{{pub_key}}')
await clerk.load()

document.getElementById('app').innerHTML = `
  <div id="waitlist"></div>
`

const waitlistDiv = document.getElementById('waitlist')

clerk.openWaitlist(waitlistDiv)
```

### `closeWaitlist()`

Closes the waitlist overlay.

```typescript
function closeWaitlist(): void
```

#### `closeWaitlist()` usage

```js {{ filename: 'main.js', mark: [17] }}
import { Clerk } from '@clerk/clerk-js'

// Initialize Clerk with your Clerk Publishable Key
const clerk = new Clerk('{{pub_key}}')
await clerk.load()

document.getElementById('app').innerHTML = `
  <div id="waitlist"></div>
`

const waitlistDiv = document.getElementById('waitlist')

clerk.openWaitlist(waitlistDiv)

// ...

clerk.closeWaitlist(waitlistDiv)
```

## Customization

To learn about how to customize Clerk components, see the [customization guide](/docs/customization/overview).

---
title: '`$authStore`'
description: Clerk's $authStore nanostore provides a convenient way to access the current auth state and helper methods for managing the active session.
---

The `$authStore` store provides a convenient way to access the current auth state and helper methods for managing the active session.

## Returns

<Properties>
  - `userId`
  - `string`

  The ID of the current user.

  ---

  - `sessionId`
  - `string`

  The ID of the current session.

  ---

  - `orgId`
  - `string`

  The ID of the user's active organization.

  ---

  - `orgRole`
  - `string`

  The current user's role in their active organization.

  ---

  - `orgSlug`
  - `string`

  The URL-friendly identifier of the user's active organization.
</Properties>

## How to use the `$authStore` store

The following example demonstrates how to use the `$authStore` store to access the current auth state. It uses `userId` to detect if the user is signed in.

<CodeBlockTabs options={['React', 'Vue', 'Svelte']}>
  ```tsx {{ filename: 'components/external-data.tsx' }}
  import { useStore } from '@nanostores/react'
  import { $authStore } from '@clerk/astro/client'

  export default function ExternalData() {
    const { userId } = useStore($authStore)

    if (userId === undefined) {
      // Handle loading state however you like
      return <div>Loading...</div>
    }

    if (userId === null) {
      // Handle signed out state however you like
      return <div>Sign in to view this page</div>
    }

    return <div>...</div>
  }
  ```

  ```vue {{ filename: 'components/external-data.vue' }}
  <script setup>
  import { useStore } from '@nanostores/vue'
  import { $authStore } from '@clerk/astro/client'

  const auth = useStore($authStore)
  </script>

  <template>
    <div v-if="auth.userId === undefined">Loading...</div>
    <div v-else-if="auth.userId === null">Sign in to view this page</div>
    <div v-else>...</div>
  </template>
  ```

  ```svelte {{ filename: 'components/external-data.svelte' }}
  <script>
    // The $ prefix is reserved in Svelte for its own reactivity system.
    // Alias the imports to avoid conflicts.
    import { $authStore as auth } from '@clerk/astro/client'
  </script>

  {#if $auth.userId === undefined}
    <div>Loading...</div>
  {:else if $auth.userId === null}
    <div>Sign in to view this page</div>
  {:else}
    <div>...</div>
  {/if}
  ```
</CodeBlockTabs>

---
title: '`$clerkStore`'
description: Clerk's $clerkStore nanostore provides a convenient way to access the `Clerk` object. This provides access to some methods that are not available in other stores.
---

The `$clerkStore` store provides a convenient way to access the [`Clerk`](/docs/references/javascript/clerk){{ target: '_blank' }} object. This provides access to some methods that are not available in other stores.

> [!WARNING]
> This is intended to be used for advanced use cases, like building a completely custom OAuth flow or as an escape hatch for getting access to the `Clerk` object.

## How to use the `$clerkStore` store

<CodeBlockTabs options={['React', 'Vue', 'Svelte']}>
  ```tsx {{ filename: 'components/sign-in.tsx' }}
  import { useStore } from '@nanostores/react'
  import { $clerkStore } from '@clerk/astro/client'

  export default function SignIn() {
    const clerk = useStore($clerkStore)

    return <button onClick={() => clerk.openSignIn()}>Sign in</button>
  }
  ```

  ```vue {{ filename: 'components/sign-in.vue' }}
  <script setup>
  import { useStore } from '@nanostores/vue'
  import { $clerkStore } from '@clerk/astro/client'

  const clerk = useStore($clerkStore)

  const openSignIn = () => clerk.value.openSignIn()
  </script>

  <template>
    <button @click="openSignIn">Sign in</button>
  </template>
  ```

  ```svelte {{ filename: 'components/sign-in.svelte' }}
  <script>
    // The $ prefix is reserved in Svelte for its own reactivity system.
    // Alias the imports to avoid conflicts.
    import { $clerkStore as clerk } from '@clerk/astro/client'
  </script>

  <button on:click={() => $clerk.openSignIn()}>Sign in</button>
  ```
</CodeBlockTabs>

---
title: '`$organizationStore`'
description: Clerk's $organizationStore store retrieves the currently active organization.
---

The `$organizationStore` store is used to retrieve attributes of the currently active organization.

## How to use the `$organizationStore` store

The following example demonstrates how to use the `$organizationStore` store to access the [`Organization`](/docs/references/javascript/organization){{ target: '_blank' }} object, which allows you to access the current active organization.

<CodeBlockTabs options={['React', 'Vue', 'Svelte']}>
  ```tsx {{ filename: 'organization.tsx' }}
  import { useStore } from '@nanostores/react'
  import { $organizationStore } from '@clerk/astro/client'

  export default function Home() {
    const organization = useStore($organizationStore)

    if (organization === undefined) {
      // Add logic to handle loading state
      return null
    }

    if (organization === null) {
      // Add logic to handle no active organization state
      return null
    }

    return (
      <div>
        <p>This current organization is {organization.name}</p>
      </div>
    )
  }
  ```

  ```vue {{ filename: 'organization.vue' }}
  <script setup>
  import { useStore } from '@nanostores/vue'
  import { $organizationStore } from '@clerk/astro/client'

  const organization = useStore($organizationStore)
  </script>

  <template>
    <div v-if="organization === undefined">
      <!-- Add logic to handle loading state -->
    </div>
    <div v-else-if="organization === null">
      <!-- Add logic to handle no active organization state -->
    </div>
    <div v-else>
      <p>This current organization is {{ organization.name }}</p>
    </div>
  </template>
  ```

  ```svelte {{ filename: 'organization.svelte' }}
  <script>
    // The $ prefix is reserved in Svelte for its own reactivity system.
    // Alias the imports to avoid conflicts.
    import { $organizationStore as organization } from '@clerk/astro/client'
  </script>

  {#if $organization === undefined}
    <!-- Add logic to handle loading state -->
  {:else if $organization === null}
    <!-- Add logic to handle no active organization state -->
  {:else}
    <div>
      <p>This current organization is {$organization.name}</p>
    </div>
  {/if}
  ```
</CodeBlockTabs>

## Paginating data

The following example demonstrates how to implement pagination for organization memberships. The `memberships` state will be populated with the first page of the organization's memberships. When the "Previous page" or "Next page" button is clicked, the `fetchMemberships` function will be called to fetch the previous or next page of memberships.

You can implement this pattern to any Clerk function that returns a [`ClerkPaginatedResponse`](/docs/references/javascript/types/clerk-paginated-response){{ target: '_blank' }} object.

<CodeBlockTabs options={['React', 'Vue', 'Svelte']}>
  ```tsx {{ filename: 'members.tsx' }}
  import { useState, useEffect } from 'react'
  import { $organizationStore } from '@clerk/astro/client'
  import { useStore } from '@nanostores/react'

  export default function OrganizationMembers() {
    const [memberships, setMemberships] = useState([])
    const [currentPage, setCurrentPage] = useState(1)
    const organization = useStore($organizationStore)

    const pageSize = 10

    useEffect(() => {
      fetchMemberships()
    }, [currentPage, organization])

    const fetchMemberships = async () => {
      if (!organization) {
        return
      }

      const { data } = await organization.getMemberships({
        initialPage: currentPage,
        pageSize: 5,
      })
      setMemberships(data)
    }

    const fetchPrevious = () => setCurrentPage(currentPage - 1)
    const fetchNext = () => setCurrentPage(currentPage + 1)

    if (organization === undefined) {
      // Handle loading state
      return null
    }

    if (organization === null) {
      // Handle no organization state
      return null
    }

    return (
      <div>
        <h2>Organization members</h2>
        <ul>
          {memberships.map((membership) => (
            <li key={membership.id}>
              {membership.publicUserData.firstName} {membership.publicUserData.lastName} &lt;
              {membership.publicUserData.identifier}&gt; :: {membership.role}
            </li>
          ))}
        </ul>
        <div>
          <button onClick={fetchPrevious} disabled={currentPage === 1}>
            Previous
          </button>
          <button onClick={fetchNext}>Next</button>
        </div>
      </div>
    )
  }
  ```

  ```vue {{ filename: 'members.vue' }}
  <script setup>
  import { useStore } from '@nanostores/vue'
  import { $organization } from '@clerk/astro/client'
  import { ref, watchEffect } from 'vue'

  const memberships = ref([])
  const currentPage = ref(1)
  const organization = useStore($organizationStore)

  const pageSize = 10

  const fetchMemberships = async () => {
    if (!organization.value) {
      return
    }

    const { data } = await organization.value.getMemberships({
      initialPage: currentPage.value,
      pageSize: 5,
    })
    memberships.value = data
  }

  watchEffect(() => {
    if (!organization.value) {
      return
    }

    fetchMemberships()
  })

  const fetchPrevious = () => currentPage.value--
  const fetchNext = () => currentPage.value++
  </script>

  <template>
    <div v-if="organization === undefined">
      <!-- Handle loading state -->
    </div>
    <div v-else-if="organization === null">
      <!-- Handle no organization state -->
    </div>
    <div v-else>
      <h2>Organization members</h2>
      <ul>
        <li v-for="membership in memberships" :key="membership.id">
          {{ membership.publicUserData.firstName }} {{ membership.publicUserData.lastName }} &lt;{{
            membership.publicUserData.identifier
          }}&gt; :: {{ membership.role }}
        </li>
      </ul>
      <div>
        <button @click="fetchPrevious" :disabled="currentPage === 1">Previous</button>
        <button @click="fetchNext">Next</button>
      </div>
    </div>
  </template>
  ```

  ```svelte {{ filename: 'members.svelte' }}
  <script>
    // The $ prefix is reserved in Svelte for its own reactivity system.
    // Alias the imports to avoid conflicts.
    import { $organizationStore as organization } from '@clerk/astro/client'

    let memberships = []
    let currentPage = 1

    async function fetchMemberships() {
      if (!$organization) {
        return
      }

      const { data } = await $organization.getMemberships({
        initialPage: currentPage,
        pageSize: 5,
      })
      memberships = data
    }

    $: fetchMemberships()

    const fetchPrevious = () => currentPage.value--
    const fetchNext = () => currentPage.value++
  </script>

  {#if organization === undefined}
    <!-- Handle loading state -->
  {:else if organization === null}
    <!-- Handle no organization state -->
  {:else}
    <div>
      <h2>Organization members</h2>
      <ul>
        {#each memberships as membership (membership.id)}
          <li>
            {membership.publicUserData.firstName}
            {membership.publicUserData.lastName} &lt;
            {membership.publicUserData.identifier}&gt; :: {membership.role}
          </li>
        {/each}
      </ul>
      <div>
        <button on:click={fetchPrevious} disabled={currentPage === 1}>Previous</button>
        <button on:click={fetchNext}>Next</button>
      </div>
    </div>
  {/if}
  ```
</CodeBlockTabs>

---
title: '`$sessionListStore`'
description: Clerk's $sessionList store retrieves a list of sessions that have been registered on the client device.
---

The `$sessionListStore` store returns an array of [`Session`](/docs/references/javascript/session){{ target: '_blank' }} objects that have been registered on the client device.

## How to use the `$sessionListStore` store

The following example demonstrates how to use the `$sessionListStore` to create a basic user button component. This component displays the current session's email address and provides a menu to switch between active sessions or sign out of all accounts.

<CodeBlockTabs options={['React', 'Vue', 'Svelte']}>
  ```tsx {{ filename: 'user-button.tsx' }}
  import { $sessionListStore, $clerkStore } from '@clerk/astro/client'

  export default function UserButton() {
    const sessions = useStore($sessionListStore)
    const { session, setActive, signOut } = useStore($clerkStore)

    if (sessions === undefined) {
      // Handle loading state
      return <div>Loading sessions...</div>
    }

    return (
      <div>
        <div>{session.user.primaryEmailAddress}</div>
        <div role="menu">
          {sessions.map((sess) => (
            <button role="menuitem" onClick={() => setActive({ session: sess.id })} key={sess.id}>
              {sess.user.primaryEmailAddress}
            </button>
          ))}
          <button role="menuitem" onClick={() => signOut()}>
            Sign out of all accounts
          </button>
        </div>
      </div>
    )
  }
  ```

  ```vue {{ filename: 'user-button.vue' }}
  <script setup>
  import { useStore } from '@nanostores/vue'
  import { $sessionListStore, $clerkStore } from '@clerk/astro/client'

  const sessions = useStore($sessionListStore)
  const clerk = useStore($clerkStore)
  </script>

  <template>
    <div v-if="sessions === undefined">Loading sessions...</div>
    <div v-else>
      <div>{{ clerk.session.user.primaryEmailAddress }}</div>
      <div role="menu">
        <button
          v-for="sess in sessions"
          :key="sess.id"
          role="menuitem"
          @click="clerk.setActive({ session: sess.id })"
        >
          {{ sess.user.primaryEmailAddress }}
        </button>
        <button role="menuitem" @click="clerk.signOut">Sign out of all accounts</button>
      </div>
    </div>
  </template>
  ```

  ```svelte {{ filename: 'session-list.svelte' }}
  <script>
    // The $ prefix is reserved in Svelte for its own reactivity system.
    // Alias the imports to avoid conflicts.
    import { $sessionListStore as sessions, $clerkStore as clerk } from '@clerk/astro/client'
  </script>

  {#if $sessions === undefined}
    <div>Loading sessions...</div>
  {:else}
    <div>
      <div>{$clerk.session.user.primaryEmailAddress}</div>
      <div role="menu">
        {#each $sessions as sess (sess.id)}
          <button role="menuitem" on:click={() => $clerk.setActive({ session: sess.id })}>
            {sess.user.primaryEmailAddress}
          </button>
        {/each}
        <button role="menuitem" on:click={() => $clerk.signOut()}> Sign out of all accounts </button>
      </div>
    </div>
  {/if}
  ```
</CodeBlockTabs>

---
title: '`$sessionStore`'
description: Clerk's $sessionStore nanostore provides a convenient way to access the current user Session object, as well as helpers to set the active session.
---

The `$sessionStore` store provides a convenient way to access the current user's [`Session`](/docs/references/javascript/session){{ target: '_blank' }} object, as well as helpers for setting the active session.

## How to use the `$sessionStore` store

The following example demonstrates how to use the `$sessionStore` store to access the `session` object, which has the `lastActiveAt` property on it. The `lastActiveAt` property is used to display the last active time of the current session to the user.

<CodeBlockTabs options={['React', 'Vue', 'Svelte']}>
  ```tsx {{ filename: 'session.tsx' }}
  import { useStore } from '@nanostores/react'
  import { $sessionStore } from '@clerk/astro/client'

  export default function Session() {
    const session = useStore($sessionStore)

    if (session === undefined) {
      // Add logic to handle loading state
      return null
    }

    if (session === null) {
      // Add logic to handle not signed in state
      return null
    }

    return (
      <div>
        <p>This session has been active since {session.lastActiveAt.toLocaleString()}</p>
      </div>
    )
  }
  ```

  ```vue {{ filename: 'session.vue' }}
  <script setup>
  import { useStore } from '@nanostores/vue'
  import { $sessionStore } from '@clerk/astro/client'

  const session = useStore($sessionStore)
  </script>

  <template>
    <div v-if="session === undefined">
      <!-- Add logic to handle loading state -->
    </div>
    <div v-else-if="session === null">
      <!-- Add logic to handle not signed in state -->
    </div>
    <div v-else>
      <p>This session has been active since {{ session.lastActiveAt.toLocaleString() }}</p>
    </div>
  </template>
  ```

  ```svelte {{ filename: 'session.svelte' }}
  <script>
    // The $ prefix is reserved in Svelte for its own reactivity system.
    // Alias the imports to avoid conflicts.
    import { $sessionStore as session } from '@clerk/astro/client'
  </script>

  {#if $session === undefined}
    <!-- Add logic to handle loading state -->
  {:else if $session === null}
    <!-- Add logic to handle not signed in state -->
  {:else}
    <div>
      <p>This session has been active since {$session.lastActiveAt.toLocaleString()}</p>
    </div>
  {/if}
  ```
</CodeBlockTabs>

---
title: '`$signInStore`'
description: Clerk's $signInStore nanostore provides a convenient way to access the SignIn object, which allows you to check the current state of a sign-in.
---

The `$signInStore` store provides a convenient way to access the [`SignIn`](/docs/references/javascript/sign-in){{ target: '_blank' }} object, which allows you to check the current state of a sign-in. This is also useful for creating a custom sign-in flow.

## How to use the `$signInStore` store

### Check the current state of a sign-in

The following example demonstrates how to use the `$signInStore` store to check the current state of a sign-in.

<CodeBlockTabs options={['React', 'Vue', 'Svelte']}>
  ```tsx {{ filename: 'sign-in-step.tsx' }}
  import { useStore } from '@nanostores/react'
  import { $signInStore } from '@clerk/astro/client'

  export default function SignInStep() {
    const signIn = useStore($signInStore)

    if (signIn === undefined) {
      // Add logic to handle loading state
      return null
    }

    return <div>The current sign in attempt status is {signIn.status}.</div>
  }
  ```

  ```vue {{ filename: 'sign-in-step.vue' }}
  <script setup>
  import { useStore } from '@nanostores/vue'
  import { $signInStore } from '@clerk/astro/client'

  const signIn = useStore($signInStore)
  </script>

  <template>
    <div v-if="signIn === undefined">
      <!-- Add logic to handle loading state -->
    </div>
    <div v-else>
      <div>The current sign in attempt status is {{ signIn.status }}.</div>
    </div>
  </template>
  ```

  ```svelte {{ filename: 'sign-in-step.svelte' }}
  <script>
    // The $ prefix is reserved in Svelte for its own reactivity system.
    // Alias the imports to avoid conflicts.
    import { $signInStore as signIn } from '@clerk/astro/client'
  </script>

  {#if $signIn === undefined}
    <!-- Add logic to handle loading state -->
  {:else}
    <div>The current sign in attempt status is {$signIn.status}.</div>
  {/if}
  ```
</CodeBlockTabs>

The possible values for the `status` property of the `SignIn` resource are listed [here](/docs/references/javascript/sign-in#properties).

### Create a custom sign-in flow

The `$signInStore` store can also be used to build fully custom sign-in flows, if Clerk's prebuilt components don't meet your specific needs or if you require more control over the authentication flow. Different sign-in flows include email and password, email and phone codes, email links, and multifactor (MFA). To learn more about using the `$signInStore` store to create custom flows, check out the [custom flow guides.](/docs/custom-flows/overview)

---
title: '`$signUpStore`'
description: Clerk's $signUpStore nanostore provides a convenient way to access the `SignUp` object, which allows you to check the current state of a sign-up. This is also useful for creating a custom sign-up flow.
---

The `$signUpStore` store provides a convenient way to access the [`SignUp`](/docs/references/javascript/sign-up){{ target: '_blank' }} object, which allows you to check the current state of a sign-up. This is also useful for creating a custom sign-up flow.

## How to use the `$signUpStore` store

### Check the current state of a sign-up

The following example demonstrates how to use the `$signUpStore` store to access the `SignUp` object and check the current state of a sign-up.

<CodeBlockTabs options={['React', 'Vue', 'Svelte']}>
  ```tsx {{ filename: 'sign-up-step.tsx' }}
  import { useStore } from '@nanostores/react'
  import { $signUpStore } from '@clerk/astro/client'

  export default function SignUpStep() {
    const signUp = useStore($signUpStore)

    if (signUp === undefined) {
      // Add logic to handle loading state
      return null
    }

    return <div>The current sign-up attempt status is {signUp.status}.</div>
  }
  ```

  ```vue {{ filename: 'sign-up-step.vue' }}
  <script setup>
  import { useStore } from '@nanostores/vue'
  import { $signUpStore } from '@clerk/astro/client'

  const signUp = useStore($signUpStore)
  </script>

  <template>
    <div v-if="signUp === undefined">
      <!-- Add logic to handle loading state -->
    </div>
    <div v-else>
      <div>The current sign-up attempt status is {{ signUp.status }}.</div>
    </div>
  </template>
  ```

  ```svelte {{ filename: 'sign-up-step.svelte' }}
  <script>
    // The $ prefix is reserved in Svelte for its own reactivity system.
    // Alias the imports to avoid conflicts.
    import { $signUpStore as signUp } from '@clerk/astro/client'
  </script>

  {#if $signUp === undefined}
    <!-- Add logic to handle loading state -->
  {:else}
    <div>The current sign-up attempt status is {$signUp.status}.</div>
  {/if}
  ```
</CodeBlockTabs>

The possible values for the `status` property of the `SignUp` resource are listed [here](/docs/references/javascript/sign-up#properties){{ target: '_blank' }}.

### Create a custom sign-up flow

The `$signUpStore` store can also be used to build fully custom sign-up flows, if Clerk's prebuilt components don't meet your specific needs or if you require more control over the authentication flow. Different sign-up flows include email and password, email and phone codes, email links, and multifactor (MFA). To learn more about using the `$signUpStore` store to create custom flows, see the [custom flow guides](/docs/custom-flows/overview).

---
title: '`$userStore`'
description: The $userStore store provides a convenient way to access current user data and helper methods for managing the active user.
---

The `$userStore` store provides a convenient way to access current [`User`](/docs/references/javascript/user){{ target: '_blank' }} data and helper methods for managing the active user.

## How to use the `$userStore` store

### Retrieve the current user data

The following example demonstrates how to use the `$userStore` store to access the `User` object. It returns `undefined` while Clerk is still loading and `null` if the user is not signed in.

For more information, see the [`User` reference](/docs/references/javascript/user){{ target: '_blank' }}.

<CodeBlockTabs options={['React', 'Vue', 'Svelte']}>
  ```tsx {{ filename: 'user.tsx' }}
  import { useStore } from '@nanostores/react'
  import { $userStore } from '@clerk/astro/client'

  export default function User() {
    const user = useStore($userStore)

    if (user === undefined) {
      // Handle loading state however you like
      return null
    }

    if (user === null) {
      return <div>Not signed in</div>
    }

    return <div>Hello {user.fullName}!</div>
  }
  ```

  ```vue {{ filename: 'user.vue' }}
  <script setup>
  import { useStore } from '@nanostores/vue'
  import { $userStore } from '@clerk/astro/client'

  const user = useStore($userStore)
  </script>

  <template>
    <div v-if="user === undefined">
      <!-- Handle loading state however you like -->
    </div>
    <div v-else-if="user === null">Not signed in</div>
    <div v-else>Hello {{ user.fullName }}!</div>
  </template>
  ```

  ```svelte {{ filename: 'user.svelte' }}
  <script>
    // The $ prefix is reserved in Svelte for its own reactivity system.
    // Alias the imports to avoid conflicts.
    import { $userStore as user } from '@clerk/astro/client'
  </script>

  {#if $user === undefined}
    <!-- Handle loading state however you like -->
  {:else if $user === null}
    <div>Not signed in</div>
  {:else}
    <div>Hello {$user.fullName}!</div>
  {/if}
  ```
</CodeBlockTabs>

### Update the current user data

The following example demonstrates how to use the `$userStore` store to update the current user's data on the client-side.

For more information on the `update()` method, see the [`User` reference](/docs/references/javascript/user#update){{ target: '_blank' }}.

<CodeBlockTabs options={['React', 'Vue', 'Svelte']}>
  ```tsx {{ filename: 'user.tsx' }}
  import { useStore } from '@nanostores/react'
  import { $userStore } from '@clerk/astro/client'

  export default function User() {
    const user = useStore($userStore)

    if (user === undefined) {
      // Handle loading state however you like
      return null
    }

    if (user === null) return null

    const updateUser = async () => {
      await user.update({
        firstName: 'John',
        lastName: 'Doe',
      })
    }

    return (
      <>
        <button onClick={updateUser}>Click me to update your name</button>
        <p>user.firstName: {user?.firstName}</p>
        <p>user.lastName: {user?.lastName}</p>
      </>
    )
  }
  ```

  ```vue {{ filename: 'user.vue' }}
  <script setup>
  import { useStore } from '@nanostores/vue'
  import { $userStore } from '@clerk/astro/client'

  const user = useStore($userStore)

  const updateUser = async () => {
    await user.value.update({
      firstName: 'John',
      lastName: 'Doe',
    })
  }
  </script>

  <template>
    <div v-if="user === undefined">
      <!-- Handle loading state however you like -->
    </div>

    <div v-else-if="user !== null">
      <button @click="updateUser">Click me to update your name</button>
      <p>user.firstName: {{ user.firstName }}</p>
      <p>user.lastName: {{ user.lastName }}</p>
    </div>
  </template>
  ```

  ```svelte {{ filename: 'user.svelte' }}
  <script>
    // The $ prefix is reserved in Svelte for its own reactivity system.
    // Alias the imports to avoid conflicts.
    import { $userStore as user } from '@clerk/astro/client'

    const updateUser = async () => {
      await $user.update({
        firstName: 'John',
        lastName: 'Doe',
      })
    }
  </script>

  {#if $user === undefined}
    <!-- Handle loading state however you like -->
  {:else if $user !== null}
    <button on:click={updateUser}>Click me to update your name</button>
    <p>user.firstName: {$user.firstName}</p>
    <p>user.lastName: {$user.lastName}</p>
  {/if}
  ```
</CodeBlockTabs>

### Reload user data

The following example demonstrates how to use the `$userStore` store to reload the current user's data on the client-side.

For more information on the `reload()` method, see the [`User` reference](/docs/references/javascript/user#reload){{ target: '_blank' }}.

<CodeBlockTabs options={['React', 'Vue', 'Svelte']}>
  ```tsx {{ filename: 'user.tsx' }}
  import { useStore } from '@nanostores/react'
  import { $userStore } from '@clerk/astro/client'

  export default function User() {
    const user = useStore($userStore)

    if (user === undefined) {
      // Handle loading state however you like
      return null
    }

    if (user === null) return null

    const updateUser = async () => {
      // Update data via an API endpoint
      const updateMetadata = await fetch('/api/updateMetadata')

      // Check if the update was successful
      if (updateMetadata.message !== 'success') {
        throw new Error('Error updating')
      }

      // If the update was successful, reload the user data
      await user.reload()
    }

    return (
      <>
        <button onClick={updateUser}>Click me to update your metadata</button>
        <p>user role: {user?.publicMetadata.role}</p>
      </>
    )
  }
  ```

  ```vue {{ filename: 'user.vue' }}
  <script setup>
  import { useStore } from '@nanostores/vue'
  import { $userStore } from '@clerk/astro/client'

  const user = useStore($userStore)

  const updateUser = async () => {
    // Update data via an API endpoint
    const updateMetadata = await fetch('/api/updateMetadata')

    // Check if the update was successful
    if (updateMetadata.message !== 'success') {
      throw new Error('Error updating')
    }

    // If the update was successful, reload the user data
    await user.value.reload()
  }
  </script>

  <template>
    <div v-if="user === undefined">
      <!-- Handle loading state however you like -->
    </div>

    <div v-else-if="user !== null">
      <button @click="updateUser">Click me to update your metadata</button>
      <p>user role: {{ user?.publicMetadata.role }}</p>
    </div>
  </template>
  ```

  ```svelte {{ filename: 'user.svelte' }}
  <script>
    // The $ prefix is reserved in Svelte for its own reactivity system.
    // Alias the imports to avoid conflicts.
    import { useStore } from '@nanostores/svelte'
    import { $userStore as userStore } from '@clerk/astro/client'

    const user = useStore(userStore)

    const updateUser = async () => {
      if ($user) {
        try {
          // Update data via an API endpoint
          const response = await fetch('/api/updateMetadata')
          const updateMetadata = await response.json()

          // Check if the update was successful
          if (updateMetadata.message !== 'success') {
            throw new Error('Error updating')
          }

          // If the update was successful, reload the user data
          await $user.reload()
        } catch (error) {
          console.error('Failed to update metadata:', error)
          // Handle the error appropriately
        }
      }
    }
  </script>

  {#if $user === undefined}
    <!-- Handle loading state however you like -->
  {:else if $user !== null}
    <button on:click={updateUser}>Click me to update your metadata</button>
    <p>user role: {$user.publicMetadata?.role}</p>
  {/if}
  ```
</CodeBlockTabs>

---
title: '`Appearance` prop'
description: Utilize Clerk's appearance property in order to share styles across every component or individually to any of the Clerk components.
---

{/* JS file: https://github.com/clerk/javascript/blob/main/packages/types/src/appearance.ts#L619 */}

Customizing the appearance of Clerk components is a powerful way to make your application look and feel unique. Clerk provides a way to customize the appearance of its components using the `appearance` prop.

The `appearance` prop can be applied to [`<ClerkProvider>`](/docs/components/clerk-provider) to share styles across every component, or individually to any of the Clerk components.

This applies to all of the React-based packages, like [Next.js](/docs/quickstarts/nextjs), as well as [the pure JavaScript ClerkJS package](/docs/references/javascript/overview).

## Properties

The `appearance` prop accepts the following properties:

<Properties>
  - `baseTheme?`
  - `BaseTheme | BaseTheme[]`

  A theme used as the base theme for the components. For more information, see [Themes](/docs/customization/themes).

  ---

  - `layout?`
  - `Layout`

  Configuration options that affect the layout of the components, allowing customizations that are hard to implement with just CSS. For more information, see [Layout](/docs/customization/layout).

  ---

  - `variables?`
  - `Variables`

  General theme overrides. This styles will be merged with our base theme. Can override global styles like colors, fonts, etc. For more information, see [Variables](/docs/customization/variables).

  ---

  - `elements?`
  - `Elements`

  Fine-grained theme overrides. Useful when you want to style specific elements or elements that are under a specific state. For more information, see the [Customize elements of a Clerk component](#customize-elements-of-a-clerk-component) section.

  ---

  - `captcha?`
  - `Captcha`

  Configuration options that affect the appearance of the CAPTCHA widget. For more information, see the [dedicated guide](/docs/customization/captcha).
</Properties>

## Using a prebuilt theme

Clerk offers a set of prebuilt themes that can be used to quickly style Clerk components. See the [Themes](/docs/customization/themes) docs for more information.

## Customize the layout

The `layout` property is used to adjust the layout of the [`<SignIn/>`](/docs/components/authentication/sign-in) and [`<SignUp/>`](/docs/components/authentication/sign-up) components, as well as set important links to your support, terms, and privacy pages. See the [Layout](/docs/customization/layout) docs for more information.

## Customize the base theme

The `variables` property is used to adjust the general styles of a component's base theme, like colors, backgrounds, and typography. See the [Variables](/docs/customization/variables) docs for more information.

## Customize elements of a Clerk component

If you want full control over the appearance of a Clerk component, you can target the underlying elements by using their CSS classes and then apply your own styles.

First, you need to identify the underlying element of the Clerk component you want to style. You can do this by **inspecting** the HTML of the component.

For example, if you want to style the primary button in a Clerk component, you can right-click on the primary button and select "Inspect" from the menu. This will open the browser's developer tools and highlight the element in the HTML, as shown in the following image:

![The inspect element tab opened with an element selected. It shows a list of classes and a lock icon in between human-readible classnames and randomly generated ones](/docs/images/customization/identifying_elements.png)

When you select an element that is part of a Clerk component, you'll notice a list of classes like so:

```html
cl-formButtonPrimary cl-button  cl-internal-1ta0xpz
```

Any of the classes listed before the lock icon () are safe to rely on, such as `cl-formButtonPrimary` or `cl-button` from the previous example. You'll use these classes to target the necessary elements of the Clerk component.

> [!NOTE]
> Anything after the lock icon () are internal classes used for Clerk's internal styling and should not be modified.

Once you have identified the classes of the element you want to target, there are many ways to apply your custom styles depending on your preference:

1. [Use global CSS styling](#use-global-css-to-style-clerk-components)
1. [Pass custom CSS classes](#use-custom-css-classes-to-style-clerk-components)
   - [Using Tailwind](#use-tailwind-classes-to-style-clerk-components)
   - [Using CSS modules](#use-css-modules-to-style-clerk-components)
1. [Pass inline CSS to your Clerk options](#use-inline-css-objects-to-style-clerk-components)

### Use global CSS to style Clerk components

You can style the elements of a Clerk component with global CSS.

For this example, say you want to style the primary button in a Clerk component. You inspect the primary button to find the classes that you can use to target the element:

```html
cl-formButtonPrimary cl-button  cl-internal-1ta0xpz
```

You can then create a global CSS file, use the classes you identified to target the primary button, and apply your custom styles. In this case, `cl-formButtonPrimary` is the class you want to use because it's specific to the primary button:

```css {{ filename: 'styles/global.css' }}
.cl-formButtonPrimary {
  font-size: 14px;
  text-transform: none;
  background-color: #611bbd;
}

.cl-formButtonPrimary:hover,
.cl-formButtonPrimary:focus,
.cl-formButtonPrimary:active {
  background-color: #49247a;
}
```

### Use custom CSS classes to style Clerk components

You can pass additional classes to Clerk component elements by using the `elements` property on the `appearance` prop.

For example, an element in a Clerk component will have classes that look something like this:

```html
cl-formButtonPrimary cl-button  cl-internal-1ta0xpz
```

Remove the `cl-` prefix from a class and use it as the key for a new object in the `elements` property. The value of this object should be the string of classes you want to apply to the element.

The following example shows how to style the primary button in a `<SignIn />` component with custom CSS classes:

<Tabs items={["Next.js"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: 'app/layout.tsx', mark: [[8, 14]] }}
      import { ClerkProvider, SignIn } from '@clerk/nextjs'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <ClerkProvider>
            <html lang="en">
              <body>
                <SignIn
                  appearance={{
                    elements: {
                      formButtonPrimary: 'your-org-button org-red-button',
                    },
                  }}
                />
              </body>
            </html>
          </ClerkProvider>
        )
      }
      ```

      ```tsx {{ filename: 'app.tsx', mark: [[7, 13]] }}
      import { ClerkProvider, SignIn } from '@clerk/nextjs'
      import type { AppProps } from 'next/app'

      function MyApp({ pageProps }: AppProps) {
        return (
          <ClerkProvider {...pageProps}>
            <SignIn
              appearance={{
                elements: {
                  formButtonPrimary: 'your-org-button org-red-button',
                },
              }}
            />
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

#### Use Tailwind classes to style Clerk components

You can style the elements of a Clerk component with Tailwind.

The following example shows how to style the primary button in a `<SignIn />` component with Tailwind classes:

<Tabs items={["Next.js"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: 'app/layout.tsx', mark: [[8, 14]] }}
      import { ClerkProvider, SignIn } from '@clerk/nextjs'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <ClerkProvider>
            <html lang="en">
              <body>
                <SignIn
                  appearance={{
                    elements: {
                      formButtonPrimary: 'bg-slate-500 hover:bg-slate-400 text-sm',
                    },
                  }}
                />
              </body>
            </html>
          </ClerkProvider>
        )
      }
      ```

      ```tsx {{ filename: 'app.tsx', mark: [[7, 13]] }}
      import { ClerkProvider, SignIn } from '@clerk/nextjs'
      import type { AppProps } from 'next/app'

      function MyApp({ pageProps }: AppProps) {
        return (
          <ClerkProvider {...pageProps}>
            <SignIn
              appearance={{
                elements: {
                  formButtonPrimary: 'bg-slate-500 hover:bg-slate-400 text-sm',
                },
              }}
            />
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

#### Use CSS modules to style Clerk components

CSS modules are a great way to scope your CSS to a specific component.

Create your module file and add the CSS you want to apply, as shown in the following example for the `<SignIn />` component:

```css {{ filename: 'styles/SignIn.module.css' }}
.primaryColor {
  background-color: bisque;
  color: black;
}
```

Then you can apply this by importing the file and using the classes whenever required:

<Tabs items={["Next.js"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: 'app/layout.tsx', mark: [[9, 15]] }}
      import styles from '../styles/SignIn.module.css'
      import { ClerkProvider, SignIn } from '@clerk/nextjs'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <ClerkProvider>
            <html lang="en">
              <body>
                <SignIn
                  appearance={{
                    elements: {
                      formButtonPrimary: styles.primaryColor,
                    },
                  }}
                />
              </body>
            </html>
          </ClerkProvider>
        )
      }
      ```

      ```tsx {{ filename: 'app.tsx', mark: [[8, 14]] }}
      import styles from '../styles/SignIn.module.css'
      import { ClerkProvider, SignIn } from '@clerk/nextjs'
      import type { AppProps } from 'next/app'

      function MyApp({ pageProps }: AppProps) {
        return (
          <ClerkProvider {...pageProps}>
            <SignIn
              appearance={{
                elements: {
                  formButtonPrimary: styles.primaryColor,
                },
              }}
            />
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

### Use inline CSS objects to style Clerk components

You can style the elements of a Clerk component with inline CSS objects.

The following example shows how to style the primary button in a `<SignIn />` component with an inline CSS object:

<Tabs items={["Next.js"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: 'app/layout.tsx', mark: [[9, 22]] }}
      import styles from '../styles/SignIn.module.css'
      import { ClerkProvider, SignIn } from '@clerk/nextjs'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <ClerkProvider>
            <html lang="en">
              <body>
                <SignIn
                  appearance={{
                    elements: {
                      formButtonPrimary: {
                        fontSize: 14,
                        textTransform: 'none',
                        backgroundColor: '#611BBD',
                        '&:hover, &:focus, &:active': {
                          backgroundColor: '#49247A',
                        },
                      },
                    },
                  }}
                />
              </body>
            </html>
          </ClerkProvider>
        )
      }
      ```

      ```tsx {{ filename: 'app.tsx', mark: [[7, 20]] }}
      import { ClerkProvider, SignIn } from '@clerk/nextjs'
      import type { AppProps } from 'next/app'

      function MyApp({ pageProps }: AppProps) {
        return (
          <ClerkProvider {...pageProps}>
            <SignIn
              appearance={{
                elements: {
                  formButtonPrimary: {
                    fontSize: 14,
                    textTransform: 'none',
                    backgroundColor: '#611BBD',
                    '&:hover, &:focus, &:active': {
                      backgroundColor: '#49247A',
                    },
                  },
                },
              }}
            />
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

## Next steps

Here are a few resources you can utilize to customize your Clerk components further:

<Cards>
  - [Localization](/docs/customization/localization)
  - Learn how to localize your Clerk components.

  ---

  - [prebuilt themes](/docs/customization/themes)
  - Explore the prebuilt themes that you can use to quickly style your Clerk components.

  ---

  - [Customize layouts](/docs/customization/layout)
  - Learn how to change the layout and links of your Clerk components.
</Cards>

---
title: '`auth()`'
description: Access minimal authentication data for managing sessions and data fetching.
---

The `auth()` helper returns the [`Auth`](/docs/references/backend/types/auth-object) object of the currently active user, as well as the [`redirectToSignIn()`](#redirect-to-sign-in) method.

- Only available for App Router.
- Only works on the server-side, such as in Server Components, Route Handlers, and Server Actions.
- Requires [`clerkMiddleware()`](/docs/references/nextjs/clerk-middleware) to be configured.

## `auth.protect()`

`auth` includes a single property, the `protect()` method, which you can use in two ways:

- to check if a user is authenticated (signed in)
- to check if a user is authorized (has the correct roles or permissions) to access something, such as a component or a route handler

The following table describes how `auth.protect()` behaves based on user authentication or authorization status:

| Authenticated | Authorized | `auth.protect()` will |
| - | - | - |
| Yes | Yes | Return the [`Auth`](/docs/references/backend/types/auth-object) object. |
| Yes | No | Return a `404` error. |
| No | No | Redirect the user to the sign-in page\*. |

> [!IMPORTANT]
> For non-document requests, such as API requests, `auth.protect()` returns a `404` error to users who aren't authenticated.

`auth.protect()` accepts the following parameters:

<Properties>
  - `role?`
  - `string`

  The role to check for.

  ---

  - `permission?`
  - `string`

  The permission to check for.

  ---

  - `has?`
  - `(isAuthorizedParams: CheckAuthorizationParamsWithCustomPermissions) => boolean`

  A function that checks if the user has an organization role or custom permission. See the [reference](/docs/references/backend/types/auth-object#has) for more information.

  ---

  - `unauthorizedUrl?`
  - `string`

  The URL to redirect the user to if they are not authorized.

  ---

  - `unauthenticatedUrl?`
  - `string`

  The URL to redirect the user to if they are not authenticated.
</Properties>

### Example

`auth.protect()` can be used to check if a user is authenticated or authorized to access certain parts of your application or even entire routes. See detailed examples in the [dedicated guide](/docs/organizations/verify-user-permissions).

## `redirectToSignIn()`

The `auth()` helper returns the `redirectToSignIn()` method, which you can use to redirect the user to the sign-in page.

`redirectToSignIn()` accepts the following parameters:

<Properties>
  - `returnBackUrl?`
  - `string | URL`

  The URL to redirect the user back to after they sign in.
</Properties>

> [!NOTE]
> `auth()` on the server-side can only access redirect URLs defined via [environment variables](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) or [`clerkMiddleware` dynamic keys](/docs/references/nextjs/clerk-middleware#dynamic-keys).

### Example

The following example shows how to use `redirectToSignIn()` to redirect the user to the sign-in page if they are not authenticated. It's also common to use `redirectToSignIn()` in `clerkMiddleware()` to protect entire routes; see [the `clerkMiddleware()` docs](/docs/references/nextjs/clerk-middleware) for more information.

```tsx {{ filename: 'app/page.tsx' }}
import { auth } from '@clerk/nextjs/server'

export default async function Page() {
  const { userId, redirectToSignIn } = await auth()

  if (!userId) return redirectToSignIn()

  return <h1>Hello, {userId}</h1>
}
```

## `auth()` usage

### Protect pages and routes

You can use `auth()` to check if a `userId` exists. If it's null, then there is not an authenticated (signed in) user. See detailed examples in the [dedicated guide](/docs/references/nextjs/read-session-data).

### Check roles and permissions

You can use `auth()` to check if a user is authorized to access certain parts of your application or even entire routes by checking their roles or permissions. See detailed examples in the [dedicated guide](/docs/organizations/verify-user-permissions).

### Data fetching with `getToken()`

If you need to send a JWT along to a server, `getToken()` retrieves the current user's [session token](/docs/backend-requests/resources/session-tokens) or a [custom JWT template](/docs/backend-requests/jwt-templates). See detailed examples in the [`Auth` reference](/docs/references/backend/types/auth-object#get-token).

---
title: '`authenticateRequest()`'
description: Use Clerk's Backend SDK to verify a token passed from the frontend.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/tokens/request.ts#L62 */}

Authenticates a token passed from the frontend. Networkless if the `jwtKey` is provided. Otherwise, performs a network call to retrieve the JWKS from the [Backend API](/docs/reference/backend-api/tag/JWKS#operation/GetJWKS){{ target: '_blank' }}.

```ts
function authenticateRequest(
  request: Request,
  options: AuthenticateRequestOptions,
): Promise<RequestState>
```

## Parameters

<Properties>
  - `request`
  - `Request`

  `Request` object

  ---

  - `options?`
  - [`AuthenticateRequestOptions`](#authenticate-request-options)

  Optional options to configure the authentication.
</Properties>

## `AuthenticateRequestOptions`

It is recommended to set these options as [environment variables](/docs/deployments/clerk-environment-variables#api-and-sdk-configuration) where possible, and then pass them to the function. For example, you can set the `secretKey` option using the `CLERK_SECRET_KEY` environment variable, and then pass it to the function like this: `createClerkClient({ secretKey: process.env.CLERK_SECRET_KEY })`.

> [!WARNING]
> You must provide either `jwtKey` or `secretKey`.
>
> For better security, it's highly recommended to explicitly set the `authorizedParties` option when authorizing requests. The value should be a list of domains that are allowed to make requests to your application. Not setting this value can open your application to [CSRF attacks](https://owasp.org/www-community/attacks/csrf).

<Properties>
  - `secretKey?`
  - `string`

  The Clerk Secret Key from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.

  ---

  - `publishableKey?`
  - `string`

  The Clerk Publishable Key from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.

  ---

  - `jwtKey?`
  - `string`

  Used to verify the session token in a networkless manner. Supply the **JWKS Public Key** from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard. For more information, refer to [Manual JWT verification](/docs/backend-requests/manual-jwt).

  ---

  - `domain?`
  - `string`

  The domain for the application. For development, you can pass the localhost your application is running on. For example: `localhost:3001`

  ---

  - `isSatellite?`
  - `boolean`

  Set to `true` if the instance is a satellite domain in a multi-domain setup.

  ---

  - `proxyUrl?`
  - `string`

  The proxy URL from a multi-domain setup.

  ---

  - `signInUrl?`
  - `string`

  The sign-in URL from a multi-domain setup.

  ---

  - `signUpUrl?`
  - `string`

  It's recommended to use sign-up URL from a multi-domain setup.

  ---

  - `afterSignInUrl?`
  - `string`

  Full URL or path to navigate to after successful sign in. Defaults to `/`.

  ---

  - `afterSignUpUrl?`
  - `string`

  Full URL or path to navigate to after successful sign up. Defaults to `/`.

  ---

  - `audience?`
  - `string | string[]`

  A string or list of [audiences](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.3).

  ---

  - `authorizedParties?`
  - `string[]`

  An allowlist of origins to verify against, to protect your application from the subdomain cookie leaking attack. For example: `['http://localhost:3000', 'https://example.com']`

  ---

  - `clockSkewInMs?`
  - `number`

  Specifies the allowed time difference (in milliseconds) between the Clerk server (which generates the token) and the clock of the user's application server when validating a token. Defaults to 5000 ms (5 seconds).

  ---

  - `jwksCacheTtlInMs?` (deprecated)
  - `number`

  Deprecated. Specifying a cache TTL is now a no-op.

  ---

  - `skipJwksCache?`
  - `boolean`

  A flag to skip ignore cache and always fetch JWKS before each jwt verification.
</Properties>

## Examples

<Tabs items={["Backend SDK on its own", "With other Clerk SDKs"]}>
  <Tab>
    If you are using the [JavaScript Backend SDK](/docs/references/backend/overview) on its own, you need to provide the `secretKey` and `publishableKey` to `createClerkClient()` so that it is passed to `authenticateRequest()`. You can set these values as [environment variables](/docs/deployments/clerk-environment-variables#clerk-publishable-and-secret-keys) and then pass them to the function.

    ```tsx
    import { createClerkClient } from '@clerk/backend'

    export async function GET(req: Request) {
      const clerkClient = createClerkClient({
        secretKey: process.env.CLERK_SECRET_KEY,
        publishableKey: process.env.CLERK_PUBLISHABLE_KEY,
      })

      const { isSignedIn } = await clerkClient.authenticateRequest(req, {
        authorizedParties: ['https://example.com'],
      })

      if (!isSignedIn) {
        return Response.json({ status: 401 })
      }

      // Add logic to perform protected actions

      return Response.json({ message: 'This is a reply' })
    }
    ```
  </Tab>

  <Tab>
    `authenticateRequest()` requires `publishableKey` to be set. If you are importing `clerkClient` from a higher-level SDK, such as Next.js, then `clerkClient` infers the `publishableKey` from your [environment variables](/docs/deployments/clerk-environment-variables#clerk-publishable-and-secret-keys). The following example uses Next.js, but the same logic applies for other frameworks.

    ```tsx
    import { clerkClient } from '@clerk/nextjs/server'

    const client = await clerkClient()

    export async function GET(req: Request) {
      const { isSignedIn } = await client.authenticateRequest(req, {
        authorizedParties: ['https://example.com'],
      })

      if (!isSignedIn) {
        return Response.json({ status: 401 })
      }

      // Perform protected actions
      // Add logic to perform protected actions

      return Response.json({ message: 'This is a reply' })
    }
    ```
  </Tab>
</Tabs>

### Networkless token verification

{/* Note: this example is duped from /authenticate-request. Probably a good opportunity to use a partial here */}

The following example uses the `authenticateRequest()` method with the [JavaScript Backend SDK](/docs/references/backend/overview) to verify the token passed by the frontend, and performs a networkless authentication by passing `jwtKey`. This will verify if the user is signed into the application or not.

<Include src="_partials/authenticate-req" />

---
title: '`BackupCodeResource`'
description: An interface that represents a backup code.
---

An interface that represents a backup code.

<Properties>
  - `id`
  - `string`

  The unique identifier for the set of backup codes.

  ---

  - `codes`
  - `string[]`

  The generated set of backup codes.

  ---

  - `createdAt`
  - `Date`

  The date when the backup codes were created.

  ---

  - `updatedAt`
  - `Date`

  The date when the backup codes were last updated.
</Properties>

---
title: '`banUser()`'
description: Use Clerk's Backend SDK to mark a given user as banned.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L247 */}

Marks the given [`User`](/docs/references/backend/types/backend-user) as banned, which means that all their sessions are revoked and they are not allowed to sign in again.

```ts
function banUser(userId: string): Promise<User>
```

## Parameters

<Properties>
  - `userId`
  - `string`

  The ID of the user to ban.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const userId = 'user_123'

const response = await clerkClient.users.banUser(userId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/users/{user_id}/ban`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/BanUser){{ target: '_blank' }} for more information.

---
title: '`buildClerkProps`'
description: Clerk uses buildClerkProps to inform the client-side helpers of the authentication state of the user. This function is used SSR in the getServerSideProps function of your Next.js application.
---

Clerk uses `buildClerkProps` to inform the client-side helpers of the authentication state of the user. This function is used SSR in the `getServerSideProps` function of your Next.js application.

## Usage

#### Basic usage

```tsx {{ filename: 'pages/myServerSidePage' }}
import { getAuth, buildClerkProps } from '@clerk/nextjs/server'
import { GetServerSideProps } from 'next'

export const getServerSideProps: GetServerSideProps = async (ctx) => {
  const { userId } = getAuth(ctx.req)

  if (!userId) {
    // handle user is not signed in.
  }

  // Load any data your application needs for the page using the userId
  return { props: { ...buildClerkProps(ctx.req) } }
}
```

#### Protecting pages using SSR

It is important to protect your API routes to ensure that only authenticated users can access them. You can do this by checking if the `userId` is present in the `getAuth()` response.

```tsx {{ filename: 'pages/api/example.ts' }}
import { clerkClient, getAuth, buildClerkProps } from '@clerk/nextjs/server'
import { GetServerSideProps } from 'next'

export const getServerSideProps: GetServerSideProps = async (ctx) => {
  const { userId } = getAuth(ctx.req)

  const client = await clerkClient()

  const user = userId ? await client.users.getUser(userId) : undefined

  return { props: { ...buildClerkProps(ctx.req, { user }) } }
}
```

#### Usage with `clerkClient`

The `clerkClient` allows you to access the Clerk API. You can use this to retrieve or update data.

```tsx {{ filename: 'pages/api/example.ts' }}
import { getAuth, buildClerkProps, clerkClient } from '@clerk/nextjs/server'
import { GetServerSideProps } from 'next'

export const getServerSideProps: GetServerSideProps = async (ctx) => {
  const { userId } = getAuth(ctx.req)

  const user = userId ? await clerkClient().users.getUser(userId) : undefined

  return { props: { ...buildClerkProps(ctx.req, { user }) } }
}
```

---
title: '`captcha` prop'
description: Utilize Clerk's `captcha` prop in order to change the appearance of the CAPTCHA widget.
---

{/* JS file: https://github.com/clerk/javascript/blob/main/packages/types/src/appearance.ts#L538 */}

The `captcha` property can be used to change the appearance of the CAPTCHA widget. It is passed as a parameter to the [`appearance` prop](/docs/customization/overview).

## Properties

<Properties>
  - `theme`
  - `'auto' | 'light' | 'dark'`

  The CAPTCHA widget theme. Defaults to `auto`.

  ---

  - `size`
  - `'normal' | 'flexible' | 'compact'`

  The CAPTCHA widget size. Defaults to `normal`.

  ---

  - `language`
  - `string`

  The CAPTCHA widget language/locale. When setting the language for CAPTCHA, this is how localization is prioritized:

  - `appearance.captcha.language`: Set by this `language` property.
  - `localization.locale`: Set by the [`localization` prop on `<ClerkProvider>`](/docs/customization/localization). Some languages are [supported by Clerk](/docs/customization/localization) but not by Cloudflare Turnstile, which is used for the CAPTCHA widget. See [Cloudflare Turnstile's supported languages](https://developers.cloudflare.com/turnstile/reference/supported-languages).
  - `en-US`: Clerk's default language.
</Properties>

## Usage

<Tabs items={["Next.js", "Astro", "React", "Remix", "Nuxt", "Vue"]}>
  <Tab>
    ```tsx {{ prettier: false, filename: 'app.tsx' }}
    import { ClerkProvider } from '@clerk/nextjs';

    <ClerkProvider
      appearance={{
        captcha: {
          theme: 'dark',
          size: 'flexible',
          language: 'es-ES',
        }
      }}
    >
      {/* ... */}
    </ClerkProvider>;
    ```
  </Tab>

  <Tab>
    ```js {{ filename: 'astro.config.mjs' }}
    import clerk from '@clerk/astro'

    export default defineConfig({
      integrations: [
        clerk({
          appearance: {
            captcha: {
              theme: 'dark',
              size: 'flexible',
              language: 'es-ES',
            },
          },
        }),
      ],
    })
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app.tsx', mark: [[13, 18]] }}
    import React from 'react'
    import './App.css'
    import { ClerkProvider } from '@clerk/clerk-react'

    if (!process.env.REACT_APP_CLERK_PUBLISHABLE_KEY) {
      throw new Error('Missing Publishable Key')
    }
    const clerkPubKey = process.env.REACT_APP_CLERK_PUBLISHABLE_KEY

    function App() {
      return (
        <ClerkProvider
          appearance={{
            captcha: {
              theme: 'dark',
              size: 'flexible',
              language: 'es-ES',
            },
          }}
          publishableKey={clerkPubKey}
        >
          {/* ... */}
        </ClerkProvider>
      )
    }

    export default App
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/root.tsx', mark: [[35, 40]] }}
    // Import ClerkApp
    import { ClerkApp } from '@clerk/remix'
    import type { MetaFunction, LoaderFunction } from '@remix-run/node'

    import { Links, LiveReload, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react'

    import { rootAuthLoader } from '@clerk/remix/ssr.server'

    export const meta: MetaFunction = () => ({
      charset: 'utf-8',
      title: 'New Remix App',
      viewport: 'width=device-width,initial-scale=1',
    })

    export const loader: LoaderFunction = (args) => rootAuthLoader(args)

    function App() {
      return (
        <html lang="en">
          <head>
            <Meta />
            <Links />
          </head>
          <body>
            <Outlet />
            <ScrollRestoration />
            <Scripts />
            <LiveReload />
          </body>
        </html>
      )
    }

    export default ClerkApp(App, {
      appearance: {
        captcha: {
          theme: 'dark',
          size: 'flexible',
          language: 'es-ES',
        },
      },
    })
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'nuxt.config.ts' }}
    export default defineNuxtConfig({
      modules: ['@clerk/nuxt'],
      clerk: {
        appearance: {
          captcha: {
            theme: 'dark',
            size: 'flexible',
            language: 'es-ES',
          },
        },
      },
    })
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'src/main.ts' }}
    import { createApp } from 'vue'
    import App from './App.vue'
    import { clerkPlugin } from '@clerk/vue'

    const app = createApp(App)
    app.use(clerkPlugin, {
      appearance: {
        captcha: {
          theme: 'dark',
          size: 'flexible',
          language: 'es-ES',
        },
      },
    })
    app.mount('#app')
    ```
  </Tab>
</Tabs>

---
title: '`Clerk` class'
description: The Clerk class is the main entrypoint class for the `@clerk/clerk-js` package. It contains a number of methods and properties for interacting with the Clerk API.
---

The `Clerk` class is the main entrypoint class for the `@clerk/clerk-js` package. It contains a number of methods and properties for interacting with the Clerk API.

## Properties

<Properties>
  - `version`
  - `string`

  A getter for the Clerk SDK version

  ---

  - `loaded`
  - `boolean`

  A getter to see if the `Clerk` object is ready for use or not

  ---

  - `isSatellite`
  - `boolean`

  Clerk Flag for satellite apps

  ---

  - `domain`
  - `string`

  A getter for the current Clerk app's domain. Prefixed with `clerk.` on production if not already prefixed. Returns `""` when ran on the server

  ---

  - `proxyUrl`
  - `string`

  A getter for your Clerk app's proxy URL. Required for applications that run behind a reverse proxy. Can be either a relative path (`/__clerk`) or a full URL (`https://<your-domain>/__clerk`).

  ---

  - `instanceType`
  - `'production' | 'development'`

  A getter to see if a Clerk instance is running in production or development mode

  ---

  - `client`
  - [`Client`][client-ref]

  The `Client` object for the current window.

  ---

  - `session`
  - <code>[Session][session-ref] | null | undefined</code>

  The currently active `Session`, which is guaranteed to be one of the sessions in `Client.sessions`. If there is no active session, this field will be `null`. If the session is loading, this field will be `undefined`.

  ---

  - `user`
  - <code>[User][user-ref] | null | undefined</code>

  A shortcut to `Session.user` which holds the currently active `User` object. If the session is `null` or `undefined`, the user field will match.

  ---

  - `organization`
  - <code>[Organization][organization-ref] | null | undefined</code>

  A shortcut to the last active `Session.user.organizationMemberships` which holds an instance of a `Organization` object. If the session is `null` or `undefined`, the user field will match.

  ---

  - `publishableKey`
  - `string | undefined`

  The Clerk Publishable Key for your instance. This can be found on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
</Properties>

## Methods

### `addListener()`

Registers a listener that triggers a callback whenever a change in the [`Client`][client-ref], [`Session`][session-ref], or [`User`][user-ref] object occurs. This method is primarily used to build frontend SDKs like [`@clerk/clerk-react`](https://www.npmjs.com/package/@clerk/clerk-react). Returns an `UnsubscribeCallback` function that can be used to remove the listener from the `Clerk` object.

```typescript
function addListener(listener: (emission: Resources) => void): UnsubscribeCallback
```

#### `Resources`

<Properties>
  - `client`
  - [`Client`][client-ref]

  ---

  - `session`
  - <code>[Session][session-ref] | null | undefined</code>

  ---

  - `user`
  - <code>[User][user-ref] | null | undefined</code>

  ---

  - `organization`
  - <code>[Organization][organization-ref] | null | undefined</code>

  ---

  - `lastOrganizationInvitation`
  - <code>[OrganizationInvitation](/docs/references/javascript/types/organization-invitation) | null | undefined</code>

  ---

  - `lastOrganizationMember`
  - <code>[OrganizationMembership](/docs/references/javascript/types/organization-membership) | null | undefined</code>
</Properties>

> [!NOTE]
> Note the following about `User` and `Session`:
>
> - When there is an active session, `user === session.user`.
> - When there is no active session, `User` and `Session` will both be `null`.

### `authenticateWithMetamask()`

```typescript
function authenticateWithMetamask({
  redirectUrl,
  signUpContinueUrl,
  customNavigate,
}?: AuthenticateWithMetamaskParams): Promise<void>
```

#### `AuthenticateWithMetamaskParams`

<Properties>
  - `redirectUrl?`
  - `string | undefined`

  The full URL or path to navigate to after a successful sign-in or sign-up.

  ---

  - `signUpContinueUrl?`
  - `string | undefined`

  The URL to navigate to if the sign-up process is missing user information.

  ---

  - `customNavigate?`
  - `((to: string) => Promise<unknown> | unknown) | undefined`

  A function that overrides Clerk's default navigation behavior, allowing custom handling of navigation during sign-up and sign-in flows.
</Properties>

### `authenticateWithCoinbaseWallet()`

```typescript
function authenticateWithCoinbaseWallet({
  redirectUrl,
  signUpContinueUrl,
  customNavigate,
}?: AuthenticateWithCoinbaseWalletParams): Promise<void>
```

#### `AuthenticateWithCoinbaseWalletParams`

<Properties>
  - `redirectUrl?`
  - `string | undefined`

  The full URL or path to navigate to after a successful sign-in or sign-up.

  ---

  - `signUpContinueUrl?`
  - `string | undefined`

  The full URL or path to navigate to if the sign-up process is missing user information.

  ---

  - `customNavigate?`
  - `((to: string) => Promise<unknown> | unknown) | undefined`

  A function that overrides Clerk's default navigation behavior, allowing custom handling of navigation during sign-up and sign-in flows.
</Properties>

### `authenticateWithOKXWallet()`

Starts a sign-in flow that uses the OKX Wallet to authenticate the user using their Web3 wallet address.

```typescript
function authenticateWithOKXWallet(props?: AuthenticateWithOKXWalletParams): Promise<void>
```

#### `AuthenticateWithOKXWalletParams`

<Properties>
  - `redirectUrl?`
  - `string | undefined`

  The full URL or path to navigate to after a successful sign-in or sign-up.

  ---

  - `signUpContinueUrl?`
  - `string | undefined`

  The full URL or path to navigate to if the sign-up process is missing user information.

  ---

  - `customNavigate?`
  - `((to: string) => Promise<unknown> | unknown) | undefined`

  A function that overrides Clerk's default navigation behavior, allowing custom handling of navigation during sign-up and sign-in flows.

  ---

  - `unsafeMetadata?`
  - [`SignUpUnsafeMetadata`](/docs/references/javascript/types/metadata#sign-up-unsafe-metadata)

  Metadata that can be read and set from the frontend. Once the sign-up is complete, the value of this field will be automatically copied to the newly created user's unsafe metadata. One common use case for this attribute is to use it to implement custom fields that can be collected during sign-up and will automatically be attached to the created `User` object.

  ---

  - `legalAccepted?`
  - `boolean`

  A boolean indicating whether the user has agreed to the [legal compliance](/docs/authentication/configuration/legal-compliance) documents.
</Properties>

### `authenticateWithWeb3()`

```typescript
function authenticateWithWeb3({
  redirectUrl,
  signUpContinueUrl,
  customNavigate,
  strategy,
}: ClerkAuthenticateWithWeb3Params): Promise<void>
```

#### `ClerkAuthenticateWithWeb3Params`

<Properties>
  - `redirectUrl?`
  - `string | undefined`

  The full URL or path to navigate to after a successful sign in or sign up.

  ---

  - `signUpContinueUrl?`
  - `string | undefined`

  The full URL or path to navigate to if the sign-up process is missing user information.

  ---

  - `customNavigate?`
  - `((to: string) => Promise<unknown> | unknown) | undefined`

  A function that overrides Clerk's default navigation behavior, allowing custom handling of navigation during sign-up and sign-in flows.

  ---

  - `strategy`
  - `Web3Strategy`

  The Web3 verification strategy.
</Properties>

### `buildCreateOrganizationUrl()`

Returns the configured URL where [`<CreateOrganization />`](/docs/components/organization/create-organization) is mounted or a custom create-organization page is rendered.

```typescript
function buildCreateOrganizationUrl(): string
```

#### Example

```js
await clerk.buildCreateOrganizationUrl()
```

### `buildHomeUrl()`

Returns the URL you've configured in the Clerk Dashboard.

```typescript
function buildHomeUrl(): string
```

#### Example

```js
await clerk.buildHomeUrl()
```

### `buildOrganizationProfileUrl()`

Returns the configured URL where [`<OrganizationProfile />`](/docs/components/organization/organization-profile) is mounted or a custom organization-profile page is rendered.

```typescript
function buildOrganizationProfileUrl(): string
```

#### Example

```js
await clerk.buildOrganizationProfileUrl()
```

### `buildSignInUrl()`

Returns the configured URL where [`<SignIn />`](/docs/components/authentication/sign-in) is mounted or a custom sign-in page is rendered.

```typescript
function buildSignInUrl(options?: RedirectOptions): string
```

#### Parameters

<Properties>
  - `options`
  - <code>[RedirectOptions](/docs/references/javascript/types/redirect-options) | undefined</code>

  Options used to control the redirect in the constructed URL.
</Properties>

#### Example

```js
await clerk.buildSignInUrl({
  signInForceRedirectUrl: '/dashboard',
  signUpForceRedirectUrl: '/dashboard',
})
```

### `buildSignUpUrl()`

Returns the configured URL where [`<SignUp />`](/docs/components/authentication/sign-up) is mounted or a custom sign-up page is rendered.

```typescript
function buildSignUpUrl(options?: RedirectOptions): string
```

#### Parameters

<Properties>
  - `options`
  - <code>[RedirectOptions](/docs/references/javascript/types/redirect-options) | undefined</code>

  Options used to control the redirect in the constructed URL.
</Properties>

#### Example

```js
await clerk.buildSignUpUrl({
  signInForceRedirectUrl: '/dashboard',
  signUpForceRedirectUrl: '/dashboard',
})
```

### `buildUrlWithAuth()`

Decorates the provided URL with the auth token for development instances.

```typescript
function buildUrlWithAuth(to: string, options?: BuildUrlWithAuthParams): string
```

#### Parameters

<Properties>
  - `to`
  - `string`

  The route to create a URL towards.

  ---

  - `options`
  - [`BuildUrlWithAuthParams`](#build-url-with-auth-params)

  Options to apply toward the URL builder.
</Properties>

#### Example

```js
await clerk.buildUrlWithAuth('/dashboard')
```

#### `BuildUrlWithAuthParams`

<Properties>
  - `useQueryParam`
  - `boolean | null | undefined`

  Controls if dev browser JWT is added as a query param.
</Properties>

### `buildUserProfileUrl()`

Returns the URL where [`<UserProfile />`](/docs/components/user/user-profile) is mounted or a custom user-profile page is rendered.

```typescript
function buildUserProfileUrl(): string
```

#### Example

```js
await clerk.buildUserProfileUrl()
```

### `constructor()`

Create an instance of the `Clerk` class with dedicated options.

This method is only available when importing `Clerk` from `@clerk/clerk-js`, rather than using a Window script.

```typescript
class Clerk {
  constructor(key: string, options?: DomainOrProxyUrl)
}
```

#### Parameters

<Properties>
  - `key`
  - `string`

  The Clerk Publishable Key for your instance. This can be found on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.

  ---

  - `options?`
  - <code>[DomainOrProxyUrl](#domain-or-proxy-url) | undefined</code>

  The domain or proxy URL used to connect to Clerk.
</Properties>

#### `DomainOrProxyUrl`

Only one of the two properties are allowed to be set at a time.

<Properties>
  - `proxyUrl?`
  - `never | string | ((url: URL) => string)`

  The proxy URL used to connect to Clerk. If a function, will be called with a `URL` made from `window.location.href`.

  ---

  - `domain?`
  - `never | string | ((url: URL) => string)`

  The domain used to connect to Clerk. If a function, will be called with a `URL` made from `window.location.href`.
</Properties>

### `createOrganization()`

Creates an organization programmatically. Returns an [`Organization`](/docs/references/javascript/organization) object.

> [!NOTE]
> For React-based apps, consider using the [`<CreateOrganization />`](/docs/components/organization/create-organization) component.

```typescript
function createOrganization({ name, slug }: CreateOrganizationParams): Promise<Organization>
```

#### Parameters

<Properties>
  - `name`
  - `string`

  The name of the organization to be created.

  ---

  - `slug?`
  - `string`

  The optional slug of the organization to be created.
</Properties>

#### Example

```js
await clerk.createOrganization({ name: 'test' })
```

### `getOrganization()`

Retrieves information for a specific organization.

```typescript
function getOrganization(organizationId: string): Promise<Organization | undefined>
```

#### Parameters

<Properties>
  - `organizationId`
  - `string`

  The ID of the organization to be found.
</Properties>

#### Example

The following example demonstrates how to retrieve information about the currently active organization.

```js
await clerk.getOrganization(clerk.organization.id)
```

### `handleEmailLinkVerification()`

Handles the completion of an email link verification flow by processing the verification results from the redirect URL query parameters. This method should be called after the user is redirected back from visiting the verification link in their email.

```typescript
function handleEmailLinkVerification(
  params: handleEmailLinkVerificationParams,
  customNavigate?: ((to: string) => Promise<unknown>) | undefined,
): Promise<unknown>
```

The `handleEmailLinkVerification()` method finalizes an email verification flow that begins when a user initiates email verification and ends when they visit the verification link.

Email verification can be completed on any device - not necessarily the one where it was initiated. For example, a user could start verification on desktop but click the email link on mobile.

When a user visits the verification link, they are redirected to the URL specified during flow initialization. Clerk appends these query parameters to the URL:

- `__clerk_status`: The verification outcome:
  - `verified`: Verification succeeded.
  - `failed`: Verification failed.
  - `expired`: Link expired.
  - `client_mismatch`: Device/browser mismatch (only if [same device verification](/docs/security/email-link-protection) is enabled).
- `__clerk_created_session`: ID of any new session created. Since verification can happen on a different device, this session may not appear in [`Client.sessions`](/docs/references/javascript/client#properties).

The method handles the verification outcome as follows:

1. On successful verification, it:
   - Determines if sign-in/sign-up is complete
   - Redirects accordingly using the provided URLs (both optional):
     - `redirectUrlComplete`: URL for completed sign-in/sign-up.
     - `redirectUrl`: URL if there are further requirements for the sign-in/sign-up attempt, such as MFA.
   - Executes an optional callback if verification happened on another device.

1. On verification failure:
   - Throws an [`EmailLinkError`](/docs/custom-flows/email-links).
   - Error code indicates if link expired or verification failed.

Take a look at the function parameters below for more usage details.

#### Parameters

<Properties>
  - `params`
  - [`handleEmailLinkVerificationParams`](#handle-email-link-verification-params)

  Allows you to define the URLs where the user should be redirected to on successful verification or pending/completed sign-up or sign-in attempts. If the email link is successfully verified on another device, there's a callback function parameter that allows custom code execution.

  ---

  - `customNavigate?`
  - `(to: string) => Promise<unknown>`

  A function that overrides Clerk's default navigation behavior, allowing custom handling of navigation during sign-up and sign-in flows.
</Properties>

#### `handleEmailLinkVerificationParams`

<Properties>
  - `redirectUrlComplete?`
  - `string | undefined`

  The full URL to navigate to after successful email link verification on completed sign-up or sign-in on the same device.

  ---

  - `redirectUrl?`
  - `string | undefined`

  The full URL to navigate to after successful email link verification on the same device, but without completing sign-in or sign-up.

  ---

  - `onVerifiedOnOtherDevice?`
  - `() => void`

  Callback function to be executed after successful email link verification on another device.
</Properties>

#### Example

See the [custom flow](/docs/custom-flows/email-links) guide for a comprehensive example of how to use the `handleEmailLinkVerification()` method.

### `handleRedirectCallback()`

Completes a custom OAuth flow started by calling either [`SignIn.authenticateWithRedirect(params)`](/docs/references/javascript/sign-in) or [`SignUp.authenticateWithRedirect(params)`](/docs/references/javascript/sign-up).

```typescript
function handleRedirectCallback(
  params: HandleOAuthCallbackParams,
  customNavigate?: ((to: string) => Promise<unknown>) | undefined,
): Promise<unknown>
```

#### Parameters

<Properties>
  - `params`
  - [`HandleOAuthCallbackParams`](#handle-o-auth-callback-params)

  Additional props that define where the user will be redirected to at the end of a successful OAuth flow.

  ---

  - `customNavigate`
  - `(to: string) => Promise<unknown>`

  A function that overrides Clerk's default navigation behavior, allowing custom handling of navigation during sign-up and sign-in flows.
</Properties>

#### `HandleOAuthCallbackParams`

<Properties>
  - `signInUrl?`
  - `string`

  Full URL or path where the SignIn component is mounted.

  ---

  - `signUpUrl?`
  - `string`

  Full URL or path where the SignUp component is mounted.

  ---

  - `signInFallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs in, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpFallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs up, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signInForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs in. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs up. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `firstFactorUrl`
  - `string | undefined`

  Full URL or path to navigate during sign in, if identifier verification is required.

  ---

  - `secondFactorUrl`
  - `string | undefined`

  Full URL or path to navigate during sign in, if 2FA is enabled.

  ---

  - `resetPasswordUrl`
  - `string`

  Full URL or path to navigate during sign in, if the user is required to reset their password.

  ---

  - `continueSignUpUrl`
  - `string | undefined | null`

  Full URL or path to navigate after an incomplete sign up.

  ---

  - `verifyEmailAddressUrl`
  - `string | undefined | null`

  Full URL or path to navigate after requesting email verification.

  ---

  - `verifyPhoneNumberUrl`
  - `string | undefined | null`

  Full URL or path to navigate after requesting phone verification.

  ---

  - `transferable?`
  - `boolean`

  Indicates whether or not sign in attempts are transferable to the sign up flow. Defaults to `true`. When set to `false`, prevents opaque sign ups when a user attempts to sign in via OAuth with an email that doesn't exist.
</Properties>

#### Example

See the [custom flow](/docs/custom-flows/oauth-connections) guide for a comprehensive example of how to use the `handleRedirectCallback()` method.

### `handleUnauthenticated()`

Handles a 401 response from [Frontend API](/docs/reference/frontend-api){{ target: '_blank' }} by refreshing the client and session object accordingly.

```typescript
function handleUnauthenticated(opts?: { broadcast: boolean }): Promise<unknown>
```

#### Example

```js
await clerk.handleUnauthenticated()
```

### `joinWaitlist()`

Create a new waitlist entry programmatically. Requires that you set your app's sign-up mode to [**Waitlist**](/docs/authentication/configuration/restrictions#waitlist) in the Clerk Dashboard.

```typescript
function joinWaitlist({ emailAddress }: JoinWaitlistParams): Promise<Waitlist>
```

#### Parameters

<Properties>
  - `emailAddress`
  - `string`

  The email address of the user you want to add in the waitlist.
</Properties>

#### Example

```js
await clerk.joinWaitlist({ emailAddress: 'user@example.com' })
```

### `load()`

Initializes the `Clerk` object and loads all necessary environment configuration and instance settings from the [Frontend API](/docs/reference/frontend-api){{ target: '_blank' }}.

You must call this method before using the `Clerk` object in your code. Refer to the [quickstart guide](/docs/quickstarts/javascript) for more information.

```typescript
function load(options?: ClerkOptions): Promise<void>
```

#### `ClerkOptions`

All props below are optional.

<Properties>
  - `appearance`
  - <code>[Appearance](/docs/customization/overview) | undefined</code>

  Optional object to style your components. Will only affect [Clerk components][components-ref] and not [Account Portal][ap-ref] pages.

  ---

  - `localization`
  - <code>[Localization](/docs/customization/localization) | undefined</code>

  Optional object to localize your components. Will only affect [Clerk components][components-ref] and not [Account Portal][ap-ref] pages.

  ---

  - `routerPush?`
  - `(to: string) => Promise<unknown> | void`

  A function which takes the destination path as an argument and performs a "push" navigation.

  ---

  - `routerReplace?`
  - `(to: string) => Promise<unknown> | void`

  A function which takes the destination path as an argument and performs a "replace" navigation.

  ---

  - `polling`
  - `boolean | undefined`

  Dictates if we should poll against Clerk's backend every 5 minutes. Defaults to `true`.

  ---

  - `selectInitialSession`
  - <code>((client: [Client][client-ref]) => Session | null) | undefined</code>

  An optional function which allows you to control which active session is the initial session to base a user's state off of. Defaults to the first session in the client's sessions array.

  ---

  - `standardBrowser`
  - `boolean | undefined`

  Controls if ClerkJS will load with the standard browser set up using Clerk cookies. Defaults to `true`.

  ---

  - `supportEmail`
  - `string | undefined`

  Optional support email for display in authentication screens.

  ---

  - `touchSession`
  - `boolean | undefined`

  Indicates whether the session should be "touched" when user interactions occur, used to record these interactions. Defaults to `true`.

  ---

  - `signInUrl`
  - `string | undefined`

  The default URL to use to direct to when the user signs in. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpUrl`
  - `string | undefined`

  The default URL to use to direct to when the user signs up. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signInForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs in. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs up. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signInFallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs in, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpFallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs up, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `afterSignOutUrl?`
  - `string`

  The full URL or path to navigate to after a successful sign-out.

  ---

  - `allowedRedirectOrigins?`
  - `Array<string | RegExp>`

  An optional array of domains to validate user-provided redirect URLs against. If no match is made, the redirect is considered unsafe and the default redirect will be used with a warning logged in the console.

  ---

  - `allowedRedirectProtocols?`
  - `Array<string>`

  An optional array of protocols to validate user-provided redirect URLs against. If no match is made, the redirect is considered unsafe and the default redirect will be used with a warning logged in the console.

  ---

  - `isSatellite`
  - `boolean | ((url: URL) => boolean) | undefined`

  Clerk flag for satellite apps. Experimental.

  ---

  - `telemetry?`
  - `false | { disabled?: boolean; debug?: boolean } | undefined`

  Controls whether or not Clerk will collect [telemetry data](/docs/telemetry).
</Properties>

#### Example

```js
await clerk.load()
```

### `navigate()`

Helper method which will use the custom push navigation function of your application to navigate to the provided URL or relative path.

Returns a promise that can be `await`ed in order to listen for the navigation to finish. The inner value should not be relied on, as it can change based on the framework it's used within.

```typescript
function navigate(to: string | undefined): Promise<unknown>
```

#### Example

```js
await clerk.navigate('/dashboard')
```

#### Parameters

<Properties>
  - `to`
  - `string | undefined`

  The route to navigate to.
</Properties>

### `redirectToCreateOrganization()`

Redirects to the configured URL where [`<CreateOrganization />`](/docs/components/organization/create-organization) is mounted. This method uses the [`navigate()`](#navigate) method under the hood.

Returns a promise that can be `await`ed in order to listen for the navigation to finish. The inner value should not be relied on, as it can change based on the framework it's used within.

```typescript
function redirectToCreateOrganization(): Promise<unknown>
```

#### Example

```js
await clerk.redirectToCreateOrganization()
```

### `redirectToOrganizationProfile()`

Redirects to the configured URL where [`<OrganizationProfile />`](/docs/components/organization/organization-profile) is mounted. This method uses the [`navigate()`](#navigate) method under the hood.

Returns a promise that can be `await`ed in order to listen for the navigation to finish. The inner value should not be relied on, as it can change based on the framework it's used within.

```typescript
function redirectToOrganizationProfile(): Promise<unknown>
```

#### Example

```js
await clerk.redirectToOrganizationProfile()
```

### `redirectToSignIn()`

Redirects to the sign-in URL, as configured in your application's instance settings. This method uses the [`navigate()`](#navigate) method under the hood.

Returns a promise that can be `await`ed in order to listen for the navigation to finish. The inner value should not be relied on, as it can change based on the framework it's used within.

```typescript
function redirectToSignIn(options?: SignInRedirectOptions): Promise<unknown>
```

#### Parameters

<Properties>
  - `options?`
  - <code>[SignInRedirectOptions](/docs/references/javascript/types/sign-in-redirect-options) | undefined</code>

  Options to use in the redirect, such as `signInForceRedirectUrl` and `signInFallbackRedirectUrl`.
</Properties>

#### Example

```js
await clerk.redirectToSignIn({
  signInForceRedirectUrl: '/dashboard',
  signUpForceRedirectUrl: '/dashboard',
})
```

### `redirectToSignUp()`

Redirects to the sign-up URL, as configured in your application's instance settings. This method uses the [`navigate()`](#navigate) method under the hood.

Returns a promise that can be `await`ed in order to listen for the navigation to finish. The inner value should not be relied on, as it can change based on the framework it's used within.

```typescript
function redirectToSignUp(options?: SignUpRedirectOptions): Promise<unknown>
```

#### Parameters

<Properties>
  - `options?`
  - <code>[SignUpRedirectOptions](/docs/references/javascript/types/sign-up-redirect-options) | undefined</code>

  Options to use in the redirect, such as `signUpForceRedirectUrl` and `signUpFallbackRedirectUrl`.
</Properties>

#### Example

```js
await clerk.redirectToSignUp({
  signUpForceRedirectUrl: '/dashboard',
  signUpFallbackRedirectUrl: '/dashboard',
})
```

### `redirectToUserProfile()`

Returns a promise that can be `await`ed in order to listen for the navigation to finish. The inner value should not be relied on, as it can change based on the framework it's used within.

```typescript
function redirectToUserProfile(): Promise<unknown>
```

#### Example

```js
await clerk.redirectToUserProfile()
```

### `redirectWithAuth()`

Redirects to the provided URL after appending authentication credentials. For development instances, this method decorates the URL with an auth token to maintain authentication state. For production instances, the standard session cookie is used.

Returns a promise that can be `await`ed in order to listen for the navigation to finish. The inner value should not be relied on, as it can change based on the framework it's used within.

```typescript
function redirectWithAuth(to: string): Promise<unknown>
```

#### Parameters

<Properties>
  - `to`
  - `string | undefined`

  The route to navigate to
</Properties>

#### Example

```js
await clerk.redirectWithAuth('/dashboard')
```

### `setActive()`

A method used to set the active session and/or organization. Accepts a [`SetActiveParams`](/docs/references/javascript/types/set-active-params) object.

```typescript
function setActive(params: SetActiveParams): Promise<void>
```

#### Example

The `setActive()` method is most commonly used when building a [custom flow](/docs/custom-flows/overview) for your application.

For example, during authentication, when a user signs in or signs up successfully, a new session is created. `setActive()` needs to be used to set the new session as the active session. See the implementation of this in the [Custom authentication flow](/docs/custom-flows/overview) guide.

Another example is when a user switches organizations in a multi-organization application. `setActive()` needs to be used to set the new organization as the active organization. See the implementation of this in the [Custom organization switcher](/docs/custom-flows/organization-switcher) guide.

### `signOut()`

- In a [multi-session application](/docs/authentication/configuration/session-options#multi-session-applications): Signs out the active user from all sessions
- In a single-session context: Signs out the active user from the current session

The current client will be deleted. You can specify a specific session to sign out by passing the `sessionId` parameter.

```typescript
function signOut(options?: SignOutOptions): Promise<void>
// OR
function signOut(
  signOutCallback?: () => void | Promise<any>,
  options?: SignOutOptions,
): Promise<void>
```

#### `SignOutOptions`

<Properties>
  - `sessionId?`
  - `string`

  Specify a specific session to sign out. Useful for multi-session applications.

  ---

  - `redirectUrl?`
  - `string`

  The full URL or path to navigate to after sign out is complete.
</Properties>

#### Example

```js
await clerk.signOut()
```

## Components

The `Clerk` class also contains a number of methods for interacting with prebuilt components.

### `<SignIn />`

- [`mountSignIn()`](/docs/components/authentication/sign-in#mount-sign-in)
- [`unmountSignIn()`](/docs/components/authentication/sign-in#unmount-sign-in)
- [`openSignIn()`](/docs/components/authentication/sign-in#open-sign-in)
- [`closeSignIn()`](/docs/components/authentication/sign-in#close-sign-in)

### `<SignUp />`

- [`mountSignUp()`](/docs/components/authentication/sign-up#mount-sign-up)
- [`unmountSignUp()`](/docs/components/authentication/sign-up#unmount-sign-up)
- [`openSignUp()`](/docs/components/authentication/sign-up#open-sign-up)
- [`closeSignUp()`](/docs/components/authentication/sign-up#close-sign-up)

### `<GoogleOneTap />`

- [`openGoogleOneTap()`](/docs/components/authentication/google-one-tap#open-google-one-tap)
- [`closeGoogleOneTap()`](/docs/components/authentication/google-one-tap#close-google-one-tap)
- [`authenticateWithGoogleOneTap()`](/docs/components/authentication/google-one-tap#authenticate-with-google-one-tap)
- [`handleGoogleOneTapCallback()`](/docs/components/authentication/google-one-tap#handle-google-one-tap-callback)

### `<UserButton />`

- [`mountUserButton()`](/docs/components/user/user-button#mount-user-button)
- [`unmountUserButton()`](/docs/components/user/user-button#unmount-user-button)

### `<UserProfile />`

- [`mountUserProfile()`](/docs/components/user/user-profile#mount-user-profile)
- [`unmountUserProfile()`](/docs/components/user/user-profile#unmount-user-profile)
- [`openUserProfile()`](/docs/components/user/user-profile#open-user-profile)
- [`closeUserProfile()`](/docs/components/user/user-profile#close-user-profile)

### `<OrganizationProfile />`

- [`mountOrganizationProfile()`](/docs/components/organization/organization-profile#mount-organization-profile)
- [`unmountOrganizationProfile()`](/docs/components/organization/organization-profile#unmount-organization-profile)
- [`openOrganizationProfile()`](/docs/components/organization/organization-profile#open-organization-profile)
- [`closeOrganizationProfile()`](/docs/components/organization/organization-profile#close-organization-profile)

### `<OrganizationSwitcher />`

- [`mountOrganizationSwitcher()`](/docs/components/organization/organization-switcher#mount-organization-switcher)
- [`unmountOrganizationSwitcher()`](/docs/components/organization/organization-switcher#unmount-organization-switcher)

### `<CreateOrganization />`

- [`mountCreateOrganization`](/docs/components/organization/create-organization#mount-create-organization)
- [`unmountCreateOrganization`](/docs/components/organization/create-organization#unmount-create-organization)
- [`openCreateOrganization`](/docs/components/organization/create-organization#open-create-organization)
- [`closeCreateOrganization`](/docs/components/organization/create-organization#close-create-organization)

### `<OrganizationList />`

- [`mountOrganizationList`](/docs/components/organization/organization-list#mount-organization-list)
- [`unmountOrganizationList`](/docs/components/organization/organization-list#unmount-organization-list)

### `<Waitlist />`

- [`mountWaitlist()`](/docs/components/waitlist#mount-waitlist)
- [`unmountWaitlist()`](/docs/components/waitlist#unmount-waitlist)
- [`openWaitlist()`](/docs/components/waitlist#open-waitlist)
- [`closeWaitlist()`](/docs/components/waitlist#close-waitlist)

[client-ref]: /docs/references/javascript/client

[session-ref]: /docs/references/javascript/session

[user-ref]: /docs/references/javascript/user

[organization-ref]: /docs/references/javascript/organization

[components-ref]: /docs/components/overview

[ap-ref]: /docs/account-portal/overview

---
title: '`ClerkAPIError`'
description: An interface that represents an error returned by the Clerk API.
---

An interface that represents an error returned by the Clerk API.

<Properties>
  - `code`
  - `string`

  A string code that represents the error, such as `username_exists_code`.

  ---

  - `message`
  - `string`

  A message that describes the error.

  ---

  - `longMessage`
  - `string`

  A more detailed message that describes the error.

  ---

  - `meta`
  - `object`

  Additional information about the error.
</Properties>

The `meta` property consists of the following structure:

```ts {{ prettier: false }}
meta?: {
  paramName?: string
  sessionId?: string
  emailAddresses?: string[]
  identifiers?: string[]
  zxcvbn?: {
    suggestions: {
      code: string
      message: string
    }[]
  }
  permissions?: string[]
}
```

---
title: '`ClerkApp`'
description: Clerk provides a ClerkApp wrapper to provide the authentication state to your React tree.
---

Clerk provides a `ClerkApp` wrapper to provide the authentication state to your React tree. This helper works with Remix SSR out-of-the-box and follows the "higher-order component" paradigm.

## Usage

```tsx {{ filename: 'app/root.tsx' }}
// The rest of your code

function App() {
  return (
    <html lang="en">
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <Outlet />
        <ScrollRestoration />
        <Scripts />
        <LiveReload />
      </body>
    </html>
  )
}

// Wrap your app with `ClerkApp`
export default ClerkApp(App)
```

## Pass configuration options

To pass configuration [options](#clerk-app-options) to `ClerkApp`, you can pass an optional argument to the `ClerkApp` function.

```tsx {{ filename: 'app/root.tsx' }}
// Wrap your app in ClerkApp(app)
export default ClerkApp(App, {
  publishableKey: import.meta.env.VITE_CLERK_PUBLISHABLE_KEY,
})
```

## `ClerkApp` options

<Include src="_partials/clerk-provider/properties" />

---
title: '`clerkMiddleware()` | Astro'
description: The `clerkMiddleware()` function allows you to protect your Astro application using Middleware.
---

The `clerkMiddleware()` helper integrates Clerk authentication into your Astro application through middleware.

## Configure `clerkMiddleware()`

Create a `middleware.ts` file inside your `src/` directory.

```ts {{ filename: 'src/middleware.ts' }}
import { clerkMiddleware } from '@clerk/astro/server'

export const onRequest = clerkMiddleware()
```

## `createRouteMatcher()`

`createRouteMatcher()` is a Clerk helper function that allows you to protect multiple routes. `createRouteMatcher()` accepts an array of routes and checks if the route the user is trying to visit matches one of the routes passed to it.

The `createRouteMatcher()` helper returns a function that, if called with the `context.request` object from the Middleware, will return `true` if the user is trying to access a route that matches one of the routes passed to `createRouteMatcher()`.

In the following example, `createRouteMatcher()` sets all `/dashboard` and `/forum` routes as protected routes.

```ts
const isProtectedRoute = createRouteMatcher(['/dashboard(.*)', '/forum(.*)'])
```

## Protect routes

You can protect routes by checking either or both of the following:

- [User authentication status](#protect-routes-based-on-user-authentication-status) -- user is signed in or out
- [User authorization status](#protect-routes-based-on-user-authorization-status) -- user has the required role or permission

### Protect routes based on user authentication status

To protect routes based on user authentication status, use [`auth().userId`](/docs/references/backend/types/auth-object){{ target: '_blank' }} to check if the `userId` is present. If it's not, the user is not authenticated, and you can redirect them to the sign-in page.

```tsx {{ filename: 'src/middleware.ts' }}
import { clerkMiddleware, createRouteMatcher } from '@clerk/astro/server'

const isProtectedRoute = createRouteMatcher(['/dashboard(.*)', '/forum(.*)'])

export const onRequest = clerkMiddleware((auth, context) => {
  const { redirectToSignIn, userId } = auth()

  if (!userId && isProtectedRoute(context.request)) {
    // Add custom logic to run before redirecting

    return redirectToSignIn()
  }
})
```

### Protect routes based on user authorization status

To protect routes based on user authorization status, use [`auth().has()`](/docs/references/backend/types/auth-object#has){{ target: '_blank' }} to check if the user has the required roles or custom permissions.

```tsx {{ filename: 'src/middleware.ts' }}
import { clerkMiddleware, createRouteMatcher } from '@clerk/astro/server'

const isProtectedRoute = createRouteMatcher(['/admin(.*)'])

export const onRequest = clerkMiddleware((auth, context) => {
  const { has, redirectToSignIn } = auth()

  // Restrict admin routes to users with specific permissions
  if (
    (isProtectedRoute(context.request) && !has({ permission: 'org:admin:example1' })) ||
    !has({ permission: 'org:admin:example2' })
  ) {
    // Add logic to run if the user does not have the required permissions; for example, redirecting to the sign-in page
    return redirectToSignIn()
  }
})
```

## Protect all routes

To protect all routes in your application and define specific routes as public, you can use any of the above methods and simply invert the `if` condition.

```tsx
import { clerkMiddleware, createRouteMatcher } from '@clerk/astro/server'

const isPublicRoute = createRouteMatcher(['/sign-in(.*)', '/sign-up(.*)'])

export const onRequest = clerkMiddleware((auth, context) => {
  const { redirectToSignIn, userId } = auth()

  if (!isPublicRoute(context.request) && !userId) {
    return redirectToSignIn()
  }
})
```

## `clerkMiddleware()` options

<Include src="_partials/clerk-middleware-options" />

---
title: '`ClerkPaginatedResponse`'
description: An interface that describes the response of a method that returns a paginated list of resources.
---

An interface that describes the response of a method that returns a paginated list of resources.

## Properties

| Properties | Type | Description |
| - | - | - |
| `data` | `T[]` | An array that contains the fetched data. |
| `totalCount` | `number` | The total count of data that exist remotely. |

## Error handling

Clerk's SDKs always use `Promise<ClerkPaginatedResponse<T>>`. If the promise resolves, you will get back the [properties](#properties) listed above. If the promise is rejected, you will receive a `ClerkAPIResponseError` or network error.

---
title: '`Client`'
description: The Client object keeps track of the authenticated sessions in the current device. The device can be a browser, a native application or any other medium that is usually the requesting part in a request/response architecture.
---

The `Client` object keeps track of the authenticated sessions in the current device. The device can be a browser, a native application or any other medium that is usually the requesting part in a request/response architecture.

The `Client` object also holds information about any sign in or sign up attempts that might be in progress, tracking the sign in or sign up progress.

## Properties

<Properties>
  - `signIn`
  - <code>[SignIn](/docs/references/javascript/sign-in) | null</code>

  The current sign in attempt, or `null` if there is none.

  ---

  - `signUp`
  - <code>[SignUp](/docs/references/javascript/sign-up) | null</code>

  The current sign up attempt, or `null` if there is none.

  ---

  - `sessions`
  - [`Session[]`](/docs/references/javascript/session)

  A list of sessions that have been created on this client.

  ---

  - `activeSessions`
  - [`Session[]`](/docs/references/javascript/session)

  A list of active sessions on this client.

  ---

  - `lastActiveSessionId`
  - `string`

  The ID of the last active [`Session`](/docs/references/javascript/session) on this client.

  ---

  - `updatedAt`
  - `Date`

  Timestamp of last update for the client.
</Properties>

## Methods

### `isNew()`

Returns `true` if this client hasn't been saved (created) yet in the Frontend API. Returns `false` otherwise.

```typescript
function isNew(): boolean
```

### `create()`

Creates a new client for the current instance along with its cookie.

```typescript
function create(): Promise<Client>
```

### `destroy()`

Deletes the client. All sessions will be reset.

```typescript
function destroy(): Promise<void>
```

---
title: '`createAllowlistIdentifier()`'
description: Use Clerk's Backend SDK to add a new identifier to the allowlist.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/AllowlistIdentifierApi.ts#L22 */}

Adds a new identifier to the allowlist. Returns the created [`AllowlistIdentifier`](/docs/references/backend/types/backend-allowlist-identifier) object.

```ts
function createAllowlistIdentifier(
  params: AllowlistIdentifierCreateParams,
): Promise<AllowlistIdentifier>
```

## `AllowlistIdentifierCreateParams`

<Properties>
  - `identifier`
  - `string`

  The identifier to be added in the allowlist. Can be an email address, a phone number in international [E.164](https://en.wikipedia.org/wiki/E.164) format, a domain, or a Web3 wallet address.

  ---

  - `notify`
  - `boolean`

  Whether the given identifier will receive an invitation to join the application. Note that this only works for email address and phone number identifiers. Not available for wildcard identifiers or Web3 wallet addresses. Defaults to `true`.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const response = await clerkClient.allowlistIdentifiers.createAllowlistIdentifier({
  identifier: 'test@example.com',
  notify: false,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/allowlist-identifiers`. See the [BAPI reference](/docs/reference/backend-api/tag/Allow-list-Block-list#operation/CreateAllowlistIdentifier){{ target: '_blank' }} for more information.

---
title: '`createClerkClient()`'
description: "`createClerkClient()` allows Chrome Extension developers to access a user's session information or get a token in a service worker."
---

The `createClerkClient()` helper initializes a new Clerk instance on demand and refreshes the session token if there is a valid, signed-in user. It can be used in a [background service worker](https://developer.chrome.com/docs/extensions/develop/concepts/service-workers/basics) to access a user's information or session token.

When a side panel or a popup is closed, the Clerk process that normally refreshes the user's session token every 60 seconds is no longer running, and the stored session will become stale. If a request were made 60 seconds after the side panel or popup was closed, it would fail because the session token is no longer valid. By configuring `createClerkClient()` to run in a background service worker, you can ensure that the user's session is always fresh.

## Usage

The following example:

- Creates a background service worker that sets up an event listener to handle requests from a [content script](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts). If the request wants to interact with Clerk, the listener calls `createClerkClient()` to create a Clerk instance and refresh the session token, and then calls [`getToken()`](/docs/references/javascript/session#get-token) to get the token.
- Adds a link to the home page of the extension that when visited, opens the page as a new tab.
- The new tab has a button on it that, when clicked, triggers the background service worker.

> [!WARNING]
> The following example assumes that you have followed the [Chrome Extension Quickstart](/docs/quickstarts/chrome-extension) and then the [Add React Router](/docs/references/chrome-extension/add-react-router) guide, but you can apply these concepts to your own application.

<Steps>
  ### Create your background service worker

  1. In the `src/` directory, create the `background/` directory.
  1. In the `background/` directory, create the `index.ts` file.
  1. In the `index.ts` file, paste the following code to create an event listener that listens for messages from content scripts and calls a function that uses `createClerkClient()` to get a new token for the user.

  ```typescript {{ filename: 'src/background/index.ts' }}
  import { createClerkClient } from '@clerk/chrome-extension/background'

  const publishableKey = process.env.PLASMO_PUBLIC_CLERK_PUBLISHABLE_KEY

  if (!publishableKey) {
    throw new Error('Please add the PLASMO_PUBLIC_CLERK_PUBLISHABLE_KEY to the .env.development file')
  }

  // Use `createClerkClient()` to create a new Clerk instance
  // and use `getToken()` to get a fresh token for the user
  async function getToken() {
    const clerk = await createClerkClient({
      publishableKey,
    })

    // If there is no valid session, then return null. Otherwise proceed.
    if (!clerk.session) {
      return null
    }

    // Return the user's session
    return await clerk.session?.getToken()
  }

  // Create a listener to listen for messages from content scripts
  // It must return true, in order to keep the connection open and send a response later.
  // NOTE: A runtime listener cannot be async.
  chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    // This example sends the token back to the content script
    // but you could also use the token to perform actions on behalf of the user
    getToken()
      .then((token) => sendResponse({ token }))
      .catch((error) => {
        console.error('[Background service worker] Error:', JSON.stringify(error))
        // If there is no token then send a null response
        sendResponse({ token: null })
      })
    return true // REQUIRED: Indicates that the listener responds asynchronously.
  })
  ```

  ### Create the tab with the content script

  1. In the `src/` directory, create the `tabs/` directory.
  1. In the `tabs/` directory, create the `background-worker-demo.html` file.
  1. In the `background-worker-demo.html` file, paste the following code to create a basic HTML file that will house the React component for the content script.
     ```html {{ filename: 'src/tabs/background-worker-demo.html' }}
     <!doctype html>
     <html>
       <head>
         <title>Clerk Background Worker Demo</title>
         <meta charset="utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1.0" />
       </head>

       <body></body>
     </html>
     ```
  1. In the `tabs/` directory, create the `background-worker-demo.tsx` file.
  1. In the `background-worker-demo.tsx` file, paste the following code to create a React component with a button that will trigger the background service worker to get the token. If the token is returned, it will be displayed on the page.
     ```tsx {{ filename: 'src/tabs/background-worker-demo.tsx' }}
     import * as React from 'react'

     export default function NewTab() {
       const [token, setToken] = React.useState<string | null>(null)

       const getToken = async (e: React.MouseEvent<HTMLButtonElement>) => {
         e.preventDefault()

         // Trigger the background service worker to get the token
         // and set the token in the state
         chrome.runtime.sendMessage({ greeting: 'get-token' }, (response) => {
           setToken(response.token)
         })
       }

       return (
         <div>
           <p>Clerk Background Worker Demo</p>
           <div className="App">
             <p>
               This new tab simulates a content page where you might want to access user information, or
               make a request to your backend server and include a user token in the request.
             </p>
             <p>Make sure that you are signed into the extension. You can have the popup closed.</p>
             <button type="button" onClick={getToken} className="button invert">
               Get token from service worker
             </button>
             {token && <p>Token: {token}</p>}
           </div>
         </div>
       )
     }
     ```

  ### Add a button to the extension to open the new tab

  Add a button to your Chrome Extension to open the page you created in the previous step as a new tab. This can be added anywhere in your extension. The following example places the button on the home page of the extension.

  ```tsx {{ filename: 'src/popup/routes/home.tsx' }}
  export const Home = () => {
    return (
      <>
        <h1>Clerk + Chrome Extension</h1>
        <button
          onClick={() => {
            chrome.tabs.create({
              url: './tabs/background-worker-demo.html',
            })
          }}
        >
          Open background worker demo in a new tab
        </button>
      </>
    )
  }
  ```

  ### Test the background service worker

  1. Run your project with the following command:
     ```bash {{ filename: 'terminal' }}
     pnpm dev
     ```
  1. In your Chrome browser, open the extension popup and sign in.
  1. Once you've signed in, select the button that you added and a new tab will open.
  1. In the new tab, select the **Get token from service worker** button. The token will be displayed on the page.
</Steps>

## `createClerkClient()` options

The `createClerkClient()` function accepts an optional object. The following options are available:

<Properties>
  - `publishableKey`
  - `string`

  The Clerk Publishable Key for your instance. This can be found on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.

  ---

  - `syncHost?`
  - `string`

  The host to sync the session with. For more information, see [the dedicated guide](/docs/references/chrome-extension/sync-host).
</Properties>

---
title: '`createClerkHandler()`'
description: The createClerkHandler() is used to configure the Clerk for your TanStack React Start application.
---

The `createClerkHandler()` function configures Clerk to handle authentication state for TanStack routes, allowing you to easily access user session information within your app.

## Usage

### Basic usage

The following example demonstrates how to use `createClerkHandler()` to configure Clerk in your TanStack React Start application.

```tsx {{ filename: 'app/ssr.tsx' }}
import { createStartHandler, defaultStreamHandler } from '@tanstack/react-start/server'
import { getRouterManifest } from '@tanstack/react-start/router-manifest'
import { createRouter } from './router'
import { createClerkHandler } from '@clerk/tanstack-react-start/server'

export default createClerkHandler(
  createStartHandler({
    createRouter,
    getRouterManifest,
  }),
)(defaultStreamHandler)
```

---
title: '`createEmailAddress()`'
description: Use Clerk's Backend SDK to create an email address for the specified user.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/EmailAddressApi.ts#L29 */}

Creates an [`EmailAddress`](/docs/references/javascript/types/email-address) for the specified user.

```ts
function createEmailAddress(params: CreateEmailAddressParams): Promise<EmailAddress>
```

## `CreateEmailAddressParams`

<Properties>
  - `userId`
  - `string`

  The ID of the user to create the email address for.

  ---

  - `emailAddress`
  - `string`

  The email address to assign to the specified user.

  ---

  - `primary?`
  - `boolean`

  Whether or not to set the email address as the user's primary email address. Defaults to `false`, unless it is the first email address.

  ---

  - `verified?`
  - `boolean`

  Whether or not the email address is verified.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const response = await clerkClient.emailAddresses.createEmailAddress({
  userId: 'user_123',
  emailAddress: 'testclerk123@gmail.com',
  primary: true,
  verified: true,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/email_addresses`. See the [BAPI reference](/docs/reference/backend-api/tag/Email-Addresses#operation/CreateEmailAddress){{ target: '_blank' }} for more information.

---
title: '`createInvitation()`'
description: Use Clerk's Backend SDK to create a new invitation for the given email address, and send the invitation email.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/InvitationApi.ts#L42 */}

Creates a new [`Invitation`](/docs/references/backend/types/backend-invitation) for the given email address and sends the invitation email.

If an email address has already been invited or already exists in your application, trying to create a new invitation will return an error. To bypass this error and create a new invitation anyways, set `ignoreExisting` to `true`.

```ts
function createInvitation(params: CreateParams): Promise<Invitation>
```

## `CreateParams`

<Properties>
  - `emailAddress`
  - `string`

  The email address of the user to invite.

  ---

  - `redirectUrl?`
  - `string`

  The full URL or path where the user is redirected upon visiting the invitation link, where they can accept the invitation. Required if you have implemented a [custom flow for handling application invitations](/docs/custom-flows/application-invitations).

  ---

  - `publicMetadata?`
  - [`UserPublicMetadata`](/docs/references/javascript/types/metadata#user-public-metadata)

  Metadata that can be read from both the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }}, but can be set only from the Backend API. Once the user accepts the invitation and signs up, these metadata will end up in the user's public metadata.

  ---

  - `notify?`
  - `boolean`

  Whether an email invitation should be sent to the given email address. Defaults to `true`.

  ---

  - `ignoreExisting?`
  - `boolean`

  Whether an invitation should be created if there is already an existing invitation for this email address, or if the email address already exists in the application. Defaults to `false`.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const response = await clerkClient.invitations.createInvitation({
  emailAddress: 'invite@example.com',
  redirectUrl: 'https://www.example.com/my-sign-up',
  publicMetadata: {
    example: 'metadata',
    example_nested: {
      nested: 'metadata',
    },
  },
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/invitations`. See the [BAPI reference](/docs/reference/backend-api/tag/Invitations#operation/CreateInvitation){{ target: '_blank' }} for more information.

---
title: '`createOrganization()`'
description: Use Clerk's Backend SDK to create an organization.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/OrganizationApi.ts#L109 */}

Creates an [`Organization`](/docs/references/backend/types/backend-organization).

```ts
function createOrganization(params: CreateParams): Promise<Organization>
```

## `CreateParams`

<Properties>
  - `name`
  - `string`

  Name of the organization.

  ---

  - `createdBy`
  - `string`

  The user ID for the user creating the organization. The user will become an administrator for the organization.

  ---

  - `slug?`
  - `string`

  Slug of the organization.

  ---

  - `publicMetadata?`
  - [`OrganizationPublicMetadata`](/docs/references/javascript/types/metadata#organization-public-metadata)

  Metadata that can be read from both the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }}, but can be set only from the Backend API.

  ---

  - `privateMetadata?`
  - [`OrganizationPrivateMetadata`](/docs/references/javascript/types/metadata#organization-private-metadata)

  Metadata that is only visible to your [Backend API](/docs/reference/backend-api){{ target: '_blank' }}.

  ---

  - `maxAllowedMemberships?`
  - `number`

  The maximum number of memberships allowed in the organization.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const name = 'test-org'

const createdBy = 'user_123'

const response = await clerkClient.organizations.createOrganization({ name, createdBy })
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/organizations`. See the [BAPI reference](/docs/reference/backend-api/tag/Organizations#operation/CreateOrganization){{ target: '_blank' }} for more information.

---
title: '`createOrganizationInvitation()`'
description: Use Clerk's Backend SDK to create an invitation for new users to join an organization.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/OrganizationApi.ts#L248 */}

Creates an [`OrganizationInvitation`](/docs/references/backend/types/backend-organization-invitation) for new users to join an organization.

```ts
function createOrganizationInvitation(
  params: CreateOrganizationInvitationParams,
): Promise<OrganizationInvitation>
```

## `CreateOrganizationInvitationParams`

<Properties>
  - `organizationId`
  - `string`

  The organization ID of the organization a user is being invited to.

  ---

  - `inviterUserId`
  - `string | null`

  The user ID of the user creating the invitation.

  ---

  - `emailAddress`
  - `string`

  The email address to send the invitation to.

  ---

  - `role`
  - `string`

  The [role](/docs/organizations/roles-permissions) to assign the invited user within the organization.

  ---

  - `redirectUrl?`
  - `string`

  The full URL or path where users will land once the organization invitation has been accepted.

  ---

  - `publicMetadata?`
  - [`OrganizationInvitationPublicMetadata`](/docs/references/javascript/types/metadata#organization-invitation-public-metadata)

  Metadata that can be read from both the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }}, but can be set only from the Backend API.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const organizationId = 'org_123'

const inviterUserId = 'user_123'

const emailAddress = 'testclerk123@clerk.dev'

const role = 'org:member'

const response = await clerkClient.organizations.createOrganizationInvitation({
  organizationId,
  inviterUserId,
  emailAddress,
  role,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/organizations/{organization_id}/invitations`. See the [BAPI reference](/docs/reference/backend-api/tag/Organization-Invitations#operation/CreateOrganizationInvitation){{ target: '_blank' }} for more information.

---
title: '`createOrganizationMembership()`'
description: Use Clerk's Backend SDK to create a membership to an organization for a user directly (circumventing the need for an invitation).
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/OrganizationApi.ts#L187 */}

Creates a membership to an organization for a user directly (circumventing the need for an invitation). Returns a [`OrganizationMembership`](/docs/references/backend/types/backend-organization-membership) object.

```ts
function createOrganizationMembership(
  params: CreateOrganizationMembershipParams,
): Promise<OrganizationMembership>
```

## `CreateOrganizationMembershipParams`

<Properties>
  - `organizationId`
  - `string`

  The ID of the organization the user is being added to.

  ---

  - `userId`
  - `string`

  The ID of the user to be added to the organization.

  ---

  - `role`
  - `string`

  The [role](/docs/organizations/roles-permissions) to assign the added user within the organization.
</Properties>

## Example

<Include src="_partials/backend/usage" />

In the following example, an [`OrganizationMembership`](/docs/references/backend/types/backend-organization-membership) is created for a user with the role `org:member`.

```tsx
const organizationId = 'org_123'

const userId = 'user_123'

const role = 'org:member'

const response = await clerkClient.organizations.createOrganizationMembership({
  organizationId,
  userId,
  role,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/organizations/{organization_id}/memberships`. See the [BAPI reference](/docs/reference/backend-api/tag/Organization-Memberships#operation/CreateOrganizationMembership){{ target: '_blank' }} for more information.

---
title: '`createPhoneNumber()`'
description: Use Clerk's Backend SDK to create a phone number for the specified user.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/PhoneNumberApi.ts#L29 */}

Creates a [`PhoneNumber`](/docs/references/javascript/types/phone-number) for the specified user.

```ts
function createPhoneNumber(params: CreatePhoneNumberParams): Promise<PhoneNumber>
```

## `CreatePhoneNumberParams`

<Properties>
  - `userId`
  - `string`

  The ID of the user to create the phone number for.

  ---

  - `phoneNumber`
  - `string`

  The phone number to assign to the specified user. Must adhere to the [E.164 format](https://en.wikipedia.org/wiki/E.164) standard for phone number format.

  ---

  - `primary?`
  - `boolean`

  Whether or not to set the phone number as the user's primary phone number. Defaults to `false`, unless it is the first phone number.

  ---

  - `verified?`
  - `boolean`

  Whether or not the phone number is verified.

  ---

  - `reservedForSecondFactor`
  - `boolean`

  Whether or not the phone number is reserved for [multi-factor authentication](/docs/authentication/configuration/sign-up-sign-in-options#multi-factor-authentication). The phone number must also be verified. If there are no other reserved second factors, the phone number will be set as the default second factor.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const response = await clerkClient.phoneNumbers.createPhoneNumber({
  userId: 'user_123',
  phoneNumber: '15551234567',
  primary: true,
  verified: true,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/phone_numbers`. See the [BAPI reference](/docs/reference/backend-api/tag/Phone-Numbers#operation/CreatePhoneNumber){{ target: '_blank' }} for more information.

---
title: '`createRedirectUrl()`'
description: Use Clerk's Backend SDK to create a redirect URL.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/RedirectUrlApi.ts#L29 */}

Creates a [`RedirectUrl`](/docs/references/backend/types/backend-redirect-url).

```ts
function createRedirectUrl(params: CreateRedirectUrlParams): Promise<RedirectUrl>
```

## `CreateRedirectUrlParams`

<Properties>
  - `url`
  - `string`

  The full url value prefixed with `https://` or a custom scheme. For example, `https://my-app.com/oauth-callback` or `my-app://oauth-callback`
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const response = await clerkClient.redirectUrls.createRedirectUrl({
  url: 'https://example.com',
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/redirect_urls`. See the [BAPI reference](/docs/reference/backend-api/tag/Redirect-URLs#operation/CreateRedirectURL){{ target: '_blank' }} for more information.

---
title: '`createSamlConnection()`'
description: Use Clerk's Backend SDK to create a SAML connection.
---

Creates a new [`SamlConnection`](/docs/references/backend/types/saml-connection).

```ts
function createSamlConnection(params: CreateSamlConnectionParams): Promise<SamlConnection>
```

## `CreateSamlConnectionParams`

<Properties>
  - `name`
  - `string`

  The name to use as a label for this SAML Connection.

  ---

  - `provider`
  - `'saml_custom' | 'saml_okta' | 'saml_google' | 'saml_microsoft'`

  The Identity Provider (IdP) provider of the connection.

  ---

  - `domain`
  - `string`

  The domain of your organization. Sign in flows using an email with this domain will use this SAML Connection. For example: `'clerk.dev'`

  ---

  - `organizationId?`
  - `string`

  The ID of the organization to which users of this SAML Connection will be added

  ---

  - `idpEntityId?`
  - `string`

  The Entity ID as provided by the Identity Provider (IdP).

  ---

  - `idpSsoUrl?`
  - `string`

  The Single-Sign On URL as provided by the Identity Provider (IdP).

  ---

  - `idpCertificate?`
  - `string`

  The X.509 certificate as provided by the Identity Provider (IdP).

  ---

  - `idpMetadataUrl?`
  - `string`

  The URL which serves the Identity Provider (IdP) metadata. If present, it takes priority over the corresponding individual properties.

  ---

  - `idpMetadata?`
  - `string`

  The XML content of the Identity Provider (IdP) metadata file. If present, it takes priority over the corresponding individual properties.

  ---

  - `attributeMapping?`
  - `{ emailAddress?: string, firstName?: string, lastName?: string, userId?: string }`

  The attribute mapping for the SAML connection.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const response = await clerkClient.samlConnections.createSamlConnection({
  name: 'test-okta',
  provider: 'saml_okta',
  domain: 'clerk.dev',
  idpMetadataUrl: 'https://trial-000000.okta.com/app/exk...',
  attributeMapping: {
    emailAddress: 'user.email',
    firstName: 'user.firstName',
    lastName: 'user.lastName',
  },
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/saml_connections`. See the [BAPI reference](/docs/reference/backend-api/tag/SAML-Connections#operation/CreateSAMLConnection){{ target: '_blank' }} for more information.

---
title: '`createSignInToken()`'
description: Use Clerk's Backend SDK to create a new sign-in token for a given user.
---

Creates a new sign-in token and associates it with the given user. By default, sign-in tokens expire in 30 days. You can optionally supply a different duration in seconds using the `expires_in_seconds` property.

```ts
function createSignInToken(params: CreateSignInTokensParams): Promise<SignInToken>
```

## `CreateSignInTokenParams`

<Properties>
  - `userId`
  - `string`

  The ID of the user who can use the newly created sign-in token.

  ---

  - `expiresInSeconds`
  - `string`

  Specifies the life duration of the sign in token in seconds. Defaults to `2592000` (30 days)
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const userId = 'user_123'

const expiresInSeconds = 60 * 60 * 24 * 7 // 1 week

const response = await clerkClient.signInTokens.createSignInToken({
  userId,
  expiresInSeconds,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/sign_in_tokens`. See the [BAPI reference](/docs/reference/backend-api/tag/Sign-in-Tokens#operation/CreateSignInToken){{ target: '_blank' }} for more information.

---
title: '`createTestingToken()`'
description: Use Clerk's Backend SDK to create a testing token for the instance.
---

Creates a [Testing Token](/docs/testing/overview#testing-tokens) for the instance.

```ts
function createTestingToken(): Promise<TestingToken>
```

## Example

<Include src="_partials/backend/usage" />

```tsx
const response = await clerk.testingTokens.createTestingToken()
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/testing_tokens`. See the [BAPI reference](/docs/reference/backend-api/tag/Testing-Tokens#operation/CreateTestingToken){{ target: '_blank' }} for more information.

---
title: '`createUser()`'
description: Use Clerk's Backend SDK to create a user.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L140 */}

Creates a [`User`](/docs/references/backend/types/backend-user).

Your user management settings in the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) determine how you should setup your user model. Anything **Required** in **Users & Authentication -> Email, phone, username** will need to be provided when creating a user. Trying to add a field that isn't enabled in **Users & Authentication -> Email, phone, username** will result in an error.

Any email address and phone number created using this method will be automatically marked as verified.

A rate limit rule of 20 requests per 10 seconds is applied to this endpoint.

```ts
function createUser(params: CreateUserParams): Promise<User>
```

## `CreateUserParams`

<Properties>
  - `externalId?`
  - `string`

  The ID of the user as used in your external systems. Must be unique across your instance.

  ---

  - `firstName?`
  - `string`

  The user's first name.

  ---

  - `lastName?`
  - `string`

  The user's last name.

  ---

  - `emailAddress[]?`
  - `string[]`

  Email addresses to add to the user. Must be unique across your instance. The first email address will be set as the users primary email address.

  ---

  - `phoneNumber[]?`
  - `string[]`

  Phone numbers that will be added to the user. Must be unique across your instance. The first phone number will be set as the users primary phone number.

  ---

  - `web3_wallet[]?`
  - `string[]`

  Web3 wallet addresses that will be added to the user. Must be unique across your instance. The first wallet will be set as the users primary wallet.

  ---

  - `username?`
  - `string`

  The username to give to the user. Must be unique across your instance.

  ---

  - `password?`
  - `string`

  The plaintext password to give the user. Must be at least 8 characters long, and can not be in any list of hacked passwords.

  ---

  - `passwordDigest?`
  - `string`

  In case you already have the password digests and not the passwords, you can use them for the newly created user via this property. The digests should be generated with one of the supported algorithms. The hashing algorithm can be specified using the `password_hasher` property.

  ---

  - `passwordHasher?`
  - `'argon2i' | 'argon2id' | 'awscognito' | 'bcrypt' | 'bcrypt_sha256_django' | 'md5' | 'pbkdf2_sha256' | 'pbkdf2_sha256_django' | 'pbkdf2_sha1' | 'phpass' | 'scrypt_firebase' | 'scrypt_werkzeug' | 'sha256'`

  The hashing algorithm that was used to generate the password digest.
  The algorithms we support at the moment are:

  > [!WARNING]
  > For password hashers considered insecure (currently, `MD5` and `SHA256`), the corresponding user password hashes will be transparently migrated to `bcrypt` (a secure hasher) upon the user's first successful password sign in.
  > Insecure schemes are marked with `(insecure)` in the list below.

  - `awscognito`
    - When set, `password_digest` must be in the format of `awscognito#<userpoolid>#<clientid>#<identifier>`.
    - Upon a successful migration, `password_hasher` will be updated to `bcrypt`, and `password_digest` will be updated to a `bcrypt` hash.
    - See the [migration guide](https://clerk.com/docs/deployments/migrate-from-cognito) for usage details.
  - [`bcrypt`](https://en.wikipedia.org/wiki/Bcrypt)
    - When set, `password_digest` must be in the format of `$<algorithm version>$<cost>$<salt & hash>`
  - [`bcrypt_sha256_django`](https://docs.djangoproject.com/en/4.0/topics/auth/passwords/)
    - This is the Django-specific variant of Bcrypt, using SHA256 hashing function. When set, `password_digest` must be in the format of (as exported from Django): `bcrypt_sha256$$<algorithm version>$<cost>$<salt & hash>`
  - [`bcrypt_peppered`](https://github.com/heartcombo/devise)
    - Used in implementations such as Devise for Ruby on Rails applications. Identical to `bcrypt` except that a `pepper` string is appended to the input before hashing. When set, `password_digest` must be in the format of `$<algorithm version>$<cost>$<salt & hash>$<pepper>`
  - [`md5` (insecure)](https://en.wikipedia.org/wiki/MD5)
    - When set, `password_digest` must be in the format of `5f4dcc3b5aa765d61d8327deb882cf99`
  - [`pbkdf2_sha1`](https://en.wikipedia.org/wiki/PBKDF2)
    - When set, `password_digest` must be in the format of `pbkdf2_sha1$<iterations>$<salt>$<hash-as-hex-string>` or `pbkdf2_sha1$<iterations>$<salt-as-hex-string>$<hash-as-hex-string>$<key-length>`
    - Accepts the salt as a hex-encoded string. If the salt is not a valid hex string, the raw bytes will be used instead. Accepts the hash as a hex-encoded string. Optionally accepts the key length as the last parameter (defaults to 32).
  - [`pbkdf2_sha256`](https://en.wikipedia.org/wiki/PBKDF2)
    - This is the PBKDF2 algorithm using the SHA256 hashing function. When set, `password_digest` must be in the format of `pbkdf2_sha256$<iterations>$<salt>$<hash>`
    - Both the salt and the hash are expected to be base64-encoded.
  - [`pbkdf2_sha512`](https://en.wikipedia.org/wiki/PBKDF2)
    - This is the PBKDF2 algorithm using the SHA512 hashing function. When set, `password_digest` must be in the format of `pbkdf2_sha512$<iterations>$<salt>$<hash>`
  - [`pbkdf2_sha256_django`](https://docs.djangoproject.com/en/4.0/topics/auth/passwords/)
    - This is the Django-specific variant of PBKDF2. When set, `password_digest` must be in the format of (as exported from Django): `pbkdf2_sha256$<iterations>$<salt>$<hash>`
    - The salt is expected to be un-encoded, the hash is expected base64-encoded.
  - [`phpass`](https://www.openwall.com/phpass/)
    - Portable public domain password hashing framework for use in PHP applications. When set, `password_digest` must be in the format of `$P$<rounds><salt><encoded-checksum>`
    - `$P$` is the prefix used to identify `phpass` hashes.
    - _rounds_ is a single character encoding a 6-bit integer representing the number of rounds used.
    - _salt_ is eight characters drawn from \[./0-9A-Za-z], providing a 48-bit salt.
    - _checksum_ is 22 characters drawn from the same set, encoding the 128-bit checksum with MD5.
  - [`scrypt_firebase`](https://firebaseopensource.com/projects/firebase/scrypt/)
    - The Firebase-specific variant of scrypt. When set, `password_digest` must be in the format of `<hash>$<salt>$<signer key>$<salt separator>$<rounds>$<memory cost>`
    - _hash:_ The actual Base64 hash. This can be retrieved when exporting the user from Firebase.
    - _salt:_ The salt used to generate the above hash. Again, this is given when exporting the user from Firebase.
    - _signer key:_ The base64 encoded signer key.
    - _salt separator:_ The base64 encoded salt separator.
    - _rounds:_ The number of rounds the algorithm needs to run.
    - _memory cost:_ The cost of the algorithm run
    - The first 2 (hash and salt) are per user and can be retrieved when exporting the user from Firebase. The other 4 values (signer key, salt separator, rounds and memory cost) are project-wide settings and can be retrieved from the project's password hash parameters.
  - [`scrypt_werkzeug`](https://werkzeug.palletsprojects.com/en/3.0.x/utils/#werkzeug.security.generate_password_hash)
    - The Werkzeug-specific variant of scrypt. When set, `password_digest` must be in the format of `$<algorithm args>$<salt>$<hash>`
    - _algorithm args:_ The algorithm used to generate the hash.
    - _salt:_ The salt used to generate the above hash.
    - _hash:_ The actual Base64 hash.
  - [`sha256` (insecure)](https://en.wikipedia.org/wiki/SHA-2)
    - When set, `password_digest` must be a 64-length hex string. For example: `9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08`
  - [`argon2`](https://argon2.online/) variants: `argon2i` and `argon2id`.
    - Algorithms in the argon2 family generate digests that encode the following information:
      - _version (v):_ The argon version, version 19 is assumed
      - _memory (m):_ The memory used by the algorithm (in kibibytes)
      - _iterations (t):_ The number of iterations to perform
      - _parallelism (p):_ The number of threads to use
    - Parts are demarcated by the `$` character, with the first part identifying the algorithm variant The middle part is a comma-separated list of the encoding options (memory, iterations, parallelism). The final part is the actual digest.
    - When set, `password_digest` must be in the format of `$argon2i$v=19$m=4096,t=3,p=1$4t6CL3P7YiHBtwESXawI8Hm20zJj4cs7/4/G3c187e0$m7RQFczcKr5bIR0IIxbpO2P0tyrLjf3eUW3M3QSwnLc`
    - For the argon2id case, the value of the algorithm in the first part of the digest is `argon2id`: `$argon2id$v=19$m=64,t=4,p=8$Z2liZXJyaXNo$iGXEpMBTDYQ8G/71tF0qGjxRHEmR3gpGULcE93zUJVU`

  If you need support for any particular hashing algorithm, [contact support](https://clerk.com/support).

  ---

  - `skipPasswordChecks?`
  - `boolean`

  When set to `true`, all password checks are skipped. It is recommended to use this method only when migrating plaintext passwords to Clerk. Upon migration the user base should be prompted to pick stronger password.

  ---

  - `skipPasswordRequirement?`
  - `boolean`

  When set to `true`, password is not required anymore when creating the user and can be omitted. This is useful when you are trying to create a user that doesn't have a password, in an instance that is using passwords. You cannot use this flag if password is the only way for a user to sign into your instance.

  ---

  - `totpSecret?`
  - `string`

  In case TOTP is configured on the instance, you can provide the secret to enable it on the newly created user without the need to reset it. Currently, the supported options are: <ul><li>Period: 30 seconds</li><li>Code length: 6 digits</li><li>Algorithm: SHA1</li></ul>

  ---

  - `backupCodes?`
  - `string[]`

  If backup codes are configured on the instance, you can provide them to enable it on the newly created user without the need to reset them. You must provide the backup codes in plain format or the corresponding bcrypt digest.

  ---

  - `publicMetadata?`
  - [`UserPublicMetadata`](/docs/references/javascript/types/metadata#user-public-metadata)

  Metadata that can be read from the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }} and can be set only from the Backend API.

  ---

  - `privateMetadata?`
  - [`UserPrivateMetadata`](/docs/references/javascript/types/metadata#user-private-metadata)

  Metadata that can be read and set only from the [Backend API](/docs/reference/backend-api){{ target: '_blank' }}.

  ---

  - `unsafeMetadata?`
  - [`UserUnsafeMetadata`](/docs/references/javascript/types/metadata#user-unsafe-metadata)

  Metadata that can be read and set from the Frontend API. It's considered unsafe because it can be modified from the frontend.

  ---

  - `legalAcceptedAt?`
  - `Date`

  The date when the user accepted the legal documents. `null` if [**Require express consent to legal documents**](/docs/authentication/configuration/legal-compliance) is not enabled.

  ---

  - `skipLegalChecks?`
  - `boolean`

  When set to `true` all legal checks are skipped. It is not recommended to skip legal checks unless you are migrating a user to Clerk.

  ---

  - `createdAt`
  - `string`

  A custom date/time denoting when the user signed up to the application, specified in [RFC3339 format](https://datatracker.ietf.org/doc/html/rfc3339). For example: `2012-10-20T07:15:20.902Z`.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const response = await clerkClient.users.createUser({
  firstName: 'Test',
  lastName: 'User',
  emailAddress: ['testclerk123@gmail.com'],
  password: 'password',
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/users`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/CreateUser){{ target: '_blank' }} for more information.

---
title: '`currentUser()`'
description: Use the currentUser() helper to access information about your user inside of your Server Components, Route Handlers, and Server Actions.
---

The `currentUser` helper returns the [`Backend User`](/docs/references/backend/types/backend-user) object of the currently active user. It can be used in Server Components, Route Handlers, and Server Actions.

Under the hood, this helper:

- calls `fetch()`, so it is automatically deduped per request.
- uses the [`GET /v1/users/{user_id}`](/docs/reference/backend-api/tag/Users#operation/GetUser){{ target: '_blank' }} endpoint.
- counts towards the [Backend API request rate limit](/docs/backend-requests/resources/rate-limits).

```tsx {{ filename: 'app/page.tsx' }}
import { currentUser } from '@clerk/nextjs/server'

export default async function Page() {
  const user = await currentUser()

  if (!user) return <div>Not signed in</div>

  return <div>Hello {user?.firstName}</div>
}
```

---
title: '`CustomMenuItem`'
description: An interface that provides the ability to add custom menu item to the <UserButton /> component.
---

An interface that provides the ability to add custom menu item to the [`<UserButton />`][userbutton-ref] component.

## Attributes

<Properties>
  - `label`
  - `string`

  The label of the custom menu item.

  ---

  - `href?`
  - `string | undefined`

  The URL or path used to navigate to a route inside the app or an external website. It should be relative for internal routes and absolute for external links.

  ---

  - `onClick?`
  - `() => void | undefined`

  A function to be called when the menu item is clicked.

  ---

  - `open?`
  - `string | undefined`

  The path segment used to open a specific custom page in the user profile modal.

  ---

  - `mountIcon?`
  - `((el: HTMLDivElement) => void) | undefined`

  This function is called to mount the icon of the label. The `el` argument is the element where the icon should be mounted.

  ---

  - `unmountIcon?`
  - `((el?: HTMLDivElement) => void) | undefined`

  This function is called to unmount the icon of the label. The `el` argument is the same element that was passed to the `mountIcon` function.

  ---

  - `mount?`
  - `((el: HTMLDivElement) => void) | undefined`

  This function is called to mount the content of the custom page. The `el` argument is the element where the content should be mounted.

  ---

  - `unmount?`
  - `((el?: HTMLDivElement) => void) | undefined`

  This function is called to unmount the content of the custom page. The `el` argument is the same element that was passed to the `mount` function.
</Properties>

[userbutton-ref]: /docs/components/user/user-button

---
title: '`CustomPage`'
description: An interface that provides the ability to add custom pages to the <UserProfile /> or <OrganizationProfile /> components.
---

An interface that provides the ability to add custom pages to the [`<UserProfile />`][userprofile-ref] or [`<OrganizationProfile />`][orgprofile-ref] components.

## Attributes

<Properties>
  - `label`
  - `string`

  The label of the custom page. It is a required property.

  ---

  - `url`
  - `string | undefined`

  The path segment that will be used to navigate to the custom page. It should be relative when providing a custom page and absolute when providing a custom link.

  ---

  - `mountIcon`
  - `((el: HTMLDivElement) => void) | undefined`

  This function is called to mount the icon of the label. The `el` argument is the element where the icon should be mounted.

  ---

  - `unmountIcon`
  - `((el?: HTMLDivElement) => void) | undefined`

  This function is called to unmount the icon of the label. The `el` argument is the same element that was passed to the `mountIcon` function.

  ---

  - `mount`
  - `((el: HTMLDivElement) => void) | undefined`

  This function is called to mount the content of the custom page. The `el` argument is the element where the content should be mounted.

  ---

  - `unmount`
  - `((el?: HTMLDivElement) => void) | undefined`

  This function is called to unmount the content of the custom page. The `el` argument is the same element that was passed to the `mount` function.
</Properties>

[userprofile-ref]: /docs/components/user/user-profile

[orgprofile-ref]: /docs/components/organization/organization-profile

---
title: '`deleteAllowlistIdentifier()`'
description: Use Clerk's Backend SDK to delete an allowlist identifier.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/AllowlistIdentifierApi.ts#L30 */}

Deletes an [`AllowlistIdentifier`](/docs/references/backend/types/backend-allowlist-identifier).

```ts
function deleteAllowlistIdentifier(allowlistIdentifierId: string): Promise<AllowlistIdentifier>
```

## Parameters

<Properties>
  - `allowlistIdentifierId`
  - `string`

  The ID of the allowlist identifier to delete.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const allowlistIdentifierId = 'alid_123'

const response =
  await clerkClient.allowlistIdentifiers.deleteAllowlistIdentifier(allowlistIdentifierId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `DELETE/allowlist-identifiers/{identifier_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Allow-list-Block-list#operation/DeleteAllowlistIdentifier){{ target: '_blank' }} for more information.

---
title: '`DeletedObject`'
description: The DeletedObject class represents an item that has been deleted from the database.
---

The `DeletedObject` class represents an item that has been deleted from the database.

## Properties

<Properties>
  - `object`
  - `string`

  The object type that has been deleted.

  ---

  - `id`
  - `string | null`

  The ID of the deleted item.

  ---

  - `slug`
  - `string | null`

  The slug of the deleted item.

  ---

  - `deleted`
  - `boolean`

  A boolean checking if the item has been deleted or not.
</Properties>

---
title: '`deleteDomain()`'
description: Use Clerk's Backend SDK to delete a satellite domain for the instance.
---

Deletes a satellite domain for the instance. It is currently not possible to delete the instance's primary domain. Returns a [`DeletedObject`](/docs/references/javascript/types/deleted-object).

```ts
function deleteDomain(id: string): Promise<DeletedObject>
```

## Parameters

<Properties>
  - `id`
  - `string`

  The ID of the domain that will be deleted. Must be a satellite domain.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const id = 'test_123'

const response = await clerkClient.users.deleteDomain(id)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `DELETE/domains/{domain_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Domains#operation/DeleteDomain){{ target: '_blank' }} for more information.

---
title: '`deleteEmailAddress()`'
description: Use Clerk's Backend SDK to delete an email address.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/EmailAddressApi.ts#L47 */}

Deletes an [`EmailAddress`](/docs/references/javascript/types/email-address).

```ts
function deleteEmailAddress(emailAddressId: string): Promise<EmailAddress>
```

## Parameters

<Properties>
  - `emailAddressId`
  - `string`

  The ID of the email address to delete.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const emailAddressId = 'idn_123'

const response = await clerkClient.emailAddresses.deleteEmailAddress(emailAddressId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `DELETE/email_addresses/{email_address_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Email-Addresses#operation/DeleteEmailAddress){{ target: '_blank' }} for more information.

---
title: '`deleteOrganization()`'
description: Use Clerk's Backend SDK to delete an organization.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/OrganizationApi.ts#L169 */}

Deletes an [`Organization`](/docs/references/backend/types/backend-organization). Returns a [`DeletedObject`](/docs/references/javascript/types/deleted-object) object.

```ts
function deleteOrganization(organizationId: string): Promise<DeletedObject>
```

## Parameters

<Properties>
  - `organizationId`
  - `string`

  The ID of the organization to delete.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const organizationId = 'org_123'

const response = await clerkClient.organizations.deleteOrganization(organizationId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `DELETE/organizations/{organization_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Organizations#operation/DeleteOrganization){{ target: '_blank' }} for more information.

---
title: '`deleteOrganizationLogo()`'
description: Use Clerk's Backend SDK to delete an organization's logo.
---

Deletes an organization's logo.

```ts
function deleteOrganizationLogo(organizationId: string): Promise<Organization>
```

## Parameters

<Properties>
  - `organizationId`
  - `string`

  The ID of the organization for which the logo will be deleted.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const organizationId = 'org_123'

const response = await clerkClient.organizations.deleteOrganizationLogo(organizationId)

console.log(response)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `DELETE/organizations/{organization_id}/logo`. See the [BAPI reference](/docs/reference/backend-api/tag/Organizations#operation/DeleteOrganizationLogo){{ target: '_blank' }} for more information.

---
title: '`deleteOrganizationMembership()`'
description: Use Clerk's Backend SDK to remove a user from the specified organization.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/OrganizationApi.ts#L227 */}

Removes a user from the specified organization. Returns a [`OrganizationMembership`](/docs/references/backend/types/backend-organization-membership) object.

```ts
function deleteOrganizationMembership(
  params: DeleteOrganizationMembershipParams,
): Promise<OrganizationMembership>
```

## `DeleteOrganizationMembershipParams`

<Properties>
  - `organizationId`
  - `string`

  The ID of the organization the user will be removed from.

  ---

  - `userId`
  - `string`

  The ID of the user to be removed from the organization.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const organizationId = 'org_123'

const userId = 'user_123'

const response = await clerkClient.organizations.deleteOrganizationMembership({
  organizationId,
  userId,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `DELETE/organizations/{organization_id}/memberships/{user_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Organization-Memberships#operation/DeleteOrganizationMembership){{ target: '_blank' }} for more information.

---
title: '`deletePhoneNumber()`'
description: Use Clerk's Backend SDK to delete a phone number.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/PhoneNumberApi.ts#L47 */}

Deletes a [`PhoneNumber`](/docs/references/javascript/types/phone-number).

```ts
function deletePhoneNumber(phoneNumberId: string): Promise<PhoneNumber>
```

## Parameters

<Properties>
  - `phoneNumberId`
  - `string`

  The ID of the phone number to delete.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const phoneNumberId = 'idn_123'

const response = await clerkClient.phoneNumbers.deletePhoneNumber(phoneNumberId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `DELETE/phone_numbers/{phone_number_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Phone-Numbers#operation/DeletePhoneNumber){{ target: '_blank' }} for more information.

---
title: '`deleteRedirectUrl()`'
description: Use Clerk's Backend SDK to delete a redirect URL.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/RedirectUrlApi.ts#L37 */}

Deletes a [`RedirectUrl`](/docs/references/backend/types/backend-redirect-url).

```ts
function deleteRedirectUrl(redirectUrlId: string): Promise<RedirectUrl>
```

## Parameters

<Properties>
  - `redirectUrlId`
  - `string`

  The ID of the redirect URL to delete.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const redirectUrlId = 'ru_123'

const response = await clerkClient.redirectUrls.deleteRedirectUrl(redirectUrlId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `DELETE/redirect_urls/{id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Redirect-URLs#operation/DeleteRedirectURL){{ target: '_blank' }} for more information.

---
title: '`deleteSamlConnection()`'
description: Use Clerk's Backend SDK to delete a SAML connection.
---

Deletes a [`SamlConnection`](/docs/references/backend/types/saml-connection) by its ID. Returns a [`DeletedObject`](/docs/references/javascript/types/deleted-object) object.

```ts
function deleteSamlConnection(samlConnectionId: string): Promise<DeletedObject>
```

## Parameters

<Properties>
  - `samlConnectionId`
  - `string`

  The ID of the SAML connection to delete.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const samlConnectionId = 'samlc_123'

const response = await clerkClient.samlConnections.deleteSamlConnection(samlConnectionId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `DELETE/saml_connections/{saml_connection_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/SAML-Connections#operation/DeleteSAMLConnection){{ target: '_blank' }} for more information.

---
title: '`deleteUser()`'
description: Use Clerk's Backend SDK to delete a user.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L171 */}

Deletes a [`User`](/docs/references/backend/types/backend-user) given a valid ID.

```ts
function deleteUser(userId: string): Promise<User>
```

## Parameters

<Properties>
  - `userId`
  - `string`

  The ID of the user to delete.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const userId = 'user_123'

const response = await clerkClient.users.deleteUser(userId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `DELETE/users/{user_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/DeleteUser){{ target: '_blank' }} for more information.

---
title: '`deleteUserProfileImage()`'
description: Use Clerk's Backend SDK to delete a user's profile image.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L158 */}

Deletes a user's profile image. Returns a [`User`](/docs/references/backend/types/backend-user) object.

```ts
function deleteUserProfileImage(userId: string): Promise<User>
```

## Example

<Include src="_partials/backend/usage" />

> [!WARNING]
> Using Backend SDK methods can contribute towards rate limiting. To remove a user's profile image, it's recommended to use the frontend [`user.setProfileImage({ file: null })`](/docs/references/javascript/user#set-profile-image-params) method instead.

```tsx
const userId = 'user_123'

const response = await clerkClient.users.deleteUserProfileImage(userId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/users/{user_id}/profile_image`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/SetUserProfileImage){{ target: '_blank' }} for more information.

---
title: '`disableUserMFA()`'
description: Use Clerk's Backend SDK to disable all of a user's MFA methods at once.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L206 */}

Disable all of a user's MFA methods (e.g. OTP sent via SMS, TOTP on their authenticator app) at once. Returns a [`User`](/docs/references/backend/types/backend-user) object.

```ts
function disableUserMFA(userId: string): Promise<User>
```

## Parameters

<Properties>
  - `userId`
  - `string`

  The ID of the user to disable MFA for.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const userId = 'user_123'

const response = await clerkClient.users.disableUserMFA(userId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `DELETE/users/{user_id}/mfa`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/DisableMFA){{ target: '_blank' }} for more information.

---
title: '`EmailAddress`'
description: The EmailAddress object is a model around an email address.
---

The `EmailAddress` object is a model around an email address. Email addresses are one of the [identifiers](/docs/authentication/configuration/sign-up-sign-in-options#identifiers) used to provide identification for users.

Email addresses must be **verified** to ensure that they are assigned to their rightful owners. The `EmailAddress` object holds all necessary state around the verification process. The following steps outline the verification process:

1. Initiate the verification process by collecting the user's email address.
1. Prepare the verification process by calling the [`prepareVerification()`](#prepare-verification) method, which will send a one-time verification code via an email link or code, depending on what parameters are passed to the method and the settings in the Clerk Dashboard.
1. Attempt to complete the verification by calling the [`attemptVerification()`](#attempt-verification) method, passing the one-time code as a parameter.

For implementation examples for adding and verifying email addresses, see the [email link custom flow](/docs/custom-flows/email-links) and [email code custom flow](/docs/custom-flows/add-email) guides.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for the email address.

  ---

  - `emailAddress`
  - `string`

  The value of the email address.

  ---

  - `verification`
  - [`Verification`](/docs/references/javascript/types/verification)

  An object holding information on the verification of the email address.

  ---

  - `linkedTo`
  - `Array<{id: string, type: string}>`

  An array of objects containing information about any identifications that might be linked to the email address.
</Properties>

## Methods

### `create()`

Creates a new email address for the current user.

```typescript
function create(): Promise<EmailAddress>
```

### `destroy()`

Deletes the email address.

```typescript
function destroy(): Promise<void>
```

### `toString()`

Returns the value for the email address. Can also be accessed via the `EmailAddress.emailAddress` attribute.

```typescript
function toString(): string
```

### `prepareVerification()`

Initiates the email address verification process. Based on the specified strategy, sends either a one-time verification code or a verification link to the email address. The verification status can be tracked through the `verification` property of the `EmailAddress` object.

```typescript
function prepareVerification(params: PrepareEmailAddressVerificationParams): Promise<EmailAddress>
```

#### `PrepareEmailAddressVerificationParams`

<Properties>
  - `strategy`
  - `'email_link' | 'email_code'`

  The verification strategy. Supported strategies are:

  - `email_link`: User will receive an email link via email.
  - `email_code`: User will receive a one-time authentication code via email.

  ---

  - `redirectUrl`
  - `string | undefined`

  **Required** if `strategy` is set to `email_link`. The full URL that the user will be redirected to when they visit the email link. See the [custom flow](/docs/custom-flows/email-links) for implementation details.
</Properties>

### `attemptVerification()`

Attempts to verify an email address using a one-time code. The code must have been previously sent to the email address via the [EmailAddress.prepareVerification()](#prepare-verification) method with `strategy: 'email_code'`. Returns the updated `EmailAddress` object if verification is successful.

```typescript
function attemptVerification(params: AttemptEmailAddressVerificationParams): Promise<EmailAddress>
```

#### `AttemptEmailAddressVerificationParams`

<Properties>
  - `code`
  - `string`

  The one-time code that was sent to the user's email address when [EmailAddress.prepareVerification()](#prepare-verification) was called with `strategy` set to `email_code`.
</Properties>

### `createEmailLinkFlow()`

Sets up an email verification with email link flow. Calling `createEmailLinkFlow()` will return two functions.

```typescript
function createEmailLinkFlow(): {
  startEmailLinkFlow: (params: StartEmailLinkFlowParams) => Promise<EmailAddress>
  cancelEmailLinkFlow: () => void
}
```

`createEmailLinkFlow` returns an object with two functions:

<Properties>
  - `startEmailLinkFlow`
  - <code>(params: [StartEmailLinkFlowParams](#start-email-link-flow-params)) => Promise\<EmailAddress></code>

  Function to start the email link flow. It sends the email with the email link and polls for the verification result.

  ---

  - `cancelEmailLinkFlow`
  - `() => void`

  Function to stop polling for the verification result, allowing for full control of the flow and cleanup.
</Properties>

#### `StartEmailLinkFlowParams`

<Properties>
  - `redirectUrl`
  - `string`

  The full URL that the user will be redirected to when they visit the email link.
</Properties>

---
title: '`EmailLinkError`'
description: Custom error for email links.
---

Custom error for email links. Raised when the email link verification doesn't succeed, either because the link has expired or a general failure. The error's `code` property will indicate the outcome, its values being:

- `EmailLinkErrorCode.Expired`
- `EmailLinkErrorCode.Failed`

---
title: '`EnterpriseAccount`'
description: An interface that represents an enterprise account.
---

An interface that represents an enterprise account.

<Properties>
  - `active`
  - `boolean`

  A boolean value that indicates whether the enterprise account is active.

  ---

  - `emailAddress`
  - `string`

  The email address of the enterprise account.

  ---

  - `enterpriseConnection`
  - <code>[EnterpriseAccountConnection](/docs/references/javascript/types/enterprise-account-connection) | null</code>

  The enterprise connection associated with the enterprise account.

  ---

  - `firstName`
  - `string | null`

  The first name of the enterprise account.

  ---

  - `lastName`
  - `string | null`

  The last name of the enterprise account.

  ---

  - `protocol`
  - `'saml' | 'oauth'`

  The authentication protocol of the enterprise account connection.

  ---

  - `provider`
  - <code>"saml\_okta" | "saml\_google" | "saml\_microsoft" | "saml\_custom" | "oauth\_$\{[OAuthProvider](/docs/references/javascript/types/sso#o-auth-provider)}"</code>

  The provider of the enterprise account.

  ---

  - `providerUserId`
  - `string | null`

  The user's ID as used in the provider.

  ---

  - `publicMetadata`
  - `Record<string, unknown> | null`

  Metadata that can be read from both the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }}, but can be set only from the Backend API. Once the user accepts the invitation and signs up, these metadata will end up in the user's public metadata.

  ---

  - `verification`
  - <code>[Verification](/docs/references/javascript/types/verification) | null</code>

  The verification of the enterprise account.
</Properties>

---
title: '`EnterpriseAccountConnection`'
description: An interface that represents an enterprise account connection.
---

An interface that represents an enterprise account connection.

<Properties>
  - `active`
  - `boolean`

  A boolean that indicates whether the enterprise account connection is active.

  ---

  - `allow_idp_initiated`
  - `boolean`

  A boolean that indicates whether the enterprise account connection allows IDP-initiated authentication.

  ---

  - `allow_subdomains`
  - `boolean`

  A boolean that indicates whether the enterprise account connection allows subdomains.

  ---

  - `disable_additional_identifications`
  - `boolean`

  A boolean that indicates whether the enterprise account connection disables additional identifications.

  ---

  - `domain`
  - `string`

  The domain of the enterprise account connection.

  ---

  - `id`
  - `string`

  The unique identifier of the enterprise account connection.

  ---

  - `logo_public_url`
  - `string | null`

  The public URL of the enterprise account connection's logo.

  ---

  - `name`
  - `string`

  The name of the enterprise account connection.

  ---

  - `protocol`
  - `'saml' | 'oauth'`

  The authentication protocol of the enterprise account connection.

  ---

  - `provider`
  - <code>"saml\_okta" | "saml\_google" | "saml\_microsoft" | "saml\_custom" | "oauth\_$\{[OAuthProvider](/docs/references/javascript/types/sso#o-auth-provider)}"</code>

  The provider of the enterprise account connection.

  ---

  - `sync_user_attributes`
  - `boolean`

  A boolean that indicates whether the enterprise account connection syncs user attributes.

  ---

  - `created_at`
  - `number`

  The timestamp of when the enterprise account connection was created.

  ---

  - `updated_at`
  - `number`

  The timestamp of when the enterprise account connection was updated.
</Properties>

---
title: '`ExternalAccount`'
description: The ExternalAccount object is a model around an identification obtained by an external provider (e.g. a social provider such as Google).
---

The `ExternalAccount` object is a model around an identification obtained by an external provider (e.g. a social provider such as Google).

External account must be verified, so that you can make sure they can be assigned to their rightful owners. The `ExternalAccount` object holds all necessary state around the verification process.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for this external account.

  ---

  - `identificationId`
  - `string`

  The identification with which this external account is associated.

  ---

  - `provider`
  - `string`

  The provider name (e.g., `google`).

  ---

  - `providerUserId`
  - `string`

  The unique ID of the user in the provider.

  ---

  - `emailAddress`
  - `string`

  The user's email address.

  ---

  - `approvedScopes`
  - `string[]`

  The scopes that the user has granted access to.

  ---

  - `firstName`
  - `string`

  The user's first name.

  ---

  - `lastName`
  - `string`

  The user's last name.

  ---

  - `imageUrl`
  - `string`

  The user's image URL.

  ---

  - `username`
  - `string | null`

  The user's username.

  ---

  - `phoneNumber`
  - `string | null`

  The phone number related to this specific external account.

  ---

  - `publicMetadata`
  - `Record<string, unknown>`

  Metadata that can be read from the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }} and can be set only from the Backend API.

  ---

  - `label`
  - `string | null`

  A descriptive label to differentiate multiple external accounts of the same user for the same provider.

  ---

  - `verification`
  - [`Verification`](/docs/references/javascript/types/verification)

  An object holding information on the verification of this external account.
</Properties>

## Methods

### `reauthorize()`

Invokes a re-authorization flow for an existing external account.

```typescript
function reauthorize(params: ReauthorizeExternalAccountParams): Promise<ExternalAccount>
```

#### `ReauthorizeExternalAccountParams`

<Properties>
  - `additionalScopes`
  - `string[]`

  Additional scopes for your user to be prompted to approve.

  ---

  - `redirectUrl`
  - `string`

  The full URL or path that the OAuth provider should redirect to on successful authorization on their part. Typically, this will be a simple `/sso-callback` route that calls [`Clerk.handleRedirectCallback`](/docs/references/javascript/clerk#handle-redirect-callback) or mounts the [`<AuthenticateWithRedirectCallback />`](/docs/components/control/authenticate-with-callback) component. See the [custom flow](/docs/custom-flows/oauth-connections) for implementation details.

  ---

  - `oidcPrompt?`
  - `string`

  The value to pass to the [OIDC `prompt` parameter](https://openid.net/specs/openid-connect-core-1_0.html#:~:text=prompt,reauthentication%20and%20consent.) in the generated OAuth redirect URL.

  ---

  - `oidcLoginHint?`
  - `string`

  The value to pass to the [OIDC `login_hint` parameter](https://openid.net/specs/openid-connect-core-1_0.html#:~:text=login_hint,in%20\(if%20necessary\).) in the generated OAuth redirect URL.
</Properties>

### `destroy()`

Deletes this external account.

```typescript
function destroy(): Promise<void>
```

### `providerSlug()`

A getter method for the `provider` attribute.

```typescript
function providerSlug(): string
```

### `providerTitle()`

Returns the title of the provider with the word "Account" appended.

EG: if `google` is passed as the parameter, `Google Account` will be returned.

```typescript
function providerTitle(): string
```

### `accountIdentifier()`

Returns the identifier of the account, which can be one of the following:

- `username` if present
- `emailAddress` if present
- `label`

```typescript
function accountIdentifier(): string
```

---
title: '`getAllowlistIdentifierList()`'
description: Use Clerk's Backend SDK to retrieve a list of allowlist identifiers.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/AllowlistIdentifierApi.ts#L14 */}

Retrieves the list of all allowlist identifiers. Returns a [`PaginatedResourceResponse`](/docs/references/backend/types/paginated-resource-response) object with a `data` property that contains an array of [`AllowlistIdentifier`](/docs/references/backend/types/backend-allowlist-identifier) objects, and a `totalCount` property that indicates the total number of allowlist identifiers in the system.

```ts
function getAllowlistIdentifierList(): Promise<PaginatedResourceResponse<AllowlistIdentifier[]>>
```

## Example

<Include src="_partials/backend/usage" />

```tsx
const response = await clerkClient.allowlistIdentifiers.getAllowlistIdentifierList()
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/allowlist-identifiers`. See the [BAPI reference](/docs/reference/backend-api/tag/Allow-list-Block-list#operation/ListAllowlistIdentifiers){{ target: '_blank' }} for more information.

---
title: '`getAuth()`'
description: The getAuth() helper retrieves authentication state from the request object.
---

The `getAuth()` helper retrieves authentication state from the request object.

> [!NOTE]
> If you are using App Router, use the [`auth()` helper](/docs/references/nextjs/auth) instead.

## Parameters

<Properties>
  - `req`

  The Next.js request object.

  ---

  - `opts?`

  An optional object that can be used to configure the behavior of the `getAuth()` function. It accepts the following properties:

  - `secretKey?`: A string that represents the Secret Key used to sign the session token. If not provided, the Secret Key is retrieved from the environment variable `CLERK_SECRET_KEY`.
</Properties>

## Returns

`getAuth()` returns the `Auth` object. See the [`Auth` reference](/docs/references/backend/types/auth-object) for more information.

## Usage

See the [dedicated guide](/docs/references/nextjs/read-session-data#pages-router) for example usage.

---
title: '`getAuth()`'
description: Access and manage the current user's authentication state in your React application with Clerk's getAuth() helper.
---

The `getAuth()` helper retrieves the current user's authentication state from the request object.

## Parameters

<Properties>
  - `request`

  The request object.

  ---

  - `opts?`

  An optional object that can be used to configure the behavior of the `getAuth()` function. It accepts the following properties:

  - `secretKey?`: A string that represents the secret key used to sign the session token. If not provided, the secret key is retrieved from the environment variable `CLERK_SECRET_KEY`.
</Properties>

## Returns

`getAuth()` returns the `Auth` object. This JavaScript object contains important information like the current user's session ID, user ID, and organization ID. Learn more about the [`Auth` object](/docs/references/backend/types/auth-object){{ target: '_blank' }}.

## Usage

See the [dedicated guide](/docs/references/react-router/read-session-data#server-side) for example usage.

---
title: '`getAuth()`'
description: The getAuth() helper retrieves the authentication state allowing you to protect your API routes or gather relevant data.
---

The `getAuth()` helper retrieves authentication state from the request object.

## Parameters

<Properties>
  - `request`

  The request object.

  ---

  - `opts?`

  An optional object that can be used to configure the behavior of the `getAuth()` function. It accepts the following properties:

  - `secretKey?`: A string that represents the Secret Key used to sign the session token. If not provided, the Secret Key is retrieved from the environment variable `CLERK_SECRET_KEY`.
</Properties>

## Returns

`getAuth()` returns the [`Auth`](/docs/references/backend/types/auth-object){{ target: '_blank' }} object.

## Usage

See the [dedicated guide](/docs/references/tanstack-react-start/read-session-data#server-side) for example usage.

---
title: '`getClient()`'
description: Use Clerk's Backend SDK to retrieve a single client by its ID.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/ClientApi.ts#L19 */}

Retrieves a single [`Client`](/docs/references/javascript/client).

```ts
function getClient(clientId: string): Promise<Client>
```

## Parameters

<Properties>
  - `clientId`
  - `string`

  The ID of the client to retrieve.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const clientId = 'client_123'

const response = await clerkClient.clients.getClient(clientId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/clients/{client_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Clients#operation/GetClient){{ target: '_blank' }} for more information.

---
title: '`getClientList()` (deprecated)'
description: Retrieves the list of clients.
---

> [!CAUTION]
> This method is now deprecated.

```tsx
const clients = await clerkClient.clients.getClientList()
```

---
title: '`getCount()`'
description: Use Clerk's Backend SDK to retrieve the total number of users.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L189 */}

Retrieves the total number of users.

```ts
function getCount(params: UserCountParams): Promise<number>
```

## `UserCountParams`

The total count of users can be filtered down by adding one or more of these parameters.

<Properties>
  - `emailAddress?`
  - `string[]`

  Counts users with emails that match the given query, via case-insensitive partial match. For example, `hello` will match a user with the email `hello@example.com`.

  ---

  - `phoneNumber?`
  - `string[]`

  Counts users with phone numbers that match the given query, via case-insensitive partial match. For example, `555` will match a user with the phone number `+1555xxxxxxx`.

  ---

  - `externalId?`
  - `string[]`

  Counts users with the specified external IDs.

  ---

  - `username?`
  - `string[]`

  Counts users with the specified usernames.

  ---

  - `web3wallet?`
  - `string[]`

  Counts users with the specified Web3 wallet addresses.

  ---

  - `userId?`
  - `string`

  Counts users with the user IDs specified.

  ---

  - `query?`
  - `string`

  Counts users that match the given query. For possible matches, Clerk checks the email addresses, phone numbers, usernames, Web3 wallet addresses, user IDs, first and last names. The query value doesn't need to match the exact value you are looking for, it is capable of partial matches as well.
</Properties>

## Examples

<Include src="_partials/backend/usage" />

### Basic

```tsx
const response = await clerkClient.users.getCount()
```

### Filter by query

The following example retrieves the total number of users matching the query `test`.

```tsx
const response = await clerkClient.users.getCount({ query: 'test' })
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/users/count`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/GetUsersCount){{ target: '_blank' }} for more information.

---
title: '`getEmailAddress()`'
description: Use Clerk's Backend SDK to retrieve a single email address by its ID.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/EmailAddressApi.ts#L20 */}

Retrieves a single [`EmailAddress`](/docs/references/javascript/types/email-address).

```ts
function getEmailAddress(emailAddressId: string): Promise<EmailAddress>
```

## Parameters

<Properties>
  - `emailAddressId`
  - `string`

  The ID of the email address to retrieve.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const emailAddressId = 'idn_123'

const response = await clerkClient.emailAddresses.getEmailAddress(emailAddressId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/email_addresses/{email_address_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Email-Addresses#operation/GetEmailAddress){{ target: '_blank' }} for more information.

---
title: '`getInvitationList()`'
description: Use Clerk's Backend SDK to retrieve a list of non-revoked invitations for your application.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/InvitationApi.ts#L34 */}

Retrieves a list of non-revoked invitations for your application, sorted by descending creation date. Returns a [`PaginatedResourceResponse`](/docs/references/backend/types/paginated-resource-response) object with a `data` property that contains an array of [`Invitation`](/docs/references/backend/types/backend-invitation) objects, and a `totalCount` property that indicates the total number of invitations in the system.

```ts
function getInvitationList(
  params: GetInvitationListParams,
): Promise<PaginatedResourceResponse<Invitation[]>>
```

## `GetInvitationListParams`

<Properties>
  - `status?`
  - `accepted | pending | revoked`

  Filter by invitation status.

  ---

  - `limit?`
  - `number`

  The number of results to return. Must be an integer greater than zero and less than 501. Can be used for paginating the results together with `offset`. Defaults to `10`.

  ---

  - `offset?`
  - `number`

  Skip the first `offset` results when paginating. Needs to be an integer greater or equal to zero. To be used in conjunction with `limit`. Defaults to `0`.
</Properties>

## Examples

### Basic

<Include src="_partials/backend/usage" />

```tsx
const response = await clerkClient.invitations.getInvitationList()
```

### Filter by invitation status

Retrieves list of invitations that have been revoked.

```tsx
// get all revoked invitations
const response = await clerkClient.invitations.getInvitationList({ status: 'revoked' })
```

### Limit the number of results

Retrieves list of invitations that have been revoked that is filtered by the number of results.

```tsx
const { data, totalCount } = await clerkClient.invitations.getInvitationList({
  status: 'revoked',
  // returns the first 10 results
  limit: 10,
})
```

### Skip results

Retrieves list of invitations that have been revoked that is filtered by the number of results to skip.

```tsx
const { data, totalCount } = await clerkClient.invitations.getInvitationList({
  status: 'revoked',
  // skips the first 10 results
  offset: 10,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/invitations`. See the [BAPI reference](/docs/reference/backend-api/tag/Invitations#operation/ListInvitations){{ target: '_blank' }} for more information.

---
title: '`getOrganization()`'
description: Use Clerk's Backend SDK to retrieve a single organization.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/OrganizationApi.ts#L117 */}

Retrieves a single [`Organization`](/docs/references/backend/types/backend-organization).

```ts
function getOrganization(params: GetOrganizationParams): Promise<Organization>
```

## `GetOrganizationParams`

<Properties>
  - `organizationId | slug`
  - `string`

  The ID of the organization to retrieve, or the slug of the organization to retrieve.
</Properties>

## Examples

<Include src="_partials/backend/usage" />

### Retrieve by ID

```tsx
const organizationId = 'org_123'

const response = await clerkClient.organizations.getOrganization({ organizationId })
```

### Retrieve by slug

Retrieve an organization by its slug instead of its ID.

```tsx
const slug = 'my-organization-slug'

const response = await clerkClient.organizations.getOrganization({ slug })
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/organizations/{organization_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Organizations#operation/GetOrganization){{ target: '_blank' }} for more information.

---
title: '`getOrganizationInvitation()`'
description: Use Clerk's Backend SDK to retrieve an organization invitation.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/OrganizationApi.ts#L259 */}

Retrieves an [`OrganizationInvitation`](/docs/references/backend/types/backend-organization-invitation).

```ts
function getOrganizationInvitation(
  params: GetOrganizationInvitationParams,
): Promise<OrganizationInvitation>
```

## `GetOrganizationInvitationParams`

<Properties>
  - `organizationId`
  - `string`

  The ID of the organization that the invitation is for.

  ---

  - `invitationId`
  - `string`

  The ID of the invitation to retrieve.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const organizationId = 'org_123'

const invitationId = 'orginv_123'

const response = await clerkClient.organizations.getOrganizationInvitation({
  organizationId,
  invitationId,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/organizations/{organization_id}/invitations/{invitation_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Organization-Invitations#operation/GetOrganizationInvitation){{ target: '_blank' }} for more information.

---
title: '`getOrganizationInvitationList()`'
description: Use Clerk's Backend SDK to retrieve a list of organization invitations.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/OrganizationApi.ts#L237 */}

Retrieves a list of organization invitations. Returns a [`PaginatedResourceResponse`](/docs/references/backend/types/paginated-resource-response) object with a `data` property that contains an array of [`OrganizationInvitation`](/docs/references/backend/types/backend-organization-invitation) objects, and a `totalCount` property that indicates the total number of organization invitations in the system for the specified organization.

```ts
function getOrganizationInvitationList(
  params: GetOrganizationInvitationListParams,
): Promise<PaginatedResourceResponse<OrganizationInvitation[]>>
```

## `GetOrganizationInvitationListParams`

<Properties>
  - `organizationId`
  - `string`

  The ID of the organization to retrieve the list of pending invitations from.

  ---

  - `limit?`
  - `number`

  The number of results to return. Must be an integer greater than zero and less than 501. Can be used for paginating the results together with `offset`. Defaults to `10`.

  ---

  - `offset?`
  - `number`

  Skip the first `offset` results when paginating. Needs to be an integer greater or equal to zero. To be used in conjunction with `limit`. Defaults to `0`.

  ---

  - `status?`
  - `string[]`

  The status of the invitation. Possible values: `pending`, `accepted`, `revoked`, `expired`. Defaults to `pending`.
</Properties>

## Examples

### Basic

<Include src="_partials/backend/usage" />

```tsx
const organizationId = 'org_123'

const response = await clerkClient.organizations.getOrganizationInvitationList({ organizationId })
```

### Filter by invitation status

Retrieves organization invitation list that is filtered by the status of the invitation.

```tsx
const organizationId = 'org_123'

const { data, totalCount } = await clerkClient.organizations.getOrganizationInvitationList({
  organizationId,
  // returns a list of invitations that have not yet been accepted
  status: ['pending'],
})
```

### Limit the number of results

Retrieves organization invitation list that is filtered by the number of results.

```tsx
const organizationId = 'org_123'

const { data, totalCount } = await clerkClient.organizations.getOrganizationInvitationList({
  organizationId,
  // returns the first 10 results
  limit: 10,
})
```

### Skip results

Retrieves organization invitation list that is filtered by the number of results to skip.

```tsx
const organizationId = 'org_123'

const { data, totalCount } = await clerkClient.organizations.getOrganizationInvitationList({
  organizationId,
  // skips the first 10 results
  offset: 10,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/organizations/{organization_id}/invitations`. See the [BAPI reference](/docs/reference/backend-api/tag/Organization-Invitations#operation/ListOrganizationInvitations){{ target: '_blank' }} for more information.

---
title: '`getOrganizationList()`'
description: Use Clerk's Backend SDK to retrieve a list of organizations.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/OrganizationApi.ts#L101 */}

Retrieves a list of organizations. Returns a [`PaginatedResourceResponse`](/docs/references/backend/types/paginated-resource-response) object with a `data` property that contains an array of [`Organization`](/docs/references/backend/types/backend-organization) objects, and a `totalCount` property that indicates the total number of organizations in the system.

```ts
function getOrganizationList(
  params: GetOrganizationListParams,
): Promise<PaginatedResourceResponse<Organization[]>>
```

## `GetOrganizationListParams`

<Properties>
  - `limit?`
  - `number`

  The number of results to return. Must be an integer greater than zero and less than 501. Can be used for paginating the results together with `offset`. Defaults to `10`.

  ---

  - `offset?`
  - `number`

  Skip the first `offset` results when paginating. Needs to be an integer greater or equal to zero. To be used in conjunction with `limit`. Defaults to `0`.

  ---

  - `includeMembersCount?`
  - `boolean`

  Whether the member counts of each organization should be included in the response or not.

  ---

  - `query?`
  - `string`

  Filters organizations with ID, name, or slug that match the given query. Uses exact match for organization ID and partial match for name and slug.

  ---

  - `orderBy?`
  - `'name' | 'created_at' | 'members_count'`

  Return organizations in a particular order. Prefix with a `-` to reverse the order. Prefix with a `+` to list in ascending order. Defaults to `'-created_at'`.
</Properties>

## Examples

### Basic

<Include src="_partials/backend/usage" />

```tsx
const response = await clerkClient.organizations.getOrganizationList()
```

### Limit the number of results

Retrieves organization list that is filtered by the number of results.

```tsx
const { data, totalCount } = await clerkClient.organizations.getOrganizationList({
  // returns the first 10 results
  limit: 10,
})
```

### Skip results

Retrieves organization list that is filtered by the number of results to skip.

```tsx
const { data, totalCount } = await clerkClient.organizations.getOrganizationList({
  // skips the first 10 results
  offset: 10,
})
```

### Filter by query

Retrieves list of organizations that match the query.

```tsx
// returns organizations that have 'test' in their name
const { data, totalCount } = await clerkClient.organizations.getOrganizationList({ query: 'test' })
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/organizations`. See the [BAPI reference](/docs/reference/backend-api/tag/Organizations#operation/ListOrganizations){{ target: '_blank' }} for more information.

---
title: '`getOrganizationMembershipList()`'
description: Use Clerk's Backend SDK to retrieve a list of memberships for an organization.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/OrganizationApi.ts#L176 */}

Retrieves a list of memberships for an organization. Returns a [`PaginatedResourceResponse`](/docs/references/backend/types/paginated-resource-response) object with a `data` property that contains an array of [`OrganizationMembership`](/docs/references/backend/types/backend-organization-membership) objects, and a `totalCount` property that indicates the total number of organization memberships in the system for the specified organization.

```ts
function getOrganizationMembershipList(
  params: GetOrganizationMembershipListParams,
): Promise<PaginatedResourceResponse<OrganizationMembership[]>>
```

## `GetOrganizationMembershipListParams`

<Properties>
  - `organizationId`
  - `string`

  The ID of the organization to retrieve the list of memberships from.

  ---

  - `limit?`
  - `number`

  The number of results to return. Must be an integer greater than zero and less than 501. Can be used for paginating the results together with `offset`. Defaults to `10`.

  ---

  - `offset?`
  - `number`

  Skip the first `offset` results when paginating. Needs to be an integer greater or equal to zero. To be used in conjunction with `limit`. Defaults to `0`.

  ---

  - `orderBy?`
  - `'phone_number' | 'email_address' | 'created_at' | 'first_name' | 'last_name' | 'username'`

  Return memberships in a particular order. Prefix with a `-` to reverse the order. Prefix with a `+` to list in ascending order. Defaults to `'-created_at'`.
</Properties>

## Examples

### Basic

<Include src="_partials/backend/usage" />

```tsx
const organizationId = 'org_2ZUtbk2yvnFGItdeze1ivCh3uqh'

const response = await clerkClient.organizations.getOrganizationMembershipList({ organizationId })
```

### `getOrganizationMembershipList({ organizationId, limit })`

Retrieves organization membership list that is filtered by the number of results.

```tsx
const organizationId = 'org_123'

const { data, totalCount } = await clerkClient.organizations.getOrganizationMembershipList({
  organizationId,
  // returns the first 10 memberships
  limit: 10,
})
```

### `getOrganizationMembershipList({ organizationId, offset })`

Retrieves organizaiton membership list that is filtered by the number of results to skip.

```tsx
const organizationId = 'org_123'

const { data, totalCount } = await clerkClient.organizations.getOrganizationMembershipList({
  organizationId,
  // skips the first 10 memberships
  offset: 10,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/organizations/{organization_id}/memberships`. See the [BAPI reference](/docs/reference/backend-api/tag/Organization-Memberships#operation/ListOrganizationMemberships){{ target: '_blank' }} for more information.

---
title: '`getPhoneNumber()`'
description: Use Clerk's Backend SDK to retrieve a single phone number by its ID.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/PhoneNumberApi.ts#L20 */}

Retrieves a single [`PhoneNumber`](/docs/references/javascript/types/phone-number).

```ts
function getPhoneNumber(phoneNumberId: string): Promise<PhoneNumber>
```

## Parameters

<Properties>
  - `phoneNumberId`
  - `string`

  The ID of the phone number to retrieve.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const phoneNumberId = 'idn_123'

const response = await clerkClient.phoneNumbers.getPhoneNumber(phoneNumberId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/phone_numbers/{phone_number_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Phone-Numbers#operation/GetPhoneNumber){{ target: '_blank' }} for more information.

---
title: '`getRedirectUrl()`'
description: Use Clerk's Backend SDK to retrieve a single redirect URL by its ID.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/RedirectUrlApi.ts#L21 */}

Retrieves a single [`RedirectUrl`](/docs/references/backend/types/backend-redirect-url).

```ts
function getRedirectUrl(redirectUrlId: string): Promise<RedirectUrl>
```

## Parameters

<Properties>
  - `redirectUrlId`
  - `string`

  The ID of the redirect URL to retrieve.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const redirectUrlId = 'ru_123'

const response = await clerkClient.redirectUrls.getRedirectUrl(redirectUrlId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/redirect_urls/{id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Redirect-URLs#operation/GetRedirectURL){{ target: '_blank' }} for more information.

---
title: '`getRedirectUrlList()`'
description: Use Clerk's Backend SDK to retrieve a list of white-listed redirect URLs.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/RedirectUrlApi.ts#L13 */}

Retrieves a list of all white-listed redirect URLs. Returns a [`PaginatedResourceResponse`](/docs/references/backend/types/paginated-resource-response) object with a `data` property that contains an array of [`RedirectUrl`](/docs/references/backend/types/backend-redirect-url) objects, and a `totalCount` property that indicates the total number of redirect URLs for the application.

```tsx
function getRedirectUrlList(): () => Promise<PaginatedResourceResponse<RedirectUrl[]>>
```

## Example

<Include src="_partials/backend/usage" />

```tsx
const response = await clerkClient.redirectUrls.getRedirectUrlList()
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/redirect_urls/{id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Redirect-URLs#operation/ListRedirectURLs){{ target: '_blank' }} for more information.

---
title: '`getSamlConnection()`'
description: Use Clerk's Backend SDK to retrieve a SAML connection.
---

Retrieves a [`SamlConnection`](/docs/references/backend/types/saml-connection) by its ID.

```ts
function getSamlConnection(samlConnectionId: string): Promise<SamlConnection>
```

## `GetOrganizationParams`

<Properties>
  - `samlConnectionId`
  - `string`

  The ID of the SAML connection to retrieve.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const samlConnectionId = 'samlc_123'

const response = await clerkClient.samlConnections.getSamlConnection(samlConnectionId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/saml_connections/{saml_connection_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/SAML-Connections#operation/GetSAMLConnection){{ target: '_blank' }} for more information.

---
title: '`getSamlConnectionList()`'
description: Use Clerk's Backend SDK to retrieve the list of SAML connections for an instance.
---

Retrieves the list of SAML connections for an instance. Returns a [`PaginatedResourceResponse`](/docs/references/backend/types/paginated-resource-response) object with a `data` property that contains an array of [`SamlConnection`](/docs/references/backend/types/saml-connection) objects, and a `totalCount` property that indicates the total number of SAML connections for the instance.

```ts
function getSamlConnectionList(params: SamlConnectionListParams = {}): Promise<SamlConnection[]>
```

## `SamlConnectionListParams`

<Properties>
  - `limit?`
  - `number`

  The number of results to return. Must be an integer greater than zero and less than 501. Default: `10`

  ---

  - `offset?`
  - `number`

  The number of results to skip. Default: `0`
</Properties>

## Examples

### Basic

<Include src="_partials/backend/usage" />

```tsx
const response = await clerkClient.samlConnections.getSamlConnectionList()
```

### Limit the number of results

Retrieves organization list that is filtered by the number of results.

```tsx
const { data, totalCount } = await clerkClient.samlConnections.getSamlConnectionList({
  // returns the first 10 results
  limit: 10,
})
```

### Skip results

Retrieves organization list that is filtered by the number of results to skip.

```tsx
const { data, totalCount } = await clerkClient.samlConnections.getSamlConnectionList({
  // skips the first 10 results
  offset: 10,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/saml_connections`. See the [BAPI reference](/docs/reference/backend-api/tag/SAML-Connections#operation/ListSAMLConnections){{ target: '_blank' }} for more information.

---
title: '`getSession()`'
description: Use Clerk's Backend SDK to retrieve a single session by its ID.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/SessionApi.ts/#L26 */}

Retrieves a single [`Session`](/docs/references/backend/types/backend-session).

```ts
function getSession(sessionId: string): Promise<Session>
```

## Parameters

<Properties>
  - `sessionId`
  - `string`

  The ID of the session to retrieve.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const sessionId = 'sess_123'

const response = await clerkClient.sessions.getSession(sessionId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/sessions/{session_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Sessions#operation/GetSession){{ target: '_blank' }} for more information.

---
title: '`getSessionList()`'
description: Use Clerk's Backend SDK to retrieve a list of sessions.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/SessionApi.ts/#L18 */}

Retrieves a list of sessions. Returns a [`PaginatedResourceResponse`](/docs/references/backend/types/paginated-resource-response) object with a `data` property that contains an array of [`Session`](/docs/references/backend/types/backend-session) objects, and a `totalCount` property that indicates the total number of sessions for the specified user.

```ts
function getSessionList(
  queryParams: SessionListParams,
): Promise<PaginatedResourceResponse<Session[]>>
```

## `SessionListParams`

`getSessionList()` requires either `clientId` or `userId` to be provided.

<Properties>
  - `clientId?`
  - `string`

  The client ID to retrieve the list of sessions for.

  ---

  - `userId?`
  - `string`

  The user ID to retrieve the list of sessions for.

  ---

  - `status?`
  - [`SessionStatus`](#session-status)

  The status of the session.

  ---

  - `limit?`
  - `number`

  The number of results to return. Must be an integer greater than zero and less than 501. Can be used for paginating the results together with `offset`. Defaults to `10`.

  ---

  - `offset?`
  - `number`

  Skip the first `offset` results when paginating. Needs to be an integer greater or equal to zero. To be used in conjunction with `limit`. Defaults to `0`.
</Properties>

### `SessionStatus`

```tsx
type SessionStatus =
  | 'abandoned'
  | 'active'
  | 'ended'
  | 'expired'
  | 'removed'
  | 'replaced'
  | 'revoked'
```

| Value | Description |
| - | - |
| `abandoned` | The session was abandoned client-side. |
| `active` | The session is valid and all activity is allowed. |
| `ended` | The user signed out of the session, but the `Session` remains in the `Client` object. |
| `expired` | The period of allowed activity for this session has passed. |
| `removed` | The user signed out of the session and the `Session` was removed from the `Client` object. |
| `replaced` | The session has been replaced by another one, but the `Session` remains in the `Client` object. |
| `revoked` | The application ended the session and the `Session` was removed from the `Client` object. |

## Examples

<Include src="_partials/backend/usage" />

Retrieve a list of sessions for a specific `userId`:

```tsx
const userId = 'user_123'

const response = await clerkClient.sessions.getSessionList({ userId })
```

### Filter by session status

In this example, a list of sessions with a `status` of `'expired'` is retrieved. You can see that the returned [`PaginatedResourceResponse`](/docs/references/backend/types/paginated-resource-response) includes `data`, which is an array of [`Session`](/docs/references/backend/types/backend-session) objects, and `totalCount`, which indicates the total number of sessions for the specified user.

```tsx {{ mark: [3, 15] }}
const userId = 'user_123'

const status = 'expired'

const response = await clerkClient.sessions.getSessionList({ userId, status })
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/sessions`. See the [BAPI reference](/docs/reference/backend-api/tag/Sessions){{ target: '_blank' }} for more information.

---
title: '`getToken()`'
description: Use Clerk's iOS SDK to retrieve a token for a JWT template that is defined in the Clerk Dashboard.
---

The `getToken()` method retrieves the user's [session token](/docs/backend-requests/resources/session-tokens) or a [custom JWT template](/docs/backend-requests/jwt-templates).

This method uses a cache so a network request will only be made if the token in memory has expired. The TTL for a Clerk token is one minute.

Tokens can only be generated if the user is signed in.

```swift {{ filename: 'Session' }}
func getToken(
  _ options: GetTokenOptions = .init()
) async throws -> TokenResource?
```

## Parameters

<Properties>
  - `options`
  - [`GetTokenOptions`](#get-token-options)

  Options that can be passed as parameters to the `getToken()` function.
</Properties>

### `GetTokenOptions`

<Properties>
  - `template`
  - `String?`

  The name of the JWT template from the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=jwt-templates) to generate a new token from. For example: 'firebase', 'grafbase', or your custom template's name.

  ---

  - `expirationBuffer`
  - `Double`

  If the cached token will expire within `{expirationBuffer}` seconds, fetch a new token instead. Max is 60 seconds. Defaults to 10 seconds.

  ---

  - `skipCache`
  - `Bool`

  Whether to skip the cache lookup and force a refresh of the token instead. Useful if the token claims are time-sensitive or depend on data that can be updated (e.g. user fields). Defaults to false.
</Properties>

## Example

```swift
let session = Clerk.shared.session

if let token = try await session?.getToken()?.jwt { // => "eyJhbGciOiJSUzI1NiIsImtpZC..."
  headers["Authorization"] = "Bearer \(token)"
}
```

---
title: '`getToken()`'
description: Use Clerk's Backend SDK to retrieve a token for a JWT template that is defined in the Clerk Dashboard.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/SessionApi.ts/#L51 */}

Retrieves a token for a JWT Template that is defined on the [**JWT templates**](https://dashboard.clerk.com/last-active?path=jwt-templates) page in the Clerk Dashboard.

```ts
function getToken(sessionId: string, template: string): Promise<Token>
```

## Parameters

<Properties>
  - `sessionId`
  - `string`

  The ID of the session to retrieve a token for.

  ---

  - `template`
  - `string`

  The name of the JWT template from the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=jwt-templates) to generate a new token from. For example: 'firebase', 'grafbase', or your custom template's name.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```js
const sessionId = 'sess_123'

const template = 'test'

const response = await clerkClient.sessions.getToken(sessionId, template)
```

## Examples with frameworks

The following examples demonstrate how to use `getToken()` with different frameworks. Each example performs the following steps:

1. Gets the current session ID using framework-specific auth helpers.
1. Checks if there's an active session.
1. Uses the Backend SDK's `getToken()` method to generate a token from a template.
1. Returns the token in the response.

The token resembles the following:

```
{
  jwt: 'eyJhbG...'
}
```

> [!NOTE]
> For these examples to work, you must have a JWT template named "test" in the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=jwt-templates) before running the code.

<Tabs items={["Next.js", "Express", "Remix"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```js {{ filename: 'app/api/get-token-example/route.ts' }}
      import { auth, clerkClient } from '@clerk/nextjs/server'

      export async function GET() {
        const { sessionId } = await auth()

        if (!sessionId) {
          return Response.json({ message: 'Unauthorized' }, { status: 401 })
        }

        const template = 'test'
        const client = await clerkClient()
        const token = await client.sessions.getToken(sessionId, template)

        return Response.json({ token })
      }
      ```

      ```ts {{ filename: 'pages/api/getToken.ts' }}
      import { clerkClient, getAuth } from '@clerk/nextjs/server'
      import type { NextApiRequest, NextApiResponse } from 'next'

      export default async function handler(req: NextApiRequest, res: NextApiResponse) {
        const { sessionId } = getAuth(req)

        if (!sessionId) {
          return res.status(401).json({ error: 'Unauthorized' })
        }

        const template = 'test'
        const client = await clerkClient()
        const token = await client.sessions.getToken(sessionId, template)

        return res.json({ token })
      }
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    ```js {{ filename: 'getToken.ts' }}
    import { clerkClient } from '@clerk/express'

    app.get('/api/get-token', async (req, res) => {
      const sessionId = req.auth.sessionId

      if (!sessionId) {
        res.status(401).json({ error: 'Unauthorized' })
        return
      }

      const template = 'test'
      const token = await clerkClient.sessions.getToken(sessionId, template)

      res.json({ token })
    })
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'app/routes/get-token.ts' }}
    import { createClerkClient } from '@clerk/remix/api.server'
    import { getAuth } from '@clerk/remix/ssr.server'
    import { ActionFunction, json } from '@remix-run/node'

    export const action: ActionFunction = async (req) => {
      const { sessionId } = await getAuth(req)

      const template = 'test'

      const token = await createClerkClient({
        secretKey: process.env.CLERK_SECRET_KEY,
      }).sessions.getToken(sessionId, template)

      return json({ token })
    }
    ```
  </Tab>
</Tabs>

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/sessions/{session_id}/tokens/{template_name}`. See the [BAPI reference](/docs/reference/backend-api/tag/Sessions#operation/CreateSessionTokenFromTemplate){{ target: '_blank' }} for more information.

---
title: '`getUser()`'
description: Use Clerk's Backend SDK to retrieve a single user by their ID.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L132 */}

Retrieves a single [`User`](/docs/references/backend/types/backend-user) by their ID, if the ID is valid.

```ts
function getUser(userId: string): Promise<User>
```

## Parameters

<Properties>
  - `userId`
  - `string`

  The ID of the user to retrieve.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const userId = 'user_123'

const response = await clerkClient.users.getUser(userId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/users/{user_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/GetUser){{ target: '_blank' }} for more information.

---
title: '`getUserList()`'
description: Use Clerk's Backend SDK to retrieve a list of users.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L116 */}

Retrieves a list of users. Returns a [`PaginatedResourceResponse`](/docs/references/backend/types/paginated-resource-response) object with a `data` property that contains an array of [`User`](/docs/references/backend/types/backend-user) objects, and a `totalCount` property that indicates the total number of users for the application.

```tsx
function getUserList(): (params: UserListParams) => Promise<PaginatedResourceResponse<User[]>>
```

## `UserListParams`

<Properties>
  - `limit?`
  - `number`

  The number of results to return. Must be an integer greater than zero and less than 501. Can be used for paginating the results together with `offset`. Defaults to `10`.

  ---

  - `offset?`
  - `number`

  Skip the first `offset` results when paginating. Needs to be an integer greater or equal to zero. To be used in conjunction with `limit`. Defaults to `0`.

  ---

  - `orderBy?`
  - `'created_at' | 'updated_at' | 'email_address' | 'web3wallet' | 'first_name' | 'last_name' | 'phone_number' | 'username' | 'last_active_at' | 'last_sign_in_at'`

  Return users in a particular order. Prefix with a `-` to reverse the order. Prefix with a `+` to list in ascending order. Defaults to `'-created_at'`.

  ---

  - `emailAddress?`
  - `string[]`

  Filters users with the specified email addresses. Accepts up to 100 email addresses. Any email addresses not found are ignored.

  ---

  - `phoneNumber?`
  - `string[]`

  Filters users with the specified phone numbers. Accepts up to 100 phone numbers. Any phone numbers not found are ignored.

  ---

  - `externalId?`
  - `string[]`

  Filters users with the specified external IDs. For each external ID, the `+` and `-` can be prepended to the ID, which denote whether the respective external ID should be included or excluded from the result set. Accepts up to 100 external IDs. Any external IDs not found are ignored.

  ---

  - `username?`
  - `string[]`

  Filters users with the specified usernames. Accepts up to 100 usernames. Any usernames not found are ignored.

  ---

  - `web3Wallet?`
  - `string[]`

  Filters users with the specified Web3 wallet addresses. Accepts up to 100 Web3 wallet addresses. Any Web3 wallet addressed not found are ignored.

  ---

  - `userId?`
  - `string[]`

  Filters users with the user IDs specified. For each user ID, the `+` and `-` can be prepended to the ID, which denote whether the respective user ID should be included or excluded from the result set. Accepts up to 100 user IDs. Any user IDs not found are ignored.

  ---

  - `organizationId?`
  - `string[]`

  Filters users that have memberships to the given organizations. For each organization ID, the `+` and `-` can be prepended to the ID, which denote whether the respective organization should be included or excluded from the result set. Accepts up to 100 organization IDs.

  ---

  - `query?`
  - `string`

  Filters users that match the given query. For possible matches, we check the email addresses, phone numbers, usernames, Web3 wallet addresses, user IDs, first and last names. The query value doesn't need to match the exact value you are looking for, it is capable of partial matches as well.

  ---

  - `last_active_at_since`
  - `number`

  Filters users that had session activity since the given date, with day precision. Providing a value with higher precision than day will result in an error. Example: use `1700690400000` to retrieve users that had session activity from 2023-11-23 until the current day. For example: `1700690400000`.
</Properties>

## Examples

### Basic

<Include src="_partials/backend/usage" />

```tsx
const response = await clerkClient.users.getUserList()
```

### Limit the number of results

Retrieves user list that is ordered and filtered by the number of results.

```tsx
const { data, totalCount } = await clerkClient.users.getUserList({
  orderBy: '-created_at',
  limit: 10,
})
```

### Filter by email addresses and phone numbers

Retrieves user list that is filtered by the given email addresses and phone numbers.

```tsx
const emailAddress = ['email1@clerk.dev', 'email2@clerk.dev']

const phoneNumber = ['+12025550108']

// If these filters are included, the response will contain only users that own any of these emails and/or phone numbers.
const { data, totalCount } = await clerkClient.users.getUserList({ emailAddress, phoneNumber })
```

### Filter by query

To do a broader match through a list of fields, you can use the query parameter which partially matches the fields: `userId`, `emailAddress`, `phoneNumber`, `username`, `web3Wallet`, `firstName` and `lastName`.

```tsx
// Matches users with the string `test` matched in multiple user attributes.
const { data, totalCount } = await clerkClient.users.getUserList({
  query: 'test',
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/users`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/GetUserList){{ target: '_blank' }} for more information.

---
title: '`Layout` prop'
description: Utilize Clerk's layout prop in order to change the layout of the <SignIn /> and <SignUp /> components, as well as set important links to your support, terms and privacy pages.
---

{/* JS file: https://github.com/clerk/javascript/blob/main/packages/types/src/appearance.ts#L538 */}

The `layout` property can be used to change the layout of the [`<SignIn/>`](/docs/components/authentication/sign-in) and [`<SignUp/>`](/docs/components/authentication/sign-up) components, as well as set important links to your support, terms, and privacy pages.

## Properties

<Properties>
  - `animations`
  - `boolean`

  Whether to enable animations inside the components. Defaults to `true`.

  ---

  - `helpPageUrl`
  - `string`

  The URL to your help page.

  ---

  - `logoImageUrl`
  - `string`

  The URL to your logo image. By default, the components will use the logo you've set in the Clerk Dashboard. This option is helpful when you need to display different logos for different themes, for example: white logo on dark themes, black logo on light themes.

  ---

  - `logoLinkUrl`
  - `string`

  Controls where the browser will redirect to after the user clicks the application logo. If a URL is provided, it will be used as the `href` of the link. If a value is not passed in, the components will use the Home URL as set in the Clerk Dashboard. Defaults to `undefined`.

  ---

  - `logoPlacement`
  - `'inside' | 'outside'`

  The placement of your logo. Defaults to `'inside'`.

  ---

  - `privacyPageUrl`
  - `string`

  The URL to your privacy page.

  ---

  - `shimmer`
  - `boolean`

  This option enables the shimmer animation for the avatars of `<UserButton />` and `<OrganizationSwitcher />`. Defaults to `true`.

  ---

  - `showOptionalFields`
  - `boolean`

  Whether to show optional fields on the sign in and sign up forms. Defaults to `true`.

  ---

  - `socialButtonsPlacement`
  - `'bottom' | 'top'`

  The placement of your social buttons. Defaults to `'top'`.

  ---

  - `socialButtonsVariant`
  - `'blockButton' | 'iconButton' | 'auto'`

  The variant of your social buttons. By default, the components will use `blockButton` if you have less than 3 social providers enabled, otherwise `iconButton` will be used.

  ---

  - `termsPageUrl`
  - `string`

  The URL to your terms page.

  ---

  - `unsafe_disableDevelopmentModeWarnings`
  - `boolean`

  Whether development warnings show up in development mode. **Only enable this if you want to preview how the components will look in production.**
</Properties>

## Usage

<Tabs items={["Next.js", "Astro", "Vue", "Nuxt"]}>
  <Tab>
    ```tsx {{ prettier: false, filename: 'app.tsx' }}
    import { ClerkProvider } from '@clerk/nextjs';

    <ClerkProvider
      appearance={{
        layout: {
          socialButtonsPlacement: 'bottom',
          socialButtonsVariant: 'iconButton',
          termsPageUrl: 'https://clerk.com/terms'
        }
      }}
    >
      {/* ... */}
    </ClerkProvider>;
    ```
  </Tab>

  <Tab>
    ```js {{ filename: 'astro.config.mjs' }}
    import clerk from '@clerk/astro'

    export default defineConfig({
      integrations: [
        clerk({
          appearance: {
            layout: {
              socialButtonsPlacement: 'bottom',
              socialButtonsVariant: 'iconButton',
              termsPageUrl: 'https://clerk.com/terms',
            },
          },
        }),
      ],
    })
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'src/main.ts' }}
    import { createApp } from 'vue'
    import App from './App.vue'
    import { clerkPlugin } from '@clerk/vue'

    const app = createApp(App)
    app.use(clerkPlugin, {
      appearance: {
        layout: {
          socialButtonsPlacement: 'bottom',
          socialButtonsVariant: 'iconButton',
          termsPageUrl: 'https://clerk.com/terms',
        },
      },
    })
    app.mount('#app')
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'nuxt.config.ts' }}
    export default defineNuxtConfig({
      modules: ['@clerk/nuxt'],
      clerk: {
        appearance: {
          layout: {
            socialButtonsPlacement: 'bottom',
            socialButtonsVariant: 'iconButton',
            termsPageUrl: 'https://clerk.com/terms',
          },
        },
      },
    })
    ```
  </Tab>
</Tabs>

---
title: '`lockUser()`'
description: Use Clerk's Backend SDK to mark a user as locked, which means they are not allowed to sign in again until the lock expires.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L263 */}

Marks the given [`User`](/docs/references/backend/types/backend-user) as locked, which means they are not allowed to sign in again until the lock expires.

By default, lockout duration is 1 hour, but it can be configured in the application's [**Attack protection**](https://dashboard.clerk.com/last-active?path=user-authentication/attack-protection) settings. For more information, see the [dedicated guide for customizing **Attack protection** settings](/docs/security/customize-user-lockout).

```ts
function lockUser(userId: string): Promise<User>
```

## Parameters

<Properties>
  - `userId`
  - `string`

  The ID of the user to lockout.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const userId = 'user_123'

const response = await clerkClient.users.lockUser(userId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/users/{user_id}/lock`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/LockUser){{ target: '_blank' }} for more information.

---
title: '`Organization` object'
description: The Organization object holds information about an organization, as well as methods for managing it.
---

The `Organization` object holds information about an organization, as well as methods for managing it.

To use these methods, you must have the **Organizations** feature [enabled in your app's settings in the Clerk Dashboard](/docs/organizations/overview#enable-organizations-in-your-application).

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier of the related organization.

  ---

  - `name`
  - `string`

  The name of the related organization.

  ---

  - `slug`
  - `string | null`

  The organization slug. If supplied, it must be unique for the instance.

  ---

  - `imageUrl`
  - `string`

  Holds the organization logo or default logo. Compatible with Clerk's [Image Optimization](/docs/guides/image-optimization).

  ---

  - `hasImage`
  - `boolean`

  A getter boolean to check if the organization has an uploaded image. Returns `false` if Clerk is displaying an avatar for the organization.

  ---

  - `membersCount`
  - `number`

  The number of members the associated organization contains.

  ---

  - `pendingInvitationsCount`
  - `number`

  The number of pending invitations to users to join the organization.

  ---

  - `adminDeleteEnabled`
  - `boolean`

  A getter boolean to check if the admin of the organization can delete it.

  ---

  - `maxAllowedMemberships`
  - `number`

  The maximum number of memberships allowed for the organization.

  ---

  - `createdAt`
  - `Date`

  The date when the organization was created.

  ---

  - `updatedAt`
  - `Date`

  The date when the organization was last updated.

  ---

  - `publicMetadata`
  - [`OrganizationPublicMetadata`](/docs/references/javascript/types/metadata#organization-public-metadata)

  Metadata that can be read from the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }} and can be set only from the Backend API.
</Properties>

## Methods

### `addMember()`

Adds a user as a member to an organization. A user can only be added to an organization if they are not already a member of it and if they already exist in the same instance as the organization. Only administrators can add members to an organization.

Returns an [`OrganizationMembership`][org-mem-ref] object.

```typescript
function addMember(params: AddMemberParams): Promise<OrganizationMembership>
```

#### `AddMemberParams`

<Properties>
  - `userId`
  - `string`

  The ID of the user to be added as a member to the organization.

  ---

  - `role`
  - `string`

  The [role][roles-perms-ref] that the user will have in the organization.
</Properties>

#### Example

```js
await organization.addMember({ userId: 'user_123', role: 'org:admin' })
```

### `createDomain()`

Creates a new domain for the currently active organization. Returns an [`OrganizationDomain`][org-domain-ref] object.

> [!WARNING]
> You must have [**Verified domains**][verified-domains-ref] enabled in your app's settings in the Clerk Dashboard.

```ts
function createDomain(domainName: string): Promise<OrganizationDomainResource>
```

#### Parameters

<Properties>
  - `domainName`
  - `string`

  The domain name that will be added to the organization.
</Properties>

#### Example

```js
await clerk.organization.createDomain('test-domain.com')
```

### `destroy()`

Deletes the organization. Only administrators can delete an organization.

Deleting an organization will also delete all memberships and invitations. **This is not reversible.**

```typescript
function destroy(): Promise<void>
```

#### Example

```js
await clerk.organization.destroy()
```

### `getDomain()`

Retrieves a domain for an organization based on the given domain ID. Returns an [`OrganizationDomain`][org-domain-ref] object.

> [!WARNING]
> You must have [**Verified domains**][verified-domains-ref] enabled in your app's settings in the Clerk Dashboard.

```typescript
function getDomain(params: GetDomainParams): Promise<OrganizationDomain>
```

#### `GetDomainParams`

<Properties>
  - `domainId`
  - string

  The ID of the domain that will be fetched.
</Properties>

#### Example

```js
await clerk.organization.getDomain({ domainId: 'domain_123' })
```

### `getDomains()`

Retrieves the list of domains for the currently active organization. Returns a [`ClerkPaginatedResponse`][pag-ref] of [`OrganizationDomain`][org-domain-ref] objects.

> [!WARNING]
> You must have [**Verified domains**][verified-domains-ref] enabled in your app's settings in the Clerk Dashboard.

```typescript
function getDomains(params?: GetDomainsParams): Promise<ClerkPaginatedResponse<OrganizationDomain>>
```

#### `GetDomainsParams`

<Properties>
  - `initialPage?`
  - `number`

  A number that can be used to skip the first n-1 pages. For example, if `initialPage` is set to 10, it is will skip the first 9 pages and will fetch the 10th page.

  ---

  - `pageSize?`
  - `number`

  A number that indicates the maximum number of results that should be returned for a specific page.

  ---

  - `enrollmentMode?`
  - `'manual_invitation' | 'automatic_invitation' | 'automatic_suggestion'`

  An [enrollment mode](/docs/organizations/verified-domains#enrollment-mode) will change how new users join an organization.
</Properties>

#### Example

```js
await clerk.organization.getDomains()
```

### `getInvitations()`

Retrieves the list of invitations for the currently active organization. Returns a [`ClerkPaginatedResponse`][pag-ref] of [`OrganizationInvitation`][org-inv-ref] objects.

```typescript
function getInvitations(
  params?: GetInvitationsParams,
): Promise<ClerkPaginatedResponse<OrganizationInvitation>>
```

#### `GetInvitationsParams`

<Properties>
  - `initialPage?`
  - `number`

  A number that can be used to skip the first n-1 pages. For example, if `initialPage` is set to 10, it is will skip the first 9 pages and will fetch the 10th page.

  ---

  - `pageSize?`
  - `number`

  A number that indicates the maximum number of results that should be returned for a specific page.

  ---

  - `status?`
  - `'pending' | 'accepted' | 'revoked'`

  The status an invitation can have.
</Properties>

#### Example

```js
await clerk.organization.getInvitations()
```

### `getMemberships()`

Retrieves the list of memberships for the currently active organization. Returns a [`ClerkPaginatedResponse`][pag-ref] of [`OrganizationMembership`][org-mem-ref] objects.

```typescript
function getMemberships(
  params?: GetMembersParams,
): Promise<ClerkPaginatedResponse<OrganizationMembership>>
```

#### `GetMembersParams`

<Properties>
  - `initialPage?`
  - `number`

  A number that can be used to skip the first n-1 pages. For example, if `initialPage` is set to 10, it is will skip the first 9 pages and will fetch the 10th page.

  ---

  - `pageSize?`
  - `number`

  A number that indicates the maximum number of results that should be returned for a specific page.

  ---

  - `role?`
  - <code>[OrganizationCustomRoleKey](/docs/references/javascript/types/organization-custom-role-key)\[]</code>

  The [roles][roles-perms-ref] of memberships that will be included in the response.
</Properties>

#### Example

For an example on how to use `getMemberships()`, see the [custom flow on managing organization roles](/docs/custom-flows/manage-roles).

### `getMembershipRequests()`

Retrieve the list of membership requests for the currently active organization. Returns a [`ClerkPaginatedResponse`][pag-ref] of [`OrganizationMembershipRequest`][org-mem-ref]-request) objects.

> [!WARNING]
> You must have [**Organizations**](/docs/organizations/overview#enable-organizations-in-your-application), and [**Verified domains** and **Automatic suggestion**][verified-domains-ref] enabled in your app's settings in the Clerk Dashboard.

```ts
function getMembershipRequests(
  params?: GetMembershipRequestParams,
): Promise<ClerkPaginatedResponse<OrganizationMembershipRequestResource>>
```

#### `GetMembershipRequestParams`

<Properties>
  - `initialPage?`
  - `number`

  A number that can be used to skip the first n-1 pages. For example, if `initialPage` is set to 10, it is will skip the first 9 pages and will fetch the 10th page.

  ---

  - `pageSize?`
  - `number`

  A number that indicates the maximum number of results that should be returned for a specific page.

  ---

  - `status?`
  - `string`

  The status of the membership requests that will be included in the response.
</Properties>

#### Example

For an example on how to use `getMembershipRequests()`, see the [custom flow guide on managing membership requests](/docs/custom-flows/manage-membership-requests).

### `getRoles()`

Returns a paginated list of roles in the organization. Returns a [`ClerkPaginatedResponse`][pag-ref] of [`RoleResource`](/docs/references/javascript/types/role) objects.

```ts
function getRoles(params?: GetRolesParams): Promise<ClerkPaginatedResponse<RoleResource>>
```

#### `GetRolesParams`

<Properties>
  - `initialPage?`
  - `number`

  A number that can be used to skip the first n-1 pages. For example, if `initialPage` is set to 10, it is will skip the first 9 pages and will fetch the 10th page.

  ---

  - `pageSize?`
  - `number`

  A number that indicates the maximum number of results that should be returned for a specific page.
</Properties>

#### Example

```js
await clerk.organization.getRoles()
```

### `inviteMember()`

Creates and sends an invitation to the target email address for becoming a member with the role passed on the function parameters. Returns an [`OrganizationInvitation`][org-inv-ref] object.

```typescript
function inviteMember(params: InviteMemberParams): Promise<OrganizationInvitation>
```

#### `InviteMemberParams`

<Properties>
  - `emailAddress`
  - `string`

  The email address to invite.

  ---

  - `role`
  - `string`

  The [role][roles-perms-ref] of the new member.
</Properties>

#### Example

```js
await clerk.organization.inviteMember({ emailAddress: 'test@test.com', role: 'org:member' })
```

### `inviteMembers()`

Creates and sends an invitation to the target email addresses for becoming a member with the role passed in the parameters. Returns an array of [`OrganizationInvitation`][org-inv-ref] objects.

```typescript
function inviteMembers(params: InviteMembersParams): Promise<OrganizationInvitation[]>
```

#### `InviteMembersParams`

<Properties>
  - `emailAddresses`
  - `string[]`

  The email addresses to invite.

  ---

  - `role`
  - `string`

  The [role][roles-perms-ref] of the new members.
</Properties>

#### Example

```js
await clerk.organization.inviteMembers({
  emailAddresses: ['test@test.com', 'test2@test.com'],
  role: 'org:member',
})
```

### `removeMember()`

Removes a member from the organization based on the `userId`. Returns an [`OrganizationMembership`][org-mem-ref] object.

```typescript
function removeMember(userId: string): Promise<OrganizationMembership>
```

#### Parameters

<Properties>
  - `userId`
  - `string`

  The ID of the user to remove from the organization.
</Properties>

#### Example

```js
await organization.removeMember('user_123')
```

### `setLogo()`

Sets or replaces an organization's logo. The logo must be an image and its size cannot exceed 10MB. Returns an `Organization` object.

```typescript
function setLogo(params: SetOrganizationLogoParams): Promise<Organization>
```

#### `SetOrganizationLogoParams`

<Properties>
  - `file`
  - `File | Blob | null`

  An image file or blob which cannot exceed 10MB. Passing `null` will delete the organization's current logo.
</Properties>

#### Example

```js
await clerk.organization.setLogo({ file })
```

### `update()`

Updates an organization's attributes. Returns an `Organization` object.

```typescript
function update(params: UpdateOrganizationParams): Promise<Organization>
```

#### `UpdateOrganizationParams`

<Properties>
  - `name`
  - `string`

  The organization name.

  ---

  - `slug?`
  - `string | undefined`

  The organization slug.

  ---

  - `maxAllowedMemberships?`
  - `number | undefined`

  The maximum number of memberships allowed for the organization.

  ---

  - `publicMetadata?`
  - [`OrganizationPublicMetadata`](/docs/references/javascript/types/metadata#organization-public-metadata)

  Metadata that can be read from both the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }}, but can be set only from the Backend API.

  ---

  - `privateMetadata?`
  - [`OrganizationPrivateMetadata`](/docs/references/javascript/types/metadata#organization-private-metadata)

  Metadata that is only visible to your [Backend API](/docs/reference/backend-api){{ target: '_blank' }}.
</Properties>

#### Example

```js
await clerk.organization.update({ name: 'New Name' })
```

### `updateMember()`

Updates a member. Currently, only a user's role can be updated. Returns an [`OrganizationMembership`][org-mem-ref] object.

```typescript
function updateMember(params: UpdateMembershipParams): Promise<OrganizationMembership>
```

#### `UpdateMembershipParams`

<Properties>
  - `userId`
  - `string`

  The ID of the user to update.

  ---

  - `role`
  - `string`

  The [role][roles-perms-ref] of the new member.
</Properties>

#### Example

```js
await organization.updateMember({ userId: 'user_123', role: 'org:admin' })
```

[org-domain-ref]: /docs/references/javascript/types/organization-domain

[org-inv-ref]: /docs/references/javascript/types/organization-invitation

[org-mem-ref]: /docs/references/javascript/types/organization-membership

[roles-perms-ref]: /docs/organizations/roles-permissions

[pag-ref]: /docs/references/javascript/types/clerk-paginated-response

[verified-domains-ref]: /docs/organizations/verified-domains

---
title: '`OrganizationCustomPermissionKey`'
description: A type that represents a user's permission in an organization.
---

`OrganizationCustomPermissionKey` is a type that represents a user's permission in an organization. It will be string unless the developer has provided their own types through [`ClerkAuthorization`](/docs/guides/custom-types#example-custom-roles-and-permissions).

Clerk provides [default system permissions](/docs/organizations/roles-permissions#system-permissions). However, you can create [custom permissions](/docs/organizations/create-roles-permissions#create-a-new-permission-for-your-organization) as well.

---
title: '`OrganizationCustomRoleKey`'
description: A type that represents the user's role in an organization.
---

`OrganizationCustomRoleKey` is a type that represents the user's role in an organization. It will be string unless the developer has provided their own types through [`ClerkAuthorization`](/docs/guides/custom-types#example-custom-roles-and-permissions).

Clerk provides the [default roles](/docs/organizations/roles-permissions#default-roles) `org:admin` and `org:member`. However, you can create [custom roles](/docs/organizations/create-roles-permissions) as well.

---
title: '`OrganizationDomain`'
description: The OrganizationDomain object is the model around an organization domain.
---

The `OrganizationDomain` object is the model around an organization domain.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for this organization domain.

  ---

  - `name`
  - `string`

  The name for this organization domain (e.g. example.com).

  ---

  - `organizationId`
  - `string`

  The organization ID of the organization this domain is for.

  ---

  - `enrollmentMode`
  - `'manual_invitation' | 'automatic_invitation' | 'automatic_suggestion'`

  An [enrollment mode](/docs/organizations/verified-domains#enrollment-mode) will change how new users join an organization.

  ---

  - `verification`
  - [`OrganizationDomainVerification`](#organization-domain-verification)

  The object that describes the status of the verification process of the domain.

  ---

  - `affiliationEmailAddress`
  - `string | null`

  The email address that was used to verify this organization domain.

  ---

  - `totalPendingInvitations`
  - `number`

  The number of total pending invitations sent to emails that match the domain name.

  ---

  - `totalPendingSuggestions`
  - `number`

  The number of total pending suggestions sent to emails that match the domain name.

  ---

  - `createdAt`
  - `Date`

  The date when the organization domain was created.

  ---

  - `updatedAt`
  - `Date`

  The date when the organization domain was last updated.
</Properties>

### `OrganizationDomainVerification`

<Properties>
  - `status`
  - `'unverified' | 'verified'`

  The status of the verification process.

  ---

  - `strategy`
  - `'email_code'`

  A string that indicates strategy of the verification.

  ---

  - `attempts`
  - `number`

  A number that indicates how many attempts have occurred in order to verify the domain.

  ---

  - `expiresAt`
  - `Date`

  The expiration date and time of the verification.
</Properties>

## Methods

## `delete()`

Deletes the organization domain and removes it from the organization.

```ts {{ prettier: false }}
function delete(): Promise<void>
```

## `prepareAffiliationVerification()`

Begins the verification process of a created organization domain. This is a required step in order to complete the registration of the domain under the organization.

```typescript
function prepareAffiliationVerification(
  params: PrepareAffiliationVerificationParams,
): Promise<OrganizationDomain>
```

### `PrepareAffiliationVerificationParams`

<Properties>
  - `affiliationEmailAddress`
  - `string`

  An email address that is affiliated with the domain name (e.g. [user@example.com](mailto:user@example.com)).
</Properties>

## `attemptAffiliationVerification()`

Attempts to complete the domain verification process. This is a required step in order to complete the registration of a domain under an organization, as the administrator should be verified as a person who is affiliated with that domain.

Make sure that an `OrganizationDomain` object already exists before you call this method, by first calling [`OrganizationDomain.prepareAffiliationVerification`](#prepare-affiliation-verification).

```typescript
function attemptAffiliationVerification(
  params: AttemptAffiliationVerificationParams,
): Promise<OrganizationDomain>
```

### `AttemptAffiliationVerificationParams`

<Properties>
  - `code`
  - `string`

  The one-time code that was sent to the user as part of this verification step.
</Properties>

---
title: '`OrganizationInvitation`'
description: The OrganizationInvitation object is the model around an organization invitation.
---

The `OrganizationInvitation` object is the model around an organization invitation.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for this organization invitation.

  ---

  - `emailAddress`
  - `string`

  The email address the invitation has been sent.

  ---

  - `organizationId`
  - `string`

  The organization ID of the organization this invitation is for.

  ---

  - `publicMetadata`
  - [`OrganizationInvitationPublicMetadata`](/docs/references/javascript/types/metadata#organization-invitation-public-metadata)

  Metadata that can be read from the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }} and can be set only from the Backend API.

  ---

  - `role`
  - [`OrganizationCustomRoleKey`](/docs/references/javascript/types/organization-custom-role-key)

  The [role](/docs/organizations/roles-permissions) of the current user in the organization.

  ---

  - `status`
  - `'pending' | 'accepted' | 'revoked'`

  The status of the invitation.

  ---

  - `createdAt`
  - `Date`

  The date when the invitation was created.

  ---

  - `updatedAt`
  - `Date`

  The date when the invitation was last updated.
</Properties>

## Methods

### `revoke()`

Revokes the invitation for the email it corresponds to.

```typescript
function revoke(): Promise<OrganizationInvitation>
```

### Example

The following example demonstrates how to revoke an organization invitation. It first gets the list of organization invitations using [`getInvitations()`](/docs/references/javascript/organization#get-invitations) and then revokes the first invitation in the list.

It assumes:

- you have followed the [quickstart](/docs/quickstarts/javascript) in order to add Clerk to your JavaScript application
- you have [enabled the Organizations feature in the Clerk Dashboard](/docs/organizations/overview#enable-organizations-in-your-application)

  ```js {{ filename: 'main.js', mark: [22, 23] }}
  import { Clerk } from '@clerk/clerk-js'

  const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(pubKey)
  await clerk.load()

  if (clerk.user) {
    // Check for an active organization
    if (clerk.organization) {
      // Get list of organization invitations
      const { totalCount, data } = await clerk.organization.getInvitations()

      const invitations = data
      console.log(`Invitations:`, invitations)

      if (invitations.length === 0) {
        console.log('No invitations to revoke.')
      }

      // Revoke the first invitation in the list
      invitations[0]
        .revoke()
        .then((res) => console.log(res))
        .catch((error) => console.log(error.errors))
    } else {
      // If there is no active organization,
      // mount Clerk's <OrganizationSwitcher />
      // to allow the user to set an organization as active
      document.getElementById('app').innerHTML = `
        <h2>Select an organization to set it as active</h2>
        <div id="org-switcher"></div>
      `

      const orgSwitcherDiv = document.getElementById('org-switcher')

      clerk.mountOrganizationSwitcher(orgSwitcherDiv)
    }
  } else {
    document.getElementById('app').innerHTML = `
      <div id="sign-in"></div>
    `

    const signInDiv = document.getElementById('sign-in')

    clerk.mountSignIn(signInDiv)
  }
  ```

---
title: '`OrganizationMembership`'
description: The OrganizationMembership object is the model around an organization membership entity and describes the relationship between users and organizations.
---

The `OrganizationMembership` object is the model around an organization membership entity and describes the relationship between users and organizations.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for this organization membership.

  ---

  - `publicMetadata`
  - [`OrganizationMembershipPublicMetadata`](/docs/references/javascript/types/metadata#organization-membership-public-metadata)

  Metadata that can be read from the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }} and can be set only from the Backend API.

  ---

  - `role`
  - `string`

  The [role](/docs/organizations/roles-permissions) of the current user in the organization.

  ---

  - `publicUserData`
  - [`PublicUserData`](/docs/references/javascript/types/public-user-data)

  Public information about the user that this membership belongs to.

  ---

  - `organization`
  - [`Organization`](/docs/references/javascript/organization)

  The [`Organization`](/docs/references/javascript/organization) object the membership belongs to.

  ---

  - `createdAt`
  - `Date`

  The date when the membership was created.

  ---

  - `updatedAt`
  - `Date`

  The date when the membership was last updated.
</Properties>

## Methods

### `destroy()`

Deletes the membership from the organization it belongs to.

```typescript
function destroy(): Promise<OrganizationMembership>
```

### `update()`

Updates the member's role.

```typescript
function update(updateParams: UpdateOrganizationMembershipParams): Promise<OrganizationMembership>
```

#### `UpdateOrganizationMembershipParams`

<Properties>
  - `role`
  - `string`

  The [role](/docs/organizations/roles-permissions) of the new member.
</Properties>

---
title: '`OrganizationMembershipRequest`'
description: The OrganizationMembershipRequest object is the model that describes the request of a user to join an organization.
---

The `OrganizationMembershipRequest` object is the model that describes the request of a user to join an organization.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for this membership request.

  ---

  - `organizationId`
  - `string`

  The organization ID of the organization this request is for.

  ---

  - `status`
  - `'pending' | 'accepted' | 'revoked'`

  The status of the request.

  ---

  - `publicUserData`
  - [`PublicUserData`](/docs/references/javascript/types/public-user-data)

  Public information about the user that this request belongs to.

  ---

  - `createdAt`
  - `Date`

  The date when the membership request was created.

  ---

  - `updatedAt`
  - `Date`

  The date when the membership request was last updated.
</Properties>

## Methods

## `accept()`

Accepts the request of a user to join the organization the request refers to.

```typescript
function accept(): Promise<OrganizationMembershipRequest>
```

## `reject()`

Rejects the request of a user to join the organization the request refers to.

```typescript
function reject(): Promise<OrganizationMembershipRequest>
```

---
title: '`PaginatedResourceResponse`'
description: An interface that describes the response of a method that returns a paginated list of resources.
---

An interface that describes the response of a method that returns a paginated list of resources.

## Properties

<Properties>
  - `data`
  - `T[]`

  An array that contains the fetched data.

  ---

  - `totalCount`
  - `number`

  The total count of data that exist remotely.
</Properties>

## Returns

If the promise resolves, you will get back the [properties](#properties) listed above. `data` will be an array of the resource type you requested. You can use the `totalCount` property to determine how many total items exist remotely.

Some methods that return this type allow pagination with the `limit` and `offset` parameters, in which case the first 10 items will be returned by default. For methods such as [`getAllowlistIdentifierList()`](/docs/references/backend/allowlist/get-allowlist-identifier-list), which do not take a `limit` or `offset`, all items will be returned.

If the promise is rejected, you will receive a `ClerkAPIResponseError` or network error.

---
title: '`PasskeyResource`'
description: An interface that describes a passkey associated with a user response.
---

An interface that describes a passkey associated with a user response.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier of the passkey.

  ---

  - `name`
  - `string`

  The passkey's name.

  ---

  - `verification`
  - [`Verification`](/docs/references/javascript/types/verification)

  The verification details for the passkey.

  ---

  - `createdAt`
  - `Date`

  The date when the passkey was created.

  ---

  - `updatedAt`
  - `Date`

  The date when the passkey was last updated.

  ---

  - `lastUsedAt`
  - `Date | null`

  The date when the passkey was last used.
</Properties>

## Methods

### `update()`

Updates the name of the associated passkey for the signed-in user.

```ts
function update(params: { name: string }): Promise<PasskeyResource>
```

For an example of how to use these methods, see the [Passkeys custom flows documentation](/docs/custom-flows/passkeys#rename-user-passkeys).

### `delete()`

Deletes the associated passkey for the signed-in user.

```ts {{ prettier: false }}
function delete(): Promise<DeletedObject>
```

Learn more:

- [`DeletedObject`](/docs/references/javascript/types/deleted-object)

For an example of how to use these methods, see the [Passkeys custom flows documentation](/docs/custom-flows/passkeys#delete-user-passkeys).

---
title: '`PermissionResource`'
description: An interface that represents a permission in an organization.
---

An interface that represents a permission in an organization.

<Properties>
  - `id`
  - `string`

  The unique identifier of the permission.

  ---

  - `key`
  - `string`

  The unique key of the permission.

  ---

  - `name`
  - `string`

  The name of the permission.

  ---

  - `type`
  - `'system' | 'user'`

  The type of the permission.

  ---

  - `createdAt`
  - `Date`

  The date when the permission was created.

  ---

  - `updatedAt`
  - `Date`

  The date when the permission was last updated.
</Properties>

---
title: '`PhoneNumber`'
description: The PhoneNumber object describes a phone number. Phone numbers can be used as a proof of identification for users, or simply as a means of contacting users.
---

The `PhoneNumber` object describes a phone number. Phone numbers can be used as a proof of identification for users, or simply as a means of contacting users.

Phone numbers must be **verified** to ensure that they can be assigned to their rightful owners. The `PhoneNumber` object holds all the necessary state around the verification process.

- The verification process always starts with the [`prepareVerification()`](#prepare-verification) method, which will send a one-time verification code via an SMS message.
- The second and final step involves an attempt to complete the verification by calling the [`attemptVerification()`](#attempt-verification) method, passing the one-time code as a parameter.

Finally, phone numbers can be used as part of [multi-factor authentication](/docs/authentication/configuration/sign-up-sign-in-options#multi-factor-authentication). During sign in, users can opt in to an extra verification step where they will receive an SMS message with a one-time code. This code must be entered to complete the sign in process.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for this phone number.

  ---

  - `phoneNumber`
  - `string`

  The value of this phone number, in [E.164 format](https://en.wikipedia.org/wiki/E.164).

  ---

  - `reservedForSecondFactor`
  - `boolean`

  Set to `true` if this phone number is reserved for multi-factor authentication (2FA). Set to `false` otherwise.

  ---

  - `defaultSecondFactor`
  - `boolean`

  Set to `true` if this phone number is the default second factor. Set to `false` otherwise. A user must have exactly one default second factor, if multi-factor authentication (2FA) is enabled.

  ---

  - `verification`
  - [`Verification`](/docs/references/javascript/types/verification)

  An object holding information on the verification of this phone number.

  ---

  - `linkedTo`
  - `Array<{id: string, type: string}>`

  An object containing information about any other identification that might be linked to this phone number.

  ---

  - `backupCodes`
  - `string[] | undefined`

  A list of backup codes in case of lost phone number access.
</Properties>

## Methods

### `create()`

Creates a new phone number for the current user.

```typescript
function create(): Promise<PhoneNumber>
```

### `destroy()`

Deletes this phone number.

```typescript
function destroy(): Promise<void>
```

### `toString()`

Returns the in [E.164 format](https://en.wikipedia.org/wiki/E.164) which includes the country code and the phone number.. Can also be accessed via the `PhoneNumber.phoneNumber` attribute.

```typescript
function toString(): string
```

### `prepareVerification()`

Kick off the verification process for this phone number. An SMS message with a one-time code will be sent to the phone number value.

```typescript
function prepareVerification(): Promise<PhoneNumber>
```

### `attemptVerification()`

Attempts to verify this phone number, passing the one-time code that was sent as an SMS message. The code will be sent when calling the [`PhoneNumber.prepareVerification()`](#prepare-verification) method.

```typescript
function attemptVerification(params: AttemptPhoneNumberVerificationParams): Promise<PhoneNumber>
```

### `AttemptPhoneNumberVerificationParams`

<Properties>
  - `code`
  - `string`

  The one-time code that was sent to the user's phone number when `prepareVerification` was called.
</Properties>

### `makeDefaultSecondFactor()`

Marks this phone number as the default second factor for [multi-factor authentication](/docs/custom-flows/email-password-mfa)(2FA). A user can have exactly one default second factor.

```typescript
function makeDefaultSecondFactor(): Promise<PhoneNumber>
```

### `setReservedForSecondFactor()`

Marks this phone number as reserved for [multi-factor authentication](/docs/custom-flows/email-password-mfa) (2FA) or not.

```typescript
function setReservedForSecondFactor(params: SetReservedForSecondFactorParams): Promise<PhoneNumber>
```

#### `SetReservedForSecondFactorParams`

<Properties>
  - `reserved`
  - `boolean`

  Pass `true` to mark this phone number as reserved for 2FA, or `false` to disable 2FA for this phone number.
</Properties>

---
title: '`PublicUserData`'
description: Information about that user that's publicly available.
---

Information about the user that's publicly available.

## Properties

<Properties>
  - `firstName`
  - `string | null`

  The user's first name.

  ---

  - `lastName`
  - `string | null`

  The user's last name.

  ---

  - `imageUrl`
  - `string`

  Holds the default avatar or user's uploaded profile image. Compatible with Clerk's [Image Optimization](/docs/guides/image-optimization).

  ---

  - `hasImage`
  - `boolean`

  A getter boolean to check if the user has uploaded an image or one was copied from OAuth. Returns `false` if Clerk is displaying an avatar for the user.

  ---

  - `identifier`
  - `string`

  The user's identifier.

  ---

  - `userId?`
  - `string | null`

  The user's ID.
</Properties>

---
title: '`RedirectOptions`'
description: An interface that provides options for a range of redirect methods.
---

An interface that provides options for a range of redirect methods.

## Properties

<Properties>
  - `signInForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs in. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs up. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signInFallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs in, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpFallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs up, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.
</Properties>

---
title: '`revokeInvitation()`'
description: Use Clerk's Backend SDK to revoke an invitation.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/InvitationApi.ts#L50 */}

Revokes an [`Invitation`](/docs/references/backend/types/backend-invitation).

Revoking an invitation makes the invitation email link unusable. However, it doesn't prevent the user from signing up if they follow the sign up flow.

Only active (i.e. non-revoked) invitations can be revoked.

```ts
function revokeInvitation(invitationId: string): Promise<Invitation>
```

## Parameters

<Properties>
  - `invitationId`
  - `string`

  The ID of the invitation to revoke.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const invitationId = 'inv_123'

const response = await clerkClient.invitations.revokeInvitation(invitationId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/invitations/{invitation_id}/revoke`. See the [BAPI reference](/docs/reference/backend-api/tag/Invitations#operation/RevokeInvitation){{ target: '_blank' }} for more information.

---
title: '`revokeOrganizationInvitation()`'
description: Use Clerk's Backend SDK to revoke an organization invitation from a user for a specified organization.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/OrganizationApi.ts#L270 */}

Revokes an [`OrganizationInvitation`](/docs/references/backend/types/backend-organization-invitation) from a user for the specified organization.

```ts
function revokeOrganizationInvitation(
  params: RevokeOrganizationInvitationParams,
): Promise<OrganizationInvitation>
```

## `RevokeOrganizationInvitationParams`

<Properties>
  - `organizationId`
  - `string`

  The ID of the organization the user was invited to.

  ---

  - `invitationId`
  - `string`

  The ID of the invitation to be revoked.

  ---

  - `requestingUserId`
  - `string`

  The ID of the user revoking the organization invitation.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx {{ mark: [22] }}
const organizationId = 'org_123'

const invitationId = 'orginv_123'

const requestingUserId = 'user_123'

const response = await clerkClient.organizations.revokeOrganizationInvitation({
  organizationId,
  invitationId,
  requestingUserId,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/organizations/{organization_id}/invitations/{invitation_id}/revoke`. See the [BAPI reference](/docs/reference/backend-api/tag/Organization-Invitations#operation/RevokeOrganizationInvitation){{ target: '_blank' }} for more information.

---
title: '`revokeSession()`'
description: Use Clerk's Backend SDK to revoke a session given its ID.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/SessionApi.ts/#L34 */}

Revokes a [`Session`](/docs/references/backend/types/backend-session).

User will be signed out from the particular client the referred to.

```ts
function revokeSession(sessionId: string): Promise<Session>
```

## Parameters

<Properties>
  - `sessionId`
  - `string`

  The ID of the session to revoke.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const sessionId = 'sess_123'

const response = await clerkClient.sessions.revokeSession(sessionId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/sessions/{session_id}/revoke`. See the [BAPI reference](/docs/reference/backend-api/tag/Sessions#operation/RevokeSession){{ target: '_blank' }} for more information.

---
title: '`revokeSignInToken()`'
description: Use Clerk's Backend SDK to revoke a pending sign-in token.
---

Revokes a pending sign-in token.

```ts
function revokeSignInToken(signInTokenId: string): Promise<SignInToken>
```

## Parameters

<Properties>
  - `signInTokenId`
  - `string`

  The ID of the sign-in token to revoke.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const signInTokenId = 'sit_123'

const response = await clerkClient.signInTokens.revokeSignInToken(signInTokenId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/sign_in_tokens/{sign_in_token_id}/revoke`. See the [BAPI reference](/docs/reference/backend-api/tag/Sign-in-Tokens#operation/RevokeSignInToken){{ target: '_blank' }} for more information.

---
title: '`RoleResource`'
description: An interface that represents a role in an organization.
---

An interface that represents a role in an organization.

<Properties>
  - `id`
  - `string`

  The unique identifier of the role.

  ---

  - `key`
  - `string`

  The unique key of the role.

  ---

  - `name`
  - `string`

  The name of the role.

  ---

  - `description`
  - `string`

  The description of the role.

  ---

  - `permissions`
  - <code>[PermissionResource](/docs/references/javascript/types/permission)\[]</code>

  The permissions of the role.

  ---

  - `createdAt`
  - `Date`

  The date when the role was created.

  ---

  - `updatedAt`
  - `Date`

  The date when the role was last updated.
</Properties>

---
title: '`rootAuthLoader()`'
description: The rootAuthLoader() function configures Clerk to handle authentication state for React Router routes.
---

The `rootAuthLoader()` function configures Clerk to handle authentication state for React Router routes, allowing easy access to user session information in your app.

## Usage

You can use the `rootAuthLoader()` in two different ways:

- [Without a callback](#without-a-callback), which will just return the auth state
- [With a callback function](#with-a-callback) to handle custom data loading while having access to auth state

You can also [pass configuration options](#pass-configuration-options) to `rootAuthLoader()` no matter which method you use.

### Without a callback

In your `root.tsx` file, add `rootAuthLoader()` to the `loader()` function. If your app doesn't have a `loader()` function yet, you'll need to add it manually.

```tsx {{ filename: 'app/root.tsx' }}
import { rootAuthLoader } from '@clerk/react-router/ssr.server'
import type { Route } from './+types/root'

export async function loader(args: Route.LoaderArgs) {
  return rootAuthLoader(args)
}
```

### With a callback

If you need to load in additional data, you can pass a callback to `rootAuthLoader()` that handles the route data loading with auth state.

```tsx {{ filename: 'app/root.tsx' }}
import { rootAuthLoader } from '@clerk/react-router/ssr.server'
import type { Route } from './+types/root'

export async function loader(args: Route.LoaderArgs) {
  return rootAuthLoader(args, ({ req, context, params }) => {
    const { sessionId, userId, getToken } = req.auth
    // Add logic to fetch data
    return { yourData: 'here' }
  })
}
```

### Pass configuration options

To pass configuration [options](#root-auth-loader-options) to `rootAuthLoader()`, you can pass an optional argument to the `rootAuthLoader()` function.

```tsx {{ filename: 'app/root.tsx' }}
import { rootAuthLoader } from '@clerk/react-router/ssr.server'
import type { Route } from './+types/root'

export async function loader(args: Route.LoaderArgs) {
  return rootAuthLoader(
    args,
    ({ req, context, params }) => {
      const { sessionId, userId, getToken } = req.auth
      // Add logic to fetch data
      return { yourData: 'here' }
    },
    { signInUrl: '/sign-in' }, // Options
  )
}
```

## `rootAuthLoader()` options

<Include src="_partials/root-auth-loader" />

---
title: '`rootAuthLoader()`'
description: The `rootAuthLoader` function is a helper function that provides the authentication state to your Remix application.
---

The `rootAuthLoader()` function is a helper function that provides the authentication state to your Remix application.

## Usage

You can use the `rootAuthLoader()` in two different ways:

- [Without a callback](#without-a-callback), which will just return the auth state
- [With a callback function](#with-a-callback) to handle custom data loading while having access to auth state

You can also [pass configuration options](#pass-configuration-options) to `rootAuthLoader()` no matter which method you use.

### Without a callback

To configure Clerk in your Remix app, you must export the `rootAuthLoader()` function as the root `loader()` function.

```tsx {{ filename: 'app/root.tsx', mark: [1, [4, 5], [15, 16]] }}
// Your other imports

// Import `rootAuthLoader`
import { rootAuthLoader } from '@clerk/remix/ssr.server'

// Export `rootAuthLoader()` as the root route `loader`
export const loader: LoaderFunction = (args) => rootAuthLoader(args)

// The rest of your code
```

### With a callback

If you need to load in additional data, you can pass a callback to `rootAuthLoader()` that handles the route data loading with auth state.

```tsx {{ filename: 'app/root.tsx' }}
// Your imports

export const loader: LoaderFunction = (args) => {
  return rootAuthLoader(args, ({ req }) => {
    const { sessionId, userId, getToken } = req.auth
    // Add logic to fetch data
    return { yourData: 'here' }
  })
}

// The rest of your code
```

### Pass configuration options

To pass configuration [options](#root-auth-loader-options) to `rootAuthLoader()`, you can pass an optional argument to the `rootAuthLoader()` function.

```tsx {{ filename: 'app/root.tsx' }}
// Your imports

export const loader: LoaderFunction = (args) => {
  return rootAuthLoader(
    args,
    ({ req }) => {
      const { sessionId, userId, getToken } = req.auth
      // Add logic to fetch data
      return { yourData: 'here' }
    },
    {
      signInForceRedirectUrl: '/dashboard',
    },
  )
}

// The rest of your code
```

## `rootAuthLoader()` options

<Include src="_partials/root-auth-loader" />

---
title: '`SamlAccount`'
description: An interface that represents a SAML account.
---

An interface that represents a SAML account.

<Properties>
  - `active`
  - `boolean`

  A boolean that indicates whether the SAML account is active.

  ---

  - `email_address`
  - `string`

  The email address of the SAML account.

  ---

  - `first_name`
  - `string`

  The first name of the SAML account.

  ---

  - `last_name`
  - `string`

  The last name of the SAML account.

  ---

  - `saml_connection`
  - <code>[SamlAccountConnection](/docs/references/javascript/types/saml-account-connection) | null</code>

  The SAML connection of the SAML account.

  ---

  - `provider`
  - `'saml_okta' | 'saml_google' | 'saml_microsoft' | 'saml_custom'`

  The provider of the SAML account.

  ---

  - `provider_user_id`
  - `string | null`

  The user's ID as used in the provider.

  ---

  - `verification`
  - <code>[Verification](/docs/references/javascript/types/verification) | null</code>

  The verification of the SAML account.
</Properties>

---
title: '`SamlAccountConnection`'
description: An interface that represents a SAML account connection.
---

An interface that represents a SAML account connection.

<Properties>
  - `active`
  - `boolean`

  A boolean that indicates whether the SAML account connection is active.

  ---

  - `allowIdpInitiated`
  - `boolean`

  A boolean that indicates whether the SAML account connection allows IDP-initiated authentication.

  ---

  - `allowSubdomains`
  - `boolean`

  A boolean that indicates whether the SAML account connection allows subdomains.

  ---

  - `createdAt`
  - `Date`

  The date and time when the SAML account connection was created.

  ---

  - `disableAdditionalIdentifications`
  - `boolean`

  A boolean that indicates whether the SAML account connection disables additional identifications.

  ---

  - `domain`
  - `string`

  The domain of the SAML account connection.

  ---

  - `id`
  - `string`

  The unique identifier of the SAML account connection.

  ---

  - `name`
  - `string`

  The name of the SAML account connection.

  ---

  - `provider`
  - `string`

  The provider of the SAML account connection.

  ---

  - `syncUserAttributes`
  - `boolean`

  A boolean that indicates whether the SAML account connection syncs user attributes.

  ---

  - `updatedAt`
  - `Date`

  The date and time when the SAML account connection was updated.
</Properties>

---
title: '`SessionStatus`'
description: The SessionStatus enum is used to indicate the status of a session.
---

The `SessionStatus` enum is used to indicate the status of a session.

```tsx
type SessionStatus =
  | 'abandoned'
  | 'active'
  | 'ended'
  | 'expired'
  | 'removed'
  | 'replaced'
  | 'revoked'
```

## Properties

| Value | Description |
| - | - |
| `abandoned` | The session was abandoned client-side. |
| `active` | The session is valid and all activity is allowed. |
| `ended` | The user signed out of the session, but the [`Session`][session-ref] remains in the [`Client`][client-ref] object. |
| `expired` | The period of allowed activity for this session has passed. |
| `removed` | The user signed out of the session and the [`Session`][session-ref] was removed from the [`Client`][client-ref] object. |
| `replaced` | The session has been replaced by another one, but the [`Session`][session-ref] remains in the [`Client`][client-ref] object. |
| `revoked` | The application ended the session and the [`Session`][session-ref] was removed from the [`Client`][client-ref] object. |

[session-ref]: /docs/references/javascript/session

[client-ref]: /docs/references/javascript/client

---
title: '`SessionWithActivities`'
description: The SessionWithActivities object is a modified Session object. It contains most of the information that the Session object stores, adding extra information about the current session's latest activity.
---

The `SessionWithActivities` object is a modified [`Session`](/docs/references/javascript/session) object. It includes most of the information stored in the `Session` object, with additional details about the latest activity in the current session. `SessionWithActivities` is returned by the [`User.getSessions()`](/docs/references/javascript/user#get-sessions) method.

The additional data included in the latest activity is useful for analytics purposes. A [`SessionActivity`](#session-activity) object provides information about the user's location, device and browser.

While the `SessionWithActivities` object wraps the most important information around a `Session` object, the two objects have entirely different methods.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for the session.

  ---

  - `status`
  - [`SessionStatus`](/docs/references/javascript/types/session-status)

  The current state of the session.

  ---

  - `lastActiveAt`
  - `Date`

  The time the session was last active on the [`Client`](/docs/references/javascript/client).

  ---

  - `abandonAt`
  - `Date`

  The time when the session was abandoned by the user.

  ---

  - `expireAt`
  - `Date`

  The time the session expires and will seize to be active.

  ---

  - `latestActivity`
  - [`SessionActivity`](#session-activity)

  An object that provides additional information about this session, focused around user activity data.
</Properties>

## Methods

### `revoke()`

Marks this session as revoked. If this is the active session, the attempt to revoke it will fail.

Users can revoke only their own sessions.

```typescript
function revoke(): Promise<SessionWithActivities>
```

## Types

### `SessionActivity`

<Properties>
  - `id`
  - `string`

  The unique identifier for the session activity record.

  ---

  - `browserName`
  - `string | undefined`

  The name of the browser from which this session activity occurred.

  ---

  - `browserVersion`
  - `string | undefined`

  The version of the browser from which this session activity occurred.

  ---

  - `deviceType`
  - `string | undefined`

  The type of the device which was used in this session activity.

  ---

  - `ipAddress`
  - `string | undefined`

  The IP address from which this session activity originated.

  ---

  - `city`
  - `string | undefined`

  The city from which this session activity occurred. Resolved by IP address geo-location.

  ---

  - `country`
  - `string | undefined`

  The country from which this session activity occurred. Resolved by IP address geo-location.

  ---

  - `isMobile`
  - `boolean | undefined`

  Will be set to `true` if the session activity came from a mobile device. Set to `false` otherwise.
</Properties>

---
title: '`SetActiveParams`'
description: The parameters for the `setActive()` method.
---

The parameters for the `setActive()` method.

<Properties>
  - `session`
  - <code>[Session](/docs/references/javascript/session) | string | null</code>

  The session resource or session ID (string version) to be set as active. If `null`, the current session is deleted.

  ---

  - `organization`
  - <code>[Organization](/docs/references/javascript/organization) | string | null</code>

  The organization resource or organization ID/slug (string version) to be set as active in the current session. If `null`, the currently active organization is removed as active.

  ---

  - `beforeEmit?` (deprecated)
  - `(session?: Session | null) => void | Promise<any>`

  Deprecated in favor of `redirectUrl`. Callback run just before the active session and/or organization is set to the passed object. Can be used to set up for pre-navigation actions.

  ---

  - `redirectUrl?`
  - `string`

  The full URL or path to redirect to just before the active session and/or organization is set.
</Properties>

---
title: '`SignIn`'
description: The SignIn object holds all the state of the current sign in and provides helper methods to navigate and complete the sign in process.
---

The `SignIn` object holds the state of the current sign-in and provides helper methods to navigate and complete the sign-in process. It is used to manage the sign-in lifecycle, including the first and second factor verification, and the creation of a new session.

The following steps outline the sign-in process:

1. Initiate the sign-in process by collecting the user's authentication information and passing the appropriate parameters to the [`create()`](#create) method.
1. Prepare the first factor verification by calling [`SignIn.prepareFirstFactor()`](#prepare-first-factor). Users _must_ complete a first factor verification. This can be something like providing a password, an email link, a one-time code (OTP), a Web3 wallet address, or providing proof of their identity through an external social account (SSO/OAuth).
1. Attempt to complete the first factor verification by calling [`SignIn.attemptFirstFactor()`](#attempt-first-factor).
1. Optionally, if you have enabled [multi-factor](/docs/authentication/configuration/sign-up-sign-in-options) for your application, you will need to prepare the second factor verification by calling [`SignIn.prepareSecondFactor()`](#prepare-second-factor).
1. Attempt to complete the second factor verification by calling [`SignIn.attemptSecondFactor()`](#attempt-second-factor).
1. If verification is successful, set the newly created session as the active session by passing the `SignIn.createdSessionId` to the [`setActive()`](/docs/references/javascript/clerk#set-active) method on the `Clerk` object.

## Properties

<Properties>
  - `status`
  - `SignInStatus`

  The current status of the sign-in. `SignInStatus` supports the following values:

  - `'complete'`: The user is signed in and the custom flow can proceed to `setActive()` to create a session.
  - `'needs_identifier'`: The user's identifier (e.g., email address, phone number, username) hasn't been provided.
  - `'needs_first_factor'`: One of the following [first factor verification strategies](/docs/references/javascript/sign-in) is missing: `'email_link'`, `'email_code'`, `'phone_code'`, `'web3_metamask_signature'`, `'web3_coinbase_wallet_signature'` or `'oauth_provider'`.
  - `'needs_second_factor'`: One of the following [second factor verification strategies](/docs/references/javascript/sign-in) is missing: `'phone_code'` or `'totp'`.
  - `'needs_new_password'`: The user needs to set a new password.

  ---

  - `supportedIdentifiers`
  - `SignInIdentifier[]`

  Array of all the authentication identifiers that are supported for this sign in. `SignInIdentifier` supports the following values:

  - `'email_address'`
  - `'phone_number'`
  - `'web3_wallet'`
  - `'username'`

  ---

  - `identifier`
  - `string | null`

  **Optional** if the `strategy` is set to `'oauth_<provider>'` or `'enterprise_sso'`. **Required** otherwise. The authentication identifier value for the current sign-in.

  ---

  - `supportedFirstFactors`
  - <code>[SignInFirstFactor](/docs/references/javascript/types/sign-in-first-factor)\[]</code>

  Array of the first factors that are supported in the current sign-in. Each factor contains information about the verification strategy that can be used. See the [`SignInFirstFactor`](/docs/references/javascript/types/sign-in-first-factor) type reference for more information.

  ---

  - `supportedSecondFactors`
  - <code>[SignInSecondFactor](/docs/references/javascript/types/sign-in-second-factor)\[]</code>

  Array of the second factors that are supported in the current sign-in. Each factor contains information about the verification strategy that can be used. This property is populated only when the first factor is verified. See the [`SignInSecondFactor`](/docs/references/javascript/types/sign-in-second-factor) type reference for more information.

  ---

  - `firstFactorVerification`
  - [`Verification`](/docs/references/javascript/types/verification)

  The state of the verification process for the selected first factor. Initially, this property contains an empty verification object, since there is no first factor selected. You need to call the [`prepareFirstFactor`](/docs/references/javascript/sign-in#prepare-first-factor) method in order to start the verification process.

  ---

  - `secondFactorVerification`
  - [`Verification`](/docs/references/javascript/types/verification)

  The state of the verification process for the selected second factor. Initially, this property contains an empty verification object, since there is no second factor selected. For the `phone_code` strategy, you need to call the [`prepareSecondFactor`](/docs/references/javascript/sign-in#prepare-second-factor) method in order to start the verification process. For the `totp` strategy, you can directly attempt.

  ---

  - `userData`
  - `UserData`

  An object containing information about the user of the current sign-in. This property is populated only once an identifier is given to the `SignIn` object.

  ---

  - `createdSessionId`
  - `string | null`

  The identifier of the session that was created upon completion of the current sign-in. The value of this property is `null` if the sign-in status is not `'complete'`.
</Properties>

## Methods

### `attemptFirstFactor()`

Attempts to complete the first factor verification process. This is a required step in order to complete a sign in, as users should be verified at least by one factor of authentication.

Make sure that a `SignIn` object already exists before you call this method, either by first calling [`SignIn.create()`](#create) or [`SignIn.prepareFirstFactor()`](#prepare-first-factor). The only strategy that does not require a verification to have already been prepared before attempting to complete it is the `password` strategy.

Depending on the strategy that was selected when the verification was prepared, the method parameters will be different.

Returns a `SignIn` object. Check the `firstFactorVerification` attribute for the status of the first factor verification process.

```typescript
function attemptFirstFactor(params: AttemptFirstFactorParams): Promise<SignIn>
```

#### `AttemptFirstFactorParams`

<Properties>
  - `strategy`
  - `'email_code' | 'phone_code' | 'password' | 'web3_metamask_signature' | 'web3_coinbase_wallet_signature' | 'web3_okx_wallet_signature' | 'passkey' | 'reset_password_phone_code' | 'reset_password_email_code'`

  The `strategy` value depends on the `SignIn.identifier` value. Each authentication identifier supports different verification strategies. The following strategies are supported:

  - `'email_code'`: User will receive a one-time authentication code via email. At least one email address should be on file for the user.
  - `'phone_code'`: User will receive a one-time code via SMS. At least one phone number should be on file for the user.
  - `'password'`: The verification will attempt to be completed with the user's password.
  - `'web3_metamask_signature'`: The verification will attempt to be completed using the user's Web3 wallet address via [Metamask](https://metamask.io/).
  - `'web3_coinbase_wallet_signature'`: The verification will attempt to be completed using the user's Web3 wallet address via [Coinbase Wallet](https://www.coinbase.com/wallet).
  - `'web3_okx_wallet_signature'`: The verification will attempt to be completed using the user's Web3 wallet address via [OKX Wallet](https://www.okx.com/help/section/faq-web3-wallet).
  - `'passkey'`: The verification will attempt to be completed using the user's passkey.
  - `'reset_password_phone_code'`: Used when the user is trying to reset their password. The user will receive a one-time code via SMS.
  - `'reset_password_email_code'`: Used when the user is trying to reset their password. The user will receive a one-time code via email.

  ---

  - `code?`
  - `string`

  **Required** if `strategy` is set to `'email_code'`, `'phone_code'`, `'reset_password_phone_code'`, or `'reset_password_email_code'`. The one-time code that was sent to the user.

  ---

  - `password?`
  - `string`

  **Required** if `strategy` is set to `'password'`. The user's password string to be verified.

  ---

  - `signature?`
  - `string`

  **Required** if `strategy` is set to `web3_metamask_signature`, `web3_coinbase_wallet_signature`, or `web3_okx_wallet_signature`. The Web3 wallet generated signature to be verified.
</Properties>

#### Example

```js
const signIn = await clerk.signIn.attemptFirstFactor({
  strategy: 'email_code',
  code: '123456',
})
```

For comprehensive examples, see the [custom flow guides](/docs/custom-flows/overview).

### `attemptSecondFactor()`

Attempts to complete the second factor (2FA) verification process, also known as 2FA, or [multi-factor authentication](/docs/authentication/configuration/sign-up-sign-in-options#multi-factor-authentication).

> [!NOTE]
> For the `phone_code` strategy, make sure that a verification has already been prepared before you call this method, by first calling [`SignIn.prepareSecondFactor`](#prepare-second-factor).

Returns a `SignIn` object. Check the `secondFactorVerification` attribute for the status of the second factor verification process.

```typescript
function attemptSecondFactor(params: AttemptSecondFactorParams): Promise<SignIn>
```

#### `AttemptSecondFactorParams`

<Properties>
  - `strategy`
  - `'phone_code' | 'totp'`

  The strategy to be used for second factor verification. Possible `strategy` values are

  - `'phone_code'`: User will receive a one-time authentication code via SMS. At least one phone number should be on file for the user.
  - `'totp'`: User must provide a 6-digit TOTP code generated by their authenticator app. The user must have previously created a TOTP secret and registered it in their authenticator app using a QR code, URI, or by manually entering the secret.

  ---

  - `code`
  - `string`

  {/* Comment to prevent lists from being merged into one */}

  - For the `'phone_code'` strategy: The one-time code that was sent to the user as part of the `prepareSecondFactor()` step.
  - For the `'totp'` strategy: The TOTP generated by the user's authenticator app.
</Properties>

#### Example

```js
const signIn = await clerk.signIn.attemptSecondFactor({
  strategy: 'phone_code',
  code: '123456',
})
```

For a comprehensive example, see the [custom flow for multi-factor authentication](/docs/custom-flows/email-password-mfa).

### `authenticateWithCoinbaseWallet()`

Initiates an authentication flow using the Coinbase Wallet browser extension, allowing users to authenticate via their Web3 wallet address. This method prompts the user to connect their Coinbase Wallet and sign a message to verify ownership of the wallet address.

```typescript
function authenticateWithCoinbaseWallet(): Promise<SignInResource>
```

#### Example

```js
const signIn = await clerk.signIn.authenticateWithCoinbaseWallet()
```

### `authenticateWithMetamask()`

Initiates an authentication flow using the MetaMask browser extension, allowing users to authenticate via their Ethereum wallet address. This method prompts the user to connect their MetaMask wallet and sign a message to verify ownership of the wallet address.

```typescript
function authenticateWithMetamask(): Promise<SignInResource>
```

#### Example

```js
const signIn = await clerk.signIn.authenticateWithMetamask()
```

### `authenticateWithOKXWallet()`

Initiates an authentication flow using the OKX Wallet browser extension, allowing users to authenticate via their Web3 wallet address. This method prompts the user to connect their OKX Wallet and sign a message to verify ownership of the wallet address.

```typescript
function authenticateWithOKXWallet(): Promise<SignInResource>
```

#### Example

```js
const signIn = await clerk.signIn.authenticateWithOKXWallet()
```

### `authenticateWithPasskey()`

Initiates a passkey-based authentication flow, enabling users to authenticate using a previously registered passkey. When called without parameters, this method requires a prior call to `SignIn.create({ strategy: 'passkey' })` to initialize the sign-in context. This pattern is particularly useful in scenarios where the authentication strategy needs to be determined dynamically at runtime.

```ts
function authenticateWithPasskey(params?: AuthenticateWithPasskeyParams): Promise<SignInResource>
```

##### `AuthenticateWithPasskeyParams`

<Properties>
  - `flow`
  - `'autofill' | 'discoverable'`

  The flow to use for the passkey sign-in.

  - `'autofill'`: The client prompts your users to select a passkey before they interact with your app.
  - `'discoverable'`: The client requires the user to interact with the client.
</Properties>

#### Example

```js
const signIn = await clerk.signIn.authenticateWithPasskey({ flow: 'discoverable' })
```

### `authenticateWithRedirect()`

Signs in a user via a Single Sign On (SSO) connection, such as OAuth or SAML, where an external account is used for verifying the user's identity.

```typescript
function authenticateWithRedirect(params: AuthenticateWithRedirectParams): Promise<void>
```

#### `AuthenticateWithRedirectParams`

<Properties>
  - `strategy`
  - <code>[OAuthStrategy](/docs/references/javascript/types/sso#o-auth-strategy) | 'saml' | 'enterprise\_sso'</code>

  The strategy to use for authentication. The following strategies are supported:

  - `'oauth_<provider>'`: The user will be authenticated with their [social connection account](/docs/authentication/social-connections/oauth). See a list of [supported values for `<provider>`](/docs/references/javascript/types/sso).
  - `'saml'` (deprecated): **Deprecated in favor of `'enterprise_sso'`.** The user will be authenticated with their [SAML account](/docs/authentication/enterprise-connections/overview#saml).
  - `'enterprise_sso'`: The user will be authenticated either through SAML or OIDC depending on the configuration of their [enterprise SSO account](/docs/authentication/enterprise-connections/overview).

  ---

  - `redirectUrl`
  - `string`

  The full URL or path that the OAuth provider should redirect to, on successful authorization on their part. Typically, this will be a simple `/sso-callback` route that calls [`Clerk.handleRedirectCallback`](/docs/references/javascript/clerk#handle-redirect-callback) or mounts the [`<AuthenticateWithRedirectCallback />`](/docs/components/control/authenticate-with-callback) component. See the [custom flow](/docs/custom-flows/oauth-connections) for implementation details.

  ---

  - `redirectUrlComplete`
  - `string`

  The full URL or path that the user will be redirected to once the sign-in is complete.

  ---

  - `identifier`
  - `string | undefined`

    The ID used to target an enterprise connection during sign-in.

  ---

  - `emailAddress`
  - `string | undefined`

  The email address used to target an enterprise connection during sign-in.

  ---

  - `legalAccepted`
  - `boolean | undefined`

  A boolean indicating whether the user has agreed to the [legal compliance](/docs/authentication/configuration/legal-compliance) documents.
</Properties>

#### Example

For OAuth connections, see the [custom flow for OAuth connections](/docs/custom-flows/oauth-connections).
For enterprise connections, see the [custom flow for enterprise connections](/docs/custom-flows/enterprise-connections).

### `authenticateWithPopup()`

Opens a popup window to allow a user to sign in via a Single Sign On (SSO) connection, such as OAuth or SAML, where an external account is used for verifying the user's identity.

```typescript
function authenticateWithPopup(params: AuthenticateWithPopupParams): Promise<void>
```

#### `AuthenticateWithPopupParams`

<Properties>
  - `continueSignUp?`
  - `boolean | undefined`

  Whether to continue (i.e. PATCH) an existing `SignUp` (if present) or create a new `SignUp`.

  ---

  - `emailAddress?`
  - `string | undefined`

  The email address used to target an enterprise connection during sign-in.

  ---

  - `identifier?`
  - `string | undefined`

    The ID used to target an enterprise connection during sign-in.

  ---

  - `legalAccepted?`
  - `boolean | undefined`

  A boolean indicating whether the user has agreed to the [legal compliance](/docs/authentication/configuration/legal-compliance) documents.

  ---

  - `popup?`
  - `Window | null`

  A reference to a popup window opened via `window.open()`.

  ---

  - `redirectUrl`
  - `string`

  The full URL or path that the OAuth provider should redirect to after successful authorization on their part. Typically, this will be a simple `/sso-callback` route that calls [`Clerk.handleRedirectCallback`](/docs/references/javascript/clerk#handle-redirect-callback) or mounts the [`<AuthenticateWithRedirectCallback />`](/docs/components/control/authenticate-with-callback) component. See the [custom flow](/docs/custom-flows/oauth-connections) for implementation details.

  ---

  - `redirectUrlComplete`
  - `string`

  The full URL or path that the user will be redirected to once the sign-in is complete.

  ---

  - `strategy`
  - <code>[OAuthStrategy](/docs/references/javascript/types/sso#o-auth-strategy) | 'saml' | 'enterprise\_sso'</code>

  The strategy to use for authentication. The following strategies are supported:

  - `'oauth_<provider>'`: The user will be authenticated with their [social connection account](/docs/authentication/social-connections/oauth). See a list of [supported values for `<provider>`](/docs/references/javascript/types/sso).
  - `'saml'` (deprecated): **Deprecated in favor of `'enterprise_sso'`.** The user will be authenticated with their [SAML account](/docs/authentication/enterprise-connections/overview#saml).
  - `'enterprise_sso'`: The user will be authenticated either through SAML or OIDC depending on the configuration of their [enterprise SSO account](/docs/authentication/enterprise-connections/overview).
</Properties>

### `authenticateWithWeb3()`

Initiates a Web3 authentication flow by verifying the user's ownership of a blockchain wallet address through cryptographic signature verification. This method enables decentralized authentication without requiring traditional credentials.

```typescript
function authenticateWithWeb3(params: AuthenticateWithWeb3Params): Promise<SignInResource>
```

#### `AuthenticateWithWeb3Params`

<Properties>
  - `identifier`
  - `string`

  The user's Web3 ID.

  ---

  - `generateSignature`
  - `(opts: GenerateSignatureParams) => Promise<string>`

  The method of how to generate the signature for the Web3 sign-in. See [`GenerateSignatureParams`](#generate-signature-params) for more information.

  ---

  - `strategy?`
  - `Web3Strategy`

  The Web3 verification strategy.
</Properties>

##### `GenerateSignatureParams`

<Properties>
  - `identifier`
  - `string`

  The user's Web3 wallet address.

  ---

  - `nonce`
  - `string`

  The [cryptographic nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce) used in the sign-in.

  ---

  - `provider?`
  - `Web3Provider`

    The Web3 provider to generate the signature with.
</Properties>

#### Example

```js
const signIn = await clerk.signIn.authenticateWithWeb3({
  identifier: '0x1234567890123456789012345678901234567890',
})
```

### `create()`

Creates and returns a new `SignIn` instance initialized with the provided parameters. The instance maintains the sign-in lifecycle state through its `status` property, which updates as the authentication flow progresses. This method serves as the entry point for initiating a sign-in flow.

What you must pass to `params` depends on which [sign-in options](/docs/authentication/configuration/sign-up-sign-in-options) you have enabled in your app's settings in the Clerk Dashboard.

You can complete the sign-in process in one step if you supply the required fields to `create()`. Otherwise, Clerk's sign-in process provides great flexibility and allows users to easily create multi-step sign-in flows.

> [!WARNING]
> Once the sign-in process is complete, pass the `createdSessionId` to the [`setActive()`](/docs/references/javascript/clerk#set-active) method on the `Clerk` object. This will set the newly created session as the active session.

```typescript
function create(params: SignInCreateParams): Promise<SignIn>
```

#### `SignInCreateParams`

<Properties>
  - `strategy?`
  - `'password' | 'email_link' | 'email_code' | 'phone_code' | 'oauth_<provider>' | 'saml' | 'enterprise_sso' | 'passkey' | 'web3_metamask_signature' | 'web3_coinbase_wallet_signature' | 'web3_okx_wallet_signature' | 'ticket' | 'google_one_tap'`

  The first factor verification strategy to use in the sign-in flow. Depends on the `SignIn.identifier` value. Each authentication identifier supports different verification strategies. The following strategies are supported:

  - `'password'`: The verification will attempt to be completed using the user's password.
  - `'email_link'`: User will receive an email magic link via email. The `identifier` parameter can also be specified to select one of the user's known email addresses. The `redirectUrl` parameter can also be specified.
  - `'email_code'`: User will receive a one-time authentication code via email. The `identifier` parameter can also be specified to select one of the user's known email addresses.
  - `'phone_code'`: User will receive a one-time authentication code via SMS. The `identifier` parameter can also be specified to select one of the user's known phone numbers.
  - `'oauth_<provider>'`: The user will be authenticated with their [social connection account](/docs/authentication/social-connections/oauth). See a list of [supported values for `<provider>`](/docs/references/javascript/types/sso).
  - `'saml'` (deprecated): **Deprecated in favor of `'enterprise_sso'`.** The user will be authenticated with their [SAML account](/docs/authentication/enterprise-connections/overview#saml).
  - `'enterprise_sso'`: The user will be authenticated either through SAML or OIDC depending on the configuration of their [enterprise SSO account](/docs/authentication/enterprise-connections/overview).
  - `'passkey'`: The user will be authenticated with their [passkey](/docs/authentication/configuration/sign-up-sign-in-options#passkeys).
  - `'web3_metamask_signature'`: The verification will attempt to be completed using the user's Web3 wallet address via [Metamask](/docs/authentication/web3/metamask). The `identifier` parameter can also be specified to select which of the user's known Web3 wallets will be used.
  - `'web3_coinbase_wallet_signature'`: The verification will attempt to be completed using the user's Web3 wallet address via [Coinbase Wallet](/docs/authentication/web3/coinbase-wallet). The `identifier` parameter can also be specified to select which of the user's known Web3 wallets will be used.
  - `'web3_okx_wallet_signature'`: The verification will attempt to be completed using the user's Web3 wallet address via [OKX Wallet](/docs/authentication/web3/okx-wallet). The `identifier` parameter can also be specified to select which of the user's known Web3 wallets will be used.
  - `'ticket'`: The user will be authenticated via the ticket _or token_ generated from the Backend API.
  - `'google_one_tap'`: The user will be authenticated with the Google One Tap UI. It's recommended to use [`authenticateWithGoogleOneTap()`](/docs/components/authentication/google-one-tap#authenticate-with-google-one-tap) instead, as it will also set the user's current session as active for you.

  ---

  - `identifier`
  - `string`

  The authentication identifier for the sign-in. This can be the value of the user's email address, phone number, username, or Web3 wallet address.

  ---

  - `password?`
  - `string`

  The user's password. Only supported if `strategy` is set to `'password'` and [password](/docs/authentication/configuration/sign-up-sign-in-options#authentication-strategies) is enabled.

  ---

  - `ticket?`
  - `string`

  **Required** if `strategy` is set to `'ticket'`. The [ticket _or token_](/docs/custom-flows/embedded-email-links#generate-a-sign-in-token) generated from the Backend API.

  ---

  - `redirectUrl?`
  - `string`

  If `strategy` is set to `'oauth_<provider>'` or `'enterprise_sso'`, this specifies the full URL or path that the OAuth provider should redirect to after successful authorization on their part. Typically, this will be a simple `/sso-callback` route that either calls [`Clerk.handleRedirectCallback`](/docs/references/javascript/clerk#handle-redirect-callback) or mounts the [`<AuthenticateWithRedirectCallback />`](/docs/components/control/authenticate-with-callback) component. See the [custom flow](/docs/custom-flows/oauth-connections) for implementation details.

  If `strategy` is set to `'email_link'`, this specifies the URL that the user will be redirected to when they visit the email link. See the [custom flow](/docs/custom-flows/email-links) for implementation details.

  ---

  - `actionCompleteRedirectUrl?`
  - `string`

  **Optional** if `strategy` is set to `'oauth_<provider>'` or `'enterprise_sso'`. The URL that the user will be redirected to, after successful authorization from the OAuth provider and Clerk sign-in.

  ---

  - `transfer?`
  - `boolean`

  When set to `true`, the `SignIn` will attempt to retrieve information from the active `SignUp` instance and use it to complete the sign-in process. This is useful when you want to seamlessly transition a user from a sign-up attempt to a sign-in attempt.

  ---

  - `oidcPrompt?`
  - `string`

  **Optional** if `strategy` is set to `'oauth_<provider>'` or `'enterprise_sso'`. The value to pass to the [OIDC `prompt` parameter](https://openid.net/specs/openid-connect-core-1_0.html#:~:text=prompt,reauthentication%20and%20consent.) in the generated OAuth redirect URL.

  ---

  - `oidcLoginHint?`
  - `string`

  **Optional** if `strategy` is set to `'oauth_<provider>'` or `'enterprise_sso'`. The value to pass to the [OIDC `login_hint` parameter](https://openid.net/specs/openid-connect-core-1_0.html#:~:text=login_hint,in%20\(if%20necessary\).) in the generated OAuth redirect URL.
</Properties>

#### Example

```js
await clerk.signIn.create({
  strategy: 'email_link',
  identifier: 'test@example.com',
})
```

For comprehensive examples, see the [custom flow guides](/docs/custom-flows/overview).

### `createEmailLinkFlow()`

Creates a flow for authenticating users via email links. This method returns functions for initiating and canceling the email link verification process; see the [returns](#returns) section for more information.

```typescript
function createEmailLinkFlow(): {
  startEmailLinkFlow: (params: SignInStartEmailLinkFlowParams) => Promise<SignIn>
  cancelEmailLinkFlow: () => void
}
```

#### Returns

`createEmailLinkFlow` returns an object with two functions:

<Properties>
  - `startEmailLinkFlow`
  - <code>(params: [SignInStartEmailLinkFlowParams](#sign-in-start-email-link-flow-params)) => Promise\<SignIn></code>

  Function to start the email link flow. It prepares an email link verification and polls for the verification result.

  ---

  - `cancelEmailLinkFlow`
  - `() => void`

  Function to cleanup the email link flow. Stops waiting for verification results.
</Properties>

#### `SignInStartEmailLinkFlowParams`

<Properties>
  - `emailAddressId`
  - `string`

  The ID of the user's email address that's going to be used as the first factor identification for verification.

  ---

  - `redirectUrl`
  - `string`

  The full URL that the user will be redirected to when they visit the email link.
</Properties>

#### Example

```js
const { startEmailLinkFlow, cancelEmailLinkFlow } = clerk.signIn.createEmailLinkFlow()
```

For a comprehensive example, see the [custom flow for email links](/docs/custom-flows/email-links).

### `prepareFirstFactor()`

Begins the first factor verification process. This is a required step in order to complete a sign in, as users should be verified at least by one factor of authentication.

Common scenarios are one-time code (OTP) or social account (SSO) verification. This is determined by the accepted `strategy` parameter values. Each authentication identifier supports different strategies.

Returns a `SignIn` object. Check the `firstFactorVerification` attribute for the status of the first factor verification process.

```typescript
function prepareFirstFactor(params: PrepareFirstFactorParams): Promise<SignIn>
```

#### `PrepareFirstFactorParams`

<Properties>
  - `strategy`
  - `'email_link' | 'email_code' | 'phone_code' | 'web3_metamask_signature' | 'web3_coinbase_wallet_signature' | 'web3_okx_wallet_signature' | 'passkey' | 'oauth_<provider>' | 'saml' | 'enterprise_sso' | 'reset_password_phone_code' | 'reset_password_email_code'`

  The `strategy` value depends on the `SignIn.identifier` value. Each authentication identifier supports different verification strategies. The following strategies are supported:

  - `'email_link'`: User will receive an email magic link via email.
  - `'email_code'`: User will receive a one-time authentication code via email. Requires `emailAddressId` parameter to be set.
  - `'phone_code'`: User will receive a one-time authentication code via SMS. Requires `phoneNumberId` parameter to be set.
  - `'web3_metamask_signature'`: The verification will attempt to be completed using the user's Web3 wallet address via [Metamask](https://metamask.io/). Requires `web3WalletId` parameter to be set.
  - `'web3_coinbase_wallet_signature'`: The verification will attempt to be completed using the user's Web3 wallet address via [Coinbase Wallet](https://www.coinbase.com/wallet). Requires `web3WalletId` parameter to be set.
  - `'web3_okx_wallet_signature'`: The verification will attempt to be completed using the user's Web3 wallet address via [OKX Wallet](https://www.okx.com/help/section/faq-web3-wallet). Requires `web3WalletId` parameter to be set.
  - `'passkey'`: The verification will attempt to be completed using the user's passkey.
  - `'oauth_<provider>'`: The user will be authenticated with their [social connection account](/docs/authentication/social-connections/oauth). See a list of [supported values for `<provider>`](/docs/references/javascript/types/sso).
  - `'saml'` (deprecated): **Deprecated in favor of `'enterprise_sso'`.** The user will be authenticated with their [SAML account](/docs/authentication/enterprise-connections/overview#saml).
  - `'enterprise_sso'`: The user will be authenticated either through SAML or OIDC depending on the configuration of their [enterprise SSO account](/docs/authentication/enterprise-connections/overview).
  - `'reset_password_phone_code'`: Used when the user is trying to reset their password. The user will receive a one-time code via SMS. Requires `phoneNumberId` parameter to be set.
  - `'reset_password_email_code'`: Used when the user is trying to reset their password. The user will receive a one-time code via email. Requires `emailAddressId` parameter to be set.

  ---

  - `emailAddressId?`
  - `string`

  **Required** if `strategy` is set to `'email_code'` or `'reset_password_email_code'`. The ID for the user's email address that will receive an email with the one-time authentication code.

  ---

  - `phoneNumberId?`
  - `string`

  **Required** if `strategy` is set to `'phone_code'` or `'reset_password_phone_code'`. The ID for the user's phone number that will receive an SMS message with the one-time authentication code.

  ---

  - `web3WalletId?`
  - `string`

  **Required** if `strategy` is set to `'web3_metamask_signature'`, `'web3_coinbase_wallet_signature'`, or `'web3_okx_wallet_signature'`. The ID for the user's Web3 wallet address.

  ---

  - `redirectUrl?`
  - `string`

  **Required** if `strategy` is set to `'oauth_<provider>'` or `'enterprise_sso'`. The full URL or path that the OAuth provider should redirect to after successful authorization on their part. Typically, this will be a simple `/sso-callback` route that either calls [`Clerk.handleRedirectCallback()`](/docs/references/javascript/clerk#handle-redirect-callback) or mounts the [`<AuthenticateWithRedirectCallback />`](/docs/components/control/authenticate-with-callback) component. See the [custom flow](/docs/custom-flows/oauth-connections) for implementation details.

  **Required** if `strategy` is set to `'email_link'`. The full URL that the user will be redirected to when they visit the email link. See the [custom flow](/docs/custom-flows/email-links) for implementation details.

  ---

  - `actionCompleteRedirectUrl?`
  - `string`

  **Required** if `strategy` is set to `'oauth_<provider>'` or `'enterprise_sso'`. The URL that the user will be redirected to once the first factor verification is complete.
</Properties>

#### Example

```js
const signIn = await clerk.signIn.prepareFirstFactor({
  strategy: 'email_link',
  identifier: 'test@example.com',
})
```

For comprehensive examples, see the [custom flow guides](/docs/custom-flows/overview).

### `prepareSecondFactor()`

Begins the second factor (2FA) verification process. Clerk calls this [multi-factor authentication (MFA)](/docs/authentication/configuration/sign-up-sign-in-options#multi-factor-authentication).

> [!NOTE]
> If the `strategy` was set to `totp` (e.g. `SignIn.create({ strategy: 'totp' })`), it does not require preparation. You can directly attempt the second factor verification by calling [`SignIn.attemptSecondFactor`](#attempt-second-factor).

Returns a `SignIn` object. Check the `secondFactorVerification` attribute for the status of the second factor verification process.

```typescript
function prepareSecondFactor(params: PrepareSecondFactorParams): Promise<SignIn>
```

#### `PrepareSecondFactorParams`

<Properties>
  - `strategy`
  - `'phone_code'`

  The strategy used for second factor verification. Supported strategies are:

  - `'phone_code'`: User will receive a one-time authentication code via SMS. At least one phone number should be on file for the user.

  ---

  - `phoneNumberId`
  - `string`

  The ID for the user's phone number that will receive an SMS message with the one-time authentication code.
</Properties>

#### Example

```js
const signIn = await clerk.signIn.prepareSecondFactor({
  strategy: 'phone_code',
  phoneNumberId: '123',
})
```

For a comprehensive example, see the [custom flow for multi-factor authentication](/docs/custom-flows/email-password-mfa).

### `resetPassword()`

Resets a user's password. It's recommended to use the [custom flow for resetting a user's password](/docs/custom-flows/forgot-password) instead.

```typescript
function resetPassword(params: ResetPasswordParams): Promise<SignIn>
```

#### `ResetPasswordParams`

<Properties>
  - `password`
  - `string`

  The user's current password.

  ---

  - `signOutOfOtherSessions?`
  - `boolean | undefined`

  If `true`, signs the user out of all other authenticated sessions.
</Properties>

#### Example

```js
await clerk.signIn.resetPassword({
  password: 'new-password',
})
```

---
title: '`SignInFirstFactor`'
description: The SignInFirstFactor type represents the first factor verification strategy that can be used in the sign-in process.
---

The `SignInFirstFactor` type represents the first factor verification strategy that can be used in the sign-in process.

```ts
type SignInFirstFactor =
  | EmailCodeFactor
  | EmailLinkFactor
  | PhoneCodeFactor
  | PasswordFactor
  | ResetPasswordPhoneCodeFactor
  | ResetPasswordEmailCodeFactor
  | Web3SignatureFactor
  | OauthFactor
  | SamlFactor
```

<Properties>
  - `strategy`
  - `'email_code'` | `'email_link'` | `'phone_code'` | `'password'` | `'passkey'` | `'reset_password_phone_code'` | `'reset_password_email_code'` | `'web3_metamask_signature'` | `'web3_coinbase_wallet_signature'` | `'web3_okx_wallet_signature'` | [`OAuthStrategy`](/docs/references/javascript/types/sso) | `'saml'` | `'enterprise_sso'`

  The strategy of the factor.

  ---

  - `emailAddressId`
  - `string`

  The ID of the email address that a code or link will be sent to. Populated when the `strategy` is `'email_code'`, `'email_link'`, or `'reset_password_email_code'`.

  ---

  - `phoneNumberId`
  - `string`

  The ID of the phone number that a code will be sent to. Populated when the `strategy` is `'phone_code'` or `'reset_password_phone_code'`.

  ---

  - `web3WalletId`
  - `string`

  The ID of the Web3 wallet that will be used to sign a message. Populated when the `strategy` is `'web3_metamask_signature'`, `'web3_coinbase_wallet_signature'`, or `'web3_okx_wallet_signature'`.

  ---

  - `safeIdentifier`
  - `'emailAddress'` | `'phoneNumber'`

  The safe identifier of the factor.

  Populated when the strategy is `'email_code'`, `'email_link'`, `'phone_code'`, `'reset_password_email_code'`, or `'reset_password_phone_code'`.

  ---

  - `primary`
  - `boolean`

  Whether the factor is the primary factor.

  Populated when the strategy is `'email_code'`, `'email_link'`, `'phone_code'`, `'web3_metamask_signature'`, `'web3_coinbase_wallet_signature'`, `'web3_okx_wallet_signature'`, `'reset_password_email_code'`, or `'reset_password_phone_code'`.
</Properties>

## `EmailCodeFactor`

```ts
type EmailCodeFactor = {
  strategy: EmailCodeStrategy
  emailAddressId: string
  safeIdentifier: string
  primary?: boolean
}
```

## `EmailLinkFactor`

```ts
type EmailLinkFactor = {
  strategy: EmailLinkStrategy
  emailAddressId: string
  safeIdentifier: string
  primary?: boolean
}
```

## `PhoneCodeFactor`

```ts
type PhoneCodeFactor = {
  strategy: PhoneCodeStrategy
  phoneNumberId: string
  safeIdentifier: string
  primary?: boolean
  default?: boolean
}
```

## `PasswordFactor`

```ts
type PasswordFactor = {
  strategy: PasswordStrategy
}
```

## `ResetPasswordPhoneCodeFactor`

```ts
type ResetPasswordPhoneCodeFactor = {
  strategy: ResetPasswordPhoneCodeStrategy
  phoneNumberId: string
  safeIdentifier: string
  primary?: boolean
}
```

## `ResetPasswordEmailCodeFactor`

```ts
type ResetPasswordEmailCodeFactor = {
  strategy: ResetPasswordEmailCodeStrategy
  emailAddressId: string
  safeIdentifier: string
  primary?: boolean
}
```

## `Web3SignatureFactor`

```ts
type Web3SignatureFactor = {
  strategy: Web3Strategy
  web3WalletId: string
  primary?: boolean
}
```

## `OauthFactor`

```ts
type OauthFactor = {
  strategy: OAuthStrategy
}
```

## `SamlFactor`

```ts
type SamlFactor = {
  strategy: SamlStrategy
}
```

---
title: '`SignInInitialValues`'
description: The type for the `initialValues` prop that is used to pre-populate the sign-in form.
---

The type for the `initialValues` prop that is used to pre-populate the sign-in form.

## Properties

<Properties>
  - `emailAddress?`
  - `string | undefined`

  The email address of the user.

  ---

  - `username?`
  - `string | undefined`

  The username of the user.

  ---

  - `phoneNumber?`
  - `string | undefined`

  The user's phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
</Properties>

---
title: '`SignInRedirectOptions`'
description: An interface that provides options for sign-in redirect methods.
---

An interface that provides options for sign-in redirect methods.

## Properties

<Properties>
  - `signInForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs in. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs up. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signInFallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs in, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpFallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs up, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.
</Properties>

---
title: '`SignInSecondFactor`'
description: The SignInSecondFactor type represents the second factor verification strategy that can be used in the sign-in process.
---

The `SignInSecondFactor` type represents the second factor verification strategy that can be used in the sign-in process.

```ts
type SignInSecondFactor = PhoneCodeFactor | TOTPFactor | BackupCodeFactor
```

<Properties>
  - `strategy`
  - `'phone_code' | 'totp' | 'backup_code'`

  The strategy of the factor.

  ---

  - `phoneNumberId`
  - `string`

  The ID of the phone number that a code will be sent to. Populated when the `strategy` is `'phone_code'`.

  ---

  - `safeIdentifier`
  - `string`

  The safe identifier of the factor. Supports the following values:

  - `'phoneNumber'`

  Populated when the strategy is `'phone_code'`.

  ---

  - `primary`
  - `boolean`

  Whether the factor is the primary factor. Populated when the strategy is `'phone_code'`.
</Properties>

## `TOTPFactor`

```ts
type TOTPFactor = {
  strategy: TOTPStrategy
}
```

## `BackupCodeFactor`

```ts
type BackupCodeFactor = {
  strategy: BackupCodeStrategy
}
```

---
title: '`SignUp`'
description: The SignUp object holds the state of the current sign-up and provides helper methods to navigate and complete the sign-up flow. Once a sign-up is complete, a new user is created.
---

The `SignUp` object holds the state of the current sign-up and provides helper methods to navigate and complete the sign-up process. Once a sign-up is complete, a new user is created.

The following steps outline the sign-up process:

1. Initiate the sign-up process by collecting the user's authentication information and passing the appropriate parameters to the [`create()`](#create) method.
1. Prepare the verification.
1. Attempt to complete the verification.
1. If the verification is successful, set the newly created session as the active session by passing the `SignIn.createdSessionId` to the [`setActive()`](/docs/references/javascript/clerk#set-active) method on the `Clerk` object.

## Properties

<Properties>
  - `id`
  - `string | undefined`

  The unique identifier of the current sign-up.

  ---

  - `status`
  - `'missing_requirements' | 'complete' | 'abandoned' | null`

  The status of the current sign-up. The following values are supported:

  - `complete:` The user has been created and the custom flow can proceed to `setActive()` to create session.
  - `missing_requirements:` A requirement is unverified or missing from the [**Email, Phone, Username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) settings. For example, in the Clerk Dashboard, the **Password** setting is required but a password wasn't provided in the custom flow.
  - `abandoned:` The sign-up has been inactive for over 24 hours.

  ---

  - `requiredFields`
  - `string[]`

  An array of all the required fields that need to be supplied and verified in order for this sign-up to be marked as complete and converted into a user.

  ---

  - `optionalFields`
  - `string[]`

  An array of all the fields that can be supplied to the sign-up, but their absence does not prevent the sign-up from being marked as complete.

  ---

  - `missingFields`
  - `string[]`

  An array of all the fields whose values are not supplied yet but they are mandatory in order for a sign-up to be marked as complete.

  ---

  - `unverifiedFields`
  - `string[]`

  An array of all the fields whose values have been supplied, but they need additional verification in order for them to be accepted. Examples of such fields are `emailAddress` and `phoneNumber`.

  ---

  - `verifications`
  - `SignUpVerifications`

  An object that contains information about all the verifications that are in-flight.

  ---

  - `username`
  - `string | null`

  The username supplied to the current sign-up. Only supported if [username](/docs/authentication/configuration/sign-up-sign-in-options#identifiers) is enabled in the instance settings.

  ---

  - `emailAddress`
  - `string | null`

  The email address supplied to the current sign-up. Only supported if [email address](/docs/authentication/configuration/sign-up-sign-in-options#identifiers) is enabled in the instance settings.

  ---

  - `phoneNumber`
  - `string | null`

  The user's phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164). Only supported if [phone number](/docs/authentication/configuration/sign-up-sign-in-options#identifiers) is enabled in the instance settings.

  ---

  - `web3Wallet`
  - `string | null`

  The Web3 wallet address, made up of 0x + 40 hexadecimal characters. Only supported if [Web3 authentication](/docs/authentication/configuration/sign-up-sign-in-options#web3-authentication) is enabled in the instance settings.

  ---

  - `hasPassword`
  - `boolean`

  The value of this attribute is true if a password was supplied to the current sign-up. Only supported if [password](/docs/authentication/configuration/sign-up-sign-in-options#authentication-strategies) is enabled in the instance settings.

  ---

  - `firstName`
  - `string | null`

  The first name supplied to the current sign-up. Only supported if [name](/docs/authentication/configuration/sign-up-sign-in-options#personal-information) is enabled in the instance settings.

  ---

  - `lastName`
  - `string | null`

  The last name supplied to the current sign-up. Only supported if [name](/docs/authentication/configuration/sign-up-sign-in-options#personal-information) is enabled in the instance settings.

  ---

  - `unsafeMetadata`
  - [`SignUpUnsafeMetadata`](/docs/references/javascript/types/metadata#sign-up-unsafe-metadata)

  Metadata that can be read and set from the frontend. Once the sign-up is complete, the value of this field will be automatically copied to the newly created user's unsafe metadata. One common use case for this attribute is to use it to implement custom fields that can be collected during sign-up and will automatically be attached to the created User object.

  ---

  - `createdSessionId`
  - `string | null`

  The identifier of the newly-created session. This attribute is populated only when the sign-up is complete.

  ---

  - `createdUserId`
  - `string | null`

  The identifier of the newly-created user. This attribute is populated only when the sign-up is complete.

  ---

  - `abandonAt`
  - `number | null`

  The epoch numerical time when the sign-up was abandoned by the user.
</Properties>

## Methods

### `attemptEmailAddressVerification()`

Attempts to verify an email address by validating the one-time verification code provided by the user against the code sent during the prepare verification step. This is a convenience method that wraps [`SignUp.attemptVerification()`](/docs/references/javascript/sign-up#attempt-verification) with the `'email_code'` strategy.

By default, this method is equivalent to calling `SignUp.attemptVerification({ strategy: 'email_code', code })`. The verification attempt will fail if the code is invalid or has expired.

```typescript
function attemptEmailAddressVerification(
  params: AttemptEmailAddressVerificationParams,
): Promise<SignUpResource>
```

#### `AttemptEmailAddressVerificationParams`

<Properties>
  - `code`
  - `string`

  The code that was sent to the user via email.
</Properties>

### `attemptPhoneNumberVerification()`

Attempts to verify a phone number by validating the one-time verification code provided by the user against the code sent during the prepare verification step. This is a convenience method that wraps [`SignUp.attemptVerification()`](#attempt-verification) with the `'phone_code'` strategy.

By default, this method is equivalent to calling `SignUp.attemptVerification({ strategy: 'phone_code', code })`. The verification attempt will fail if the code is invalid or has expired.

```typescript
function attemptPhoneNumberVerification(
  params: AttemptPhoneNumberVerificationParams,
): Promise<SignUpResource>
```

#### `AttemptPhoneNumberVerificationParams`

<Properties>
  - `code`
  - `string`

  The code that was sent to the user via SMS.
</Properties>

### `attemptVerification()`

Attempts to complete a pending verification process for the specified verification strategy. This method must be called after initiating verification via [`SignUp.prepareVerification()`](#prepare-verification). The verification attempt will validate the provided verification parameters (code, signature, etc.) against the pending verification request.

Depending on the strategy, the method parameters could differ.

```typescript
function attemptVerification(params: AttemptVerificationParams): Promise<SignUp>
```

#### `AttemptVerificationParams`

<Properties>
  - `strategy`
  - `'phone_code' | 'email_code' | 'web3_metamask_signature' | 'web3_coinbase_wallet_signature' | 'web3_okx_wallet_signature'`

  The verification strategy to complete the user's sign-up request against. The following strategies are supported:

  - `'phone_code'`: Validates an SMS with a unique token to input.
  - `'email_code'`: Validates an email with a unique token to input.
  - `'web3_metamask_signature'`: The verification will attempt to be completed using the user's Web3 wallet address via [Metamask](https://metamask.io/). The `web3_wallet_id` parameter can also be specified to select which of the user's known Web3 wallets will be used.
  - `'web3_coinbase_wallet_signature'`: The verification will attempt to be completed using the user's Web3 wallet address via [Coinbase Wallet](https://www.coinbase.com/wallet). The `web3_wallet_id` parameter can also be specified to select which of the user's known Web3 wallets will be used.
  - `'web3_okx_wallet_signature'`: The verification will attempt to be completed using the user's Web3 wallet address via [OKX Wallet](https://www.okx.com/help/section/faq-web3-wallet). The `web3_wallet_id` parameter can also be specified to select which of the user's known Web3 wallets will be used.

  ---

  - `code`
  - `string`

  **Required** if `strategy` is set to `'phone_code'` or `'email_code'`. The code that was sent to the user.

  ---

  - `signature`
  - `string`

  **Required** if `strategy` is set to `'web3_metamask_signature'`, `'web3_coinbase_wallet_signature'`, or `'web3_okx_wallet_signature'`. The signature that was sent to the user via the Web3 verification strategy.
</Properties>

### `attemptWeb3WalletVerification()`

Attempts to verify a Web3 wallet address by validating the cryptographic signature generated by the wallet against the nonce provided during the prepare verification step. This is a convenience method that wraps [`SignUp.attemptVerification()`](#attempt-verification) with Web3 wallet strategies.

By default, this method is equivalent to calling `SignUp.attemptVerification({ strategy: 'web3_metamask_signature', signature })`. The verification attempt will fail if the signature is invalid or the nonce has expired.

```typescript
function attemptWeb3WalletVerification(params: AttemptWeb3WalletVerificationParams): Promise<SignUp>
```

#### `AttemptWeb3WalletVerificationParams`

<Properties>
  - `signature`
  - `string`

  The signature that was generated after [`prepareVerification`](#prepare-verification) was called.
</Properties>

### `authenticateWithCoinbaseWallet()`

Initiates an authentication flow using the Coinbase Wallet browser extension, allowing users to authenticate via their Web3 wallet address. This method prompts the user to connect their Coinbase Wallet and sign a message to verify ownership of the wallet address.

```typescript
function authenticateWithCoinbaseWallet(
  params?: SignUpAuthenticateWithWeb3Params,
): Promise<SignUpResource>
```

#### Example

```js
const signUp = await clerk.signUp.authenticateWithCoinbaseWallet()
```

### `authenticateWithMetamask()`

Initiates an authentication flow using the MetaMask browser extension, allowing users to authenticate via their Ethereum wallet address. This method prompts the user to connect their MetaMask wallet and sign a message to verify ownership of the wallet address.

```typescript
function authenticateWithMetamask(
  params?: SignUpAuthenticateWithWeb3Params,
): Promise<SignUpResource>
```

#### Example

```js
const signUp = await clerk.signUp.authenticateWithMetamask()
```

### `authenticateWithOKXWallet()`

Initiates an authentication flow using the OKX Wallet browser extension, allowing users to authenticate via their Web3 wallet address. This method prompts the user to connect their OKX Wallet and sign a message to verify ownership of the wallet address.

```typescript
function authenticateWithOKXWallet(
  params?: SignUpAuthenticateWithWeb3Params,
): Promise<SignUpResource>
```

#### `SignUpAuthenticateWithWeb3Params`

<Properties>
  - `unsafeMetadata`
  - [`SignUpUnsafeMetadata`](/docs/references/javascript/types/metadata#sign-up-unsafe-metadata)

  Metadata that can be read and set from the frontend and the backend. Once the sign-up is complete, the value of this field will be automatically copied to the created user's unsafe metadata (`User.unsafeMetadata`). One common use case is to collect custom information about the user during the sign-up process and store it in this property. Read more about [unsafe metadata](/docs/users/metadata#unsafe-metadata).
</Properties>

#### Example

```js
const signUp = await clerk.signUp.authenticateWithOKXWallet()
```

### `authenticateWithRedirect()`

Signs up a user via a Single Sign On (SSO) connection, such as OAuth or SAML, where an external account is used for verifying the user's identity.

```typescript
function authenticateWithRedirect(params: AuthenticateWithRedirectParams): Promise<void>
```

#### `AuthenticateWithRedirectParams`

<Properties>
  - `redirectUrl`
  - `string`

  The full URL or path that the OAuth provider should redirect to after successful authorization on their part. Typically, this will be a simple `/sso-callback` route that either calls [`Clerk.handleRedirectCallback`](/docs/references/javascript/clerk#handle-redirect-callback) or mounts the [`<AuthenticateWithRedirectCallback />`](/docs/components/control/authenticate-with-callback) component. See the [custom flow](/docs/custom-flows/oauth-connections) for implementation details.

  ---

  - `redirectUrlComplete`
  - `string`

  The full URL or path to navigate to after the OAuth or SAML flow completes.

  ---

  - `continueSignUp`
  - `boolean | undefined`

  Whether to continue (i.e. PATCH) an existing `SignUp` (if present) or create a new `SignUp`.

  ---

  - `strategy`
  - `'oauth_<provider>' | 'saml' | 'enterprise_sso'`

  The strategy to use for authentication. The following strategies are supported:

  - `'oauth_<provider>'`: The user will be authenticated with their [social connection account](/docs/authentication/social-connections/oauth). See a list of [supported values for `<provider>`](/docs/references/javascript/types/sso).
  - `'saml'` (deprecated): **Deprecated in favor of `'enterprise_sso'`.** The user will be authenticated with their [SAML account](/docs/authentication/enterprise-connections/overview#saml).
  - `'enterprise_sso'`: The user will be authenticated either through SAML or OIDC depending on the configuration of their [enterprise SSO account](/docs/authentication/enterprise-connections/overview).

  ---

  - `identifier`
  - `string | undefined`

  Identifier to use for targeting an enterprise connection at sign-up.

  ---

  - `emailAddress`
  - `string | undefined`

  Email address to use for targeting an enterprise connection at sign-up.

  ---

  - `legalAccepted?`
  - `boolean`

  A boolean indicating whether the user has agreed to the [legal compliance](/docs/authentication/configuration/legal-compliance) documents.
</Properties>

#### Example

For OAuth connections, see the [custom flow for OAuth connections](/docs/custom-flows/oauth-connections).
For enterprise connections, see the [custom flow for enterprise connections](/docs/custom-flows/enterprise-connections).

### `authenticateWithPopup()`

Opens a popup window to allow a user to sign up via a Single Sign On (SSO) connection, such as OAuth or SAML, where an external account is used for verifying the user's identity.

```typescript
function authenticateWithPopup(params: AuthenticateWithPopupParams): Promise<void>
```

#### `AuthenticateWithPopupParams`

<Properties>
  - `redirectUrl`
  - `string`

  The full URL or path that the OAuth provider should redirect to after successful authorization on their part. Typically, this will be a simple `/sso-callback` route that either calls [`Clerk.handleRedirectCallback`](/docs/references/javascript/clerk#handle-redirect-callback) or mounts the [`<AuthenticateWithRedirectCallback />`](/docs/components/control/authenticate-with-callback) component. See the [custom flow](/docs/custom-flows/oauth-connections) for implementation details.

  ---

  - `redirectUrlComplete`
  - `string`

  The full URL or path to navigate to after the OAuth or SAML flow completes.

  ---

  - `strategy`
  - `'oauth_<provider>' | 'saml' | 'enterprise_sso'`

  The strategy to use for authentication. The following strategies are supported:

  - `'oauth_<provider>'`: The user will be authenticated with their [social connection account](/docs/authentication/social-connections/oauth). See a list of [supported values for `<provider>`](/docs/references/javascript/types/sso).
  - `'saml'` (deprecated): **Deprecated in favor of `'enterprise_sso'`.** The user will be authenticated with their [SAML account](/docs/authentication/enterprise-connections/overview#saml).
  - `'enterprise_sso'`: The user will be authenticated either through SAML or OIDC depending on the configuration of their [enterprise SSO account](/docs/authentication/enterprise-connections/overview).

  ---

  - `continueSignUp?`
  - `boolean | undefined`

  Whether to continue (i.e. PATCH) an existing `SignUp` (if present) or create a new `SignUp`.

  ---

  - `emailAddress?`
  - `string | undefined`

  Email address to use for targeting an enterprise connection at sign-up.

  ---

  - `identifier?`
  - `string | undefined`

  Identifier to use for targeting an enterprise connection at sign-up.

  ---

  - `legalAccepted?`
  - `boolean`

  A boolean indicating whether the user has agreed to the [legal compliance](/docs/authentication/configuration/legal-compliance) documents.

  ---

  - `popup?`
  - `Window`

  A reference to a popup window opened via `window.open()`.
</Properties>

#### Example

For OAuth connections, see the [custom flow for OAuth connections](/docs/custom-flows/oauth-connections).
For enterprise connections, see the [custom flow for enterprise connections](/docs/custom-flows/enterprise-connections).

### `authenticateWithWeb3()`

Initiates a Web3 authentication flow by verifying the user's ownership of a blockchain wallet address through cryptographic signature verification. This method enables decentralized authentication without requiring traditional credentials.

```typescript
function authenticateWithWeb3(params: AuthenticateWithWeb3Params): Promise<SignUpResource>
```

#### `AuthenticateWithWeb3Params`

<Properties>
  - `identifier`
  - `string`

  The user's Web3 ID

  ---

  - `generateSignature`
  - <code>(opts: [GenerateSignatureParams](#generate-signature-params)) => Promise\<string></code>

  The method of how to generate the signature for the Web3 sign-in. See [`GenerateSignatureParams`](#generate-signature-params) for more information.

  ---

  - `strategy?`
  - `Web3Strategy`

  The Web3 verification strategy.

  ---

  - `legalAccepted?`
  - `boolean`

  A boolean indicating whether the user has agreed to the [legal compliance](/docs/authentication/configuration/legal-compliance) documents.
</Properties>

#### `GenerateSignatureParams`

<Properties>
  - `identifier`
  - `string`

  The user's Web3 wallet address.

  ---

  - `nonce`
  - `string`

  The [cryptographic nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce) used in the sign-in.

  ---

  - `provider?`
  - `Web3Provider`

  The Web3 provider to generate the signature with.

  ---

  - `legalAccepted?`
  - `boolean`

  A boolean indicating whether the user has agreed to the [legal compliance](/docs/authentication/configuration/legal-compliance) documents.
</Properties>

#### Example

```js
const signUp = await clerk.signUp.authenticateWithWeb3({
  identifier: '0x1234567890123456789012345678901234567890',
})
```

### `create()`

Returns a new `SignUp` object based on the `params` you pass to it, stores the sign-up lifecycle state in the `status` property, and deactivates any existing sign-up process the client may already have in progress. Use this method to initiate a new sign-up process.

What you must pass to `params` depends on which [sign-up options](/docs/authentication/configuration/sign-up-sign-in-options) you have enabled in your Clerk application instance.

Optionally, you can complete the sign-up process in one step if you supply the required fields to `create()`. Otherwise, Clerk's sign-up process provides great flexibility and allows users to easily create multi-step sign-up flows.

> [!WARNING]
> Once the sign-up process is complete, pass the `createdSessionId` to the [`setActive()`](/docs/references/javascript/clerk#set-active) method on the `Clerk` object. This will set the newly created session as the active session.

```typescript
function create(params: SignUpCreateParams): Promise<SignUpResource>
```

#### `SignUpCreateParams`

<Properties>
  - `strategy`
  - `'oauth_<provider>' | 'saml' | 'enterprise_sso' | 'ticket' | 'google_one_tap'`

  The strategy to use for the sign-up flow. The following strategies are supported:

  - `'oauth_<provider>'`: The user will be authenticated with their [social connection account](/docs/authentication/social-connections/oauth). See a list of [supported values for `<provider>`](/docs/references/javascript/types/sso).
  - `'saml'` (deprecated): **Deprecated in favor of `'enterprise_sso'`.** The user will be authenticated with their [SAML account](/docs/authentication/enterprise-connections/overview#saml).
  - `'enterprise_sso'`: The user will be authenticated either through SAML or OIDC depending on the configuration of their [enterprise SSO account](/docs/authentication/enterprise-connections/overview).
  - `'ticket'`: The user will be authenticated via the ticket _or token_ generated from the Backend API.
  - `'google_one_tap'`: The user will be authenticated with the Google One Tap UI. It's recommended to use [`authenticateWithGoogleOneTap()`](/docs/components/authentication/google-one-tap#authenticate-with-google-one-tap) instead, as it will also set the user's current session as active for you.

  ---

  - `firstName`
  - `string | null`

  The user's first name. Only supported if [name](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) is enabled.

  ---

  - `lastName`
  - `string | null`

  The user's last name. Only supported if [name](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) is enabled.

  ---

  - `password`
  - `string | null`

  The user's password. Only supported if [password](/docs/authentication/configuration/sign-up-sign-in-options#authentication-strategies) is enabled.

  ---

  - `emailAddress`
  - `string | null`

  The user's email address. Only supported if [email address](/docs/authentication/configuration/sign-up-sign-in-options#identifiers) is enabled. Keep in mind that the email address requires an extra verification process.

  ---

  - `phoneNumber`
  - `string | null`

  The user's phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164). Only supported if [phone number](/docs/authentication/configuration/sign-up-sign-in-options#identifiers) is enabled. Keep in mind that the phone number requires an extra verification process.

  ---

  - `web3Wallet`
  - `string | null`

  **Required** if [Web3 authentication](/docs/authentication/configuration/sign-up-sign-in-options#web3-authentication) is enabled. The Web3 wallet address, made up of 0x + 40 hexadecimal characters.

  ---

  - `username`
  - `string | null`

  The user's username. Only supported if [usernames](/docs/authentication/configuration/sign-up-sign-in-options#identifiers) are enabled.

  ---

  - `unsafeMetadata`
  - [`SignUpUnsafeMetadata`](/docs/references/javascript/types/metadata#sign-up-unsafe-metadata)

  Metadata that can be read and set from the frontend. Once the sign-up is complete, the value of this field will be automatically copied to the newly created user's unsafe metadata. One common use case for this attribute is to use it to implement custom fields that can be collected during sign-up and will automatically be attached to the created `User` object.

  ---

  - `redirectUrl`
  - `string`

  If `strategy` is set to `'oauth_<provider>'` or `'enterprise_sso'`, this specifies full URL or path that the OAuth provider should redirect to after successful authorization on their part. Typically, this will be a simple `/sso-callback` route that either calls [`Clerk.handleRedirectCallback()`](/docs/references/javascript/clerk#handle-redirect-callback) or mounts the [`<AuthenticateWithRedirectCallback />`](/docs/components/control/authenticate-with-callback) component. See the [custom flow](/docs/custom-flows/oauth-connections) for implementation details.

  If `strategy` is set to `'email_link'`, this specifies The full URL that the user will be redirected to when they visit the email link. See the [custom flow](/docs/custom-flows/email-links) for implementation details.

  ---

  - `actionCompleteRedirectUrl`
  - `string`

  **Optional** if `strategy` is set to `'oauth_<provider>'` or `'enterprise_sso'`. The full URL or path that the user will be redirected to after successful authorization from the OAuth provider and Clerk sign-in.

  ---

  - `ticket`
  - `string`

  **Required** if `strategy` is set to `'ticket'`. The [ticket _or token_](/docs/custom-flows/application-invitations) generated from the Backend API.

  ---

  - `transfer`
  - `boolean`

  When set to `true`, the `SignUp` will attempt to retrieve information from the active `SignIn` instance and use it to complete the sign-up process. This is useful when you want to seamlessly transition a user from a sign-in attempt to a sign-up attempt.

  ---

  - `legalAccepted`
  - `boolean`

  A boolean indicating whether the user has agreed to the [legal compliance](/docs/authentication/configuration/legal-compliance) documents.

  ---

  - `oidcPrompt`
  - `string`

  **Optional** if `strategy` is set to `'oauth_<provider>'` or `'enterprise_sso'`. The value to pass to the [OIDC `prompt` parameter](https://openid.net/specs/openid-connect-core-1_0.html#:~:text=prompt,reauthentication%20and%20consent.) in the generated OAuth redirect URL.

  ---

  - `oidcLoginHint`
  - `string`

  **Optional** if `strategy` is set to `'oauth_<provider>'` or `'enterprise_sso'`. The value to pass to the [OIDC `login_hint` parameter](https://openid.net/specs/openid-connect-core-1_0.html#:~:text=login_hint,in%20\(if%20necessary\).) in the generated OAuth redirect URL.
</Properties>

### `createEmailLinkFlow()`

```typescript
function createEmailLinkFlow(): {
  startEmailLinkFlow: (params: StartEmailLinkFlowParams) => Promise<SignUp>
  cancelEmailLinkFlow: () => void
}
```

Sets up a sign-up with email link flow. Calling `createEmailLinkFlow()` will return two functions.

The first function is async and starts the email link flow, preparing an email link verification. It sends the email link email and starts polling for verification results. The signature is `startEmailLinkFlow({ redirectUrl: string }) => Promise<SignUpResource>`.

The second function can be used to stop polling at any time, allowing for full control of the flow and cleanup. The signature is `cancelEmailLinkFlow() => void`.

```typescript
function createEmailLinkFlow(): {
  startEmailLinkFlow: (params: StartEmailLinkFlowParams) => Promise<SignUpResource>
  cancelEmailLinkFlow: () => void
}
```

#### `createEmailLinkFlow()` returns

`createEmailLinkFlow` returns an object with two functions:

<Properties>
  - `startEmailLinkFlow`
  - <code>(params: [StartEmailLinkFlowParams](#start-email-link-flow-params)) => Promise\<SignUp></code>

  Function to start the email link flow. It prepares an email link verification and polls for the verification result.
</Properties>

#### `StartEmailLinkFlowParams`

<Properties>
  - `redirectUrl`
  - `string`

  The full URL that the user will be redirected to when they visit the email link.
</Properties>

### `prepareEmailAddressVerification()`

Initiates an email verification process by sending a one-time verification code to the email address associated with the current sign-up attempt. This is a convenience method that wraps [`SignUp.prepareVerification()`](#prepare-verification) with the `'email_code'` strategy.

By default, this method is equivalent to calling `SignUp.prepareVerification({ strategy: 'email_code' })`. It can be customized via the `PrepareEmailAddressVerificationParams` to use alternative verification strategies like email links.

```typescript
function prepareEmailAddressVerification(
  params?: PrepareEmailAddressVerificationParams,
): Promise<SignUpResource>
```

#### `PrepareEmailAddressVerificationParams`

<Properties>
  - `strategy`
  - `'email_code' | 'email_link'`

  The verification strategy to validate the user's sign-up request. The following strategies are supported:

  - `'email_code'`: Send an email with a unique token to input.
  - `'email_link'`: Send an email with a link which validates sign-up.

  ---

  - `redirectUrl`
  - `string`

  **Required** if `strategy` is set to `'email_link'`. The full URL that the user will be redirected to when they visit the email link. See the [custom flow](/docs/custom-flows/email-links) for implementation details.
</Properties>

### `preparePhoneNumberVerification()`

Initiates a phone number verification process by sending a one-time verification code (OTP) via SMS to the phone number associated with the current sign-up attempt. This is a convenience method that wraps [`SignUp.prepareVerification()`](#prepare-verification) with the `'phone_code'` strategy.

By default, this method is equivalent to calling `SignUp.prepareVerification({ strategy: 'phone_code' })`. The verification process will fail if the phone number is invalid, unreachable, or has already been verified. The sent verification code has a limited validity period and can only be used once.

```typescript
function preparePhoneNumberVerification(
  params?: PreparePhoneNumberVerificationParams,
): Promise<SignUpResource>
```

#### `PreparePhoneNumberVerificationParams`

<Properties>
  - `strategy`
  - `'phone_code'`

  The verification strategy to validate the user's sign-up request. The following strategies are supported:

  - `'phone_code'`: Send an SMS with a unique token to input.
</Properties>

### `prepareVerification()`

Initiates the verification process for a field that requires validation during sign-up. This method prepares the necessary verification flow based on the specified strategy, such as sending verification codes, generating OAuth URLs, or preparing Web3 wallet signatures.

```typescript
function prepareVerification(params: PrepareVerificationParams): Promise<SignUpResource>
```

#### `PrepareVerificationParams`

<Properties>
  - `strategy`
  - `'phone_code' | 'email_code' | 'email_link' | 'oauth_<provider>' | 'saml' | 'enterprise_sso' | 'web3_metamask_signature' | 'web3_coinbase_wallet_signature' | 'web3_okx_wallet_signature'`

  The verification strategy to validate the user's sign-up request. The following strategies are supported:

  - `'phone_code'`: User will receive a one-time authentication code via SMS.
  - `'email_code'`: Send an email with a unique token to input.
  - `'email_link'`: Send an email with a link which validates sign-up.
  - `'oauth_<provider>'`: The user will be authenticated with their [social connection account](/docs/authentication/social-connections/oauth). See a list of [supported values for `<provider>`](/docs/references/javascript/types/sso).
  - `'saml'` (deprecated): **Deprecated in favor of `'enterprise_sso'`.** The user will be authenticated with their [SAML account](/docs/authentication/enterprise-connections/overview#saml).
  - `'enterprise_sso'`: The user will be authenticated either through SAML or OIDC depending on the configuration of their [enterprise SSO account](/docs/authentication/enterprise-connections/overview).
  - `'web3_metamask_signature'`: The verification will attempt to be completed using the user's Web3 wallet address via [Metamask](https://metamask.io/). The `web3_wallet_id` parameter can also be specified to select which of the user's known Web3 wallets will be used.
  - `'web3_coinbase_wallet_signature'`: The verification will attempt to be completed using the user's Web3 wallet address via [Coinbase Wallet](https://www.coinbase.com/wallet). The `web3_wallet_id` parameter can also be specified to select which of the user's known Web3 wallets will be used.
  - `'web3_okx_wallet_signature'`: The verification will attempt to be completed using the user's Web3 wallet address via [OKX Wallet](https://www.okx.com/help/section/faq-web3-wallet). The `web3_wallet_id` parameter can also be specified to select which of the user's known Web3 wallets will be used.

  ---

  - `redirectUrl`
  - `string`

  If `strategy` is set to `'oauth_<provider>'` or `'enterprise_sso'`, this specifies the full URL or path that the OAuth provider should redirect to after successful authorization. Typically, this will be a simple `/sso-callback` route that either calls [`Clerk.handleRedirectCallback()`](/docs/references/javascript/clerk#handle-redirect-callback) or mounts the [`<AuthenticateWithRedirectCallback />`](/docs/components/control/authenticate-with-callback) component. See the [custom flow](/docs/custom-flows/oauth-connections) for implementation details.

  If `strategy` is set to `'email_link'`, this specifies The full URL that the user will be redirected to when they visit the email link. See the [custom flow](/docs/custom-flows/email-links) for implementation details.

  ---

  - `actionCompleteRedirectUrl?`
  - `string`

  The full URL or path that the user will be redirected to after successful authorization from the OAuth provider and Clerk sign-in.

  ---

  - `oidcPrompt?`
  - `string`

  **Optional** if `strategy` is set to `'oauth_<provider>'` or `'enterprise_sso'`. The value to pass to the [OIDC `prompt` parameter](https://openid.net/specs/openid-connect-core-1_0.html#:~:text=prompt,reauthentication%20and%20consent) in the generated OAuth redirect URL.

  ---

  - `oidcLoginHint?`
  - `string`

  **Optional** if `strategy` is set to `'oauth_<provider>'` or `'enterprise_sso'`. The value to pass to the [OIDC `login_hint` parameter](https://openid.net/specs/openid-connect-core-1_0.html#:~:text=login_hint,in%20\(if%20necessary\).) in the generated OAuth redirect URL.
</Properties>

### `prepareWeb3WalletVerification()`

Initiates a verification process for a Web3 wallet by sending the wallet address to the server and retrieving a nonce that must be cryptographically signed by the wallet. This is a convenience method that wraps [`SignUp.prepareVerification()`](#prepare-verification) with Web3 wallet strategies.

By default, this method is equivalent to calling `SignUp.prepareVerification({ strategy: 'web3_metamask_signature' })`. The verification process will fail if the wallet address is invalid or has already been verified. The returned nonce has a limited validity period and can only be used once.

```typescript
function prepareWeb3WalletVerification(
  params?: PrepareWeb3WalletVerificationParams,
): Promise<SignUpResource>
```

#### `PrepareWeb3WalletVerificationParams`

<Properties>
  - `strategy`
  - `'web3_metamask_signature'` | `'web3_coinbase_wallet_signature'` | `'web3_okx_wallet_signature'`

  The verification strategy to validate the user's sign-up request. The following strategies are supported:

  - `'web3_metamask_signature'`: User will need to sign a message and generate a signature using MetaMask browser extension.
  - `'web3_coinbase_wallet_signature'`: User will need to sign a message and generate a signature using Coinbase Wallet.
  - `'web3_okx_wallet_signature'`: User will need to sign a message and generate a signature using OKX Wallet.
</Properties>

### `update()`

Updates the current `SignUp`.

```typescript
function update(params: SignUpUpdateParams): Promise<SignUpResource>
```

#### `SignUpUpdateParams`

`SignUpUpdateParams` is a mirror of [`SignUpCreateParams`](#sign-up-create-params) with the same fields and types, depending on the configuration of the instance.

---
title: '`SignUpInitialValues`'
description: The type for the `initialValues` prop that is used to pre-populate the sign-up form.
---

The type for the `initialValues` prop that is used to pre-populate the sign-up form.

## Properties

<Properties>
  - `emailAddress?`
  - `string | undefined`

  The user's email address.

  ---

  - `username?`
  - `string | undefined`

  The user's username.

  ---

  - `phoneNumber?`
  - `string | undefined`

  The user's phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).

  ---

  - `firstName?`
  - `string | undefined`

  The user's first name.

  ---

  - `lastName?`
  - `string | undefined`

  The user's last name.
</Properties>

---
title: '`SignUpRedirectOptions`'
description: An interface that provides options for sign-up redirect methods.
---

An interface that provides options for sign-up redirect methods.

## Properties

<Properties>
  - `signInForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs in. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs up. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signInFallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs in, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpFallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs up, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.
</Properties>

---
title: '`TOTPResource`'
description: An interface that represents a TOTP secret.
---

An interface that represents a TOTP secret.

<Properties>
  - `id`
  - `string`

  The unique identifier for this TOTP secret.

  ---

  - `secret?`
  - `string`

  The generated TOTP secret. This is only returned to the client upon creation and cannot be retrieved afterwards.

  ---

  - `uri?`
  - `string`

  A complete TOTP configuration URI including the Issuer, Account, etc that can be pasted to an authenticator app or encoded to a QR code and scanned for convenience. This is only returned to the client upon creation and cannot be retrieved afterwards.

  ---

  - `verified`
  - `boolean`

  A boolean indicating whether this TOTP secret has been verified by the user by providing one code generated with it. TOTP is not enabled on the user unless they have a verified secret.

  ---

  - `backupCodes?`
  - `string[]`

  A set of fresh generated Backup codes. This will be populated if the feature is enabled in your instance and the user doesn't already have backup codes generated.

  ---

  - `createdAt`
  - `Date`

  The date when the TOTP secret was created.

  ---

  - `updatedAt`
  - `Date`

  The date when the TOTP secret was last updated.
</Properties>

---
title: '`unbanUser()`'
description: Use Clerk's Backend SDK to remove the ban mark from a user.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L255 */}

Removes the ban mark from the given [`User`](/docs/references/backend/types/backend-user).

```ts
function unbanUser(userId: string): Promise<User>
```

## Parameters

<Properties>
  - `userId`
  - `string`

  The ID of the user to unban.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const userId = 'user_123'

const response = await clerkClient.users.unbanUser(userId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/users/{user_id}/unban`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/UnbanUser){{ target: '_blank' }} for more information.

---
title: '`unlockUser()`'
description: Use Clerk's Backend SDK to remove a sign-in lock from a user.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L271 */}

Removes a sign-in lock from the given [`User`](/docs/references/backend/types/backend-user).

```ts
function unlockUser(userId: string): Promise<User>
```

## Parameters

<Properties>
  - `userId`
  - `string`

  The ID of the user to unlock.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const userId = 'user_123'

const response = await clerkClient.users.unlockUser(userId)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/users/{user_id}/unlock`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/UnlockUser){{ target: '_blank' }} for more information.

---
title: '`updateEmailAddress()`'
description: Use Clerk's Backend SDK to update an email address.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/EmailAddressApi.ts#L37 */}

Updates an [`EmailAddress`](/docs/references/javascript/types/email-address).

```ts
function updateEmailAddress(
  emailAddressId: string,
  params: UpdateEmailAddressParams,
): Promise<EmailAddress>
```

## `UpdateEmailAddressParams`

<Properties>
  - `primary?`
  - `boolean`

  Whether or not to set the email address as the user's primary email address.

  ---

  - `verified?`
  - `boolean`

  Whether or not the email address is verified.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx {{ mark: [[12, 13]] }}
const emailAddressId = 'idn_123'

const params = { verified: false }

const response = await clerkClient.emailAddresses.updateEmailAddress(emailAddressId, params)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `PATCH/email_addresses/{email_address_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Email-Addresses#operation/UpdateEmailAddress){{ target: '_blank' }} for more information.

---
title: '`updateOrganization()`'
description: Use Clerk's Backend SDK to update an organization's name.
---

Updates an [`Organization`](/docs/references/backend/types/backend-organization).

```ts
function updateOrganization(params: UpdateOrganizationParams): Promise<Organization>
```

## `UpdateOrganizationParams`

<Properties>
  - `organizationId`
  - `string`

  The organization ID of the organization being updated.

  ---

  - `name?`
  - `string`

  The updated name of the organization.

  ---

  - `slug?`
  - `string`

  The updated slug of the organization.

  ---

  - `publicMetadata?`
  - [`OrganizationPublicMetadata`](/docs/references/javascript/types/metadata#organization-public-metadata)

  Metadata that can be read from both the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }}, but can be set only from the Backend API. Updating this property will override the existing metadata. To merge metadata, use [`updateOrganizationMetadata()`](/docs/references/backend/organization/update-organization-metadata).

  ---

  - `privateMetadata?`
  - [`OrganizationPrivateMetadata`](/docs/references/javascript/types/metadata#organization-private-metadata)

  Metadata that is only visible to your [Backend API](/docs/reference/backend-api){{ target: '_blank' }}. Updating this property will override the existing metadata. To merge metadata, use [`updateOrganizationMetadata()`](/docs/references/backend/organization/update-organization-metadata).

  ---

  - `maxAllowedMemberships?`
  - `number`

  The maximum number of memberships allowed in the organization. Setting this value to `0` removes any limit, allowing an unlimited number of memberships.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx {{ mark: [3, 11] }}
const organizationId = 'org_123'

const name = 'Test Updated'

const response = await clerkClient.organizations.updateOrganization(organizationId, { name })
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `PATCH/organizations/{organization_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Organizations#operation/UpdateOrganization){{ target: '_blank' }} for more information.

---
title: '`updateOrganizationLogo()`'
description: Use Clerk's Backend SDK to update an organization's logo.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/OrganizationApi.ts#L136 */}

Updates the organization's logo. Returns an [`Organization`](/docs/references/backend/types/backend-organization) object.

```ts
function updateOrganizationLogo(
  organizationId: string,
  params: UpdateLogoParams,
): Promise<Organization>
```

## `UpdateLogoParams`

<Properties>
  - `file`
  - `Blob | File`

  The file to upload as the organization's logo.

  ---

  - `uploaderUserId?`
  - `string`

  The ID of the user uploading the logo.
</Properties>

## Example

<Include src="_partials/backend/usage" />

> [!WARNING]
> Using Backend SDK methods can contribute towards rate limiting. To set an organization's logo, it's recommended to use the frontend [`organization.setLogo()`](/docs/references/javascript/organization#set-logo) method instead.

```tsx
const organizationId = 'org_123'
const uploaderUserId = 'user_123'

const fileBits = ['logo-pic-content']
const fileName = 'logo.png'
const file = new File(fileBits, fileName, { type: 'image/png' })

const params = {
  file,
  uploaderUserId,
}

const response = await clerkClient.organizations.updateOrganizationLogo(organizationId, params)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `PUT/organizations/{organization_id}/logo`. See the [BAPI reference](/docs/reference/backend-api/tag/Organizations#operation/UploadOrganizationLogo){{ target: '_blank' }} for more information.

---
title: '`updateOrganizationMembership()`'
description: Use Clerk's Backend SDK to update a user's organization membership.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/OrganizationApi.ts#L201 */}

Updates a user's [`OrganizationMembership`](/docs/references/backend/types/backend-organization-membership). Currently, only the role can be updated.

```ts
function updateOrganizationMembership(
  params: UpdateOrganizationMembershipParams,
): Promise<OrganizationMembership>
```

## `UpdateOrganizationMembershipParams`

<Properties>
  - `organizationId`
  - `string`

  The ID of the organization this membership belongs to.

  ---

  - `userId`
  - `string`

  The ID of the user that this membership belongs to.

  ---

  - `role`
  - `string`

  The [role](/docs/organizations/roles-permissions) to assign user.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx {{ mark: [5, 17] }}
const organizationId = 'org_123'

const userId = 'user_123'

const role = 'org:admin'

const response = await clerkClient.organizations.updateOrganizationMembership({
  organizationId,
  userId,
  role,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `PATCH/organizations/{organization_id}/memberships/{user_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Organization-Memberships#operation/UpdateOrganizationMembership){{ target: '_blank' }} for more information.

---
title: '`updateOrganizationMembershipMetadata()`'
description: Use Clerk's Backend SDK to update the metadata associated with a user's organization membership.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/OrganizationApi.ts#L214 */}

Update the metadata attributes of an [`OrganizationMembership`](/docs/references/backend/types/backend-organization-membership) by merging existing values with the provided parameters. Metadata values will be updated via a "deep" merge - "deep" means that any nested JSON objects will be merged as well. You can remove metadata keys at any level by setting their value to `null`.

```ts
function updateOrganizationMembershipMetadata(
  params: UpdateOrganizationMembershipMetadataParams,
): Promise<OrganizationMembership>
```

## `UpdateOrganizationMembershipMetadataParams`

<Properties>
  - `organizationId`
  - `string`

  The ID of the organization this membership belongs to.

  ---

  - `userId`
  - `string`

  The ID of the user that this membership belongs to.

  ---

  - `publicMetadata?`
  - [`OrganizationMembershipPublicMetadata`](/docs/references/javascript/types/metadata#organization-membership-public-metadata)

  Metadata that can be read from both the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }}, but can be set only from the Backend API.

  ---

  - `privateMetadata?`
  - [`OrganizationMembershipPrivateMetadata`](/docs/references/javascript/types/metadata#organization-membership-private-metadata)

  Metadata that is only visible to your [Backend API](/docs/reference/backend-api){{ target: '_blank' }}.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx {{ mark: [[8, 10], 18] }}
const organizationId = 'org_123'

const userId = 'user_123'

const response = await clerkClient.organizations.updateOrganizationMembershipMetadata({
  organizationId,
  userId,
  publicMetadata: {
    example: 'this value is updated!',
  },
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `PATCH/organizations/{organization_id}/memberships/{user_id}/metadata`. See the [BAPI reference](/docs/reference/backend-api/tag/Organization-Memberships#operation/UpdateOrganizationMembershipMetadata){{ target: '_blank' }} for more information.

---
title: '`updateOrganizationMetadata()`'
description: Use Clerk's Backend SDK to update the metadata associated with a given organization.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/OrganizationApi.ts#L159 */}

Updates the metadata attributes of an [`Organization`](/docs/references/backend/types/backend-organization) by merging existing values with the provided parameters. Metadata values will be updated via a "deep" merge - "deep" meaning that any nested JSON objects will be merged as well. You can remove metadata keys at any level by setting their value to `null`.

```ts
function updateOrganizationMetadata(
  organizationId: string,
  params: UpdateOrganizationMetadataParams,
): Promise<Organization>
```

## `UpdateOrganizationMetadataParams`

<Properties>
  - `organizationId`
  - `string`

  The ID of the organization to update.

  ---

  - `publicMetadata?`
  - [`OrganizationPublicMetadata`](/docs/references/javascript/types/metadata#organization-public-metadata)

  Metadata that can be read from both the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }}, but can be set only from the Backend API .

  ---

  - `privateMetadata?`
  - [`OrganizationPrivateMetadata`](/docs/references/javascript/types/metadata#organization-private-metadata)

  Metadata that is only visible to your [Backend API](/docs/reference/backend-api){{ target: '_blank' }}.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx {{ mark: [[4, 6], 20] }}
const organizationId = 'org_123'

const response = await clerkClient.organizations.updateOrganizationMetadata(organizationId, {
  publicMetadata: {
    example: 'metadata',
  },
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `PATCH/organizations/{organization_id}/metadata`. See the [BAPI reference](/docs/reference/backend-api/tag/Organizations#operation/MergeOrganizationMetadata){{ target: '_blank' }} for more information.

---
title: '`updatePhoneNumber()`'
description: Use Clerk's Backend SDK to update a phone number.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/PhoneNumberApi.ts#L37 */}

Updates a [`PhoneNumber`](/docs/references/javascript/types/phone-number).

```ts
function updatePhoneNumber(
  phoneNumberId: string,
  params: UpdatePhoneNumberParams,
): Promise<PhoneNumber>
```

## `UpdatePhoneNumberParams`

<Properties>
  - `primary?`
  - `boolean`

  Whether or not to set the phone number as the user's primary phone number.

  ---

  - `verified?`
  - `boolean`

  Whether or not the phone number is verified.

  ---

  - `reservedForSecondFactor`
  - `boolean`

  Whether or not the phone number is reserved for [multi-factor authentication](/docs/authentication/configuration/sign-up-sign-in-options#multi-factor-authentication). The phone number must also be verified. If there are no other reserved second factors, the phone number will be set as the default second factor.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx {{ mark: [3, [14, 15]] }}
const phoneNumberId = 'idn_123'

const params = { verified: false }

const response = await clerkClient.phoneNumbers.updatePhoneNumber(phoneNumberId, params)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `PATCH/phone_numbers/{phone_number_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Phone-Numbers#operation/UpdatePhoneNumber){{ target: '_blank' }} for more information.

---
title: '`updateSamlConnection()`'
description: Use Clerk's Backend SDK to update a SAML connection.
---

Updates a [`SamlConnection`](/docs/references/backend/types/saml-connection) by its ID.

```ts
function updateSamlConnection(
  samlConnectionId: string,
  params: UpdateSamlConnectionParams = {},
): Promise<Organization>
```

## `UpdateSamlConnectionParams`

<Properties>
  - `name?`
  - `string`

  The name to use as a label for this SAML Connection.

  ---

  - `provider?`
  - `'saml_custom' | 'saml_okta' | 'saml_google' | 'saml_microsoft'`

  The IdP provider of the connection.

  ---

  - `domain?`
  - `string`

  The domain of your organization. Sign in flows using an email with this domain will use this SAML Connection. For example: `'clerk.dev'`

  ---

  - `organizationId?`
  - `string`

  The ID of the organization to which users of this SAML Connection will be added

  ---

  - `idpEntityId?`
  - `string`

  The Entity ID as provided by the IdP.

  ---

  - `idpSsoUrl?`
  - `string`

  The Single-Sign On URL as provided by the IdP.

  ---

  - `idpCertificate?`
  - `string`

  The X.509 certificate as provided by the IdP.

  ---

  - `idpMetadataUrl?`
  - `string`

  The URL which serves the IdP metadata. If present, it takes priority over the corresponding individual properties.

  ---

  - `idpMetadata?`
  - `string`

  The XML content of the IdP metadata file. If present, it takes priority over the corresponding individual properties.

  ---

  - `attributeMapping?`
  - `{ emailAddress?: string, firstName?: string, lastName?: string, userId?: string }`

  The attribute mapping for the SAML connection.

  ---

  - `active?`
  - `boolean`

  Indicates whether the connection is active or not.

  ---

  - `syncUserAttributes?`
  - `boolean`

  Indicates whether the connection syncs user attributes between the Service Provider (SP) and Identity Provider (IdP) or not.

  ---

  - `allowSubdomains?`
  - `boolean`

  Indicates whether users with an email address subdomain are allowed to use this connection in order to authenticate or not.

  ---

  - `allowIdpInitiated?`
  - `boolean`

  Indicates whether the connection allows Identity Provider (IdP) initiated flows or not.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const samlConnectionId = 'samlc_123'

const response = await clerkClient.samlConnections.updateSamlConnection(samlConnectionId, {
  name: 'Updated SAML Connection',
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `PATCH/saml_connections/{saml_connection_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/SAML-Connections#operation/UpdateSAMLConnection){{ target: '_blank' }} for more information.

---
title: '`updateUser()`'
description: Use Clerk's Backend SDK to update a user.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L148 */}

Updates a [`User`](/docs/references/backend/types/backend-user).

```ts
function updateUser(userId: string, params: UpdateUserParams): Promise<User>
```

## `UpdateUserParams`

<Properties>
  - `userId`
  - `string`

  The ID of the user to update.

  ---

  - `externalId?`
  - `string`

  The ID of the user as used in your external systems or your previous authentication solution. Must be unique across your instance.

  ---

  - `firstName?`
  - `string`

  The user's first name.

  ---

  - `lastName?`
  - `string`

  The user's last name.

  ---

  - `primaryEmailAddressID?`
  - `string`

  The ID of the email address to set as primary. It must be verified, and present on the current user.

  ---

  - `notifyPrimaryEmailAddressChanged?`
  - `boolean`

  If set to `true`, the user will be notified that their primary email address has changed. By default, no notification is sent. Defaults to `false`.

  ---

  - `primaryPhoneNumberID?`
  - `string`

  The ID of the phone number to set as primary. It must be verified, and present on the current user.

  ---

  - `primaryWeb3WalletID?`
  - `string`

  The ID of the Web3 wallet to set as primary. It must be verified, and present on the current user.

  ---

  - `username?`
  - `string`

  The user's username. It must be unique across your instance.

  ---

  - `profileImageID?`
  - `string`

  The ID of the image to set as the user's profile image.

  ---

  - `password?`
  - `string`

  The plaintext password to give the user. Must be at least 8 characters long, and can not be in any list of hacked passwords.

  ---

  - `passwordDigest?`
  - `string`

  In case you already have the password digests and not the passwords, you can use them for the newly created user via this property. The digests should be generated with one of the supported algorithms. The hashing algorithm can be specified using the `password_hasher` property.

  ---

  - `passwordHasher?`
  - `'argon2i' | 'argon2id' | 'bcrypt' | 'bcrypt_sha256_django' | 'md5' | 'pbkdf2_sha256' | 'pbkdf2_sha256_django' | 'pbkdf2_sha1' | 'phpass' | 'scrypt_firebase' | 'scrypt_werkzeug' | 'sha256'`

  The hashing algorithm that was used to generate the password digest. Each of the supported hashers expects the incoming digest to be in a particular format. See the [Clerk Backend API reference](/docs/reference/backend-api/tag/Users#operation/CreateUser){{ target: '_blank' }} for more information.

  ---

  - `skipPasswordChecks?`
  - `boolean`

  When set to `true`, all password checks are skipped. It is recommended to use this method only when migrating plaintext passwords to Clerk. Upon migration the user base should be prompted to pick stronger password.

  ---

  - `skipPasswordRequirement?`
  - `boolean`

  When set to `true`, password is not required anymore when creating the user and can be omitted. This is useful when you are trying to create a user that doesn't have a password, in an instance that is using passwords. You cannot use this flag if password is the only way for a user to sign into your instance.

  ---

  - `signOutOfOtherSessions?`
  - `boolean`

  Set to `true` to sign out the user from all their active sessions once their password is updated. Can only be used when providing the `password` parameter.

  ---

  - `totpSecret?`
  - `string`

  In case TOTP is configured on the instance, you can provide the secret to enable it on the newly created user without the need to reset it. Currently, the supported options are: <ul><li>Period: 30 seconds</li><li>Code length: 6 digits</li><li>Algorithm: SHA1</li></ul>

  ---

  - `backupCodes?`
  - `string[]`

  If backup codes are configured on the instance, you can provide them to enable it on the newly created user without the need to reset them. You must provide the backup codes in plain format or the corresponding bcrypt digest.

  ---

  - `publicMetadata?`
  - [`UserPublicMetadata`](/docs/references/javascript/types/metadata#user-public-metadata)

  Metadata that can be read from the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }} and can be set only from the Backend API. Updating this property will override the existing metadata. To merge metadata, use [`updateUserMetadata()`](/docs/references/backend/user/update-user-metadata).

  ---

  - `privateMetadata?`
  - [`UserPrivateMetadata`](/docs/references/javascript/types/metadata#user-private-metadata)

  Metadata that can be read and set only from the [Backend API](/docs/reference/backend-api){{ target: '_blank' }}. Updating this property will override the existing metadata. To merge metadata, use [`updateUserMetadata()`](/docs/references/backend/user/update-user-metadata).

  ---

  - `unsafeMetadata?`
  - [`UserUnsafeMetadata`](/docs/references/javascript/types/metadata#user-unsafe-metadata)

  Metadata that can be read and set from the Frontend API. It's considered unsafe because it can be modified from the frontend.

  ---

  - `deleteSelfEnabled?`
  - `boolean`

  If `true`, the user can delete themselves with the Frontend API.

  ---

  - `createOrganizationEnabled?`
  - `boolean`

  If `true`, the user can create organizations with the Frontend API.

  ---

  - `createOrganizationsLimit?`
  - `number`

  An integer indicating the number of organizations that can be created by the user. If the value is `0`, then the user can create unlimited organizations. Default is `null`.

  ---

  - `legalAcceptedAt?`
  - `Date`

  The date when the user accepted the legal documents. `null` if [**Require express consent to legal documents**](/docs/authentication/configuration/legal-compliance) is not enabled.

  ---

  - `skipLegalChecks?`
  - `boolean`

  When set to `true` all legal checks are skipped. It is not recommended to skip legal checks unless you are migrating a user to Clerk.

  ---

  - `createdAt?`
  - `Date`

  A custom date/time denoting when the user signed up to the application, specified in RFC3339 format. For example: `2012-10-20T07:15:20.902Z`.

  ---

  - `skipLegalChecks?`
  - `boolean`

  When set to `true` all legal checks are skipped. It is not recommended to skip legal checks unless you are migrating a user to Clerk.

  ---

  - `legalAcceptedAt?`
  - `Date`

  A custom date/time denoting when the user accepted legal requirements, specified in RFC3339 format. For example: `2012-10-20T07:15:20.902Z`.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const userId = 'user_123'

const params = { firstName: 'John', lastName: 'Wick' }

const response = await clerkClient.users.updateUser(userId, params)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `PATCH/users/{user_id}`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/UpdateUser){{ target: '_blank' }} for more information.

---
title: '`updateUserMetadata()`'
description: Use Clerk's Backend SDK to update the metadata associated with the specified user.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L171 */}

Updates the metadata associated with the specified user by merging existing values with the provided parameters.

A "deep" merge will be performed - "deep" means that any nested JSON objects will be merged as well. You can remove metadata keys at any level by setting their value to `null`.

Returns a [`User`](/docs/references/backend/types/backend-user) object.

```ts
function updateUserMetadata(userId: string, params: UpdateUserMetadataParams): Promise<User>
```

## `UpdateUserMetadataParams`

<Properties>
  - `userId`
  - `string`

  The ID of the user to update.

  ---

  - `publicMetadata?`
  - [`UserPublicMetadata`](/docs/references/javascript/types/metadata#user-public-metadata)

  Metadata that can be read from the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }} and can be set only from the Backend API.

  ---

  - `privateMetadata?`
  - [`UserPrivateMetadata`](/docs/references/javascript/types/metadata#user-private-metadata)

  Metadata that can be read and set only from the [Backend API](/docs/reference/backend-api){{ target: '_blank' }}.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const userId = 'user_123'

const response = await clerkClient.users.updateUserMetadata(userId, {
  publicMetadata: {
    example: 'metadata',
  },
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `PATCH/users/{user_id}/metadata`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/UpdateUserMetadata){{ target: '_blank' }} for more information.

---
title: '`updateUserProfileImage()`'
description: Use Clerk's Backend SDK to update a user's profile image.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L158 */}

Updates a user's profile image. Returns a [`User`](/docs/references/backend/types/backend-user) object.

```ts
function updateUserProfileImage(userId: string, params: { file: Blob | File }): Promise<User>
```

## Example

<Include src="_partials/backend/usage" />

> [!WARNING]
> Using Backend SDK methods can contribute towards rate limiting. To set a user's profile image, it's recommended to use the frontend [`user.setProfileImage()`](/docs/references/javascript/user#set-profile-image) method instead.

```tsx
const userId = 'user_123'
const fileBits = ['profile-pic-content']
const fileName = 'profile-pic.png'
const file = new File(fileBits, fileName, { type: 'image/png' })

const params = {
  file,
}

const response = await clerkClient.users.updateUserProfileImage(userId, params)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/users/{user_id}/profile_image`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/SetUserProfileImage){{ target: '_blank' }} for more information.

---
title: '`useLocalCredentials()`'
description: Clerk's useLocalCredentials() hook enables you to store and access a user's password credentials on their device.
---

The `useLocalCredentials()` hook enables you to store a user's password credentials on their device and subsequently use biometrics for sign-in. This enhances the user experience by allowing users to sign in using Face ID or another biometric authentication method during future sign-ins.

> [!WARNING]
> This hook isn't supported in web apps and can only be used in native apps.
> This API is available only for [`@clerk/clerk-expo >=2.2.0`](/docs/upgrade-guides/expo/v2).
> Be aware that this works only for sign-in attempts with the [password strategy](/docs/authentication/configuration/sign-up-sign-in-options#authentication-strategies).

## Returns

<Properties>
  - `hasCredentials`
  - `boolean`

  Indicates if there are any credentials stored on the device.

  ---

  - `userOwnsCredentials`
  - `boolean`

  Indicates if the stored credentials belong to the signed in user. When there is no signed-in user, the value will always be `false`.

  ---

  - `biometricType`
  - `'face-recognition' | 'fingerprint' | null`

  Indicates the supported enrolled biometric authenticator type.

  ---

  - `setCredentials()`
  - <code>(params: [LocalCredentials](#local-credentials)) => Promise\<void></code>

  Stores the provided credentials on the device if the device has enrolled biometrics. The end user needs to have a passcode set in order for the credentials to be stored, and those credentials will be removed if the passcode gets removed. The promise will reject if the value cannot be stored on the device.

  ---

  - `clearCredentials()`
  - <code>() => Promise\<void></code>

  Removes the stored credentials from the device. The promise will reject if the value cannot be deleted from the device.

  ---

  - `authenticate()`
  - <code>() => Promise\<[SignInResource](/docs/references/javascript/sign-in)></code>

  Attempts to read the stored credentials and creates a sign-in attempt with the password strategy.The promise will resolve to a `SignInResource` if the stored credentials were accessed. Otherwise, the promise will reject.
</Properties>

### `LocalCredentials`

<Properties>
  - `identifier`
  - `string?`

  The identifier of the credentials to be stored on the device. It can be a username, email, phone number, etc.

  ---

  - `password`
  - `string`

  The password for the identifier to be stored on the device. If an identifier already exists on the device, passing only `password` would update the password for the stored identifier.
</Properties>

## How to use the `useLocalCredentials()` hook

To learn how to use the `useLocalCredentials()` hook, see the [reference doc](/docs/references/expo/local-credentials).

---
title: '`useOrganizationList()`'
description: Access and manage the current user's organization list in your React application with Clerk's useOrganizationList() hook.
---

The `useOrganizationList()` hook provides access to the current user's organization memberships, invitations, and suggestions. It also includes methods for creating new organizations and managing the active organization.

## Parameters

`useOrganizationList()` accepts a single object with the following properties:

<Properties>
  - `userMemberships`
  - `true | { SharedProperties }`

  If set to `true`, all default properties will be used.

  Otherwise, accepts an object with the following optional properties:

  - Any of the properties described in [Shared properties](#shared-properties).

  ---

  - `userInvitations`
  - `true | { status?: 'pending' | 'accepted' | 'revoked' } & { SharedProperties }`

  If set to `true`, all default properties will be used.

  Otherwise, accepts an object with the following optional properties:

  - `status`: A string that filters the invitations by the provided status.
  - Any of the properties described in [Shared properties](#shared-properties).

  ---

  - `userSuggestions`
  - `true | { status?: 'pending' | 'accepted' } & { SharedProperties }`

  If set to `true`, all default properties will be used.

  Otherwise, accepts an object with the following optional properties:

  - `status`: A string that filters the suggestions by the provided status.
  - Any of the properties described in [Shared properties](#shared-properties).
</Properties>

> [!WARNING]
> By default, the `userMemberships`, `userInvitations`, and `userSuggestions` attributes are not populated. To fetch and paginate the data, you must pass `true` or an object with the desired properties.

### Shared properties

Optional properties that are shared across the `userMemberships`, `userInvitations`, and `userSuggestions` properties.

<Include src="_partials/hooks/shared-properties" />

## Returns

<Properties>
  - `isLoaded`
  - `boolean`

  A boolean that indicates whether Clerk has completed initialization. Initially `false`, becomes `true` once Clerk loads.

  ---

  - `createOrganization()`
  - <code>(params: [CreateOrganizationParams](#create-organization-params)) => Promise\<[OrganizationResource](/docs/references/javascript/organization)></code>

  A function that returns a `Promise` which resolves to the newly created `Organization`.

  ---

  - `setActive()`
  - <code>(params: [SetActiveParams](/docs/references/javascript/types/set-active-params)) => Promise\<void></code>

  A function that sets the active session and/or organization.

  ---

  - `userMemberships`
  - <code>[PaginatedResources](#paginated-resources)[\<OrganizationMembership>](/docs/references/javascript/types/organization-membership)</code>

  Returns `PaginatedResources` which includes a list of the user's organization memberships.

  ---

  - `userInvitations`
  - <code>[PaginatedResources](#paginated-resources)[\<OrganizationInvitation>](/docs/references/javascript/types/organization-invitation)</code>

  Returns `PaginatedResources` which includes a list of the user's organization invitations.

  ---

  - `userSuggestions`
  - <code>[PaginatedResources](#paginated-resources)[\<OrganizationSuggestion>](/docs/references/javascript/types/organization-suggestion)</code>

  Returns `PaginatedResources` which includes a list of suggestions for organizations that the user can join.
</Properties>

### `CreateOrganizationParams`

<Properties>
  - `name`
  - `string`

  The name of the organization.

  ---

  - `slug?`
  - `string`

  The slug of the organization.
</Properties>

### `PaginatedResources`

<Include src="_partials/hooks/paginated-resources" />

## How to use the `useOrganizationList()` hook

### Expanding and paginating attributes

To keep network usage to a minimum, developers are required to opt-in by specifying which resource they need to fetch and paginate through. So by default, the `userMemberships`, `userInvitations`, and `userSuggestions` attributes are not populated. You must pass `true` or an object with the desired [properties](#shared-properties) to fetch and paginate the data.

```jsx
// userMemberships.data will never be populated
const { userMemberships } = useOrganizationList()

// Use default values to fetch userMemberships, such as initialPage = 1 and pageSize = 10
const { userMemberships } = useOrganizationList({
  userMemberships: true,
})

// Pass your own values to fetch userMemberships
const { userMemberships } = useOrganizationList({
  userMemberships: {
    pageSize: 20,
    initialPage: 2, // skips the first page
  },
})

// Aggregate pages in order to render an infinite list
const { userMemberships } = useOrganizationList({
  userMemberships: {
    infinite: true,
  },
})
```

### Infinite pagination

The following example demonstrates how to use the `infinite` property to fetch and append new data to the existing list. The `userMemberships` attribute will be populated with the first page of the user's organization memberships. When the "Load more" button is clicked, the `fetchNext` helper function will be called to append the next page of memberships to the list.

<Tabs items={['React', 'Next.js']}>
  <Tab>
    ```tsx {{ filename: 'src/components/JoinedOrganizations.tsx' }}
    import { useOrganizationList } from '@clerk/clerk-react'
    import React from 'react'

    const JoinedOrganizations = () => {
      const { isLoaded, setActive, userMemberships } = useOrganizationList({
        userMemberships: {
          infinite: true,
        },
      })

      if (!isLoaded) {
        return <>Loading</>
      }

      return (
        <>
          <ul>
            {userMemberships.data?.map((mem) => (
              <li key={mem.id}>
                <span>{mem.organization.name}</span>
                <button onClick={() => setActive({ organization: mem.organization.id })}>Select</button>
              </li>
            ))}
          </ul>

          <button disabled={!userMemberships.hasNextPage} onClick={() => userMemberships.fetchNext()}>
            Load more
          </button>
        </>
      )
    }

    export default JoinedOrganizations
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'components/JoinedOrganizations.tsx' }}
    'use client'

    import { useOrganizationList } from '@clerk/nextjs'

    export const JoinedOrganizations = () => {
      const { isLoaded, setActive, userMemberships } = useOrganizationList({
        userMemberships: {
          infinite: true,
        },
      })

      if (!isLoaded) {
        return <>Loading</>
      }

      return (
        <>
          <ul>
            {userMemberships.data?.map((mem) => (
              <li key={mem.id}>
                <span>{mem.organization.name}</span>
                <button onClick={() => setActive({ organization: mem.organization.id })}>Select</button>
              </li>
            ))}
          </ul>

          <button disabled={!userMemberships.hasNextPage} onClick={() => userMemberships.fetchNext()}>
            Load more
          </button>
        </>
      )
    }
    ```
  </Tab>
</Tabs>

### Simple pagination

The following example demonstrates how to use the `fetchPrevious` and `fetchNext` helper functions to paginate through the data. The `userInvitations` attribute will be populated with the first page of invitations. When the "Previous page" or "Next page" button is clicked, the `fetchPrevious` or `fetchNext` helper function will be called to fetch the previous or next page of invitations.

Notice the difference between this example's pagination and the infinite pagination example above.

<Tabs items={['React', 'Next.js']}>
  <Tab>
    ```tsx {{ filename: 'src/components/UserInvitationsTable.tsx' }}
    import { useOrganizationList } from '@clerk/clerk-react'
    import React from 'react'

    const UserInvitationsTable = () => {
      const { isLoaded, userInvitations } = useOrganizationList({
        userInvitations: {
          infinite: true,
          keepPreviousData: true,
        },
      })

      if (!isLoaded || userInvitations.isLoading) {
        return <>Loading</>
      }

      return (
        <>
          <table>
            <thead>
              <tr>
                <th>Email</th>
                <th>Org name</th>
              </tr>
            </thead>

            <tbody>
              {userInvitations.data?.map((inv) => (
                <tr key={inv.id}>
                  <th>{inv.emailAddress}</th>
                  <th>{inv.publicOrganizationData.name}</th>
                </tr>
              ))}
            </tbody>
          </table>

          <button disabled={!userInvitations.hasPreviousPage} onClick={userInvitations.fetchPrevious}>
            Prev
          </button>
          <button disabled={!userInvitations.hasNextPage} onClick={userInvitations.fetchNext}>
            Next
          </button>
        </>
      )
    }

    export default UserInvitationsTable
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'components/UserInvitationsTable.tsx' }}
    'use client'

    import { useOrganizationList } from '@clerk/nextjs'

    export const UserInvitationsTable = () => {
      const { isLoaded, userInvitations } = useOrganizationList({
        userInvitations: {
          infinite: true,
          keepPreviousData: true,
        },
      })

      if (!isLoaded || userInvitations.isLoading) {
        return <>Loading</>
      }

      return (
        <>
          <table>
            <thead>
              <tr>
                <th>Email</th>
                <th>Org name</th>
              </tr>
            </thead>

            <tbody>
              {userInvitations.data?.map((inv) => (
                <tr key={inv.id}>
                  <th>{inv.emailAddress}</th>
                  <th>{inv.publicOrganizationData.name}</th>
                </tr>
              ))}
            </tbody>
          </table>

          <button disabled={!userInvitations.hasPreviousPage} onClick={userInvitations.fetchPrevious}>
            Prev
          </button>
          <button disabled={!userInvitations.hasNextPage} onClick={userInvitations.fetchNext}>
            Next
          </button>
        </>
      )
    }
    ```
  </Tab>
</Tabs>

To see the different organization features integrated into one application, take a look at our [organizations demo repository](https://github.com/clerk/organizations-demo).

---
title: '`User` object'
description: The User object holds all the information for a user of your application and provides a set of methods to manage their account. Users have a unique authentication identifier which might be their email address, phone number or a username.
---

<Include src="_partials/user-object" />

The ClerkJS SDK provides some helper [methods](#methods) on the `User` object to help retrieve and update user information and authentication status.

## Properties

<Properties>
  - `backupCodeEnabled`
  - `boolean`

  A boolean indicating whether the user has enabled backup codes for their account.

  ---

  - `createdAt`
  - `Date`

  The date when the user was first created.

  ---

  - `createOrganizationEnabled`
  - `boolean`

  A boolean indicating whether the organization creation permission is enabled for the user. Defaults to `false`.

  ---

  - `createOrganizationsLimit`
  - `number`

  A number indicating the number of organizations that can be created by the user. If the value is `0`, then the user can create unlimited organizations. Defaults to `null`.

  ---

  - `deleteSelfEnabled`
  - `boolean`

  A boolean indicating whether the user is able to delete their own account.

  ---

  - `emailAddresses`
  - <code>\[EmailAddress]\[email-ref]\[]</code>

  An array of all the `EmailAddress` objects associated with the user. Includes the primary.

  ---

  - `enterpriseAccounts`
  - <code>[EnterpriseAccount](/docs/references/javascript/types/enterprise-account)\[]</code>

  An array of all the `EnterpriseAccount` objects associated with the user.

  ---

  - `externalAccounts`
  - <code>\[ExternalAccount]\[exacc-ref]\[]</code>

  An array of all the `ExternalAccount` objects associated with the user via OAuth. This includes both verified & unverified external accounts.

  ---

  - `externalId`
  - `string | null`

  The user's ID as used in your external systems. Must be unique across your instance.

  ---

  - `firstName`
  - `string | null`

  The user's first name.

  ---

  - `fullName`
  - `string | null`

  The user's full name.

  ---

  - `hasImage`
  - `boolean`

  A boolean that indicates whether the user has uploaded an image or one was copied from OAuth. Returns `false` if Clerk is displaying an avatar for the user.

  ---

  - `hasVerifiedEmailAddress`
  - `boolean`

  A boolean that indicates whether the user has verified an email address.

  ---

  - `hasVerifiedPhoneNumber`
  - `boolean`

  A boolean that indicates whether the user has verified a phone number.

  ---

  - `id`
  - `string`

  The user's unique identifier.

  ---

  - `imageUrl`
  - `string`

  Holds the default avatar or user's uploaded profile image. Compatible with Clerk's [Image Optimization](/docs/guides/image-optimization).

  ---

  - `lastSignInAt`
  - `Date | null`

  The date when the user last signed in. `null` if the user has never signed in.

  ---

  - `lastName`
  - `string | null`

  The user's last name.

  ---

  - `legalAcceptedAt`
  - `Date`

  The date when the user accepted the legal documents. `null` if [**Require express consent to legal documents**](/docs/authentication/configuration/legal-compliance) is not enabled.

  ---

  - `organizationMemberships`
  - <code>[OrganizationMembership](/docs/references/javascript/types/organization-membership)\[]</code>

  A list of `OrganizationMembership`s representing the list of organizations the user is member with.

  ---

  - `passkeys`
  - <code>[PasskeyResource](/docs/references/javascript/types/passkey-resource)\[] | null</code>

  An array of passkeys associated with the user's account.

  ---

  - `passwordEnabled`
  - `boolean`

  A boolean indicating whether the user has a password on their account.

  ---

  - `phoneNumbers`
  - <code>\[PhoneNumber]\[phone-ref]\[]</code>

  An array of all the `PhoneNumber` objects associated with the user. Includes the primary.

  ---

  - `primaryEmailAddress`
  - <code>\[EmailAddress]\[email-ref] | null</code>

  Information about the user's primary email address.

  ---

  - `primaryEmailAddressId`
  - `string | null`

  The ID for the `EmailAddress` that the user has set as primary.

  ---

  - `primaryPhoneNumber`
  - <code>\[PhoneNumber]\[phone-ref] | null</code>

  Information about the user's primary phone number.

  ---

  - `primaryPhoneNumberId`
  - `string | null`

  The ID for the `PhoneNumber` that the user has set as primary.

  ---

  - `primaryWeb3Wallet`
  - <code>\[Web3Wallet]\[web3-ref] | null</code>

  The `Web3Wallet` that the user signed up with.

  ---

  - `primaryWeb3WalletId`
  - `string | null`

  The ID for the \[`Web3Wallet`]\[web3-ref] that the user signed up with.

  ---

  - `privateMetadata`
  - [`UserPrivateMetadata`](/docs/references/javascript/types/metadata#user-private-metadata)

  Metadata that can be read and set only from the [Backend API](/docs/reference/backend-api){{ target: '_blank' }}.

  ---

  - `publicMetadata`
  - [`UserPublicMetadata`](/docs/references/javascript/types/metadata#user-public-metadata)

  Metadata that can be read from the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }} and can be set only from the Backend API.

  ---

  - `samlAccounts` (deprecated)
  - <code>[SamlAccount](/docs/references/javascript/types/saml-account)\[]</code>

  **Deprecated in favor of `enterpriseAccounts`.** An array of all the `SamlAccount` objects associated with the user.

  ---

  - `totpEnabled`
  - `boolean`

  A boolean indicating whether the user has enabled TOTP by generating a TOTP secret and verifying it via an authenticator app.

  ---

  - `twoFactorEnabled`
  - `boolean`

  A boolean indicating whether the user has enabled two-factor authentication.

  ---

  - `unsafeMetadata`
  - [`UserUnsafeMetadata`](/docs/references/javascript/types/metadata#user-unsafe-metadata)

  Metadata that can be read and set from the Frontend API. It's considered unsafe because it can be modified from the frontend.

  There is also an `unsafeMetadata` attribute in the [`SignUp`](/docs/references/javascript/sign-up) object. The value of that field will be automatically copied to the user's unsafe metadata once the sign up is complete.

  ---

  - `updatedAt`
  - `Date`

  The date when the user was last updated.

  ---

  - `verifiedExternalAccounts`
  - <code>\[ExternalAccount]\[exacc-ref]\[]</code>

  An array of all the `ExternalAccount` objects associated with the user via OAuth that are verified.

  ---

  - `verifiedWeb3Wallets`
  - <code>\[Web3Wallet]\[web3-ref]\[]</code>

  An array of all the `Web3Wallet` objects associated with the user that are verified.

  ---

  - `unverifiedExternalAccounts`
  - <code>\[ExternalAccount]\[exacc-ref]\[]</code>

  An array of all the `ExternalAccount` objects associated with the user via OAuth that are not verified.

  ---

  - `username`
  - `string | null`

  The user's username.

  ---

  - `web3Wallets`
  - <code>\[Web3Wallet]\[web3-ref]\[]</code>

  An array of all the `Web3Wallet` objects associated with the user. Includes the primary.
</Properties>

## Methods

### `createBackupCode()`

Generates a fresh new set of backup codes for the user. Every time the method is called, it will replace the previously generated backup codes. Returns a [`BackupCodeResource`][backupcode-ref] object.

> [!WARNING]
> Can only be created for the user if the user has _another_ multi-factor authentication method enabled for their account, in the Clerk Dashboard, as backup codes are a fallback for when the user is unable to use their primary MFA method.

```typescript
function createBackupCode(): Promise<BackupCodeResource>
```

#### Example

```js
await clerk.user.createBackupCode()
```

### `createEmailAddress()`

Adds an email address for the user. A new [`EmailAddress`](/docs/references/javascript/types/email-address) will be created and associated with the user.

> [!WARNING]
> **Email address** must be enabled as an identifier in your app's settings in the Clerk Dashboard. See the [Identifiers](/docs/authentication/configuration/sign-up-sign-in-options#identifiers) section to learn more.

```ts
function createEmailAddress(params: CreateEmailAddressParams): Promise<EmailAddress>
```

#### `CreateEmailAddressParams`

<Properties>
  - `email`
  - `string`

  The email address to be added to the user.
</Properties>

#### Example

```js
await clerk.user.createEmailAddress({ email: 'test@test.com' })
```

### `createExternalAccount()`

Adds an external account for the user. A new [`ExternalAccount`](/docs/references/javascript/types/external-account) will be created and associated with the user. This method is useful if you want to allow an already signed-in user to connect their account with an external provider, such as Facebook, GitHub, etc., so that they can sign in with that provider in the future.

> [!WARNING]
> The social provider that you want to connect to must be enabled in your app's settings in the Clerk Dashboard. See the [Social connections (OAuth)](/docs/authentication/configuration/sign-up-sign-in-options#social-connections-o-auth) section to learn more.

```ts
function createExternalAccount(params: CreateExternalAccountParams): Promise<ExternalAccount>
```

#### `CreateExternalAccountParams`

<Properties>
  - `strategy`
  - [`OAuthStrategy`](/docs/references/javascript/types/sso#o-auth-strategy)

  The strategy corresponding to the OAuth provider. For example: `'oauth_facebook'`, `'oauth_github'`, etc.

  ---

  - `redirectUrl?`
  - `string`

  The full URL or path that the OAuth provider should redirect to, on successful authorization on their part. Typically, this will be a simple `/sso-callback` route that calls [`Clerk.handleRedirectCallback`](/docs/references/javascript/clerk#handle-redirect-callback) or mounts the [`<AuthenticateWithRedirectCallback />`](/docs/components/control/authenticate-with-callback) component. See the [custom flow](/docs/custom-flows/oauth-connections) for implementation details.

  ---

  - `additionalScopes?`
  - `string[]`

  Additional scopes for your user to be prompted to approve.

  ---

  - `oidcPrompt?`
  - `string`

  The value to pass to the [OIDC `prompt` parameter](https://openid.net/specs/openid-connect-core-1_0.html#:~:text=prompt,reauthentication%20and%20consent.) in the generated OAuth redirect URL.

  ---

  - `oidcLoginHint?`
  - `string`

  The value to pass to the [OIDC `login_hint` parameter](https://openid.net/specs/openid-connect-core-1_0.html#:~:text=login_hint,in%20\(if%20necessary\).) in the generated OAuth redirect URL.
</Properties>

#### Example

After calling `createExternalAccount`, the initial `state` of the returned `ExternalAccount` will be `unverified`. To initiate the connection with the external provider, redirect the user to the `externalAccount.verification.externalVerificationRedirectURL` contained in the result of `createExternalAccount`.

Upon return, inspect within the `user.externalAccounts` the entry that corresponds to the requested strategy:

- If the connection succeeded, then `externalAccount.verification.status` will be `verified`.
- If the connection failed, then the `externalAccount.verification.status` will not be `verified` and the `externalAccount.verification.error` will contain the error encountered, which you can present to the user. To learn more about the properties available on `verification`, see the [`verification`](/docs/references/javascript/types/verification) reference.

The following example demonstrates how to add a Notion account as an external account for the user. When the user selects the "Add Notion as a social connection" button, the user will be redirected to Notion to connect their account. After connecting their account, they will be redirected to the `/` route of your application, and the status of the connection will be displayed.

<CodeBlockTabs options={["index.html", "main.js"]}>
  ```html {{ filename: 'index.html', collapsible: true }}
  <!doctype html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <link rel="icon" type="image/svg+xml" href="/vite.svg" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Clerk + JavaScript App</title>
    </head>
    <body>
      <div id="app"></div>

      <p>
        Notion verification status:
        <span id="notion-status"></span>
      </p>
      <button id="add-notion">Add Notion as a social connection</button>

      <script type="module" src="/main.js"></script>
    </body>
  </html>
  ```

  ```js {{ filename: 'main.js', collapsible: true }}
  import { Clerk } from '@clerk/clerk-js'

  // Initialize Clerk with your Clerk Publishable Key
  const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  const clerk = new Clerk(pubKey)
  await clerk.load()

  if (clerk.user) {
    // Find the external account for the provider
    const externalAccount = clerk.user.externalAccounts.find((p) => p.provider === 'notion')
    // If the external account exists, display its status
    document.getElementById('notion-status').innerHTML = externalAccount.verification.status

    // When the button is clicked, initiate the connection with the provider
    document.getElementById('add-notion').addEventListener('click', async () => {
      clerk.user
        .createExternalAccount({ strategy: 'oauth_notion', redirect_url: '/' })
        .then((externalAccount) => {
          window.location.href = externalAccount.verification.externalVerificationRedirectURL
        })
        .catch((error) => {
          console.log('An error occurred:', error.errors)
        })
    })
  } else {
    document.getElementById('app').innerHTML = `
      <div id="sign-in"></div>
    `

    const signInDiv = document.getElementById('sign-in')

    clerk.mountSignIn(signInDiv)
  }
  ```
</CodeBlockTabs>

### `createPasskey()`

Creates a passkey for the signed-in user. Returns a [`PasskeyResource`](/docs/references/javascript/types/passkey-resource) object.

> [!NOTE]
> When creating a passkey for a user in a multi-domain Clerk app, `createPasskey()` must be called from the primary domain.

```ts
function createPasskey(): Promise<PasskeyResource>
```

#### Example

For an example on how to use `createPasskey()`, see the [custom flow guide on passkeys](/docs/custom-flows/passkeys#create-user-passkeys).

### `createPhoneNumber()`

Adds a phone number for the user. A new [`PhoneNumber`](/docs/references/javascript/types/phone-number) will be created and associated with the user.

> [!WARNING]
> **Phone number** must be enabled as an identifier in your app's settings in the Clerk Dashboard. See the [Identifiers](/docs/authentication/configuration/sign-up-sign-in-options#identifiers) section to learn more.

```ts
function createPhoneNumber(params: CreatePhoneNumberParams): Promise<PhoneNumberResource>
```

#### `CreatePhoneNumberParams`

<Properties>
  - `phoneNumber`
  - `string`

  The phone number to be added to the user. Must be in E.164 format.
</Properties>

### Example

```js
await clerk.user.createPhoneNumber({ phoneNumber: '1234567890' })
```

### `createTOTP()`

Generates a TOTP secret for a user that can be used to register the application on the user's authenticator app of choice. If this method is called again (while still unverified), it replaces the previously generated secret. Returns a [`TOTPResource`][totp-ref] object.

> [!WARNING]
> The **Authenticator application** multi-factor strategy must be enabled in your app's settings in the Clerk Dashboard. See the [Multi-factor authentication](/docs/authentication/configuration/sign-up-sign-in-options#multi-factor-authentication) section to learn more.

```typescript
function createTOTP(): Promise<TOTPResource>
```

#### Example

```js
await clerk.user.createTOTP()
```

### `delete()`

Deletes the current user.

```ts {{ prettier: false }}
function delete(): Promise<void>
```

#### Example

```js
await clerk.user.delete()
```

### `disableTOTP()`

Disables TOTP by deleting the user's TOTP secret. Returns a [`DeletedObject`](/docs/references/javascript/types/deleted-object) object.

> [!WARNING]
> The **Authenticator application** multi-factor strategy must be enabled in your app's settings in the Clerk Dashboard. See the [Multi-factor authentication](/docs/authentication/configuration/sign-up-sign-in-options#multi-factor-authentication) section to learn more.

```typescript
function disableTOTP(): Promise<DeletedObject>
```

#### Example

```js
await clerk.user.disableTOTP()
```

### `getOrganizationInvitations()`

Retrieves a list of organization invitations for the user. Returns a [`ClerkPaginatedResponse`](/docs/references/javascript/types/clerk-paginated-response) of [`UserOrganizationInvitation`](/docs/references/javascript/types/user-organization-invitation) objects.

```ts
function getOrganizationInvitations(
  params?: GetUserOrganizationInvitationsParams,
): Promise<ClerkPaginatedResponse<UserOrganizationInvitation>>
```

#### `GetUserOrganizationInvitationsParams`

<Properties>
  - `initialPage?`
  - `number`

  A number that can be used to skip the first n-1 pages. For example, if `initialPage` is set to 10, it is will skip the first 9 pages and will fetch the 10th page.

  ---

  - `pageSize?`
  - `number`

  A number that indicates the maximum number of results that should be returned for a specific page.

  ---

  - `status?`
  - `'pending' | 'accepted' | 'revoked'`

  The status an invitation can have.
</Properties>

#### Example

```js
await clerk.user.getOrganizationInvitations()
```

### `getOrganizationMemberships()`

Retrieves a list of organization memberships for the user. Returns a [`ClerkPaginatedResponse`](/docs/references/javascript/types/clerk-paginated-response) of [`OrganizationMembershipResource`](/docs/references/javascript/types/organization-membership) objects.

```ts
function getOrganizationMemberships(
  params?: GetUserOrganizationMembershipParams,
): Promise<ClerkPaginatedResponse<OrganizationMembershipResource>>
```

#### `GetUserOrganizationMembershipParams`

<Properties>
  - `initialPage?`
  - `number`

  A number that can be used to skip the first n-1 pages. For example, if `initialPage` is set to 10, it is will skip the first 9 pages and will fetch the 10th page.

  ---

  - `pageSize?`
  - `number`

  A number that indicates the maximum number of results that should be returned for a specific page.
</Properties>

#### Example

```js
await clerk.user.getOrganizationMemberships()
```

### `getOrganizationSuggestions()`

Retrieves a list of organization suggestions for the user. Returns a [`ClerkPaginatedResponse`](/docs/references/javascript/types/clerk-paginated-response) of [`OrganizationSuggestion`](/docs/references/javascript/types/organization-suggestion) objects.

```ts
function getOrganizationSuggestions(
  params?: GetUserOrganizationSuggestionsParams,
): Promise<ClerkPaginatedResponse<OrganizationSuggestion>>
```

#### `GetUserOrganizationSuggestionsParams`

<Properties>
  - `initialPage?`
  - `number`

  A number that can be used to skip the first n-1 pages. For example, if `initialPage` is set to 10, it is will skip the first 9 pages and will fetch the 10th page.

  ---

  - `pageSize?`
  - `number`

  A number that indicates the maximum number of results that should be returned for a specific page.

  ---

  - `status?`
  - `'pending' | 'accepted' | ['pending' | 'accepted']`

  The status an invitation can have.
</Properties>

#### Example

```js
await clerk.user.getOrganizationSuggestions()
```

### `getSessions()`

Retrieves all **active** sessions for this user. This method uses a cache so a network request will only be triggered only once. Returns an array of [`SessionWithActivities`](/docs/references/javascript/types/session-with-activities) objects.

```ts
function getSessions(): Promise<SessionWithActivities[]>
```

#### Example

```js
await clerk.user.getSessions()
```

### `isPrimaryIdentification()`

A check whether or not the given resource is the primary identifier for the user.

```ts
function isPrimaryIdentification(
  ident: EmailAddressResource | PhoneNumberResource | Web3WalletResource,
): boolean
```

#### Parameters

<Properties>
  - `ident`
  - <code>\[EmailAddress]\[email-ref] | \[PhoneNumber]\[phone-ref] | \[Web3Wallet]\[web3-ref]</code>

  The resource checked against the user to see if it is the primary identifier.
</Properties>

#### Example

```js
await clerk.user.isPrimaryIdentification(clerk.user.emailAddresses[0])
```

### `reload()`

Reloads the user's data from Clerk's API. Useful for when you want to refresh the user's data after performing some form of mutation.

```ts
function reload(p?: ClerkResourceReloadParams): Promise<this>
```

#### `ClerkResourceReloadParams`

<Properties>
  - `rotatingTokenNonce?`
  - `string`

  A nonce to use for rotating the user's token. Used in native application OAuth flows to allow the native client to update its JWT once despite changes in its rotating token.
</Properties>

#### Example

```js
await clerk.user.reload()
```

### `removePassword()`

Removes the user's password.

```ts
function removePassword(params: RemoveUserPasswordParams): Promise<User>
```

#### `RemoveUserPasswordParams`

<Properties>
  - `currentPassword`
  - `string`

  The user's current password.
</Properties>

#### Example

```js
await clerk.user.removePassword({ currentPassword: 'current-password' })
```

### `setProfileImage()`

Adds the user's profile image or replaces it if one already exists. This method will upload an image and associate it with the user.

```ts
function setProfileImage(params: SetProfileImageParams): Promise<ImageResource>
```

#### `SetProfileImageParams`

<Properties>
  - `file`
  - `Blob | File | string | null`

  The file to set as the user's profile image, or `null` to remove the current image.
</Properties>

##### `ImageResource`

<Properties>
  - `id?`
  - `string`

  The unique identifier of the image.

  ---

  - `name`
  - `string | null`

  The name of the image.

  ---

  - `publicUrl`
  - `string | null`

  The publicly accessible url for the image.
</Properties>

#### Example

```js
await clerk.user.setProfileImage({ file: profileImage })
```

### `update()`

Updates the user's attributes. Use this method to save information you collected about the user.

The appropriate settings must be enabled in the Clerk Dashboard for the user to be able to update their attributes. For example, if you want to use the `update({ firstName })` method, you must enable the **Name** setting. It can be found on the [**Email, phone, username > Personal information**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) section in the Clerk Dashboard.

```ts
function update(params: UpdateUserParams): Promise<User>
```

#### `UpdateUserParams`

All props below are optional.

<Properties>
  - `username`
  - `string`

  The user's username.

  ---

  - `firstName`
  - `string`

  The user's first name.

  ---

  - `lastName`
  - `string`

  The user's last name.

  ---

  - `primaryEmailAddressId`
  - `string`

  The ID for the \[`EmailAddress`]\[email-ref] that the user has set as primary.

  ---

  - `primaryPhoneNumberId`
  - `string`

  The ID for the \[`PhoneNumber`]\[phone-ref] that the user has set as primary.

  ---

  - `primaryWeb3WalletId`
  - `string`

  The ID for the \[`Web3Wallet`]\[web3-ref] that the user signed up with.

  ---

  - `unsafeMetadata`
  - [`UserUnsafeMetadata`](/docs/references/javascript/types/metadata#user-unsafe-metadata)

  Metadata that can be read and set from the Frontend API. One common use case for this attribute is to implement custom fields that will be attached to the `User` object. Updating this value overrides the previous value; it does not merge. To perform a merge, you can pass something like `{ user.unsafeMetadata, newData }` to this parameter.
</Properties>

#### Example

```js
await clerk.user.update({ firstName: 'Test' })
```

### `updatePassword()`

Updates the user's password. Passwords must be at least 8 characters long.

```ts
function updatePassword(params: UpdateUserPasswordParams): Promise<User>
```

#### `UpdateUserPasswordParams`

<Properties>
  - `newPassword`
  - `string`

  The user's new password.

  ---

  - `currentPassword?`
  - `string`

  The user's current password.

  ---

  - `signOutOfOtherSessions?`
  - `boolean | undefined`

  If set to `true`, all sessions will be signed out.
</Properties>

#### Example

```js
await clerk.user.updatePassword({
  currentPassword: 'current-password',
  newPassword: 'new-password',
})
```

### `verifyTOTP()`

Verifies a TOTP secret after a user has created it. The user must provide a code from their authenticator app that has been generated using the previously created secret. This way, correct set up and ownership of the authenticator app can be validated. Returns a [`TOTPResource`][totp-ref] object.

> [!WARNING]
> The **Authenticator application** multi-factor strategy must be enabled in your app's settings in the Clerk Dashboard. See the [Multi-factor authentication](/docs/authentication/configuration/sign-up-sign-in-options#multi-factor-authentication) section to learn more.

```typescript
function verifyTOTP(params: VerifyTOTPParams): Promise<TOTPResource>
```

#### `VerifyTOTPParams`

<Properties>
  - `code`
  - `string`

  A 6 digit TOTP generated from the user's authenticator app.
</Properties>

#### Example

```js
await clerk.user.verifyTOTP({ code: '123456' })
```

[backupcode-ref]: /docs/references/javascript/types/backup-code

[email-ref]: /docs/references/javascript/types/email-address

[exacc-ref]: /docs/references/javascript/types/external-account

[phone-ref]: /docs/references/javascript/types/phone-number

[totp-ref]: /docs/references/javascript/types/totp

[web3-ref]: /docs/references/javascript/types/web3-wallet

---
title: '`Variables` prop'
description: Utilize Clerk's variables property in order to adjust the general styles of the component's base theme, like colors, backgrounds, typography.
---

{/* JS file: https://github.com/clerk/javascript/blob/main/packages/types/src/appearance.ts#L399 */}

The `variables` property is used to adjust the general styles of the component's base theme, like colors, backgrounds, and typography.

## Properties

<Properties>
  - `colorPrimary`
  - `string`

  The primary color used throughout the components.

  ---

  - `colorDanger`
  - `string`

  The color used for error states.

  ---

  - `colorSuccess`
  - `string`

  The color used for success states.

  ---

  - `colorWarning`
  - `string`

  The color used for warning states.

  ---

  - `colorNeutral`
  - `string`

  The color that will be used for all to generate the neutral shades the components use. This option applies to borders, backgrounds for hovered elements, hovered dropdown options.

  ---

  - `colorText`
  - `string`

  The color used for text.

  ---

  - `colorTextOnPrimaryBackground`
  - `string`

  The color used for text on the primary background.

  ---

  - `colorTextSecondary`
  - `string`

  The color used for secondary text.

  ---

  - `colorBackground`
  - `string`

  The background color for the card container.

  ---

  - `colorInputText`
  - `string`

  The color used for text in input fields.

  ---

  - `colorInputBackground`
  - `string`

  The background color used for input fields.

  ---

  - `colorShimmer`
  - `string`

  The color of the avatar shimmer.

  ---

  - `fontFamily`
  - `string`

  The font family used throughout the components. By default, it is set to `inherit`.

  ---

  - `fontFamilyButtons`
  - `string`

  The font family used for buttons. By default, it is set to `inherit`.

  ---

  - `fontSize`
  - `string`

  The font size used throughout the components. By default, this is set to `0.8125rem`.

  ---

  - `fontWeight`
  - `{normal: number, medium: number, semibold: number, bold: number}`

  The font weight used throughout the components. By default, this is set to `{normal: 400, medium: 500, semibold: 600, bold: 700}`.

  ---

  - `borderRadius`
  - `string`

  The border radius used throughout the components. By default, this is set to `0.375rem`.

  ---

  - `spacingUnit`
  - `string`

  The spacing unit used throughout the components. By default, this is set to `1rem`.
</Properties>

## Usage

You can customize Clerk components by passing an object of variables to the `variables` property of the [`appearance`](/docs/customization/overview) prop.

### Apply `variables` to all Clerk components

To customize all Clerk components, pass the `variables` property to the `appearance` prop of the [`<ClerkProvider>`](/docs/components/clerk-provider) component.

In the following example, the primary color is set to blue and the text color is set to white. Because these styles are applied to the `<ClerkProvider>`, which wraps the entire application, these styles will be applied to all Clerk components that use the primary color and text color.

<Tabs items={["Next.js", "React", "Remix", "Astro", "Vue", "Nuxt"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: '/src/app/layout.tsx', mark: [[6, 11]] }}
      import { ClerkProvider } from '@clerk/nextjs'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <ClerkProvider
            appearance={{
              variables: {
                colorPrimary: 'blue',
                colorText: 'black',
              },
            }}
          >
            <html lang="en">
              <body>{children}</body>
            </html>
          </ClerkProvider>
        )
      }
      ```

      ```tsx {{ filename: '_app.tsx', mark: [[7, 12]] }}
      import { ClerkProvider } from '@clerk/nextjs'
      import type { AppProps } from 'next/app'

      function MyApp({ Component, pageProps }: AppProps) {
        return (
          <ClerkProvider
            appearance={{
              variables: {
                colorPrimary: 'blue',
                colorText: 'black',
              },
            }}
          >
            <Component {...pageProps} />
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app.tsx', mark: [[13, 18]] }}
    import React from 'react'
    import './App.css'
    import { ClerkProvider } from '@clerk/clerk-react'

    if (!process.env.REACT_APP_CLERK_PUBLISHABLE_KEY) {
      throw new Error('Missing Publishable Key')
    }
    const clerkPubKey = process.env.REACT_APP_CLERK_PUBLISHABLE_KEY

    function App() {
      return (
        <ClerkProvider
          appearance={{
            variables: {
              colorPrimary: 'blue',
              colorText: 'black',
            },
          }}
          publishableKey={clerkPubKey}
        >
          <div>Hello from clerk</div>
        </ClerkProvider>
      )
    }

    export default App
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/root.tsx', mark: [[35, 40]] }}
    // Import ClerkApp
    import { ClerkApp } from '@clerk/remix'
    import type { MetaFunction, LoaderFunction } from '@remix-run/node'

    import { Links, LiveReload, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react'

    import { rootAuthLoader } from '@clerk/remix/ssr.server'

    export const meta: MetaFunction = () => ({
      charset: 'utf-8',
      title: 'New Remix App',
      viewport: 'width=device-width,initial-scale=1',
    })

    export const loader: LoaderFunction = (args) => rootAuthLoader(args)

    function App() {
      return (
        <html lang="en">
          <head>
            <Meta />
            <Links />
          </head>
          <body>
            <Outlet />
            <ScrollRestoration />
            <Scripts />
            <LiveReload />
          </body>
        </html>
      )
    }

    export default ClerkApp(App, {
      appearance: {
        variables: {
          colorPrimary: 'blue',
          colorText: 'black',
        },
      },
    })
    ```
  </Tab>

  <Tab>
    ```js {{ filename: 'astro.config.mjs', mark: [[6, 11]] }}
    import clerk from '@clerk/astro'

    export default defineConfig({
      integrations: [
        clerk({
          appearance: {
            variables: {
              colorPrimary: 'blue',
              colorText: 'black',
            },
          },
        }),
      ],
    })
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'src/main.ts', mark: [[7, 12]] }}
    import { createApp } from 'vue'
    import App from './App.vue'
    import { clerkPlugin } from '@clerk/vue'

    const app = createApp(App)
    app.use(clerkPlugin, {
      appearance: {
        variables: {
          colorPrimary: 'blue',
          colorText: 'black',
        },
      },
    })
    app.mount('#app')
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'nuxt.config.ts', mark: [[4, 9]] }}
    export default defineNuxtConfig({
      modules: ['@clerk/nuxt'],
      clerk: {
        appearance: {
          variables: {
            colorPrimary: 'blue',
            colorText: 'black',
          },
        },
      },
    })
    ```
  </Tab>
</Tabs>

### Apply `variables` to all instances of a Clerk component

You can customize all instances of a Clerk component by passing the component to the `appearance` prop of the `<ClerkProvider>`. The `appearance` prop accepts the name of the Clerk component you want to style as a key.

In the following example, the primary color is set to blue and the text color is set to white for all instances of the [`<SignIn />`](/docs/components/authentication/sign-in) component.

<Tabs items={["Next.js", "React", "Remix", "Astro", "Vue", "Nuxt"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: '/src/app/layout.tsx', mark: [[6, 13]] }}
      import { ClerkProvider } from '@clerk/nextjs'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <ClerkProvider
            appearance={{
              signIn: {
                variables: {
                  colorPrimary: 'blue',
                  colorText: 'black',
                },
              },
            }}
          >
            <html lang="en">
              <body>{children}</body>
            </html>
          </ClerkProvider>
        )
      }
      ```

      ```tsx {{ filename: '_app.tsx', mark: [[7, 14]] }}
      import { ClerkProvider } from '@clerk/nextjs'
      import type { AppProps } from 'next/app'

      function MyApp({ Component, pageProps }: AppProps) {
        return (
          <ClerkProvider
            appearance={{
              signIn: {
                variables: {
                  colorPrimary: 'blue',
                  colorText: 'black',
                },
              },
            }}
          >
            <Component {...pageProps} />
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app.tsx', mark: [[13, 20]] }}
    import React from 'react'
    import './App.css'
    import { ClerkProvider } from '@clerk/clerk-react'

    if (!process.env.REACT_APP_CLERK_PUBLISHABLE_KEY) {
      throw new Error('Missing Publishable Key')
    }
    const clerkPubKey = process.env.REACT_APP_CLERK_PUBLISHABLE_KEY

    function App() {
      return (
        <ClerkProvider
          appearance={{
            signIn: {
              variables: {
                colorPrimary: 'blue',
                colorText: 'black',
              },
            },
          }}
          publishableKey={clerkPubKey}
        >
          <div>Hello from clerk</div>
        </ClerkProvider>
      )
    }

    export default App
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/root.tsx', mark: [[35, 42]] }}
    // Import ClerkApp
    import { ClerkApp } from '@clerk/remix'
    import type { MetaFunction, LoaderFunction } from '@remix-run/node'

    import { Links, LiveReload, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react'

    import { rootAuthLoader } from '@clerk/remix/ssr.server'

    export const meta: MetaFunction = () => ({
      charset: 'utf-8',
      title: 'New Remix App',
      viewport: 'width=device-width,initial-scale=1',
    })

    export const loader: LoaderFunction = (args) => rootAuthLoader(args)

    function App() {
      return (
        <html lang="en">
          <head>
            <Meta />
            <Links />
          </head>
          <body>
            <Outlet />
            <ScrollRestoration />
            <Scripts />
            <LiveReload />
          </body>
        </html>
      )
    }

    export default ClerkApp(App, {
      appearance: {
        signIn: {
          variables: {
            colorPrimary: 'blue',
            colorText: 'black',
          },
        },
      },
    })
    ```
  </Tab>

  <Tab>
    ```js {{ filename: 'astro.config.mjs', mark: [[6, 13]] }}
    import clerk from '@clerk/astro'

    export default defineConfig({
      integrations: [
        clerk({
          appearance: {
            signIn: {
              variables: {
                colorPrimary: 'blue',
                colorText: 'black',
              },
            },
          },
        }),
      ],
    })
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'src/main.ts', mark: [[7, 14]] }}
    import { createApp } from 'vue'
    import App from './App.vue'
    import { clerkPlugin } from '@clerk/vue'

    const app = createApp(App)
    app.use(clerkPlugin, {
      appearance: {
        signIn: {
          variables: {
            colorPrimary: 'blue',
            colorText: 'black',
          },
        },
      },
    })
    app.mount('#app')
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'nuxt.config.ts', mark: [[4, 11]] }}
    export default defineNuxtConfig({
      modules: ['@clerk/nuxt'],
      clerk: {
        appearance: {
          signIn: {
            variables: {
              colorPrimary: 'blue',
              colorText: 'black',
            },
          },
        },
      },
    })
    ```
  </Tab>
</Tabs>

### Apply `variables` to a single Clerk component

To customize a single Clerk component, pass the `variables` property to the `appearance` prop of the Clerk component.

The following example shows how to customize the [`<SignIn />`](/docs/components/authentication/sign-in) component by setting the primary color to blue and the text color to white.

<Tabs items={["Next.js", "React", "Remix", "Astro", "Vue", "Nuxt"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx', mark: [[6, 11]] }}
      import { SignIn } from '@clerk/nextjs'

      export default function Page() {
        return (
          <SignIn
            appearance={{
              variables: {
                colorPrimary: 'blue',
                colorText: 'black',
              },
            }}
          />
        )
      }
      ```

      ```tsx {{ filename: '/pages/sign-in/[[...index]].tsx', mark: [[5, 10]] }}
      import { SignIn } from '@clerk/nextjs'

      const SignInPage = () => (
        <SignIn
          appearance={{
            variables: {
              colorPrimary: 'blue',
              colorText: 'black',
            },
          }}
        />
      )

      export default SignInPage
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    ```tsx {{ filename: '/src/sign-in/[[...index]].tsx', mark: [[5, 10]] }}
    import { SignIn } from '@clerk/clerk-react'

    const SignInPage = () => (
      <SignIn
        appearance={{
          variables: {
            colorPrimary: 'blue',
            colorText: 'black',
          },
        }}
      />
    )

    export default SignInPage
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/routes/sign-in/$.tsx', mark: [[8, 13]] }}
    import { SignIn } from '@clerk/remix'

    export default function SignInPage() {
      return (
        <div style={{ border: '2px solid blue', padding: '2rem' }}>
          <h1>Sign In route</h1>
          <SignIn
            appearance={{
              variables: {
                colorPrimary: 'blue',
                colorText: 'black',
              },
            }}
          />
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: 'pages/sign-in.astro', mark: [[7, 10]] }}
    ---
    import { SignIn } from '@clerk/astro/components'
    ---

    <SignIn
      appearance={{
        colorPrimary: 'blue',
        colorText: 'black',
      }}
    />
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'src/pages/sign-in.vue', mark: [6] }}
    <script setup lang="ts">
    import { SignIn } from '@clerk/vue'
    </script>

    <template>
      <SignIn :appearance="{ colorPrimary: 'blue', colorText: 'black' }" />
    </template>
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'pages/sign-in.vue', mark: [6] }}
    <script setup lang="ts">
    // Components are automatically imported
    </script>

    <template>
      <SignIn :appearance="{ colorPrimary: 'blue', colorText: 'black' }" />
    </template>
    ```
  </Tab>
</Tabs>

---
title: '`Verification`'
description: An interface that represents the state of the verification process of a sign-in or sign-up attempt.
---

An interface that represents the state of the verification process of a sign-in or sign-up attempt.

<Properties>
  - `attempts`
  - `number | null`

  The number of attempts related to the verification.

  ---

  - `error`
  - `ClerkAPIError | null`

  The last error the verification attempt ran into.

  ---

  - `expireAt`
  - `Date | null`

  The time the verification will expire at.

  ---

  - `externalVerificationRedirectURL`
  - `URL | null`

  The redirect URL for an external verification.

  ---

  - `nonce`
  - `string | null`

  The [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce) pertaining to the verification.

  ---

  - `message`
  - `string | null`

  The message that will be presented to the user's Web3 wallet for signing during authentication. This follows the [Sign-In with Ethereum (SIWE) protocol format](https://docs.login.xyz/general-information/siwe-overview/eip-4361#example-message-to-be-signed), which typically includes details like the requesting service, wallet address, terms acceptance, nonce, timestamp, and any additional resources.

  ---

  - `status`
  - `'unverified' | 'verified' | 'transferable' | 'failed' | 'expired' | null`

  The state of the verification.

  - `unverified`: The verification has not been verified yet.
  - `verified`: The verification has been verified.
  - `transferable`: The verification is transferable to between sign-in and sign-up flows.
  - `failed`: The verification has failed.
  - `expired`: The verification has expired.

  ---

  - `strategy`
  - `string | null`

  The strategy pertaining to the parent sign-up or sign-in attempt.

  ---

  - `verifiedAtClient`
  - `string | null`

  The client ID where the verification was completed.
</Properties>

## Methods

### `verifiedFromTheSameClient()`

A check to see if the verification was verified from the same client as the parent sign-in or sign-up attempt. For example, checking if the verification was verified from the same browser as the parent sign-in or sign-up attempt.

```typescript
function verifiedFromTheSameClient(): boolean
```

---
title: '`verifyClient()`'
description: Use Clerk's Backend SDK to retrieve a client for a given session token, if the session is active.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/ClientApi.ts#L27 */}

Verifies the [`Client`](/docs/references/javascript/client) in the provided token.

```ts
function verifyClient(token: string): Promise<Client>
```

## Parameters

<Properties>
  - `token`
  - `string`

  The session token to verify.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const token = 'my-session-token'

const response = await clerkClient.clients.verifyClient(token)
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/clients/verify`. See the [BAPI reference](/docs/reference/backend-api/tag/Clients#operation/VerifyClient){{ target: '_blank' }} for more information.

---
title: '`verifyPassword()`'
description: Use Clerk's Backend SDK to check that the user's password matches the supplied input. Useful for custom auth flows and re-verification.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L225 */}

Check that the user's password matches the supplied input. Useful for custom auth flows and re-verification.

```ts
function verifyPassword(params: VerifyPasswordParams): Promise<{ verified: true }>
```

## `VerifyPasswordParams`

<Properties>
  - `userId`
  - `string`

  The ID of the user to verify the password for.

  ---

  - `password`
  - `string`

  The password to verify.
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const userId = 'user_123'

const password = 'testpassword123'

const response = await clerkClient.users.verifyPassword({
  userId,
  password,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/users/{user_id}/verify_password`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/VerifyPassword){{ target: '_blank' }} for more information.

---
title: '`verifySession()` (deprecated)'
description: Use Clerk's Backend SDK to to verify whether a session with a given ID corresponds to the provided session token.
---

> [!CAUTION]
> This method is now deprecated. Refer to the [Manual JWT Verification](/docs/backend-requests/manual-jwt) guide for the recommended way to verify sessions/tokens.

Verifies whether a session with a given ID corresponds to the provided session token. Throws an error if the provided ID is invalid.

## Example

<Include src="_partials/backend/usage" />

```tsx
const sessionId = 'my-session-id'

const token = 'my-session-token'

const session = await clerkClient.sessions.verifySession(sessionId, token)
```

## Required parameters

<Properties>
  - `sessionId`
  - `string`

  The ID of the session to verify.

  ---

  - `token`
  - `string`

  The token of the session to verify with.
</Properties>

---
title: '`verifyToken()`'
description: Use Clerk's Backend SDK to verify a token signature.
---

{/* JS page: https://github.com/clerk/javascript/blob/843e96e505cd91d676f0736e24465726b55014a7/packages/backend/src/tokens/verify.ts#L13 */}

> [!WARNING]
> This is a lower-level method intended for more advanced use-cases. It's recommended to use [`authenticateRequest()`](/docs/references/backend/authenticate-request), which fully authenticates a token passed from the `request` object.

Verifies a Clerk-generated token signature. Networkless if the `jwtKey` is provided. Otherwise, performs a network call to retrieve the JWKS from the [Backend API](/docs/reference/backend-api/tag/JWKS#operation/GetJWKS){{ target: '_blank' }}.

```ts
function verifyToken(
  token: string,
  options: VerifyTokenOptions,
): Promise<JwtReturnType<JwtPayload, TokenVerificationError>>
```

## Parameters

<Properties>
  - `token`
  - `string`

  The token to verify.

  ---

  - `options`
  - `VerifyTokenOptions`

  Options for verifying the token.
</Properties>

### `VerifyTokenOptions`

It is recommended to set these options as [environment variables](/docs/deployments/clerk-environment-variables#api-and-sdk-configuration) where possible, and then pass them to the function. For example, you can set the `secretKey` option using the `CLERK_SECRET_KEY` environment variable, and then pass it to the function like this: `createClerkClient({ secretKey: process.env.CLERK_SECRET_KEY })`.

> [!WARNING]
> You must provide either `jwtKey` or `secretKey`.

<Properties>
  - `audience?`
  - `string | string[]`

  A string or list of [audiences](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.3).

  ---

  - `authorizedParties`
  - `string[]`

  Can be used to validate that the `azp` claim equals any of your known origins that are permitted to generate those tokens. For example: `['http://localhost:4003', 'https://clerk.dev']`

  ---

  - `clockSkewInMs?`
  - `number`

  Specifies the allowed time difference (in milliseconds) between the Clerk server (which generates the token) and the clock of the user's application server when validating a token. Defaults to 5000 ms (5 seconds).

  ---

  - `jwtKey?`
  - `string`

  Used to verify the session token in a networkless manner. Supply the **JWKS Public Key** from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard. For more information, refer to [Manual JWT verification](/docs/backend-requests/manual-jwt).

  ---

  - `secretKey?`
  - `string`

  The Clerk Secret Key from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.

  ---

  - `skipJwksCache?`
  - `boolean`

  A flag to ignore the JWKS cache and always fetch JWKS before each JWT verification.

  ---

  - `apiUrl?`
  - `string`

  The [Clerk Backend API](/docs/reference/backend-api){{ target: '_blank' }} endpoint. Defaults to `'https://api.clerk.com'`.

  ---

  - `apiVersion?`
  - `string`

  The version passed to the Clerk API. Defaults to `'v1'`.
</Properties>

## Example

The following example demonstrates how to use the [JavaScript Backend SDK](/docs/references/backend/overview) to verify the token signature.

In the following example:

1. The **JWKS Public Key** from the Clerk Dashboard is set in the environment variable `CLERK_JWT_KEY`.
1. The session token is retrieved from the `__session` cookie or the Authorization header.
1. The token is verified in a networkless manner by passing the `jwtKey` prop.
1. The `authorizedParties` prop is passed to verify that the session token is generated from the expected frontend application.
1. If the token is valid, the response contains the verified token.

```ts
import { verifyToken } from '@clerk/backend'
import { cookies } from 'next/headers'

export async function GET(request: Request) {
  const cookieStore = cookies()
  const sessToken = cookieStore.get('__session')?.value
  const bearerToken = request.headers.get('Authorization')?.replace('Bearer ', '')
  const token = sessToken || bearerToken

  if (!token) {
    return Response.json({ error: 'Token not found. User must sign in.' }, { status: 401 })
  }

  try {
    const verifiedToken = await verifyToken(token, {
      jwtKey: process.env.CLERK_JWT_KEY,
      authorizedParties: ['http://localhost:3001', 'api.example.com'], // Replace with your authorized parties
    })

    return Response.json({ verifiedToken })
  } catch (error) {
    return Response.json({ error: 'Token not verified.' }, { status: 401 })
  }
}
```

If the token is valid, the response will contain a JSON object that looks something like this:

```json
{
  "verifiedToken": {
    "azp": "http://localhost:3000",
    "exp": 1687906422,
    "iat": 1687906362,
    "iss": "https://magical-marmoset-51.clerk.accounts.dev",
    "nbf": 1687906352,
    "sid": "sess_2Ro7e2IxrffdqBboq8KfB6eGbIy",
    "sub": "user_2RfWKJREkjKbHZy0Wqa5qrHeAnb"
  }
}
```

---
title: '`verifyTOTP()`'
description: Use Clerk's Backend SDK to verify a TOTP or backup code for a user.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L236 */}

Verify that the provided TOTP or backup code is valid for the user. Verifying a backup code will result it in being consumed (i.e. it will become invalid). Useful for custom auth flows and re-verification.

```ts
function verifyTOTP(params: VerifyTOTPParams): Promise<{ verified: true; code_type: 'totp' }>
```

## `verifyTOTPParams`

<Properties>
  - `userId`
  - `string`

  The ID of the user to verify the TOTP for.

  ---

  - `code`
  - `string`

  The TOTP or backup code to verify
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const userId = 'user_123'

const code = '123456'

const response = await clerkClient.users.verifyTOTP({
  userId,
  code,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `POST/users/{user_id}/verify_totp`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/VerifyTOTP){{ target: '_blank' }} for more information.

---
title: '`verifyWebhook()`'
description: Use Clerk's Backend SDK to verify a webhook signature.
---

Verifies the authenticity of a webhook request using Svix. Returns a promise that resolves to the verified webhook event data.

```ts
function verifyWebhook(request: Request, options?: VerifyWebhookOptions): Promise<WebhookEvent>
```

## Parameters

<Properties>
  - `request`
  - `Request`

  The request object.

  ---

  - `options`
  - [`VerifyWebhookOptions`](#verify-webhook-options)

  Optional configuration object.
</Properties>

### `VerifyWebhookOptions`

<Properties>
  - `signingSecret?`
  - `string`

  The signing secret for the webhook. It's recommended to use the [`CLERK_WEBHOOK_SIGNING_SECRET` environment variable](/docs/deployments/clerk-environment-variables#webhooks) instead.
</Properties>

## Example

See the [guide on syncing data](/docs/webhooks/sync-data) for more comprehensive and framework-specific examples that you can copy and paste into your app.

```ts
try {
  const evt = await verifyWebhook(request)

  // Access the event data
  const { id } = evt.data
  const eventType = evt.type

  // Handle specific event types
  if (evt.type === 'user.created') {
    console.log('New user created:', evt.data.id)
    // Handle user creation
  }

  return new Response('Success', { status: 200 })
} catch (err) {
  console.error('Webhook verification failed:', err)
  return new Response('Webhook verification failed', { status: 400 })
}
```

---
title: <code>\<AuthenticateWith<wbr />RedirectCallback/></code>
description: Clerk's `<AuthenticateWithRedirectCallback />` component is used to implement custom OAuth flows. It handles the OAuth callback and completes the authentication process.
---

The `<AuthenticateWithRedirectCallback />` component is a crucial part of implementing custom OAuth flows in your application. It serves as the callback handler for the authentication process initiated by the `authenticateWithRedirect()` method. Render it on the route specified as the `redirectUrl` in your `authenticateWithRedirect()` call.

This component automatically handles the OAuth callback, completing the authentication process and managing the user's session.

## Properties

<Properties>
  - `signInUrl?`
  - `string`

  The full URL or path where the `<SignIn />` component is mounted.

  ---

  - `signUpUrl?`
  - `string`

  The full URL or path where the `<SignUp />` component is mounted.

  ---

  - `signInFallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs in, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpFallbackRedirectUrl?`
  - `string`

  The fallback URL to redirect to after the user signs up, if there's no `redirect_url` in the path already. Defaults to `/`. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signInForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs in. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `signUpForceRedirectUrl?`
  - `string`

  If provided, this URL will always be redirected to after the user signs up. It's recommended to use [the environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ---

  - `firstFactorUrl`
  - `string | undefined`

  The full URL or path to navigate to during sign in, if first factor verification is required.

  ---

  - `secondFactorUrl`
  - `string | undefined`

  The full URL or path to navigate to during sign in, if [multi-factor authentication](/docs/authentication/configuration/sign-up-sign-in-options#multi-factor-authentication) is enabled.

  ---

  - `resetPasswordUrl`
  - `string`

  The full URL or path to navigate to during sign in, if the user is required to reset their password.

  ---

  - `continueSignUpUrl`
  - `string | undefined | null`

  The full URL or path to navigate to if the sign up requires additional information.

  ---

  - `verifyEmailAddressUrl`
  - `string | undefined | null`

  The full URL or path to navigate to after requesting email verification.

  ---

  - `verifyPhoneNumberUrl`
  - `string | undefined | null`

  The full URL or path to navigate to after requesting phone verification.
</Properties>

## Usage

For an example of how to use the `<AuthenticateWithRedirectCallback />` component, see the [custom flow](/docs/custom-flows/oauth-connections) guide.

---
title: Access the Clerk object outside of components
description: Learn how to access and use the Clerk instance outside of React components in Expo applications.
---

The [`Clerk`](/docs/references/javascript/clerk) object is accessible using the [`useClerk()`](/docs/hooks/use-clerk) hook. However, if you need to access the [`Clerk`](/docs/references/javascript/clerk) object outside of React components, such as in utility functions or background tasks, you can use the `getClerkInstance()` function.

<Tabs items={["Fetch", "Axios"]}>
  <Tab>
    ```ts
    import { getClerkInstance } from '@clerk/clerk-expo'

    export async function fetchFoo() {
      const clerkInstance = getClerkInstance()
      // Use `getToken()` to get the current session token
      const token = await clerkInstance.session?.getToken()

      const response = await fetch('/api/foo', {
        headers: {
          // Include the session token as a Bearer token in the Authorization header
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
      })

      if (!response.ok) {
        // Include status code and status text in error message
        throw new Error(`API Error: ${response.status} ${response.statusText}`)
      }

      return response.json()
    }
    ```
  </Tab>

  <Tab>
    ```ts
    import axios from 'axios'
    import { getClerkInstance } from '@clerk/clerk-expo'

    export async function fetchFoo() {
      try {
        const data = await axios.get('/api/foo')
        return data
      } catch (error) {
        if (axios.isAxiosError(error) && error.response) {
          throw new Error(`API Error: ${error.response.status} ${error.response.statusText}`)
        }

        throw new Error('Unknown error')
      }
    }

    // Intercept requests and modify them to include the current session token
    axios.interceptors.request.use(async (config) => {
      const clerkInstance = getClerkInstance()
      // Use `getToken()` to get the current session token
      const token = await clerkInstance.session?.getToken()

      if (token) {
        // Include the session token as a Bearer token in the Authorization header
        config.headers.Authorization = `Bearer ${token}`
      }

      return config
    })
    ```
  </Tab>
</Tabs>

---
title: Account linking
description: Learn how Clerk handles account linking during Enterprise SSO.
---

Account linking is the process of connecting multiple user accounts from different services or platforms, allowing users to access various services with a single set of credentials. It enables seamless sign-in using Enterprise SSO alongside other authentication methods like username/password. Clerk automatically attempts to link accounts that share the same email address, assuming a single owner for each email.

## How it works

When a user attempts to sign in or up, Clerk checks if the email address from the Identity Provider (IdP) matches an existing account and attempts to link them. Email addresses from IdPs are considered verified by default.

The following sections explain the different scenarios that can occur during this process and how Clerk handles each one.

![Flow chart of the SAML SSO account linking process in various scenarios.](/docs/images/authentication/account-linking-flow-saml.webp)

### Email is verified in Clerk

When a user signs into your app using an IdP that returns a matching verified email address, Clerk automatically links the Enterprise SSO account to the existing account and completes the sign-in process. This includes accounts protected by passwords, as the Enterprise SSO sign-in flow automatically bypasses password verification.

### Email is not verified and verification isn't required

By default, Clerk requires email verification at sign-up. For instances that have disabled this behavior, there's a possibility that an account may be created using an unverified email address.

To configure email verification at sign-up:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. Next to **Email address**, select the settings icon and disable the **Verify at sign-up** toggle.

When a user signs into your app using an IdP, Clerk automatically links the Enterprise SSO account to the existing account by **also verifying the existing email address** and signing the user in. This includes accounts protected by passwords, as the Enterprise SSO sign-in flow automatically bypasses password verification.

### Email is not verified

When a user signs into your app using an IdP that returns a matching unverified email address, Clerk doesn't link the Enterprise SSO account to the existing account, but instead signs the user up and creates a completely new account.

---
title: Account linking for OAuth
description: Learn how Clerk handles account linking and manages unverified email addresses from OAuth providers.
---

Account linking is the process of connecting multiple user accounts from different services or platforms, allowing users to access various services with a single set of credentials. By using the email address as the common identifier, Clerk automatically attempts to link accounts whenever possible. Account linking is triggered when an OAuth provider returns an email address that matches an existing account, assuming a single owner for each email address.

## How it works

When a user attempts to sign in or sign up, Clerk first checks the provided email address. Clerk will attempt to link the OAuth account with any existing Clerk account that shares the same email address.

In the following sections, we'll look at the different scenarios that can occur during this process and explain how Clerk handles each one.

![Flow chart of the account linking process in various scenarios](/docs/images/authentication/account-linking-flow-oauth.webp)

### Email address is verified in both OAuth and Clerk

When a user signs in to your app using an OAuth provider that returns a **verified** email address, Clerk links the OAuth account to the existing account and signs the user in. This even applies to password-protected accounts, as the OAuth sign-in process automatically bypasses password verification.

### Email address is verified in Clerk but not in OAuth

When a user signs in to your app using an OAuth provider that returns an **unverified** email address, Clerk will initiate a verification process. Once the email address is verified, the OAuth account is linked to the existing one, and the user is signed in.

### Email address is unverified in Clerk

By default, users are required to verify their email addresses before they can sign up.

If you disabled the **Verify at sign-up** option in the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username), users will be able to sign up without verifying their email addresses.

When a user signs up with an **unverified** email address and later attempts to sign in with an OAuth provider, Clerk implements security measures to prevent potential account takeovers. For example, if an account was created with an unverified email/password combination and the user later signs in with Google (where the email is verified), Clerk will prompt the user to change their password before linking the accounts. This process begins with email verification, regardless of the method used. After successful verification, Clerk may require additional steps, such as validating existing connections or passwords, to ensure the account's security. These measures are in place because Clerk cannot confirm the original ownership of the account, which could otherwise lead to unauthorized access.

## Users with different email addresses

If a user has a different email from the one associated with the OAuth account, they can manually associate the two by following these steps:

1. Sign in to their Clerk application with the account that uses their main email address.
1. In the [`<UserProfile />`](/docs/components/user/user-profile), add the different email.

After following these steps, the user's OAuth accounts associated with both their primary and added email addresses will be linked to their main account.

---
title: Account Portal overview
description: The Account Portal offers a comprehensive solution for managing user authentication and profile management in your web application and is the fastest way to add Clerk's authentication to your application with minimal code required.
---

The Account Portal in Clerk is a powerful feature that allows you to streamline the sign-in, sign-up, and profile management experience for your users, without having to build your own components or host your own pages. **To integrate the Account Portal with your application, see the [setup guide](/docs/account-portal/getting-started).**

![Account Portal](/docs/images/account-portal/account_portal_splash.png)

## Why use the Account Portal?

The Account Portal provides the pages necessary for your users to sign-up, sign-in, and manage their accounts, all while maintaining seamless integration with your application. These pages are hosted on Clerk servers for you and they require minimal setup to get started. If you're looking for the fastest way to add authentication and user management to your application, then this is a great choice.

However, if you require more precise customization or prefer having your application self-contained, then you can use Clerk's fully customizable [prebuilt components](/docs/components/overview), or you can build your own [custom user interface using the Clerk API](/docs/custom-flows/overview).

## How the Account Portal works

The Account Portal uses Clerk's [prebuilt components](/docs/components/overview), which are embedded into dedicated pages hosted on Clerk servers.

![Account Portal](/docs/images/account-portal/account_portal_how_it_works.png)

After a user has finished their flow in an Account Portal page, Clerk automatically redirects them back to your application along with the required authentication context. This way, users are automatically redirected to and from your application for a seamless experience.

For each application environment, Clerk provides pages for sign-up, sign-in, user profile, organization profile, and organization creation flow. **To integrate the Account Portal with your application, see the [setup guide](/docs/account-portal/getting-started).**

> [!IMPORTANT]
> These pages cannot be customized beyond the options provided in the [Clerk Dashboard](https://dashboard.clerk.com). If you need more customization such as [localization](/docs/customization/localization), consider using [prebuilt components](/docs/components/overview) or building your own [custom user interface](/docs/custom-flows/overview).

## Hosted pages

### Sign-in

The sign-in page hosts the prebuilt [`<SignIn />`](/docs/components/authentication/sign-in) component, which renders a UI for signing in users. The functionality of the `<SignIn />` component is controlled by the instance settings you specify in the [Clerk Dashboard](https://dashboard.clerk.com), such as [sign-up and sign-in options](/docs/authentication/configuration/sign-up-sign-in-options) and [social connections](/docs/authentication/social-connections/oauth).

![The Account Portal sign-in page hosts the \<SignIn /> component](/docs/images/account-portal/sign-in.png)

Redirect users to the sign-in page using the [`<RedirectToSignIn />`](/docs/components/control/redirect-to-signin) control component.

### Sign-up

The sign-up page hosts the prebuilt [`<SignUp />`](/docs/components/authentication/sign-up) component, which renders a UI for signing up users. The functionality of the `<SignUp />` component is controlled by the instance settings you specify in the [Clerk Dashboard](https://dashboard.clerk.com), such as [sign-up and sign-in options](/docs/authentication/configuration/sign-up-sign-in-options) and [social connections](/docs/authentication/social-connections/oauth).

![The Account Portal sign-up page hosts the \<SignUp /> component](/docs/images/account-portal/sign-up.png)

Redirect users to the sign-up page using the [`<RedirectToSignUp />`](/docs/components/control/redirect-to-signup) control component.

### User profile

The user profile page hosts the prebuilt [`<UserProfile />`](/docs/components/user/user-profile) component, which renders a beautiful, full-featured account management UI that allows users to manage their profile and security settings.

![The Account Portal user profile page hosts the \<UserProfile /> component](/docs/images/account-portal/user-profile.png)

Redirect your authenticated users to their user profile page using the [`<RedirectToUserProfile />`](/docs/components/control/redirect-to-userprofile) control component.

### Unauthorized sign-in

The unauthorized sign-in page doesn't host any prebuilt Clerk component. It displays a UI confirming that a session from an unrecognized device was successfully revoked. For more information, see the [Unauthorized sign-in](/docs/security/unauthorized-sign-in) feature.

The unauthorized sign-in page displays a UI confirming that a session from an unrecognized device was successfully revoked. For more information, refer to [the reference.](/docs/security/unauthorized-sign-in)

![Clerk's Account Portal unauthorized sign-in page](/docs/images/account-portal/unauthorized-sign-in.png)

### Create organization

The create organization page hosts the prebuilt [`<CreateOrganization />`](/docs/components/organization/create-organization) component, which provides a streamlined interface for users to create new organizations within your application.

![The Account Portal create organization page hosts the \<CreateOrganization /> component](/docs/images/account-portal/create-org.png)

Redirect your authenticated users to the create organization page using the [`<RedirectToCreateOrganization />`](/docs/components/control/redirect-to-createorganization) control component.

### Organization profile

The user profile page hosts the prebuilt [`<OrganizationProfile />`](/docs/components/organization/organization-profile) component, which renders a beautiful, full-featured organization management UI that allows users to manage their organization profile and security settings.

![The Account Portal organization profile page hosts the \<OrganizationProfile /> component](/docs/images/account-portal/org-profile.png)

Redirect your authenticated users to their organization profile page using the [`<RedirectToOrganizationProfile />`](/docs/components/control/redirect-to-organizationprofile) control component.

### Waitlist

The waitlist page hosts the prebuilt [`<Waitlist />`](/docs/components/waitlist) component which renders a form that allows users to join for early access to your app.

![The Account Portal waitliste page hosts the \<Waitlist /> component](/docs/images/account-portal/waitlist.png)

---
title: Actor token errors
description: An index of Clerk errors related to actor tokens.
type: reference
---

An index of Clerk errors related to actor tokens.

## `ActorTokenRevoked`

```json
{
  "shortMessage": "actor token has been revoked",
  "longMessage": "This actor token has been revoked and cannot be used anymore.",
  "code": "actor_token_revoked_code"
}
```

## `ActorTokenAlreadyUsed`

```json
{
  "shortMessage": "actor token has already been used",
  "longMessage": "This actor token has already been used. Each token can only be used once.",
  "code": "actor_token_already_used_code"
}
```

## `ActorTokenCannotBeUsed`

```json
{
  "shortMessage": "actor token cannot be used",
  "longMessage": "This actor token cannot be used anymore. Please request a new one.",
  "code": "actor_token_cannot_be_used_code"
}
```

## <code>ActorTokenCanBeUsed<wbr />OnlyInSignIn</code>

```json
{
  "shortMessage": "not in sign in",
  "longMessage": "Actor tokens can only be used during sign in.",
  "code": "actor_token_not_in_sign_in_code"
}
```

## `ActorTokenSubjectNotFound`

```json
{
  "shortMessage": "user not found",
  "longMessage": "The user of the actor token no longer exists. Please request a new one.",
  "code": "actor_token_subject_not_found_code"
}
```

## `ActorTokenCannotBeRevoked`

```json
{
  "shortMessage": "cannot revoke",
  "longMessage": "Actor token cannot be revoked because its status is <status>. Only pending tokens can be revoked.",
  "code": "actor_token_cannot_be_revoked_code"
}
```

---
title: Add a custom Identity Provider (IdP) as a SAML connection
description: Learn how to integrate an Identity Provider (IdP) with Clerk using SAML SSO.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Add the Enhanced authentication add-on to your Pro plan",
      link: "/pricing",
      icon: "plus-circle",
    },
    {
      title: "Enable email address as an identifier for your application.",
      link: "/docs/authentication/configuration/sign-up-sign-in-options#identifiers",
      icon: "key",
    }
  ]}
/>

Clerk supports Enterprise SSO via the SAML protocol, enabling you to create authentication strategies for an Identity Provider (IdP). Currently, Clerk offers direct integrations with the following IdPs: [Microsoft Azure AD](/docs/authentication/enterprise-connections/saml/azure), [Google Workspace](/docs/authentication/enterprise-connections/saml/google), and [Okta Workforce](/docs/authentication/enterprise-connections/saml/okta). However, you can also integrate with any other IdPs that supports the SAML protocol.

This guide shows you how to set up a SAML connection with a custom IdP in Clerk.

<Steps>
  ## Set up an enterprise connection in Clerk

  To create a SAML connection in Clerk:

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For specific domains or organizations**.
  1. Under **SAML**, select **Custom SAML Provider**.
  1. Add the **Domain** for which you want to enable this connection. This is the domain of the users you wish to allow to sign in to your application. Optionally, select an **Organization**.
  1. Enter the **Name**. This will be displayed on the sign-in form.
  1. Select **Add connection**. You'll be redirected to the connection's configuration page.

  ## Create a new enterprise application in your IdP

  Create a new application in your IdP. In the next steps, you'll configure your IdP with the settings provided by your Service Provider (Clerk), and configure Clerk with the settings provided by your IdP. Keep both the IdP and Clerk Dashboard open.

  ## Configure your Identity Provider

  There are two options for configuring your IdP:

  - [**Metadata configuration**](#metadata-configuration) - This is where you can download your IdP's metadata file or input the metadata URL that you got from your IdP. This is the recommended way to configure your IdP, but not all IdPs support this method.
  - [**Custom configuration**](#custom-configuration) - This is where you can manually input the configuration settings for your IdP.

  ### Metadata configuration

  1. In your IdP dashboard, find where you can download the metadata file or copy the metadata URL.
  1. In the Clerk Dashboard on the connection's configuration page, under **Identity Provider Configuration**,select **Add via metadata**. Input the metadata URL or upload the metadata file that you got from your IdP.

  ### Custom configuration

  If you choose to manually input the configuration settings for your IdP, you will need to fill these three fields in the Clerk Dashboard:

  - **SSO URL** - This is your IdP's URL that Clerk will redirect your users to so that they authenticate.
  - **Entity ID** - This is the unique identifier of your IdP application.
  - **Certificate** - This is the certificate needed for Clerk to securely connect to your IdP.

  1. In your IdP dashboard, find these values and copy them.
  1. In the Clerk Dashboard, paste the values you copied from your IdP into the appropriate fields, and upload the certificate you got from your IdP.

  ### Configure your Service Provider

  To configure your Service Provider (Clerk), your IdP will either ask for the **Assertion Consumer Service (ACS) URL** and **Entity ID** or it will ask for the **Metadata URL**. If your IdP gives you the option to choose between the two, it is recommended to choose the **Metadata URL** as it is the quickest and most reliable way to configure your Service Provider.

  Here are what these settings mean:

  - **Assertion Consumer Service (ACS) URL** - This is your application's URL that your IdP will redirect your users back to after they have authenticated in your IdP.
  - **Entity ID** - This is a unique identifier for your SAML connection that your IdP application needs.
  - **Metadata URL** - This is the URL to your SAML connection's metadata file. This is the recommended way to configure your Service Provider.

  To find the values for these settings:

  1. In the Clerk Dashboard, on the connection's configuration page, find the **Service Provider configuration** section.
  1. Copy the values you need for your IdP.
  1. In your IdP dashboard, paste the values in the appropriate fields.

  > [!TIP]
  > If you closed the connection's configuration page in the Clerk Dashboard, you can find it by navigating to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page and selecting the settings icon next to the connection you want to configure.

  ### Map your IdP's claims to Clerk fields

  Mapping the claims in your IdP to the attributes in Clerk ensures that the data from your IdP is correctly mapped to the data in Clerk.

  In the Clerk Dashboard, find the **Attribute mapping** section. Here, you are shown what properties on the [`User`](/docs/references/javascript/user) object in Clerk are being mapped to the claims in your IdP.

  In your IdP dashboard, there should be a section where you can map the IdP's claims to the attributes in Clerk. For example, Google has a `Primary email` claim that needs to be mapped to Clerk's `mail` property. During SAML configuration in the Google dashboard, Google provides a section where these claims can be mapped.

  If you have additional claims that you would like to map to Clerk that are not listed in the **Attribute mapping** section, you can do so by following the steps in the [Map other claims](#map-other-claims-optional) section.

  ### Map other claims (optional)

  In Clerk, the [`User`](/docs/references/javascript/user) object has a `publicMetadata` property that you can use to store additional information about your users.

  To map other claims from your IdP that do not have a direct mapping to Clerk attributes, you can map them to the `publicMetadata` property. To do this, prepend the Clerk claims with `public_metadata_` during the mapping process.

  For example, say you were using Google as your IdP. Google users have the "Phone number" attribute. Clerk does not have a direct mapping for this attribute, as you can see in the Clerk Dashboard in the **Attribute mapping** section. Instead, in the Google dashboard, you would map Google's "Phone number" claim to `public_metadata_phone_number`. Then, in Clerk, the value for the user's phone number would be saved in the user's `User.publicMetadata` under the key `phone_number`.

  Learn more about [how to access the metadata from our APIs](/docs/users/metadata).

  ### Enable the connection for Clerk

  To make the connection available for your users to authenticate with:

  1. In the Clerk Dashboard, you should still have the connection's configuration page open. If not, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page and select the connection.
  1. Toggle on **Enable connection** and select **Save**.
</Steps>

---
title: Add a custom OAuth provider as a social connection
description: Configure a custom OpenID Connect (OIDC) compatible authentication provider for your Clerk application.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk application is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "An OIDC identity provider is required.",
      link: "https://openid.net/specs/openid-connect-core-1_0.html",
      icon: "user-circle",
    }
  ]}
/>

Clerk allows you to configure custom OpenID Connect (OIDC) compatible authentication providers for your application. This guide walks you through the steps to set up a custom OAuth provider.

## Configuration

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select the **Add connection** button, and select **For all users**.
1. At the top of the modal that opened, select **Custom provider**.
1. Fill in the following fields:
   - **Name**: The provider name (visible to users)
   - **Key**: A unique identifier for the provider (cannot be changed after creation)
   - **Discovery Endpoint**: The OIDC discovery endpoint URL of your provider
     - Alternatively, select **Manual configuration** to set up provider endpoints manually
   - **Client ID**: Obtained from your provider
   - **Client Secret**: Obtained from your provider
1. Select **Add connection**. You will be redirected to the connection's configuration page.

The provider is now configured but not yet enabled. On the connection's configuration page, find the **Authorized redirect URLs** to configure in your provider's settings.

Enable the provider either from the provider list or the top of the details page when ready.

## Attribute mapping

If your provider returns claims in a non-standard format:

1. Go to the provider's details page.
1. Under **Attribute mapping**, configure the mapping to match your provider's claim format.

### Tips

- For fields like **Email address verified**, set default values for missing claims.
- If the provider returns a claim but you don't want to set it, leave the mapping field empty.
- If you set a user info URL, it takes priority over the ID Token for claim retrieval.

## Handling edge cases

Sometimes [attribute mapping](#attribute-mapping) isn't enough to get a provider working. For example, the call to the **User info URL** might require additional credentials or API calls. In these instances you should implement a proxy between Clerk and the provider to handle these transformations. The proxy will then be set as the **User info URL**.

The proxy receives the request from Clerk (which contains an `Authorization` header) and should return a JSON object which you can use for attribute mapping.

### Example: Hono with Cloudflare Workers

1. Initialize a new [Hono + Cloudflare Workers](https://hono.dev/docs/getting-started/cloudflare-workers) project

1. Implement your proxy logic, e.g. making an additional API call. Here's a minimal example:

   ```ts {{ filename: 'src/index.ts' }}
   import { Hono } from 'hono'

   const app = new Hono()

   app.get('/', async (c) => {
     const authorization = c.req.header('authorization')

     const userRes = await fetch('https://api.com/user', {
       headers: {
         'Content-Type': 'application/json',
         Authorization: authorization,
         'api-key': 'some-api-key',
       },
     })

     const user = await userRes.json()

     return c.json({
       uuid: user.uuid,
       avatar_url: user.avatar,
       name: user.name,
       username: user.username,
       slug: user.id.slug,
     })
   })

   export default app
   ```

1. Deploy your proxy

1. Set the URL of the deployed Cloudflare worker as the **User info URL**

1. Map the returned claim format of the proxy to the respective attributes in the **Attribute mapping** section

## References

- [OpenID Connect Specification](https://openid.net/specs/openid-connect-core-1_0.html)
- [OAuth 2.0 Framework](https://oauth.net/2/)

---
title: Add a custom OpenID Connect (OIDC) Provider as an enterprise connection
description: Learn how to integrate a custom OIDC provider with Clerk for Enterprise SSO.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Add the Enhanced Authentication add-on to your Pro plan",
      link: "/pricing",
      icon: "plus-circle",
    },
    {
      title: "Enable email address as an identifier for your app",
      link: "/docs/authentication/configuration/sign-up-sign-in-options#identifiers",
      icon: "key",
    },
  ]}
/>

This guide explains how to use a custom [OpenID Connect (OIDC)](https://openid.net/developers/how-connect-works) provider to authenticate users via Enterprise SSO.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your Identity Provider (IdP).

<Steps>
  ## Set up an enterprise connection in Clerk

  1. In the Clerk Dashboard, navigate to the [**SSO Connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For specific domains or organizations**.
  1. Under **OpenID Connect (OIDC)**, select **Custom OIDC Provider**.
  1. Add the **Name** of the connection.
  1. Add the **Key** of the provider. This is the provider's unique identifier (cannot be changed after creation).
  1. Enter the **Domain**. This is the email domain of the users you want to allow to sign in to your application. Optionally, select an **Organization**.
  1. Select **Add connection**. You will be redirected to the connection's configuration page. Keep this page open.

  ## Configure your IdP

  1. If necessary, create a new application in your IdP.
  1. In the connection's configuration page of the Clerk Dashboard, copy the **Authorized redirect URI**.
  1. Add the value to your IdP's whitelisted URLs.
  1. Find your application's **Discovery Endpoint**, **Client ID**, and **Client Secret** and copy them.

  ## Set the Discovery Endpoint, Client ID, and Client Secret in Clerk

  1. In your IdP settings, copy your application's **Discovery Endpoint**, **Client ID**, and **Client Secret**.
  1. In the connection's configuration page in the Clerk Dashboard, paste these values in their respective fields.
  1. Under **Scopes**, add the minimum required scopes based on the IdP's documentation if needed. Common OIDC scopes include `openid`, `email`, and `profile`.
  1. Select **Save**.

  > [!NOTE]
  > Most IdPs provide a **Discovery Endpoint** to retrieve metadata about an OIDC provider. If your IdP doesn't offer this endpoint or if you need greater control over the setup process, in the connection's configuration page in the Clerk Dashboard, find the **Identity Provider Configuration** section and select **Use Manual Configuration** to manually configure the connection.

  ## Configure attribute mapping (optional)

  Clerk expects the claims returned by your IdP to follow the [OIDC Standard](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). If your provider returns claims in a non-standard format, use the **Attribute Mapping** section on the connection's configuration page to adjust the mapping of Clerk's user properties to match the IdP's claim attributes.

  > [!WARNING]
  > OIDC Enterprise connections require the [`email_verified`](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims:~:text=Section%C2%A05.7.-,email_verified,-boolean) claim to verify email ownership. However, some IdPs, such as Microsoft Azure Active Directory, might not return this claim or use a non-standard format.
  >
  > If the IdP doesn't return this claim, you can leave the **Email address verified** field blank and set the **Default value** to **True**. This should only be done if you fully trust the IdP, as it can expose your app to [OAuth attacks](https://www.descope.com/blog/post/noauth).

  ## Allow additional identifiers (optional)

  User profile information is sourced from the IdP. To allow users to add new identifiers (e.g., email address or phone number) to their profiles:

  1. In the connection's configuration page of the Clerk Dashboard, navigate to the **Advanced** tab.
  1. Enable **Allow additional identifiers**.
  1. Select **Save**.

  ## Enable the connection for Clerk

  To make the connection available for your users to authenticate with:

  1. Navigate back to the Clerk Dashboard where you should still have the connection's configuration page open. If not, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page and select the connection.
  1. At the top of the page, toggle on **Enable connection** and select **Save**.

  ## Test your connection

  The simplest way to test your enterprise connection is to visit your Clerk app's [Account Portal](/docs/account-portal/overview), which is available for all Clerk apps out-of-the-box.

  1. In the Clerk Dashboard, navigate to the [**Account Portal**](https://dashboard.clerk.com/last-active?path=account-portal) page.
  1. Next to the **Sign-in** URL, select **Visit**. The URL should resemble:
     - **For development**  `https://your-domain.accounts.dev/sign-in`
     - **For production**  `https://accounts.your-domain.com/sign-in`
  1. Sign in with your IdP account.
</Steps>

---
title: Add Apple as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Apple ID using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk application is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "An Apple Developer account is required.",
      link: "https://developer.apple.com/programs/enroll/",
      icon: "user-circle",
    }
  ]}
/>

Enabling OAuth via [Sign in with Apple](https://developer.apple.com/sign-in-with-apple/) allows your users to sign in and sign up to your Clerk app with their Apple ID.

> [!IMPORTANT]
> This guide explains how to configure Sign in with Apple for web based flows. To configure native Sign in with Apple on native applications (iOS), see the [dedicated guide](/docs/references/ios/sign-in-with-apple).

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIs.

To configure your development instance, follow these steps:

1. In the Clerk Dashboard, navigate to the [**SSO Connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **Apple**.
1. Then, select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials.

You must generate and provide your own **Apple Services ID**, **Apple Private Key**, **Apple Team ID**, and **Apple Key ID** using your Apple Developer account.

To make the setup process easier, it's recommended to keep two browser tabs open: one for your [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Apple Developer dashboard](https://developer.apple.com/account).

<Steps>
  ### Enable Apple as a social connection

  1. In the Clerk Dashboard, navigate to the [**SSO Connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Apple**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Email Source for Apple Private Email Relay** and **Return URL** values somewhere secure, as you'll need to provide them to Apple later. Keep this page and modal open.

  ### Get your Apple Team ID

  To get your **Apple Team ID**, create a new **App ID** in the Apple Developer portal by following these steps:

  1. On a separate page, navigate to the [Apple Developer dashboard](https://developer.apple.com/account).
  1. Under **Certificates, IDs and Profiles**, select [**Identifiers**](https://developer.apple.com/account/resources/identifiers/list).
  1. In the top-right, select the dropdown and select **App IDs**.
  1. Next to **Identifiers** at the top of the page, select the plus icon (+) to register a new identifier. You'll be redirected to the **Register a new identifier** page.
  1. Select **App IDs**, then select **Continue**.
  1. On the next page, you'll be prompted to **Select a type** for your app. Choose **App** and select **Continue**. You will be redirected to the **Register an App ID** page.
  1. Fill in a description for your **App ID** and a **Bundle ID**. Under **Capabilities**, ensure that **Sign In with Apple** is enabled. Then select **Continue**. You'll be redirected to the **Confirm your App ID** page.
  1. At the top of the page, you'll see your **App ID Prefix**. Save this value somewhere secure. This is your **Apple Team ID** in Clerk.
  1. Finally, select **Register**. You'll be redirected to the **Identifiers** page.

  ### Get your Apple Services ID

  To get your **Apple Services ID**, create a new **Services ID** in the Apple Developer portal.

  1. On the **Identifiers** page, in the dropdown near the top-right of the page, select the **Services IDs** option from the list.
  1. Next to **Identifiers** at the top of the page, select the plus icon (+) to register a new identifier. You'll be redirected to the **Register a new identifier** page.
  1. Select **Services IDs**, then select **Continue**. You'll be redirected to the **Register a Services ID** page.
  1. Add a description for your **Services ID**, and set an **Identifier**. Save the **Identifier** value somewhere secure. This is your **Apple Services ID** in Clerk. Finally, select **Continue**.
  1. In the confirmation view, select **Register**.
  1. After the registration is finished, select the newly-created **Services ID**. Ensure the **Sign In with Apple** box is enabled and select **Configure**.
  1. Under **Primary App ID**, select the **App ID** you created in the previous step.
  1. Under **Domains and Subdomains**, add your Clerk **Frontend API URL** **without the protocol**. For example, if your domain is `https://myapp.com`, then your **Frontend API URL** is `https://clerk.myapp.com`, and you would add `clerk.myapp.com` to **Domains and Subdomains**.
  1. Under **Return URLS**, add the **Return URL** value you saved from the Clerk Dashboard.
  1. Select **Next**. You'll be redirected to the **Confirm your web authentication configuration** screen.
  1. Select **Done**. You'll be redirected to the **Edit your Services ID Configuration** page.
  1. Select **Continue**. You'll be redirected to the confirmation page.
  1. Select **Save**. You'll be redirected to the **Identifiers** page.

  ### Get your Apple Private Key and Key ID

  To get your **Apple Private Key** and **Key ID**, create a new **Key** in the Apple Developer portal.

  1. On the **Identifiers** page, in the sidenav, select **Keys**.
  1. Next to **Keys** at the top of the page, select the plus icon (+) to register a new key. You'll be redirected to the **Register a New Key** page.
  1. Add a **Key Name** and ensure the **Sign In with Apple** box is enabled and select **Configure**. You'll be redirected to the **Configure Key** page.
  1. Under **Primary App ID**, select the **App ID** you created in the first step of this guide. Then select **Save**. You'll be redirected to the previous **Register a New Key** page.
  1. Select **Continue** and you'll be presented with the final confirmation screen. Verify that **Sign in with Apple** is checked. Select **Register**. You'll be redirected to the **Download Your Key** page.
  1. Save the **Key ID** value somewhere secure. This is your **Apple Key ID** in Clerk.
  1. Download the private key file. This is your **Apple Private Key** in Clerk. Ensure you back up the key in a secure location, as it cannot be downloaded again later.
  1. Select **Done**. You'll be redirected to the **Keys** page.

  ### Configure Email Source for Apple Private Relay

  Apple provides a privacy feature called [Hide My Email](https://support.apple.com/en-us/HT210425#hideemail), allowing users to sign in to your app with Apple without disclosing their actual email addresses. Instead, your instance receives an app-specific email address that forwards any emails to the user real's address.

  To be able to send emails properly to users with hidden addresses, you must configure an additional setting in the Apple Developer portal.

  1. In the sidenav of the Apple Developer Portal, select [**Services**](https://developer.apple.com/account/resources/services/list).
  1. Under **Sign in with Apple for Email Communication**, select **Configure**. You'll be redirected to the **Configure Sign in with Apple for Email Communication** page.
  1. Next to **Email Sources** at the top of the page, select the plus icon (+) to add a new **Email Source**.
  1. In the **Register your email sources** modal that opens, under **Email Addresses**, add the **Email Source for Apple Private Email Relay** value that you copied from the [**Apple SSO custom credentials**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) in the Clerk Dashboard. It should look something like this: `bounces+00000000@clkmail.myapp.com`.
  1. Select **Next**. The modal will redirect to the **Confirm your email sources** screen.
  1. Select **Register**. The modal will redirect to the **Email Source Registration Complete** screen.
  1. Select **Done**.

  After this step, the email address should appear in the list and display a green check icon, indicating it has been verified. If it's not marked as verified yet, DNS propagation may still be in progress. Wait for the propagation to complete before attempting to select **Reverify SPF**.

  For more info about Apple's Private Relay service, refer to the following documentation:

  - [https://support.apple.com/en-us/HT210425#hideemail](https://support.apple.com/en-us/HT210425#hideemail)
  - [https://developer.apple.com/help/account/configure-app-capabilities/configure-private-email-relay-service](https://developer.apple.com/help/account/configure-app-capabilities/configure-private-email-relay-service)

  ### Connect your Apple app to your Clerk app

  By now, you should have the following values saved from the Apple Developer portal:

  - **Apple Team ID**
  - **Apple Services ID**
  - **Apple Key ID**
  - **Apple Private Key** file

  Connect your Apple app to your Clerk app by adding these values to the Clerk Dashboard.

  1. Navigate back to the Clerk Dashboard where the configuration modal should still be open.
  1. Add all the corresponding fields depending on your desired flow. For the **Apple Private Key** file, open it with a text editor and copy/paste the contents. You must include the `-----BEGIN PRIVATE KEY-----` and `-----END PRIVATE KEY-----` lines.
  1. Select **Add connection**.

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add Atlassian as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Atlassian account using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "An Atlassian account is required.",
      link: "https://developer.atlassian.com/",
      icon: "user-circle",
    }
  ]}
/>

Enabling OAuth with Atlassian allows your users to sign up and sign in to your Clerk app with their Atlassian account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **Atlassian**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Atlassian Developer console](https://developer.atlassian.com/console/myapps/).

<Steps>
  ### Enable Atlassian as a social connection

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Atlassian**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Callback URL** somewhere secure. Keep this modal and page open.

  ### Create an Atlassian workspace

  > [!TIP]
  > If you already have an Atlassian workspace you'd like to connect to Clerk, select your workspace from the [Atlassian Developer console](https://developer.atlassian.com/console/myapps/) and skip to [the next step in this tutorial](#configure-your-atlassian-app).

  1. In the [Atlassian Developer console](https://developer.atlassian.com/console/myapps/), next to **My apps**, select **Create**. Then, select **OAuth 2.0 integration**. You'll be redirected to the **Create a new OAuth 2.0 (3LO) integration** page.
  1. Fill out the necessary information. Then, select **Create**. Once the integration is created, you'll be redirected to the app's **Overview** page.

  ### Configure your Atlassian app

  1. In the left sidenav of your app's **Overview** page, select **Permissions**. Configure the OAuth 2.0 scopes to request from your users when they connect with Atlassian. At a minimum, next to **User identity API**, select **Add**.
  1. In the left sidenav, select **Authorization**.
  1. Next to **OAuth 2.0 (3LO)**, select **Add**.
  1. In the **Callback URL** field, paste the **Callback URL** you saved from the Clerk Dashboard.
  1. Select **Save changes**.
  1. In the left sidenav, select **Settings**.
  1. Under **Authentication details**, save the **Client ID** and **Secret** somewhere secure.
  1. In the left sidenav, select **Distribution**.
  1. Select **Edit**.
  1. Set the **Distribution Status** to **Sharing**.
  1. Complete the required fields. For **Does your app store personal data?**, select **Yes**, as Clerk uses the user's personal data to authenticate them.
  1. Select **Save changes**.

  ### Set the Client ID and Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ### Test your connection

  > [!WARNING]
  > To be able to connect, the user must have access to at least one Atlassian site (e.g. JIRA, Confluence). Currently, the user can authorize access only to a single Atlassian site.

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add Bitbucket as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Bitbucket account with OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A Bitbucket account is required.",
      link: "https://bitbucket.org/account/signup",
      icon: "user-circle",
    }
  ]}
/>

Enabling OAuth with [Bitbucket](https://developer.atlassian.com/cloud/bitbucket/oauth-2) allows your users to sign up and sign in to your Clerk application with their Bitbucket account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **Bitbucket**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Bitbucket Workspaces](https://bitbucket.org/account/workspaces/) page.

<Steps>
  ### Enable Bitbucket as a social connection in Clerk

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Bitbucket**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Callback URL** somewhere secure. Keep the modal and page open.

  ### Create a Bitbucket OAuth Consumer

  1. On a separate page, go to the [Bitbucket Workspaces](https://bitbucket.org/account/workspaces/) page and sign in.
  1. Under **Workspaces**, find your workspace and select **Manage**.
  1. In the sidenav, scroll down and select **OAuth consumers**.
  1. Select **Add consumer**.
  1. Complete the required fields. In  **Permissions** , under **Account**, select **Email** and **Read**.
  1. Select **Save**. You'll be redirected to the **OAuth consumers** page.
  1. Select your consumer and save the **Key** and **Secret** values somewhere secure.

  ### Set the Key and Secret in the Clerk Dashboard

  1. Navigate back to the Clerk Dashboard where the modal should still be open. Paste the **Key** and **Secret** values that you saved into the respective fields.
  1. Select **Add connection**.

  > [!NOTE]
  > If the modal or page is no longer open, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page in the Clerk Dashboard. Select the connection. Under **Use custom credentials**, paste the values into their respective fields.

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add bot protection to your custom sign-up flow
description: Learn how to add Clerk's bot protection to your custom sign-up flow.
---

<Include src="_partials/custom-flows-callout" />

Clerk provides the ability to add a CAPTCHA widget to your sign-up flows to protect against bot sign-ups. The [`<SignUp />`](/docs/components/authentication/sign-up) component handles this flow out-of-the-box. However, if you're building a custom user interface, this guide will show you how to add the CAPTCHA widget to your custom sign-up flow.

<Steps>
  ## Enable bot sign-up protection

  1. In the Clerk Dashboard, navigate to the [**Attack protection**](https://dashboard.clerk.com/last-active?path=user-authentication/attack-protection) page.
  1. In the **Bot sign-up protection** section, enable the feature and choose the **CAPTCHA type** you want to use.

  ## Add the CAPTCHA widget to your custom sign-up form

  To render the CAPTCHA widget in your custom sign-up form, you need to include a specific element in your DOM. Specifically, there should be a `<div id="clerk-captcha" />` element by the time you call `signUp.create()`. This element acts as a placeholder onto which the widget will be rendered.

  If this element is not found, the SDK will transparently fall back to the **Invisible** widget in order to avoid breaking your sign-up flow. If this happens, you should see a relevant error in your browser's console.

  > [!TIP]
  > The **Invisible** widget automatically blocks suspected bot traffic without offering users falsely detected as bots with an opportunity to prove otherwise. Therefore, it's strongly recommended that you ensure the `<div id="clerk-captcha" />` element exists in your DOM.

  <Tabs items={["Next.js"]}>
    <Tab>
      The following example demonstrates how to add the CAPTCHA widget to a custom sign-up form. This example uses the [Email & password custom flow](/docs/custom-flows/email-password) but you can add the CAPTCHA widget to _any_ custom sign-up form.

      ```tsx {{ filename: 'app/sign-up/[[...sign-up]]/page.tsx', mark: [112, 113], collapsible: true }}
      'use client'

      import * as React from 'react'
      import { useSignUp } from '@clerk/nextjs'
      import { useRouter } from 'next/navigation'

      export default function Page() {
        const { isLoaded, signUp, setActive } = useSignUp()
        const [emailAddress, setEmailAddress] = React.useState('')
        const [password, setPassword] = React.useState('')
        const [verifying, setVerifying] = React.useState(false)
        const [code, setCode] = React.useState('')
        const router = useRouter()

        // Handle submission of the sign-up form
        const handleSubmit = async (e: React.FormEvent) => {
          e.preventDefault()

          if (!isLoaded) return

          // Start the sign-up process using the email and password provided
          try {
            await signUp.create({
              emailAddress,
              password,
            })

            // Send the user an email with the verification code
            await signUp.prepareEmailAddressVerification({
              strategy: 'email_code',
            })

            // Set 'verifying' true to display second form
            // and capture the OTP code
            setVerifying(true)
          } catch (err: any) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error(JSON.stringify(err, null, 2))
          }
        }

        // Handle the submission of the verification form
        const handleVerify = async (e: React.FormEvent) => {
          e.preventDefault()

          if (!isLoaded) return

          try {
            // Use the code the user provided to attempt verification
            const completeSignUp = await signUp.attemptEmailAddressVerification({
              code,
            })

            // If verification was completed, set the session to active
            // and redirect the user
            if (completeSignUp.status === 'complete') {
              await setActive({ session: completeSignUp.createdSessionId })
              router.push('/')
            } else {
              // If the status is not complete, check why. User may need to
              // complete further steps.
              console.error(JSON.stringify(completeSignUp, null, 2))
            }
          } catch (err: any) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error('Error:', JSON.stringify(err, null, 2))
          }
        }

        // Display the verification form to capture the OTP code
        if (verifying) {
          return (
            <>
              <h1>Verify your email</h1>
              <form onSubmit={handleVerify}>
                <label id="code">Enter your verification code</label>
                <input value={code} id="code" name="code" onChange={(e) => setCode(e.target.value)} />
                <button type="submit">Verify</button>
              </form>
            </>
          )
        }

        // Display the initial sign-up form to capture the email and password
        return (
          <>
            <h1>Sign up</h1>
            <form onSubmit={handleSubmit}>
              <div>
                <label htmlFor="email">Enter email address</label>
                <input
                  id="email"
                  type="email"
                  name="email"
                  value={emailAddress}
                  onChange={(e) => setEmailAddress(e.target.value)}
                />
              </div>
              <div>
                <label htmlFor="password">Enter password</label>
                <input
                  id="password"
                  type="password"
                  name="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                />
              </div>

              {/* CAPTCHA Widget */}
              <div id="clerk-captcha"></div>

              <div>
                <button type="submit">Next</button>
              </div>
            </form>
          </>
        )
      }
      ```
    </Tab>
  </Tabs>

  ## Customize the appearance of the CAPTCHA widget

  You can customize the appearance of the CAPTCHA widget by passing data attributes to the `<div id="clerk-captcha" />` element. The following attributes are supported:

  - `data-cl-theme`: The CAPTCHA widget theme. Can take the following values: `'light'`, `'dark'`, `'auto'`. Defaults to `'auto'`.
  - `data-cl-size`: The CAPTCHA widget size. Can take the following values: `'normal'`, `'flexible'`, `'compact'`. Defaults to `'normal'`.
  - `data-cl-language`: The CAPTCHA widget language. Must be either `'auto'` (default) to use the language that the visitor has chosen, or language and country code (e.g. `'en-US'`). Some languages are [supported by Clerk](/docs/customization/localization) but not by Cloudflare Turnstile, which is used for the CAPTCHA widget. See [Cloudflare Turnstile's supported languages](https://developers.cloudflare.com/turnstile/reference/supported-languages).

  For example, to set the theme to `'dark'`, the size to `'flexible'`, and the language to `'es-ES'`, you would add the following attributes to the `<div id="clerk-captcha" />` element:

  ```html
  <div id="clerk-captcha" data-cl-theme="dark" data-cl-size="flexible" data-cl-language="es-ES" />
  ```
</Steps>

---
title: Add Box as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Box account using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A Box account is required.",
      link: "https://account.box.com/login",
      icon: "user-circle",
    }
  ]}
/>

Enabling OAuth with Box allows your users to sign up and sign in to your Clerk app with their Box account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **Box**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Box Developer Console](https://app.box.com/developers/console).

<Steps>
  ### Enable Box as a social connection

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Box**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Redirect URI** somewhere secure. Keep this modal and page open.

  ### Create a Box app

  1. On the homepage of the [Box Developer Console](https://app.box.com/developers/console), select **Custom App**. A modal will open.
  1. Fill out the necessary information. Use Box's [guide on OAuth 2.0 setup](https://developer.box.com/guides/authentication/oauth2/oauth2-setup/#app-creation-steps) to help you.
  1. Select **Next**.
  1. In the list of authentication methods, select **User Authentication (OAuth 2.0)**.
  1. Select **Create App**. You'll be redirected to the app's **Configuration** page.
  1. In the **OAuth 2.0 Redirect URIs** section, paste the **Redirect URI** value you saved from the Clerk Dashboard.
  1. In the **OAuth 2.0 Credentials** section, save the **Client ID** and **Client Secret** somewhere secure.

  ### Set the Client ID and Client Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add Coinbase as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Coinbase account using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A Coinbase account is required.",
      link: "https://login.coinbase.com/signup",
      icon: "user-circle",
    },
  ]}
/>

Enabling OAuth with [Coinbase](https://docs.cdp.coinbase.com/coinbase-app/docs/coinbase-app) allows your users to sign up and sign in to your Clerk app with their Coinbase account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **Coinbase**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Coinbase Developer Platform](https://portal.cdp.coinbase.com).

<Steps>
  ### Enable Coinbase as a social connection in Clerk

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Coinbase**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Redirect URI** somewhere secure. Keep the modal and page open.

  ### Create a Coinbase app

  > [!NOTE]
  > Coinbase automatically creates a default project for you named `Project 1`. Select the icon next to the project name to rename it.

  1. In your [Coinbase Developer Platform project dashboard](https://portal.cdp.coinbase.com/projects), select the **API keys** tab.
  1. Select **OAuth**, then select **Create client**.
  1. Complete the required fields. In **Redirect URIs**, paste the **Redirect URI** you saved from the Clerk Dashboard.
  1. Select **Create client**. The page will refresh and you should see the **Client ID** and **Client Secret**. Save these values somewhere secure.

  ### Set the Client ID and Client Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add custom items and links to the `<UserButton />` component
description: Learn how to add custom items and include external links within the <UserButton /> menu.
---

The [`<UserButton />`](/docs/components/user/user-button) component supports _custom_ menu items, allowing the incorporation of app-specific settings or additional functionality.

There are two types of custom menu items available:

- [`<UserButton.Action>`](#user-button-action) - A menu item that triggers an action when clicked.
- [`<UserButton.Link>`](#user-button-link) - A menu item that navigates to a page when clicked.

You can also [reorder default items](#reorder-default-items) and [conditionally render menu items](#conditionally-render-menu-items).

## `<UserButton.Action>`

`<UserButton.Action />` allows you to add actions to the `<UserButton />` component, like opening a chat or triggering a modal.

### Props

`<UserButton.Action />` accepts the following props:

<Properties>
  - `label`
  - `string`

  The name that will be displayed in the menu of the user button.

  ---

  - `labelIcon`
  - `React.ReactElement`

  An icon displayed next to the label in the menu.

  ---

  - `open?`
  - `string`

  The path segment that will be used to open the user profile modal to a specific page.

  ---

  - `onClick?`
  - `void`

  A function to be called when the menu item is clicked.
</Properties>

### Examples

#### Add an action

The following example adds an "Open chat" action to the `<UserButton />` component. When a user selects the `<UserButton />`, there will be an "Open chat" menu item.

<Tabs items={["Next.js", "Astro", "JavaScript", "Vue"]}>
  <Tab>
    ```tsx {{ filename: '/app/page.tsx' }}
    'use client'

    import { UserButton } from '@clerk/nextjs'

    const DotIcon = () => {
      return (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
          <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
        </svg>
      )
    }

    export default function Home() {
      return (
        <header>
          <UserButton>
            <UserButton.MenuItems>
              <UserButton.Action
                label="Open chat"
                labelIcon={<DotIcon />}
                onClick={() => alert('init chat')}
              />
            </UserButton.MenuItems>
          </UserButton>
        </header>
      )
    }
    ```
  </Tab>

  <Tab>
    In Astro components, props are converted to strings, so you can't use an `onClick` handler to handle click events. Instead, you can set an arbitrary prop, set up a custom event listener that will check for the value passed to that prop, and then execute a desired action based on that value.

    For example, `clickIdentifier` is the arbitrary prop being used to identify the click event. Two `<UserButton.Action />` components are added to the menu, each with a different `clickIdentifier` prop. When the menu item is clicked, the custom event listener will check for the value passed to the `clickIdentifier` prop, either `"open_chat"` or `"open_cart"`, and then execute an action based on that value.

    ```astro {{ filename: 'pages/index.astro' }}
    ---
    import { UserButton } from '@clerk/astro/components'
    ---

    <header>
      <UserButton>
        <UserButton.MenuItems>
          <UserButton.Action label="Open chat" clickIdentifier="open_chat">
            <svg
              slot="label-icon"
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 512 512"
              fill="currentColor"
            >
              <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
            </svg>
          </UserButton.Action>
          <UserButton.Action label="Open cart" clickIdentifier="open_cart">
            <svg
              slot="label-icon"
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 512 512"
              fill="currentColor"
            >
              <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
            </svg>
          </UserButton.Action>
        </UserButton.MenuItems>
      </UserButton>
    </header>

    <script>
      document.addEventListener('clerk:menu-item-click', (e) => {
        if (e.detail === 'open_chat') {
          console.log('init chat')
        }
        if (e.detail === 'open_cart') {
          console.log('init cart')
        }
      })
    </script>
    ```
  </Tab>

  <Tab>
    To add custom menu items to the `<UserButton />` component using the [JavaScript SDK](/docs/references/javascript/overview), pass the `customMenuItems` property to the `mountUserButton()` method, as shown in the following example:

    ```js {{ filename: 'main.js' }}
    import { Clerk } from '@clerk/clerk-js'

    // Initialize Clerk with your Clerk Publishable Key
    const clerk = new Clerk('{{pub_key}}')
    await clerk.load()

    document.getElementById('app').innerHTML = `
      <div id="user-button"></div>
    `

    const userButtonDiv = document.getElementById('user-button')

    clerk.mountUserButton(userButtonDiv, {
      customMenuItems: [
        {
          label: 'Help modal',
          onClick: () => {
            alert('Open modal') // your custom event
          },
          mountIcon: (el) => {
            el.innerHTML = ''
          },
          unmountIcon: (el) => {},
        },
      ],
    })
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'App.vue' }}
    <script setup lang="ts">
    import { UserButton } from '@clerk/vue'

    function openChat() {
      alert('init chat')
    }
    </script>

    <template>
      <header>
        <UserButton>
          <UserButton.MenuItems>
            <UserButton.Action label="Open chat" @click="openChat">
              <template #labelIcon>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                  <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
                </svg>
              </template>
            </UserButton.Action>
          </UserButton.MenuItems>
        </UserButton>
      </header>
    </template>
    ```
  </Tab>
</Tabs>

#### Add an action and a custom page

The following example adds an "Open chat" action to the `<UserButton />` component, as well as a [custom page](/docs/customization/user-profile) titled "Help". When a user selects the `<UserButton />`, there will be "Open chat" and "Help" menu items.

<Tabs items={["Next.js", "Astro", "Vue"]}>
  <Tab>
    ```tsx {{ filename: '/app/page.tsx' }}
    'use client'

    import { UserButton } from '@clerk/nextjs'

    const DotIcon = () => {
      return (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
          <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
        </svg>
      )
    }

    export default function Home() {
      return (
        <header>
          <UserButton>
            <UserButton.MenuItems>
              <UserButton.Action label="Help" labelIcon={<DotIcon />} open="help" />
            </UserButton.MenuItems>

            <UserButton.UserProfilePage label="Help" labelIcon={<DotIcon />} url="help">
              <div>
                <h1>Help Page</h1>
                <p>This is the custom help page</p>
              </div>
            </UserButton.UserProfilePage>
          </UserButton>
        </header>
      )
    }
    ```
  </Tab>

  <Tab>
    In the following example, the `<UserButton.Action />` component is used to add a "Help" menu item to the `<UserButton />` component. The `open` prop is set to `"help"` to open the `/help` page when the menu item is selected.

    The `<UserButton.UserProfilePage />` component is used to render the `/help` page, and because its configured as a user profile page, the `<UserProfile />` modal will be opened with the custom "Help" menu item. [Read more about custom pages](/docs/customization/user-profile).

    ```astro {{ filename: 'pages/index.astro' }}
    ---
    import { UserButton } from '@clerk/astro/components'
    ---

    <header>
      <UserButton>
        <UserButton.MenuItems>
          <UserButton.Action label="Help" open="help">
            <svg
              slot="label-icon"
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 512 512"
              fill="currentColor"
            >
              <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
            </svg>
          </UserButton.Action>
        </UserButton.MenuItems>

        <UserButton.UserProfilePage label="Help" url="help">
          <svg
            slot="label-icon"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 512 512"
            fill="currentColor"
          >
            <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
          </svg>
          <div>
            <h1>Help Page</h1>
            <p>This is the custom help page</p>
          </div>
        </UserButton.UserProfilePage>
      </UserButton>
    </header>
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'App.vue' }}
    <script setup lang="ts">
    import { UserButton } from '@clerk/vue'
    </script>

    <template>
      <header>
        <UserButton>
          <UserButton.MenuItems>
            <UserButton.Action label="Help" open="help">
              <template #labelIcon>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                  <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
                </svg>
              </template>
            </UserButton.Action>
          </UserButton.MenuItems>

          <UserButton.UserProfilePage label="Help" url="help">
            <template #labelIcon>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
              </svg>
            </template>
            <div>
              <h1>Help Page</h1>
              <p>This is the custom help page</p>
            </div>
          </UserButton.UserProfilePage>
        </UserButton>
      </header>
    </template>
    ```
  </Tab>
</Tabs>

## `<UserButton.Link>`

`<UserButton.Link />` allows you to add links to the `<UserButton />` component, like custom pages or external URLs.

### Props

`<UserButton.Link />` accept the following props, all of which are **required**:

<Properties>
  - `label`
  - `string`

  The name that will be displayed in the menu of the user button.

  ---

  - `labelIcon`
  - `React.ReactElement`

  An icon displayed next to the label in the menu.

  ---

  - `href`
  - `string`

  The path segment that will be used to navigate to the custom page.
</Properties>

### Example

The following example adds a "Create organization" link to the `<UserButton />` component. When a user selects the `<UserButton />`, there will be a "Create organization" menu item.

<Tabs items={["Next.js", "Astro", "JavaScript", "Vue"]}>
  <Tab>
    ```tsx {{ filename: '/app/page.tsx' }}
    'use client'

    import { UserButton } from '@clerk/nextjs'

    const DotIcon = () => {
      return (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
          <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
        </svg>
      )
    }

    export default function Home() {
      return (
        <header>
          <UserButton>
            <UserButton.MenuItems>
              <UserButton.Link
                label="Create organization"
                labelIcon={<DotIcon />}
                href="/create-organization"
              />
            </UserButton.MenuItems>
          </UserButton>
        </header>
      )
    }
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: 'pages/index.astro' }}
    ---
    import { UserButton } from '@clerk/astro/components'
    ---

    <header>
      <UserButton>
        <UserButton.MenuItems>
          <UserButton.Link label="Create organization" href="/create-organization">
            <svg
              slot="label-icon"
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 512 512"
              fill="currentColor"
            >
              <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
            </svg>
          </UserButton.Link>
        </UserButton.MenuItems>
      </UserButton>
    </header>
    ```
  </Tab>

  <Tab>
    To add custom menu items to the `<UserButton />` component using the [JavaScript SDK](/docs/references/javascript/overview), pass the `customMenuItems` property to the `mountUserButton()` method, as shown in the following example:

    ```js {{ filename: 'main.js' }}
    import { Clerk } from '@clerk/clerk-js'

    // Initialize Clerk with your Clerk Publishable Key
    const clerk = new Clerk('{{pub_key}}')
    await clerk.load()

    document.getElementById('app').innerHTML = `
      <div id="user-button"></div>
    `

    const userButtonDiv = document.getElementById('user-button')

    clerk.mountUserButton(userButtonDiv, {
      customMenuItems: [
        {
          label: 'User page',
          href: '/user',
          mountIcon: (el) => {
            el.innerHTML = ''
          },
          unmountIcon: (el) => {},
        },
      ],
    })
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'App.vue' }}
    <script setup lang="ts">
    import { UserButton } from '@clerk/vue'
    </script>

    <template>
      <header>
        <UserButton>
          <UserButton.MenuItems>
            <UserButton.Link label="Create organization" href="/create-organization">
              <template #labelIcon>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                  <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
                </svg>
              </template>
            </UserButton.Link>
          </UserButton.MenuItems>
        </UserButton>
      </header>
    </template>
    ```
  </Tab>
</Tabs>

## Reorder default items

The `<UserButton />` component includes two default menu items: `Manage account` and `Sign out`, in that order. You can reorder these default items by setting the `label` prop to `'manageAccount'` or `'signOut'`. This will target the existing default item and allow you to rearrange it.

In the following example, the "Sign out" menu item is moved to the top of the menu, a custom "Create organization" link is added as the second menu item, and the "Manage account" menu item is moved to the bottom of the menu.

<Tabs items={["Next.js", "Astro", "Vue"]}>
  <Tab>
    ```tsx {{ filename: '/app/page.tsx' }}
    'use client'

    import { UserButton } from '@clerk/nextjs'

    const DotIcon = () => {
      return (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
          <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
        </svg>
      )
    }

    export default function Home() {
      return (
        <header>
          <UserButton>
            <UserButton.MenuItems>
              <UserButton.Action label="signOut" />
              <UserButton.Link
                label="Create organization"
                labelIcon={<DotIcon />}
                href="/create-organization"
              />
              <UserButton.Action label="manageAccount" />
            </UserButton.MenuItems>
          </UserButton>
        </header>
      )
    }
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: 'pages/index.astro' }}
    ---
    import { UserButton } from '@clerk/astro/components'
    ---

    <header>
      <UserButton>
        <UserButton.MenuItems>
          <UserButton.Action label="signOut" />
          <UserButton.Link label="Create organization" open="/create-organization">
            <svg
              slot="label-icon"
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 512 512"
              fill="currentColor"
            >
              <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
            </svg>
          </UserButton.Link>
          <UserButton.Action label="manageAccount" />
        </UserButton.MenuItems>
      </UserButton>
    </header>
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'App.vue' }}
    <script setup lang="ts">
    import { UserButton } from '@clerk/vue'
    </script>

    <template>
      <header>
        <UserButton>
          <UserButton.MenuItems>
            <UserButton.Action label="signOut" />
            <UserButton.Link label="Create organization" href="/create-organization">
              <template #labelIcon>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                  <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
                </svg>
              </template>
            </UserButton.Link>
            <UserButton.Action label="manageAccount" />
          </UserButton.MenuItems>
        </UserButton>
      </header>
    </template>
    ```
  </Tab>
</Tabs>

## Conditionally render menu items

To conditionally render menu items based on a user's role or custom permissions, you can use the [`has()`](/docs/references/backend/types/auth-object#has) helper function.

In the following example, the "Create organization" menu item will only render if the current user has the `org:app:admin` permission.

<Tabs items={["Next.js", "Astro", "Vue"]}>
  <Tab>
    ```tsx {{ filename: '/app/page.tsx' }}
    'use client'

    import { UserButton, useAuth } from '@clerk/nextjs'

    const DotIcon = () => {
      return (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
          <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
        </svg>
      )
    }

    export default function Home() {
      const { has, isLoaded } = useAuth()

      if (!isLoaded) {
        return <span>Loading...</span>
      }

      const isAdmin = has({ permission: 'org:app:admin' })

      return (
        <header>
          <UserButton>
            {isAdmin && (
              <UserButton.MenuItems>
                <UserButton.Link
                  label="Create organization"
                  labelIcon={<DotIcon />}
                  href="/create-organization"
                />
              </UserButton.MenuItems>
            )}
          </UserButton>
        </header>
      )
    }
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: 'pages/index.astro' }}
    ---
    import { UserButton } from '@clerk/astro/components'

    const { has } = Astro.locals.auth()

    const isAdmin = has({ permission: 'org:app:admin' })
    ---

    <header>
      <UserButton>
        {
          isAdmin && (
            <UserButton.MenuItems>
              <UserButton.Link label="Create organization" open="/create-organization">
                <svg
                  slot="label-icon"
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 512 512"
                  fill="currentColor"
                >
                  <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
                </svg>
              </UserButton.Link>
            </UserButton.MenuItems>
          )
        }
      </UserButton>
    </header>
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'App.vue' }}
    <script setup lang="ts">
    import { UserButton, useAuth } from '@clerk/vue'
    import { computed } from 'vue'

    const { has, isLoaded } = useAuth()

    const isAdmin = computed(() => has.value?.({ permission: 'org:app:admin' }))
    </script>

    <template>
      <header v-if="isLoaded && isAdmin">
        <UserButton>
          <UserButton.MenuItems>
            <UserButton.Link label="Create organization" href="/create-organization">
              <template #labelIcon>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                  <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
                </svg>
              </template>
            </UserButton.Link>
          </UserButton.MenuItems>
        </UserButton>
      </header>
    </template>
    ```
  </Tab>
</Tabs>

---
title: Add custom onboarding to your authentication flow
description: Leverage Clerks customizable session tokens, public metadata, and Middleware to create a robust onboarding experience.
---

Onboarding is a crucial part of many authentication flows. Sometimes you need to make sure certain criteria is met and collected before allowing access to parts of your application. With Clerk, you can leverage customizable session tokens, public metadata, and Middleware to create a custom onboarding experience.

This guide demonstrates how to create a custom onboarding flow that requires users to complete a form before they can access the application. After a user authenticates using the [Account Portal](/docs/account-portal/overview), the user is prompted to fill out a form with an application name and type. Once the user has completed the form, they are redirected to the application's homepage.

In this guide, you will learn how to:

1. Add custom claims to your session token
1. Configure your Middleware to read session data
1. Update the users onboarding state

For the sake of this guide, examples are written for Next.js App Router, but can be used with Next.js Pager Router as well. The examples have been pared down to the bare minimum to enable you to easily customize them to your needs.

> [!NOTE]
> To see this guide in action, see the [repository](https://github.com/clerk/clerk-nextjs-onboarding-sample-app/tree/main).

## Add custom claims to your session token

[Session tokens](/docs/backend-requests/resources/session-tokens) are JWTs that are generated by Clerk on behalf of your instance, and contain claims that allow you to store data about a user's session. With Clerk, when a session token exists for a user, it indicates that the user is authenticated, and the associated claims can be retrieved at any time.

For this guide, you will use an `onboardingComplete` property in the user's public metadata to track their onboarding status. But first, you need to add a custom claim to the session token that will allow you to access the user's public metadata in your Middleware.

To edit the session token:

1. In the Clerk Dashboard, navigate to the [**Sessions**](https://dashboard.clerk.com/last-active?path=sessions) page.
1. In the **Customize session token** section, select the **Edit** button.
1. In the modal that opens, you can add any claim to your session token that you need. For this guide, add the following:

   ```json
   {
     "metadata": "{{user.public_metadata}}"
   }
   ```
1. Select **Save**.

To get auto-complete and prevent TypeScript errors when working with custom session claims, you can define a global type.

1. In your application's root folder, add a `types` directory.
1. Inside of the `types` directory, add a `globals.d.ts` file.
1. Create the `CustomJwtSessionClaims` interface and declare it globally.
1. Add the custom claims to the `CustomJwtSessionClaims` interface.

For this guide, your `globals.d.ts` file should look like this:

```ts {{ filename: 'types/globals.d.ts' }}
export {}

declare global {
  interface CustomJwtSessionClaims {
    metadata: {
      onboardingComplete?: boolean
    }
  }
}
```

## Configure your Middleware to read session data

[`clerkMiddleware()`](/docs/references/nextjs/clerk-middleware) allows you to configure access to your routes with fine grained control. It also allows you to retrieve claims directly from the session and redirect your user accordingly.

The following example demonstrates how to use `clerkMiddleware()` to redirect users based on their onboarding status. If the user is signed in and has not completed onboarding, they will be redirected to the onboarding page.

Note that the following example protects all routes except one. This is so that any user visiting your application is forced to authenticate, and then forced to onboard. You can customize the array in the `createRouteMatcher()` function assigned to `isPublicRoute` to include any routes that should be accessible to all users, even unauthenticated ones.

```tsx {{ filename: 'src/middleware.ts' }}
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'
import { NextRequest, NextResponse } from 'next/server'

const isOnboardingRoute = createRouteMatcher(['/onboarding'])
const isPublicRoute = createRouteMatcher(['/public-route-example'])

export default clerkMiddleware(async (auth, req: NextRequest) => {
  const { userId, sessionClaims, redirectToSignIn } = await auth()

  // For users visiting /onboarding, don't try to redirect
  if (userId && isOnboardingRoute(req)) {
    return NextResponse.next()
  }

  // If the user isn't signed in and the route is private, redirect to sign-in
  if (!userId && !isPublicRoute(req)) return redirectToSignIn({ returnBackUrl: req.url })

  // Catch users who do not have `onboardingComplete: true` in their publicMetadata
  // Redirect them to the /onboarding route to complete onboarding
  if (userId && !sessionClaims?.metadata?.onboardingComplete) {
    const onboardingUrl = new URL('/onboarding', req.url)
    return NextResponse.redirect(onboardingUrl)
  }

  // If the user is logged in and the route is protected, let them view.
  if (userId && !isPublicRoute(req)) return NextResponse.next()
})

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

### Create a layout for the `/onboarding` route

You will need a layout for the `/onboarding` route that will redirect users to the homepage if they have already completed onboarding.

1. In your `/app` directory, create an `/onboarding` folder.
1. In your `/onboarding` directory, create a `layout.tsx` file and add the following code to the file. This file could also be expanded to handle multiple steps, if multiple steps are required for an onboarding flow.

```tsx {{ filename: 'src/app/onboarding/layout.tsx' }}
import { auth } from '@clerk/nextjs/server'
import { redirect } from 'next/navigation'

export default async function RootLayout({ children }: { children: React.ReactNode }) {
  if ((await auth()).sessionClaims?.metadata.onboardingComplete === true) {
    redirect('/')
  }

  return <>{children}</>
}
```

### Add fallback and force redirect URLs

To ensure a smooth onboarding flow, add redirect URL's to your environment variables. The fallback redirect URL is used when there is no `redirect_url` in the path. The force redirect URL will always be used after a successful sign up.

```env {{ filename: '.env' }}
NEXT_PUBLIC_CLERK_SIGN_IN_FALLBACK_REDIRECT_URL=/dashboard
NEXT_PUBLIC_CLERK_SIGN_UP_FORCE_REDIRECT_URL=/onboarding
```

## Use `publicMetadata` to track user onboarding state

Each Clerk user has a `User` object that contains a `publicMetadata` property, which can be used to store custom data about the user. This information can be accessed on the client-side and can be used to drive application state. For more information, see the [guide on metadata](/docs/users/metadata#public-metadata).

You can use the user's `publicMetadata` to track the user's onboarding state. To do this, you will create:

- A process in your frontend with logic to collect and submit all the information for onboarding. In this guide, you will create a simple form.
- A method in your backend to securely update the user's `publicMetadata`

### Collect user onboarding information

To collect the user's onboarding information, create a form that will be displayed on the `/onboarding` page. This form will collect the user's application name and application type. This is a very loose example  you can use this step to capture information from the user, sync user data to your database, have the user sign up to a course or subscription, or more.

1. In your `/onboarding` directory, create a `page.tsx` file.
1. Add the following code to the file.

```tsx
'use client'

import * as React from 'react'
import { useUser } from '@clerk/nextjs'
import { useRouter } from 'next/navigation'
import { completeOnboarding } from './_actions'

export default function OnboardingComponent() {
  const [error, setError] = React.useState('')
  const { user } = useUser()
  const router = useRouter()

  const handleSubmit = async (formData: FormData) => {
    const res = await completeOnboarding(formData)
    if (res?.message) {
      // Reloads the user's data from the Clerk API
      await user?.reload()
      router.push('/')
    }
    if (res?.error) {
      setError(res?.error)
    }
  }
  return (
    <div>
      <h1>Welcome</h1>
      <form action={handleSubmit}>
        <div>
          <label>Application Name</label>
          <p>Enter the name of your application.</p>
          <input type="text" name="applicationName" required />
        </div>

        <div>
          <label>Application Type</label>
          <p>Describe the type of your application.</p>
          <input type="text" name="applicationType" required />
        </div>
        {error && <p className="text-red-600">Error: {error}</p>}
        <button type="submit">Submit</button>
      </form>
    </div>
  )
}
```

### Update the user's `publicMetadata` in your backend

Now that there is a form to collect the user's onboarding information, you need to create a method in your backend to update the user's `publicMetadata` with this information. This method will be called when the user submits the form.

1. In your `/onboarding` directory, create an `_actions.ts` file.
1. Add the following code to the file. This file includes a method that will be called on form submission and will update the user's `publicMetadata` accordingly. The following example uses the [`clerkClient`](/docs/references/backend/overview) wrapper to interact with the Backend API and update the user's `publicMetadata`.

```tsx
'use server'

import { auth, clerkClient } from '@clerk/nextjs/server'

export const completeOnboarding = async (formData: FormData) => {
  const { userId } = await auth()

  if (!userId) {
    return { message: 'No Logged In User' }
  }

  const client = await clerkClient()

  try {
    const res = await client.users.updateUser(userId, {
      publicMetadata: {
        onboardingComplete: true,
        applicationName: formData.get('applicationName'),
        applicationType: formData.get('applicationType'),
      },
    })
    return { message: res.publicMetadata }
  } catch (err) {
    return { error: 'There was an error updating the user metadata.' }
  }
}
```

## Wrap up

Your onboarding flow is now complete!  Users who have not onboarded yet will now land on your `/onboarding` page. New users signing up or signing in to your application will have to complete the onboarding process before they can access your application. By using Clerk, you have streamlined the user authentication and onboarding process, ensuring a smooth and efficient experience for your new users.

---
title: Add custom pages and links to the `<OrganizationProfile />` component
description: Learn how to add custom pages and include external links within the navigation sidenav of the <OrganizationProfile /> component.
---

The [`<OrganizationProfile />`](/docs/components/organization/organization-profile) component supports the addition of custom pages and external links to the component's sidenav.

## Before you start

To access the `<OrganizationProfile />` component, the user must select the [`<OrganizationSwitcher />`](/docs/components/organization/organization-switcher) component and then select the **Manage Organization** option. The `<OrganizationProfile />` will open as a modal by default. You can also render the component as a dedicated page. This guide includes examples for both use cases. On the code examples, you can select one of the following two tabs to see the implementation for your preferred use case:

- `<OrganizationSwitcher />` tab: By default, the `<OrganizationSwitcher />` sets `organizationProfileMode='modal'`. If you are using the default settings, then you should select this tab.
- `Dedicated page` tab: If you do not want the `<OrganizationProfile />` to open as a modal, then you should select this tab. For these examples, you need to set `organizationProfileMode='navigation'` and `organizationProfileUrl='/organization-profile'` on the `<OrganizationSwitcher />` component.

## Add a custom page

To add a custom page to the `<OrganizationProfile />` component, use the `<OrganizationSwitcher.OrganizationProfilePage />` component or the `<OrganizationProfile.Page />` component, depending on your use case.

### Props

`<OrganizationSwitcher.OrganizationProfilePage />` and `<OrganizationProfile.Page />` accept the following props, all of which are **required**:

<Properties>
  - `label`
  - `string`

  The name that will be displayed in the navigation sidenav for the custom page.

  ---

  - `labelIcon`
  - `React.ReactElement`

  An icon displayed next to the label in the navigation sidenav.

  ---

  - `url`
  - `string`

  The path segment that will be used to navigate to the custom page. For example, if the `<OrganizationProfile />` component is rendered at `/organization`, then the custom page will be accessed at `/organization/{url}` when using [path routing](/docs/guides/routing).

  ---

  - `children`
  - `React.ReactElement`

  The content to be rendered inside the custom page.
</Properties>

### Example

<Tabs items={["Next.js", "JavaScript", "Vue"]}>
  <Tab>
    The following example demonstrates two ways that you can render content in a custom page: as a component or as a direct child.

    <CodeBlockTabs options={["<OrganizationSwitcher />", "Dedicated page"]}>
      ```tsx {{ filename: 'app/components/Header.tsx' }}
      'use client'

      import { OrganizationSwitcher } from '@clerk/nextjs'

      const DotIcon = () => {
        return (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
            <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
          </svg>
        )
      }

      const CustomPage = () => {
        return (
          <div>
            <h1>Custom page</h1>
            <p>This is the content of the custom page.</p>
          </div>
        )
      }

      const Header = () => (
        <header>
          <OrganizationSwitcher>
            {/* You can pass the content as a component */}
            <OrganizationSwitcher.OrganizationProfilePage
              label="Custom Page"
              url="custom"
              labelIcon={<DotIcon />}
            >
              <CustomPage />
            </OrganizationSwitcher.OrganizationProfilePage>

            {/* You can also pass the content as direct children */}
            <OrganizationSwitcher.OrganizationProfilePage
              label="Terms"
              labelIcon={<DotIcon />}
              url="terms"
            >
              <div>
                <h1>Custom Terms Page</h1>
                <p>This is the content of the custom terms page.</p>
              </div>
            </OrganizationSwitcher.OrganizationProfilePage>
          </OrganizationSwitcher>
        </header>
      )

      export default Header
      ```

      ```tsx {{ filename: 'app/organization-profile/[[...organization-profile]]/page.tsx' }}
      'use client'

      import { OrganizationProfile } from '@clerk/nextjs'

      const DotIcon = () => {
        return (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
            <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
          </svg>
        )
      }

      const CustomPage = () => {
        return (
          <div>
            <h1>Custom page</h1>
            <p>This is the content of the custom page.</p>
          </div>
        )
      }

      const OrganizationProfilePage = () => (
        <OrganizationProfile path="/organization-profile" routing="path">
          {/* You can pass the content as a component */}
          <OrganizationProfile.Page label="Custom Page" labelIcon={<DotIcon />} url="custom-page">
            <CustomPage />
          </OrganizationProfile.Page>

          {/* You can also pass the content as direct children */}
          <OrganizationProfile.Page label="Terms" labelIcon={<DotIcon />} url="terms">
            <div>
              <h1>Custom Terms Page</h1>
              <p>This is the content of the custom terms page.</p>
            </div>
          </OrganizationProfile.Page>
        </OrganizationProfile>
      )

      export default OrganizationProfilePage
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    To add custom pages to the `<OrganizationProfile />` component using the [JavaScript SDK](/docs/references/javascript/overview), pass the `customPages` property to the `mountOrganizationProfile()` or `openOrganizationProfile()` method, as shown in the following example:

    ```js {{ filename: 'main.js' }}
    import { Clerk } from '@clerk/clerk-js'

    const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

    const clerk = new Clerk(pubKey)
    await clerk.load()

    document.getElementById('app').innerHTML = `
      <div id="organization-profile"></div>
    `

    const orgProfileDiv = document.getElementById('organization-profile')

    clerk.openOrganizationProfile(orgProfileDiv, {
      customPages: [
        {
          url: 'custom-page',
          label: 'Custom Page',
          mountIcon: (el) => {
            el.innerHTML = ''
          },
          unmountIcon: (el) => {
            el.innerHTML = ''
          },
          mount: (el) => {
            el.innerHTML = `
              <h1><b>Custom Page</b></h1>
              <p>This is the content of the custom page.</p>
              `
          },
          unmount: (el) => {
            el.innerHTML = ''
          },
        },
        {
          url: '/other-page',
          label: 'Other Page',
          mountIcon: (el) => {
            el.innerHTML = ''
          },
          unmountIcon: (el) => {
            el.innerHTML = ''
          },
        },
      ],
    })
    ```
  </Tab>

  <Tab>
    <CodeBlockTabs options={["<OrganizationSwitcher />", "Dedicated page"]}>
      ```vue {{ filename: 'App.vue' }}
      <script setup lang="ts">
      import { OrganizationSwitcher } from '@clerk/vue'
      </script>

      <template>
        <header>
          <OrganizationSwitcher>
            <OrganizationSwitcher.OrganizationProfilePage label="Custom Page" url="custom">
              <template #labelIcon>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                  <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
                </svg>
              </template>
              <div>
                <h1>Custom page</h1>
                <p>This is the content of the custom page.</p>
              </div>
            </OrganizationSwitcher.OrganizationProfilePage>
          </OrganizationSwitcher>
        </header>
      </template>
      ```

      ```vue {{ filename: 'pages/organization-profile.vue' }}
      <script setup lang="ts">
      import { OrganizationProfile } from '@clerk/vue'
      </script>

      <template>
        <OrganizationProfile>
          <OrganizationProfile.Page label="Custom Page" url="custom">
            <template #labelIcon>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
              </svg>
            </template>
            <div>
              <h1>Custom page</h1>
              <p>This is the content of the custom page.</p>
            </div>
          </OrganizationProfile.Page>
        </OrganizationProfile>
      </template>
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

## Add a custom link

To add an external link to the `<OrganizationProfile />` navigation sidenav, use the `<OrganizationSwitcher.OrganizationProfileLink />` component or the `<OrganizationProfile.Link />` component, depending on your use case.

### Props

`<OrganizationSwitcher.OrganizationProfileLink />` and `<OrganizationProfile.Link />` accept the following props, all of which are **required**:

<Properties>
  - `label`
  - `string`

  The name that will be displayed in the navigation sidenav for the link.

  ---

  - `labelIcon`
  - `React.ReactElement`

  An icon displayed next to the label in the navigation sidenav.

  ---

  - `url`
  - `string`

  The full URL or path that will be used to navigate to the external link. For path segments, if the `<OrganizationProfile />` component is rendered at `/organization`, then the external link will be accessed at `/organization/{url}` when using [path routing](/docs/guides/routing).
</Properties>

### Example

The following example adds a custom link to the `<OrganizationProfile />` sidenav that navigates to the homepage.

<Tabs items={["Next.js", "Vue"]}>
  <Tab>
    <CodeBlockTabs options={["<OrganizationSwitcher />", "Dedicated page"]}>
      ```tsx {{ filename: 'app/components/Header.tsx' }}
      'use client'

      import { OrganizationSwitcher } from '@clerk/nextjs'

      const DotIcon = () => {
        return (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
            <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
          </svg>
        )
      }

      const Header = () => (
        <header>
          <OrganizationSwitcher>
            <OrganizationSwitcher.OrganizationProfileLink
              label="Homepage"
              url="/"
              labelIcon={<DotIcon />}
            />
          </OrganizationSwitcher>
        </header>
      )

      export default Header
      ```

      ```tsx {{ filename: 'app/organization-profile/[[...organization-profile]]/page.tsx' }}
      'use client'

      import { OrganizationProfile } from '@clerk/nextjs'

      const DotIcon = () => {
        return (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
            <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
          </svg>
        )
      }

      const OrganizationProfilePage = () => (
        <OrganizationProfile path="/organization-profile" routing="path">
          <OrganizationProfile.Link label="Homepage" labelIcon={<DotIcon />} url="/" />
        </OrganizationProfile>
      )

      export default OrganizationProfilePage
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    <CodeBlockTabs options={["<OrganizationSwitcher />", "Dedicated page"]}>
      ```vue {{ filename: 'App.vue' }}
      <script setup lang="ts">
      import { OrganizationSwitcher } from '@clerk/vue'
      </script>

      <template>
        <header>
          <OrganizationSwitcher>
            <OrganizationSwitcher.OrganizationProfileLink label="Homepage" url="/">
              <template #labelIcon>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                  <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
                </svg>
              </template>
            </OrganizationSwitcher.OrganizationProfileLink>
          </OrganizationSwitcher>
        </header>
      </template>
      ```

      ```vue {{ filename: 'pages/organization-profile.vue' }}
      <script setup lang="ts">
      import { OrganizationProfile } from '@clerk/vue'
      </script>

      <template>
        <OrganizationProfile>
          <OrganizationProfile.Link label="Homepage" url="/">
            <template #labelIcon>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
              </svg>
            </template>
          </OrganizationProfile.Link>
        </OrganizationProfile>
      </template>
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

## Reordering default routes

The `<OrganizationProfile />` component includes two default menu items: `Members` and `General`, in that order. You can reorder these default items by setting the `label` prop to `'members'` or `'general'`. This will target the existing default item and allow you to rearrange it.

Note that when reordering default routes, the first item in the navigation sidenav cannot be a custom link.

The following example adds a custom page as the first item in the sidenav, followed by a custom link to the homepage, and then the default members and general pages.

<Tabs items={["Next.js", "Vue"]}>
  <Tab>
    <CodeBlockTabs options={["<OrganizationSwitcher />", "Dedicated Page"]}>
      ```tsx {{ filename: 'app/components/Header.tsx' }}
      'use client'

      import { OrganizationSwitcher } from '@clerk/nextjs'

      const DotIcon = () => {
        return (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
            <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
          </svg>
        )
      }

      const CustomPage = () => {
        return (
          <div>
            <h1>Custom page</h1>
            <p>This is the content of the custom page.</p>
          </div>
        )
      }

      const Header = () => (
        <header>
          <OrganizationSwitcher>
            <OrganizationSwitcher.OrganizationProfilePage
              label="Custom Page"
              url="custom"
              labelIcon={<DotIcon />}
            >
              <CustomPage />
            </OrganizationSwitcher.OrganizationProfilePage>
            <OrganizationSwitcher.OrganizationProfileLink
              label="Homepage"
              url="/"
              labelIcon={<DotIcon />}
            />
            <OrganizationSwitcher.OrganizationProfilePage label="members" />
            <OrganizationSwitcher.OrganizationProfilePage label="general" />
          </OrganizationSwitcher>
        </header>
      )

      export default Header
      ```

      ```tsx {{ filename: 'app/organization-profile/[[...organization-profile]]/page.tsx' }}
      'use client'

      import { OrganizationProfile } from '@clerk/nextjs'

      const DotIcon = () => {
        return (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
            <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
          </svg>
        )
      }

      const CustomPage = () => {
        return (
          <div>
            <h1>Custom page</h1>
            <p>This is the content of the custom page.</p>
          </div>
        )
      }

      const OrganizationProfilePage = () => (
        <OrganizationProfile>
          <OrganizationProfile.Page label="Custom Page" url="custom" labelIcon={<DotIcon />}>
            <CustomPage />
          </OrganizationProfile.Page>
          <OrganizationProfile.Link label="Homepage" url="/" labelIcon={<DotIcon />} />
          <OrganizationProfile.Page label="members" />
          <OrganizationProfile.Page label="general" />
        </OrganizationProfile>
      )

      export default OrganizationProfilePage
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    <CodeBlockTabs options={["<OrganizationSwitcher />", "Dedicated page"]}>
      ```vue {{ filename: 'App.vue' }}
      <script setup lang="ts">
      import { OrganizationSwitcher } from '@clerk/vue'
      </script>

      <template>
        <header>
          <OrganizationSwitcher>
            <OrganizationSwitcher.OrganizationProfilePage label="Custom Page" url="custom">
              <template #labelIcon>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                  <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
                </svg>
              </template>
              <div>
                <h1>Custom page</h1>
                <p>This is the content of the custom page.</p>
              </div>
            </OrganizationSwitcher.OrganizationProfilePage>
            <OrganizationSwitcher.OrganizationProfileLink label="Homepage" url="/">
              <template #labelIcon>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                  <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
                </svg>
              </template>
            </OrganizationSwitcher.OrganizationProfileLink>
            <OrganizationSwitcher.OrganizationProfilePage label="members" />
            <OrganizationSwitcher.OrganizationProfilePage label="general" />
          </OrganizationSwitcher>
        </header>
      </template>
      ```

      ```vue {{ filename: 'pages/organization-profile.vue' }}
      <script setup lang="ts">
      import { OrganizationProfile } from '@clerk/vue'
      </script>

      <template>
        <OrganizationProfile>
          <OrganizationProfile.Page label="Custom Page" url="custom">
            <template #labelIcon>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
              </svg>
            </template>
            <div>
              <h1>Custom page</h1>
              <p>This is the content of the custom page.</p>
            </div>
          </OrganizationProfile.Page>
          <OrganizationProfile.Link label="Homepage" url="/">
            <template #labelIcon>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
              </svg>
            </template>
          </OrganizationProfile.Link>
          <OrganizationProfile.Page label="members" />
          <OrganizationProfile.Page label="general" />
        </OrganizationProfile>
      </template>
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

---
title: Add custom pages and links to the `<UserProfile />` component
description: Learn how to add custom pages and include external links within the navigation sidenav of the <UserProfile /> component.
---

The [`<UserProfile />`](/docs/components/user/user-profile) component supports the addition of custom pages and external links to the component's sidenav.

## Before you start

To access the `<UserProfile />` component, the user must select the [`<UserButton />`](/docs/components/user/user-button) component and then select the **Manage account** menu item. The `<UserProfile />` will open as a modal by default. You can also render the component as a dedicated page. This guide includes examples for both use cases. On the code examples, you can select one of the following two tabs to see the implementation for your preferred use case:

- `<UserButton />` tab: By default, the `<UserButton />` sets `userProfileMode='modal'`. If you are using the default settings, then you should select this tab.
- `Dedicated page` tab: If you do not want the `<UserProfile />` to open as a modal, then you should select this tab. For these examples, you need to set `userProfileMode='navigation'` and `userProfileUrl='/user-profile'` on the `<UserButton />` component.

## Add a custom page

To add a custom page to the `<UserProfile />` component, use the `<UserButton.UserProfilePage />` component or the `<UserProfile.Page />` component, depending on your use case.

### Props

`<UserButton.UserProfilePage />` and `<UserProfile.Page />` accept the following props, all of which are **required**:

<Properties>
  - `label`
  - `string`

  The name that will be displayed in the navigation sidenav for the custom page.

  ---

  - `labelIcon`
  - `React.ReactElement`

  An icon displayed next to the label in the navigation sidenav.

  ---

  - `url`
  - `string`

  The path segment that will be used to navigate to the custom page. For example, if the `<UserProfile />` component is rendered at `/user`, then the custom page will be accessed at `/user/{url}` when using [path routing](/docs/guides/routing).

  ---

  - `children`
  - `React.ReactElement`

  The content to be rendered inside the custom page.
</Properties>

### Example

<Tabs items={["Next.js", "JavaScript", "Astro", "Vue"]}>
  <Tab>
    The following example demonstrates two ways that you can render content in a custom page: as a component or as a direct child.

    <CodeBlockTabs options={["<UserButton />", "Dedicated page"]}>
      ```tsx {{ filename: 'app/page.tsx' }}
      'use client'

      import { UserButton } from '@clerk/nextjs'

      const DotIcon = () => {
        return (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
            <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
          </svg>
        )
      }

      const CustomPage = () => {
        return (
          <div>
            <h1>Custom page</h1>
            <p>This is the content of the custom page.</p>
          </div>
        )
      }

      export default function Home() {
        return (
          <header>
            <UserButton>
              {/* You can pass the content as a component */}
              <UserButton.UserProfilePage label="Custom Page" url="custom" labelIcon={<DotIcon />}>
                <CustomPage />
              </UserButton.UserProfilePage>

              {/* You can also pass the content as direct children */}
              <UserButton.UserProfilePage label="Terms" labelIcon={<DotIcon />} url="terms">
                <div>
                  <h1>Custom Terms Page</h1>
                  <p>This is the content of the custom terms page.</p>
                </div>
              </UserButton.UserProfilePage>
            </UserButton>
          </header>
        )
      }
      ```

      ```tsx {{ filename: 'app/user-profile/[[...user-profile]]/page.tsx' }}
      'use client'

      import { UserProfile } from '@clerk/nextjs'

      const DotIcon = () => {
        return (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
            <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
          </svg>
        )
      }

      const CustomPage = () => {
        return (
          <div>
            <h1>Custom page</h1>
            <p>This is the content of the custom page.</p>
          </div>
        )
      }

      const UserProfilePage = () => (
        <UserProfile path="/user-profile" routing="path">
          {/* You can pass the content as a component */}
          <UserProfile.Page label="Custom Page" labelIcon={<DotIcon />} url="custom-page">
            <CustomPage />
          </UserProfile.Page>

          {/* You can also pass the content as direct children */}
          <UserProfile.Page label="Terms" labelIcon={<DotIcon />} url="terms">
            <div>
              <h1>Custom Terms Page</h1>
              <p>This is the content of the custom terms page.</p>
            </div>
          </UserProfile.Page>
        </UserProfile>
      )

      export default UserProfilePage
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    To add custom pages to the `<UserProfile />` component using the [JavaScript SDK](/docs/references/javascript/overview), pass the `customPages` property to the `mountUserProfile()` method, as shown in the following example:

    ```js {{ filename: 'main.js' }}
    import { Clerk } from '@clerk/clerk-js'

    const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

    const clerk = new Clerk(pubKey)
    await clerk.load()

    document.getElementById('app').innerHTML = `
      <div id="user-profile"></div>
    `

    const userProfileDiv = document.getElementById('user-profile')

    clerk.mountUserProfile(userProfileDiv, {
      customPages: [
        {
          url: 'custom-page',
          label: 'Custom Page',
          mountIcon: (el) => {
            el.innerHTML = ''
          },
          unmountIcon: (el) => {
            el.innerHTML = ''
          },
          mount: (el) => {
            el.innerHTML = `
              <h1><b>Custom Page</b></h1>
              <p>This is the content of the custom page.</p>
              `
          },
          unmount: (el) => {
            el.innerHTML = ''
          },
        },
        {
          url: '/other-page',
          label: 'Other Page',
          mountIcon: (el) => {
            el.innerHTML = ''
          },
          unmountIcon: (el) => {
            el.innerHTML = ''
          },
        },
      ],
    })
    ```
  </Tab>

  <Tab>
    <CodeBlockTabs options={["<UserButton />", "Dedicated page"]}>
      ```astro {{ filename: 'pages/index.astro' }}
      ---
      import { UserButton } from '@clerk/astro/components'
      ---

      <header>
        <UserButton>
          <UserButton.UserProfilePage label="Custom Page" url="custom">
            <svg
              slot="label-icon"
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 512 512"
              fill="currentColor"
            >
              <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
            </svg>
            <div>
              <h1>Custom page</h1>
              <p>This is the content of the custom page.</p>
            </div>
          </UserButton.UserProfilePage>
        </UserButton>
      </header>
      ```

      ```astro {{ filename: 'pages/user-profile.astro' }}
      ---
      import { UserProfile } from '@clerk/astro/components'
      ---

      <UserProfile>
        <UserProfile.Page label="Custom Page" url="custom-page">
          <svg
            slot="label-icon"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 512 512"
            fill="currentColor"
          >
            <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
          </svg>
          <div>
            <h1>Custom page</h1>
            <p>This is the content of the custom page.</p>
          </div>
        </UserProfile.Page>
      </UserProfile>
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    <CodeBlockTabs options={["<UserButton />", "Dedicated page"]}>
      ```vue {{ filename: 'App.vue' }}
      <script setup lang="ts">
      import { UserButton } from '@clerk/vue'
      </script>

      <template>
        <header>
          <UserButton>
            <UserButton.UserProfilePage label="Custom Page" url="custom">
              <template #labelIcon>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                  <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
                </svg>
              </template>
              <div>
                <h1>Custom page</h1>
                <p>This is the content of the custom page.</p>
              </div>
            </UserButton.UserProfilePage>
          </UserButton>
        </header>
      </template>
      ```

      ```vue {{ filename: 'pages/user-profile.vue' }}
      <script setup lang="ts">
      import { UserProfile } from '@clerk/vue'
      </script>

      <template>
        <UserProfile>
          <UserProfile.Page label="Custom Page" url="custom">
            <template #labelIcon>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
              </svg>
            </template>
            <div>
              <h1>Custom page</h1>
              <p>This is the content of the custom page.</p>
            </div>
          </UserProfile.Page>
        </UserProfile>
      </template>
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

## Add a custom link

To add a custom link to the `<UserProfile />` component, use the `<UserButton.UserProfileLink />` component or the `<UserProfile.Link />` component, depending on your use case.

### Props

`<UserButton.UserProfileLink />` and `<UserProfile.Link />` accept the following props, all of which are **required**:

<Properties>
  - `label`
  - `string`

  The name that will be displayed in the navigation sidenav for the link.

  ---

  - `labelIcon`
  - `React.ReactElement`

  An icon displayed next to the label in the navigation sidenav.

  ---

  - `url`
  - `string`

  The path segment that will be used to navigate to the custom page. For example, if the `<UserProfile />` component is rendered at `/user`, then the custom link will be navigate to `/user/{url}` when using [path routing](/docs/guides/routing).
</Properties>

### Example

The following example adds a custom link to the `<UserProfile />` sidenav that navigates to the homepage.

<Tabs items={["Next.js", "Astro", "Vue"]}>
  <Tab>
    <CodeBlockTabs options={["<UserButton />", "Dedicated page"]}>
      ```tsx {{ filename: 'app/page.tsx' }}
      'use client'

      import { UserButton } from '@clerk/nextjs'

      const DotIcon = () => {
        return (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
            <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
          </svg>
        )
      }

      export default function Home() {
        return (
          <header>
            <UserButton>
              <UserButton.UserProfileLink label="Homepage" url="/" labelIcon={<DotIcon />} />
            </UserButton>
          </header>
        )
      }
      ```

      ```tsx {{ filename: 'app/user-profile/[[...user-profile]]/page.tsx' }}
      'use client'

      import { UserProfile } from '@clerk/nextjs'

      const DotIcon = () => {
        return (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
            <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
          </svg>
        )
      }

      const UserProfilePage = () => (
        <UserProfile path="/user-profile" routing="path">
          <UserProfile.Link label="Homepage" labelIcon={<DotIcon />} url="/" />
        </UserProfile>
      )

      export default UserProfilePage
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    <CodeBlockTabs options={["<UserButton />", "Dedicated page"]}>
      ```astro {{ filename: 'pages/index.astro' }}
      ---
      import { UserButton } from '@clerk/astro/components'
      ---

      <header>
        <UserButton>
          <UserButton.UserProfileLink label="Homepage" url="/">
            <svg
              slot="label-icon"
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 512 512"
              fill="currentColor"
            >
              <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
            </svg>
          </UserButton.UserProfileLink>
        </UserButton>
      </header>
      ```

      ```astro {{ filename: 'pages/user-profile.astro' }}
      ---
      import { UserProfile } from '@clerk/astro/components'
      ---

      <UserProfile>
        <UserProfile.Link label="Homepage" url="/">
          <svg
            slot="label-icon"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 512 512"
            fill="currentColor"
          >
            <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
          </svg>
        </UserProfile.Link>
      </UserProfile>
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    <CodeBlockTabs options={["<UserButton />", "Dedicated page"]}>
      ```vue {{ filename: 'App.vue' }}
      <script setup lang="ts">
      import { UserButton } from '@clerk/vue'
      </script>

      <template>
        <header>
          <UserButton>
            <UserButton.UserProfileLink label="Homepage" url="/">
              <template #labelIcon>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                  <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
                </svg>
              </template>
            </UserButton.UserProfileLink>
          </UserButton>
        </header>
      </template>
      ```

      ```vue {{ filename: 'pages/user-profile.vue' }}
      <script setup lang="ts">
      import { UserProfile } from '@clerk/vue'
      </script>

      <template>
        <UserProfile>
          <UserProfile.Link label="Homepage" url="/">
            <template #labelIcon>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
              </svg>
            </template>
          </UserProfile.Link>
        </UserProfile>
      </template>
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

## Reorder default routes

The `<UserProfile />` component includes two default menu items: `Account` and `Security`, in that order. You can reorder these default items by setting the `label` prop to `'account'` or `'security'`. This will target the existing default item and allow you to rearrange it.

Note that when reordering default routes, the first item in the navigation sidenav cannot be a custom link.

The following example adds a custom page as the first item in the sidenav, followed by a custom link to the homepage, and then the default account and security pages.

<Tabs items={["Next.js", "Astro", "Vue"]}>
  <Tab>
    <Tabs items={["<UserButton />", "Dedicated page"]}>
      <Tab>
        ```tsx {{ filename: 'app/page.tsx' }}
        'use client'

        import { UserButton } from '@clerk/nextjs'

        const DotIcon = () => {
          return (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
              <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
            </svg>
          )
        }

        const CustomPage = () => {
          return (
            <div>
              <h1>Custom page</h1>
              <p>This is the content of the custom page.</p>
            </div>
          )
        }

        export default function Home() {
          return (
            <header>
              <UserButton>
                <UserButton.UserProfilePage label="Custom Page" url="custom" labelIcon={<DotIcon />}>
                  <CustomPage />
                </UserButton.UserProfilePage>
                <UserButton.UserProfileLink label="Homepage" url="/" labelIcon={<DotIcon />} />
                <UserButton.UserProfilePage label="account" />
                <UserButton.UserProfilePage label="security" />
              </UserButton>
            </header>
          )
        }
        ```
      </Tab>

      <Tab>
        ```tsx {{ filename: 'app/user-profile/[[...user-profile]]/page.tsx' }}
        'use client'

        import { UserProfile } from '@clerk/nextjs'

        const DotIcon = () => {
          return (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
              <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z" />
            </svg>
          )
        }

        const CustomPage = () => {
          return (
            <div>
              <h1>Custom page</h1>
              <p>This is the content of the custom page.</p>
            </div>
          )
        }

        const UserProfilePage = () => (
          <UserProfile>
            <UserProfile.Page label="Custom Page" url="custom" labelIcon={<DotIcon />}>
              <CustomPage />
            </UserProfile.Page>
            <UserProfile.Link label="Homepage" url="/" labelIcon={<DotIcon />} />
            <UserProfile.Page label="account" />
            <UserProfile.Page label="security" />
          </UserProfile>
        )

        export default UserProfilePage
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab>
    <Tabs items={["<UserButton />", "Dedicated page"]}>
      <Tab>
        ```astro {{ filename: 'pages/index.astro' }}
        ---
        import { UserButton } from '@clerk/astro/components'
        ---

        <header>
          <UserButton>
            <UserButton.UserProfilePage label="Custom Page" url="custom">
              <svg
                slot="label-icon"
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 512 512"
                fill="currentColor"
              >
                <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
              </svg>
              <div>
                <h1>Custom page</h1>
                <p>This is the content of the custom page.</p>
              </div>
            </UserButton.UserProfilePage>
            <UserButton.UserProfileLink label="Homepage" url="/">
              <svg
                slot="label-icon"
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 512 512"
                fill="currentColor"
              >
                <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
              </svg>
            </UserButton.UserProfileLink>
            <UserButton.UserProfilePage label="account" />
            <UserButton.UserProfilePage label="security" />
          </UserButton>
        </header>
        ```
      </Tab>

      <Tab>
        ```astro {{ filename: 'pages/user-profile.astro' }}
        ---
        import { UserProfile } from '@clerk/astro/components'
        ---

        <UserProfile>
          <UserProfile.Page label="Custom Page" url="custom">
            <svg
              slot="label-icon"
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 512 512"
              fill="currentColor"
            >
              <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
            </svg>
            <div>
              <h1>Custom page</h1>
              <p>This is the content of the custom page.</p>
            </div>
          </UserProfile.Page>
          <UserProfile.Link label="Homepage" url="/">
            <svg
              slot="label-icon"
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 512 512"
              fill="currentColor"
            >
              <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
            </svg>
          </UserProfile.Link>
          <UserProfile.Page label="account" />
          <UserProfile.Page label="security" />
        </UserProfile>
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab>
    <CodeBlockTabs options={["<UserButton />", "Dedicated page"]}>
      ```vue {{ filename: 'App.vue' }}
      <script setup lang="ts">
      import { UserButton } from '@clerk/vue'
      </script>

      <template>
        <UserButton>
          <UserButton.UserProfilePage label="Custom Page" url="custom">
            <template #labelIcon>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
              </svg>
            </template>
            <div>
              <h1>Custom page</h1>
              <p>This is the content of the custom page.</p>
            </div>
          </UserButton.UserProfilePage>
          <UserButton.UserProfileLink label="Homepage" url="/">
            <template #labelIcon>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
              </svg>
            </template>
          </UserButton.UserProfileLink>
          <UserButton.UserProfilePage label="account" />
          <UserButton.UserProfilePage label="security" />
        </UserButton>
      </template>
      ```

      ```vue {{ filename: 'pages/user-profile.vue' }}
      <script setup lang="ts">
      import { UserProfile } from '@clerk/vue'
      </script>

      <template>
        <UserProfile>
          <UserProfile.Page label="Custom Page" url="custom">
            <template #labelIcon>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
              </svg>
            </template>
            <div>
              <h1>Custom page</h1>
              <p>This is the content of the custom page.</p>
            </div>
          </UserProfile.Page>
          <UserProfile.Link label="Homepage" url="/">
            <template #labelIcon>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"></path>
              </svg>
            </template>
          </UserProfile.Link>
          <UserProfile.Page label="account" />
          <UserProfile.Page label="security" />
        </UserProfile>
      </template>
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

---
title: Add Discord as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Discord account with OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A Discord account is required.",
      link: "https://discord.com/register",
      icon: "user-circle",
    }
  ]}
/>

Enabling OAuth with [Discord](https://discord.com/developers/docs/topics/oauth2) allows your users to sign up and sign in to your Clerk application with their Discord account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **Discord**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Discord Developer Portal](https://discord.com/developers/applications).

<Steps>
  ### Enable Discord as a social connection in Clerk

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Discord**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Redirect URI** somewhere secure. Keep the modal and page open.

  ### Create a Discord Developer app

  1. On a separate page, go to the [Discord Developer Portal](https://discord.com/developers/applications) and sign in.
  1. In the top-right, select **New Application**.
  1. Complete the required fields and select **Create**. You'll be redirected to the **General Information** page.
  1. In the left sidenav, select **OAuth2**.
  1. Under **Redirects**, select **Add Redirect**. Paste the **Redirect URI** you saved from the Clerk Dashboard.
  1. Select **Save Changes**. You may need to tap anywhere on the screen for the button to show.
  1. Save the **Client ID** and **Client Secret** somewhere secure. If you don't see the **Copy** button under the **Client Secret**, select **Reset Secret** to generate a new one.

  ### Set the Client ID and Client Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add Dropbox as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Dropbox account using OAuth.
---

<TutorialHero
  beforeYouStart={[
  {
    title: "A Clerk application is required.",
    link: "/docs/quickstarts/setup-clerk",
    icon: "clerk",
  },
  {
    title: "A Dropbox Developer account is required.",
    link: "https://www.dropbox.com/developers",
    icon: "user-circle",
  }
]}
/>

Enabling OAuth with Dropbox allows your users to sign up and sign in to your Clerk application with their Dropbox account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **Dropbox**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Dropbox App Console](https://www.dropbox.com/developers/apps).

<Steps>
  ### Enable Dropbox as a social connection

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Dropbox**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Redirect URI** somewhere secure. Keep this modal and page open.

  ### Configure your Dropbox app

  1. In the [Dropbox App Console](https://www.dropbox.com/developers/apps), select a project or [create a new one](https://www.dropbox.com/developers/apps/create).
  1. On your app's **Settings** page, save the **App key** and **App secret** somewhere secure.
  1. In the **Redirect URIs** input, paste the **Redirect URI** value you saved from the Clerk Dashboard and select **Add**.

  ### Set the App Key and App Secret in the Clerk Dashboard

  1. Navigate back to the Clerk Dashboard where the modal should still be open. Paste the **App key** and **App secret** values that you saved into the respective fields.
  1. Select **Add connection**.

  > [!NOTE]
  > If the modal or page is not still open, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page in the Clerk Dashboard. Select the connection. Under **Use custom credentials**, you can paste the values into their respective fields.

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add Facebook as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Facebook account using OAuth.
---

<TutorialHero
  beforeYouStart={[
  {
    title: "A Clerk app is required.",
    link: "/docs/quickstarts/setup-clerk",
    icon: "clerk",
  },
  {
    title: "A Meta Developer account is required.",
    link: "https://developers.facebook.com/docs/development/register",
    icon: "user-circle",
  }
]}
/>

Enabling OAuth with Facebook allows your users to sign up and sign in to your Clerk app with their Facebook account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **Facebook**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Facebook Developer](https://developers.facebook.com) page.

<Steps>
  ### Enable Facebook as a social connection

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Facebook**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Redirect URI** somewhere secure. Keep this modal and page open.

  ### Create a Facebook app

  1. In the top-right of the Facebook Developer page, select [**My Apps**](https://developers.facebook.com/apps).
  1. In the top-right, select **Create App**. You'll be redirected to the **Create an app** process.
     1. In the **App details** step, fill out the necessary information and select **Next**.
     1. In the **Use Cases** step, select **Authenticate and request data from users with Facebook Login** and then select **Next**.
     1. In the **Business** step, select the business portfolio to connect to your app and then select **Next**.
     1. In the **Finalize** step, select **Go to dashboard**. You'll be redirected to the app's **Dashboard** page.
  1. In the left sidenav, select **Use cases**.
  1. Next to **Authenticate and request data from users with Facebook Login**, select **Customize**. You'll be redirected to the **Permissions** tab of the **Customize use case** page.
  1. Next to **email**, select **Add**. This permission allows Clerk to read your user's primary email address.
  1. In the left sidenav, under **Facebook Login**, select **Settings**.
  1. In the **Client OAuth settings** section, in the **Valid OAuth Redirect URIs** field, paste the **Redirect URI** value you saved from the Clerk Dashboard.
  1. Select **Save changes**.
  1. In the left sidenav, select **App settings** (hover over the settings icon to view the title or expand the menu), and then select **Basic**.
  1. Save the **App ID** and **App Secret** somewhere secure.

  ### Set the App ID and App Secret in the Clerk Dashboard

  1. Navigate back to the Clerk Dashboard where the modal should still be open. Paste the **App ID** and **App Secret** values that you saved into the respective fields.
  1. Select **Add connection**.

  > [!NOTE]
  > If the modal or page is not still open, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page in the Clerk Dashboard. Select the connection. Under **Use custom credentials**, you can paste the values into their respective fields.

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add GitHub as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their GitHub account using OAuth.

---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A GitHub account is required.",
      link: "https://github.com/signup",
      icon: "user-circle",
    },
  ]}
/>

Enabling OAuth with [GitHub](https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-oauth-app) allows your users to sign up and sign in to your Clerk app with their GitHub account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **GitHub**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for [GitHub's Developer Settings](https://github.com/settings/apps).

<Steps>
  ### Enable GitHub as a social connection in Clerk

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and choose **For all users**.
  1. In the **Choose provider** dropdown, select **GitHub**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Authorization Callback URL** somewhere secure. Keep the modal and page open.

  ### Create a GitHub app

  1. In the left sidenav of your [GitHub's Developer Settings](https://github.com/settings/apps), select **OAuth Apps**.
  1. Select **New OAuth app**. You'll be redirected to the **Register a new OAuth app** page.
  1. Complete the required fields. In **Authorization Callback URL**, paste the **Authorization Callback URL** you saved from the Clerk Dashboard.
  1. Select **Register application**. You'll be redirected to your app's **General** page.
  1. Select **Generate a new client secret**. Save the **Client ID** and **Client Secret** somewhere secure.

  ### Set the Client ID and Client Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add GitLab as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their GitLab account using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A GitLab account is required.",
      link: "https://gitlab.com/users/sign_up",
      icon: "user-circle",
    },
  ]}
/>

Enabling OAuth with [GitLab](https://docs.gitlab.com/ee/integration/oauth_provider.html) allows your users to sign up and sign in to your Clerk app with their GitLab account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **GitLab**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [GitLab](https://gitlab.com) account.

<Steps>
  ### Enable GitLab as a social connection in Clerk

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **GitLab**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Redirect URI** somewhere secure. Keep the modal and page open.

  ### Create a GitLab app

  1. In [Gitlab](https://gitlab.com), navigate to the [**Applications**](https://gitlab.com/-/user_settings/applications) page.
  1. Select **Add new application**.
  1. Enter your app name in **Name**.
  1. In **Redirect URI**, paste the **Redirect URI** you saved from the Clerk Dashboard.
  1. Select the **Scopes** needed for your app. At minimum, select `read_user`.
  1. Select **Save application**. You'll be redirected to your app's settings page. Save the **Application ID** and **Secret** somewhere secure.

  ### Set the Application ID and Secret in the Clerk Dashboard

  1. Navigate back to the Clerk Dashboard where the modal should still be open. Paste the **Application ID** and **Secret** values that you saved into the respective fields.
  1. Select **Add connection**.

  > [!NOTE]
  > If the modal or page is not still open, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page in the Clerk Dashboard. Select the connection. Under **Use custom credentials**, you can paste the values into their respective fields.

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add Google as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Google account using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk application is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A Google Developer account is required.",
      link: "https://console.developers.google.com/",
      icon: "user-circle",
    }
  ]}
/>

Enabling OAuth with [Google](https://developers.google.com/identity/protocols/oauth2) allows your users to sign up and sign in to your Clerk application with their Google account.

> [!WARNING]
> Google OAuth 2.0 **does not** allow apps to use WebViews for authentication. See the dedicated [Google blog post](https://developers.googleblog.com/en/modernizing-oauth-interactions-in-native-apps-for-better-usability-and-security) for more information. If your app requires users to sign in via in-app browsers, follow the setup instructions in the [Google Help guide](https://support.google.com/faqs/answer/12284343).

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **Google**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Google Cloud Console](https://console.cloud.google.com/).

<Steps>
  ### Enable Google as a social connection

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Google**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Authorized Redirect URI** somewhere secure. Keep this modal and page open.

  ### Create a Google Developer project

  1. Navigate to the [Google Cloud Console](https://console.cloud.google.com/).
  1. Select a project or [create a new one](https://console.cloud.google.com/projectcreate). You'll be redirected to your project's **Dashboard** page.
  1. In the top-left, select the menu icon (****) and select **APIs & Services**. Then, select **Credentials**.
  1. Next to **Credentials**, select **Create Credentials**. Then, select **OAuth client ID.** You might need to [configure your OAuth consent screen](https://support.google.com/cloud/answer/6158849#userconsent). Otherwise, you'll be redirected to the **Create OAuth client ID** page.
  1. Select the appropriate application type for your project. In most cases, it's **Web application**.
  1. In the **Authorized JavaScript origins** setting, select **Add URI** and add your domain (e.g., `https://your-domain.com` and `https://www.your-domain.com` if you have a `www` version). For local development, add `http://localhost:PORT` (replace `PORT` with the port number of your local development server).
  1. In the **Authorized Redirect URIs** setting, paste the **Authorized Redirect URI** value you saved from the Clerk Dashboard.
  1. Select **Create**. A modal will open with your **Client ID** and **Client Secret**. Save these values somewhere secure.

  ### Set the Client ID and Client Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />

  > [!WARNING]
  > Google sign-in [**does not** allow users to sign in via in-app browsers](https://developers.googleblog.com/en/modernizing-oauth-interactions-in-native-apps-for-better-usability-and-security).
</Steps>

### Important note about switching to production

Google OAuth apps have a publishing status that determines who can access the app. The publishing status setting can be found in the Google Cloud Platform console on the **APIs & Services > OAuth consent screen** page. You can only view the publishing status if the **User type** is set to **External**.

By default, Google OAuth apps are set to the **"Testing"** [publishing status](https://support.google.com/cloud/answer/10311615#publishing-status), which is intended for internal testing before opening connections to your [intended audience](https://support.google.com/cloud/answer/10311615#user-type). It's limited to 100 test users and depending on the requested OAuth scopes, they might need to be explicitly added to your trusted user list to be able to connect.

To switch a Google OAuth app to production, **you must set the publishing status to "In production".** This involves a verification process with regard to your app name, logo, and scopes requested before Google accepts the switch to production.

Ensure that your Clerk production app always uses a corresponding Google OAuth app that is set to the **"In production"** publishing status, so your end users don't encounter any issues using Google as a social connection.

### Block email subaddresses

By default, your app will block any Google account with an email address that contains the characters `+`, `=` or `#` from being able to sign up, sign in, or be added to existing accounts.

For a Google organization with the domain `example.com`, blocking email subaddresses prevents someone with access to `user@example.com` from signing up with `user+alias@example.com`. This is a known [Google OAuth vulnerability](https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of/) that could allow unauthorized, as Google organization administrators cannot suspend or delete the email alias account. It's recommended to keep this setting enabled for enhanced security.

To configure this setting:

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select the **Google** connection.
1. Enable or disable **Block email subaddresses**.

> [!NOTE]
> Existing Google accounts with email subaddresses will be blocked by this restriction and won't be able to sign in.

## Google One Tap

[Google One Tap](https://developers.google.com/identity/gsi/web/guides/features) enables users to sign up or sign in to your Clerk app with the press of a button. After adding Google to your Clerk app as a social connection, you can use the prebuilt `<GoogleOneTap />` component to render the One Tap UI in your app. See [the `<GoogleOneTap />` component reference](/docs/components/authentication/google-one-tap) to learn more.

---
title: Add Google as an EASIE connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Google account using EASIE SSO.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Add the Enhanced authentication add-on to your Pro plan",
      link: "/pricing",
      icon: "plus-circle",
    },
    {
      title: "Enable email address as an identifier for your application.",
      link: "/docs/authentication/configuration/sign-up-sign-in-options#identifiers",
      icon: "key",
    },
    {
      title: "A Google Developer account is required.",
      link: "https://console.developers.google.com/",
      icon: "user-circle",
    }
  ]}
/>

Enabling [EASIE SSO](/docs/authentication/enterprise-connections/overview#easie) with Google allows your users to sign up and sign in to your Clerk application with their Google account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For specific domains or organizations**.
1. Under **EASIE**, select **Google**.
1. Enter the **Domain**. This is the email domain of the users you want to allow to sign in to your application. Optionally, select an **Organization**.
1. Select **Add connection**.

## Configure for your production instance

> [!WARNING]
> If you already [configured Google as a social provider](/docs/authentication/social-connections/google), you can skip this step. EASIE SSO will automatically use the credentials you configured for your social connection.

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Google Cloud Console](https://console.cloud.google.com/).

<Steps>
  ### Enable Google as an EASIE connection

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For specific domains or organizations**.
  1. Under **EASIE**, select **Google**.
  1. Enter the **Domain**. This is the email domain of the users you want to allow to sign in to your application. Optionally, select an **Organization**.
  1. Save the **Redirect URI** somewhere secure. Keep this modal open to enter the OAuth credentials in the following steps.

  ### Create a Google Developer project

  1. Navigate to the [Google Cloud Console](https://console.cloud.google.com/).
  1. Select a project or [create a new one](https://console.cloud.google.com/projectcreate).
  1. If the **APIs & Services** page isn't already open, open the menu on the left and select **APIs & Services**.
  1. In the left sidenav, select **Credentials**.
  1. Select **Create Credentials**. Then, select **OAuth client ID.** You may need to [configure your OAuth consent screen](https://support.google.com/cloud/answer/6158849?hl=en#userconsent\&zippy=%2Cuser-consent).
  1. Select the appropriate application type for your project. Most likely, you will choose **Web application**.
  1. In the **Authorized redirect URIs** section, select **Add URI** and paste the **Redirect URI** value you saved from the Clerk Dashboard.
  1. Select **Create**.

  ### Set the Client ID and Client Secret in the Clerk Dashboard

  Once the OAuth client is created in the Google Cloud Console, a modal will open with your **Client ID** and **Client Secret**. Save these values somewhere secure.

  Go back to the Clerk Dashboard, where the modal should still be open, and paste these values into the respective fields. Note that if you have any other Google EASIE connections or a [Google social connection](docs/authentication/social-connections/google), this will update the credentials for all of them. Select **Add connection**.
</Steps>

---
title: Add Google Workspace as a SAML connection
description: Learn how to integrate Google Workspace with Clerk using SAML SSO.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Add the Enhanced authentication add-on to your Pro plan",
      link: "/pricing",
      icon: "plus-circle",
    },
    {
      title: "Enable email address as an identifier for your application.",
      link: "/docs/authentication/configuration/sign-up-sign-in-options#identifiers",
      icon: "key",
    }
  ]}
/>

Enabling SAML with Google allows your users to sign up and sign in to your Clerk application with their Google account.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Google Admin Console](https://admin.google.com/).

<Steps>
  ## Enable Google as a SAML connection in Clerk

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For specific domains or organizations**.
  1. Under **SAML**, select **Google Workspace**.
  1. Enter the **Domain**. This is the email domain of the users you want to allow to sign in to your application. Optionally, select an **Organization**.
  1. Enter the **Name**. This will be displayed on the sign-in form.
  1. Select **Add connection**. You'll be redirected to the connection's configuration page.
  1. In the **Service Provider Configuration** section, save the **ACS URL** and **Entity ID** values somewhere secure. Keep this page open.

  ## Create a new enterprise application in Google

  1. Navigate to the [Google Admin Console](https://admin.google.com/) and sign in.
  1. In the navigation sidenav, under **Apps**, select **Web and mobile apps**.
  1. Select the **Add app** button.
  1. From the dropdown, select **Add custom SAML app**.
  1. In the **App details** section, an **App name** is required.
  1. Select the **Continue** button.

  ## Configure Google as your Identity Provider

  There are two options for configuring your identity provider:

  - **[Metadata configuration](#metadata-configuration) (recommended)** - A URL or file to your IdP's metadata. This is quicker than manually inputting the configuration settings.
  - [**Custom configuration**](#custom-configuration) - Manually input the configuration settings for your IdP.

  ### Metadata configuration

  1. In the Google Admin Console, under **Option 1: Download IdP Metadata**, select the **Download Metadata** button.
  1. Navigate back to the Clerk Dashboard and in the **Identity Provider Configuration** section, select the **Upload file** button.
  1. Upload the metadata file you downloaded from Google.

  ### Custom configuration

  If you choose to manually input the configuration settings for your IdP, you must add these three fields to your Clerk settings:

  - **SSO URL** - The unique identifier of your IdP application.
  - **Entity ID** - Your IdP's URL that Clerk will redirect your users to so that they can authenticate.
  - **Certificate** - The certificate needed for Clerk to securely connect to your IdP.

  1. In the Google Admin Console, under **Option 2**, copy the **SSO URL**, **Entity ID**, and download the **Certificate**.
  1. Navigate back to the Clerk Dashboard and in the **Identity Provider Configuration** section, select **Use manual configuration**.
  1. Fill in the **SSO URL**, **Entity ID**, and upload the **Certificate**. Don't forget to select **Save**.
  1. In the Google Admin Console, select the **Continue** button.

  ## Configure Clerk as your Service Provider

  1. In the Google Admin Console, paste the **ACS URL** and **Entity ID** values you saved from the Clerk Dashboard into their respective fields.
  1. Under the **Name ID** section, select the **Name ID format** dropdown and select **Email**.
  1. Select **Continue**.

  ## Map Google claims to Clerk attributes

  Mapping the claims in your IdP to the attributes in Clerk ensures that the data from your IdP is correctly mapped to the data in Clerk.

  | Clerk attribute | Google claim |
  | - | - |
  | `mail` | Basic Information > Primary email |
  | `firstName` | Basic Information > First name |
  | `lastName` | Basic Information > Last name |

  The only Google claim that is necessary to map is the **Primary email**. This is the email address that your users will use to authenticate into your application.

  1. In the Google Admin Console, under the **Attributes** section, select **Add mapping**.
  1. Select the dropdown under **Google Directory attributes**.
  1. Select **Primary email**.
  1. In the **App attributes** field, enter `mail`.
  1. If you have additional claims that you would like to map to Clerk, you can do so by following the steps in the [Map other claims](#map-other-claims-optional) section. Otherwise, select the **Finish** button.

  ### Map other claims (optional)

  In Clerk, the [`User`](/docs/references/javascript/user) object has a `publicMetadata` property that you can use to store additional information about your users.

  To map other claims from Google that don't have a direct mapping to Clerk attributes, you can map them to Clerk's `publicMetadata` property. To do this, prepend the Clerk claims with `public_metadata_` during the mapping process.

  For example, say your users have the "Phone number" attribute in Google. You can map this to your users' public metadata in Clerk by mapping the Google field to `public_metadata_phone_number`.

  1. In the Google Admin Console, under the **Attributes** section, select the dropdown under **Google Directory attributes**.
  1. Select **Phone number**.
  1. In the **App attributes** field, enter `public_metadata_phone_number`.
  1. Select the **Finish** button.

  The value for the user's phone number will be saved in the user's `User.publicMetadata` under the key `phone_number`.

  Learn more about [how to access the metadata from our APIs](/docs/users/metadata).

  ## Enable the connection in Google

  Once the configuration is complete in Google, you'll be redirected to the app's overview page.

  1. In the **User access** section, select **OFF for everyone**. You'll be redirected to the **Service status** page.
  1. Select **ON for everyone**.
  1. Select **Save**.

  ## Enable the connection in Clerk

  <Include src="_partials/authentication/saml/enable-connection" />
</Steps>

---
title: Add HubSpot as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their HubSpot account using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk application is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A HubSpot Developer account is required.",
      link: "https://app.hubspot.com/signup-hubspot/developers",
      icon: "user-circle",
    }
  ]}
/>

Enabling OAuth with HubSpot allows your users to sign up and sign in to your Clerk application with their HubSpot account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **HubSpot**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials, which involves generating your own **Client ID** and **Client Secret** using your HubSpot Developer account.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [HubSpot developer account](https://app.hubspot.com/signup-hubspot/developers).

<Steps>
  ### Enable HubSpot as a social connection

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **HubSpot**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Redirect URI** somewhere secure. Keep this modal and page open.

  ### Create a HubSpot Developer project

  1. Navigate to the [HubSpot account selection page](https://app.hubspot.com/myaccounts-beta) and select the **developer** account you want to use. You'll be redirected to the **Developer home** page.
  1. Select **Create app**. You'll be redirected to the app's configuration settings.
  1. In the **App Info** tab, complete the form. The **Public app name** is required.
  1. Select the **Auth** tab.
  1. In the **Redirect URLs** section, paste the **Redirect URI** value you saved from the Clerk Dashboard.
  1. In the **Scopes** section, select **Add new scope**.
  1. Enable the **crm.objects.owners.read** scope and select **Update**.
  1. Select **Create app**. You'll be redirected back to the **App Info** tab.
  1. Select the **Auth** tab.
  1. Save the **Client ID** and **Client Secret** values somewhere secure.

  ### Set the Client ID and Client Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add Hugging Face as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Hugging Face account using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A Hugging Face account is required.",
      link: "https://huggingface.co/join",
      icon: "user-circle",
    }
  ]}
/>

Enabling OAuth with [Hugging Face](https://huggingface.co/) allows your users to sign up and sign in to your Clerk application with their Hugging Face account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIs  no other configuration is needed.

To configure your development instance, follow these steps:

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select the **Add connection** button and select **For all users**.
1. In the **Choose provider** dropdown, select **Hugging Face**.
1. Select **Add connection**.

## Configure for your production instance

In _production instances_, you must provide custom credentials.

To configure your production instance, follow these steps:

<Steps>
  ### Enable Hugging Face as a social connection

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select the **Add connection** button and select **For all users**.
  1. In the **Choose provider** dropdown, select **Hugging Face**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Redirect URL** somewhere secure. Keep this modal and page open.

  ### Create a Hugging Face Connected App

  1. In the top-right of [Hugging Face](https://huggingface.co/), select your avatar and select **Settings**.
  1. In the left sidenav, select **Connected Apps**.
  1. Under **Developer Applications**, select **Create App**.
  1. Complete the form. Under **Scopes**, select the scopes that your app requires. At minimum, select **openid**, **profile**, and **email**. Under **Redirect URLs**, paste the **Redirect URL** value you saved from the Clerk Dashboard.
  1. Select **Create**. The page should refresh and display the **Client ID** and **App Secret**. Save these values somewhere secure.

  ### Set the Client ID and App Secret in the Clerk Dashboard

  1. Navigate back to the Clerk Dashboard where the modal should still be open. Paste the **Client ID** and **App Secret** values that you saved into the respective fields.
  1. Select **Add connection**.

  > [!NOTE]
  > If the modal or page is not still open, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page in the Clerk Dashboard. Select the connection. Under **Use custom credentials**, you can paste the values into their respective fields.

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add LINE as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their LINE account using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A LINE Business ID account is required.",
      link: "https://developers.line.biz/en/",
      icon: "user-circle",
    }
  ]}
/>

Enabling OAuth with LINE allows your users to sign up and sign in to your Clerk app with their LINE account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **LINE**.
1. Select **Add connection**.

<Callout type="info">
  Clerk's preconfigured shared OAuth credentials use **Japan** as the LINE region.
</Callout>

## Configure for your production instance

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [LINE Developers Console](https://developers.line.biz/console/).

<Steps>
  ### Enable LINE as a social connection

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **LINE**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Callback URL** somewhere secure. Keep this modal and page open.

  ### Create a LINE app

  1. In the [LINE Developers Console](https://developers.line.biz/console/), select **Create a new provider**. A modal will open.
  1. Fill out the necessary information. Select **Create**. You'll be redirected to the app's **Channels** tab.
  1. Select **Create a LINE Login channel**.
  1. Fill out the necessary information. Select **Create**. You'll be redirected to the app's **Basic settings**.
  1. Save the **Channel ID** and **Channel secret** somewhere secure.
  1. Select the **LINE Login** tab.
  1. Under **Callback URL**, select **Edit**. Paste the **Callback URL** value you saved from the Clerk Dashboard.
  1. Select **Update**.

  ### Set the Channel ID and Channel Secret in the Clerk Dashboard

  1. Navigate back to the Clerk Dashboard where the modal should still be open. Paste the **Channel ID** and **Channel Secret** values that you saved into the respective fields.
  1. Select **Add connection**.

  > [!NOTE]
  > If the modal or page is not still open, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page in the Clerk Dashboard. Select the connection. Under **Use custom credentials**, you can paste the values into their respective fields.

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add Linear as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Linear account using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A Linear account is required.",
      link: "https://linear.app/signup",
      icon: "user-circle",
    },
  ]}
/>

Enabling OAuth with [Linear](https://developers.linear.app/docs/oauth/authentication) allows your users to sign up and sign in to your Clerk app with their Linear account.

> [!IMPORTANT]
> You must be a workspace admin to create and manage OAuth apps in Linear.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **Linear**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Linear's API settings](https://linear.app/clerk/settings/api) page.

<Steps>
  ### Enable Linear as a social connection in Clerk

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Linear**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Callback URL** somewhere secure. Keep the modal and page open.

  ### Create a Linear app

  1. In the top-left of [Linear](https://linear.app/), select your workspace, then select **Settings**.
  1. In the sidenav, under **Account**, select **API**. Scroll down to **OAuth Applications** and select **Create new OAuth Application**. You'll be navigated to the [**Create new application**](https://linear.app/clerk/settings/api/applications/new) page.
  1. Complete the required fields. In **Callback URLs**, paste the **Redirect URI** you saved from the Clerk Dashboard.
  1. Select **Save**. The page will refresh and you should see the **Client ID** and **Client Secret** at the top. Save both values somewhere secure.

  ### Set the Client ID and Client Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add LinkedIn Open ID Connect (OIDC) as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their LinkedIn Open ID Connect (OIDC) account.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A LinkedIn developer account is required.",
      link: "https://developer.linkedin.com/",
      icon: "user-circle",
    }
  ]}
/>

Enabling OpenID Connect (OIDC) with [LinkedIn](https://learn.microsoft.com/en-us/linkedin/shared/authentication/authentication) allows your users to sign up and sign in to your Clerk application with their LinkedIn account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIs  no other configuration is needed.

To configure your development instance, follow these steps:

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select the **Add connection** button and select **For all users**.
1. In the **Choose provider** dropdown, select **LinkedIn**.
1. Select **Add connection**.

## Configure for your production instance

In _production instances_, you must provide custom credentials, which involves generating your own **Client ID** and **Client Secret** using your LinkedIn Developer account.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [LinkedIn Developer Portal](https://developer.linkedin.com/).

<Steps>
  ### Enable LinkedIn as a social connection

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select the **Add connection** button, and select **For all users**.
  1. In the **Choose provider** dropdown, select **LinkedIn**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Redirect URI** somewhere secure. Keep this modal and page open.

  ### Create a LinkedIn application

  > [!TIP]
  > If you already have a LinkedIn app you'd like to connect to Clerk, select your app from the [**My apps**](https://www.linkedin.com/developers/apps?appStatus=active) page in the LinkedIn Developer Portal and proceed to the [next step](#set-the-client-id-and-primary-client-secret-in-the-clerk-dashboard) in this tutorial.

  1. On the homepage of the [LinkedIn Developer Portal](https://developer.linkedin.com/), select **Create app**. You'll be redirected to the **Create an app** form.
  1. Fill out the necessary information. Then, select **Create app**. You'll be redirected to the app's **Products** page.
  1. Select the **Auth** tab.
  1. Under **Application credentials**, save the **Client ID** and **Primary Client Secret** somewhere secure.
  1. Under the **OAuth 2.0 settings** section, next to **Authorized redirect URLs for your app**, select the **Edit** icon.
  1. Select **Add redirect URL** and paste the **Redirect URL** you copied from the Clerk Dashboard.
  1. Select **Update**.

  ### Set the Client ID and Primary Client Secret in the Clerk Dashboard

  1. Navigate back to the Clerk Dashboard where the modal should still be open. Paste the **Client ID** and **Primary Client Secret** values that you saved into the respective fields.
  1. Select **Add connection**.

  > [!NOTE]
  > If the modal or page is no longer open, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page in the Clerk Dashboard. Select the connection. Under **Use custom credentials**, paste the values into their respective fields.

  ### Enable OpenID Connect in your LinkedIn application

  1. Select the **Products** tab.
  1. Next to **Sign In with LinkedIn using OpenID Connect**, select **Request access**. A modal will open.
  1. Follow the instructions and select **Request access**.

  > [!NOTE]
  > If you need to ensure the longevity of the user's access token without requiring re-authentication, consider getting approval as a [Marketing Developer Platform (MDP) partner](https://learn.microsoft.com/en-us/linkedin/marketing/quick-start?view=li-lms-2023-10#step-1-apply-for-api-access). This isn't necessary if you don't directly interact with the LinkedIn API using the access token.

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add Microsoft as an EASIE connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Microsoft account using EASIE SSO.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Add the Enhanced authentication add-on to your Pro plan",
      link: "/pricing",
      icon: "plus-circle",
    },
    {
      title: "Enable email address as an identifier for your app.",
      link: "/docs/authentication/configuration/sign-up-sign-in-options#identifiers",
      icon: "key",
    },
    {
      title: "A Microsoft Azure account is required.",
      link: "https://azure.microsoft.com/en-us/free/",
      icon: "user-circle",
    }
  ]}
/>

Enabling [EASIE SSO](/docs/authentication/enterprise-connections/overview#easie) with Microsoft (formerly [Active Directory](https://learn.microsoft.com/en-us/entra/fundamentals/new-name)) allows your users to sign up and sign in to your Clerk application with their Microsoft account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For specific domains or organizations**.
1. Under **EASIE**, select **Microsoft**.
1. Enter the **Domain**. This is the email domain of the users you want to allow to sign in to your application. Optionally, select an **Organization**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials. If you already [configured Microsoft as a social provider](/docs/authentication/social-connections/microsoft), you can skip this step. EASIE SSO will automatically use the credentials you configured for your social connection.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Microsoft Azure portal](https://portal.azure.com).

<Steps>
  ### Enable Microsoft as an EASIE connection

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For specific domains or organizations**.
  1. Under **EASIE**, select **Microsoft**.
  1. Enter the **Domain**. This is the email domain of the users you want to allow to sign in to your application. Optionally, select an **Organization**.
  1. Save the **Redirect URI** somewhere secure. Keep this modal and page open.

  ### Create a Microsoft Entra ID app

  <Include src="_partials/authentication/microsoft/create-app" />

  ### Get your Client ID and Client Secret

  <Include src="_partials/authentication/microsoft/get-client-id-secret" />

  ### Enable OpenID

  <Include src="_partials/authentication/microsoft/enable-openid" />

  ### Secure your app against the nOAuth vulnerability

  <Include src="_partials/authentication/microsoft/noauth" />

  ### Set the Client ID and Client Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add Microsoft Azure Entra ID as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Microsoft account using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A Microsoft Azure account is required.",
      link: "https://azure.microsoft.com/en-us/free/",
      icon: "user-circle",
    }
  ]}
/>

Enabling OAuth with Microsoft Azure Entra ID (formerly [Active Directory](https://learn.microsoft.com/en-us/entra/fundamentals/new-name)) allows your users to sign up and sign in to your Clerk app with their Microsoft account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **Microsoft**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials. If you already [configured Microsoft as an EASIE connection](/docs/authentication/enterprise-connections/easie/microsoft), you can skip this step. EASIE SSO will automatically use the credentials you configured for your enterprise connection.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Microsoft Azure portal](https://portal.azure.com).

<Steps>
  ### Enable Microsoft as a social connection

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Microsoft**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Redirect URI** somewhere secure. Keep this modal and page open.

  ### Create a Microsoft Entra ID app

  <Include src="_partials/authentication/microsoft/create-app" />

  ### Get your Client ID and Client Secret

  <Include src="_partials/authentication/microsoft/get-client-id-secret" />

  ### Enable OpenID

  <Include src="_partials/authentication/microsoft/enable-openid" />

  ### Secure your app against the nOAuth vulnerability

  <Include src="_partials/authentication/microsoft/noauth" />

  ### Set the Client ID and Client Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

## Limitations

- Currently, Clerk supports only the `common` tenant type, which allows sign-ins both from organization members and public Microsoft users.
  - The option to selecting the desired tenant type (`common`, `organizations`, `consumers` or specific tenant ID) will be available in an upcoming version of Clerk.
- Only credentials of type `secret` are supported (not the `certificate` type).

> [!TIP]
> If you're using [SAML with Microsoft](/docs/authentication/enterprise-connections/saml/azure), the different tenant types _are_ supported, and you can disregard these limitations.

---
title: Add Microsoft Entra ID as a SAML connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Microsoft account using SAML SSO.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Add the Enhanced authentication add-on to your Pro plan",
      link: "/pricing",
      icon: "plus-circle",
    },
    {
      title: "Enable email address as an identifier for your app.",
      link: "/docs/authentication/configuration/sign-up-sign-in-options#identifiers",
      icon: "key",
    }
  ]}
/>

Enabling SAML with Microsoft Entra ID (formerly [Azure Active Directory](https://learn.microsoft.com/en-us/entra/fundamentals/new-name)) allows your users to sign up and sign in to your Clerk application with their Microsoft account. It requires that a SAML connection is configured in both the Clerk Dashboard and Microsoft Entra ID. This guide assumes that you have access to the Clerk app's settings in the Clerk Dashboard. The "customer" in this case is whoever has access to the Microsoft Entra ID settings.

<Steps>
  ## Create a Microsoft Entra ID SAML connection in Clerk

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For specific domains or organizations**.
  1. Under **SAML**, select **Microsoft Entra ID (Formerly AD)**.
  1. Enter the **Domain**. This is the email domain of the users you want to allow to sign in to your application. Optionally, select an **Organization**.
  1. Enter the **Name**. This will be displayed on the sign-in form.
  1. Select **Add connection**. You'll be redirected to the connection's configuration page. Note that the connection is disabled by default.
  1. In the **Service Provider Configuration** section, save the **Reply URL (Assertion Consumer Service URL)** and **Identifier (Entity ID)** values somewhere secure. You'll need to give these to the customer so they can configure their Microsoft Entra ID application.

  ## Configure SAML application

  Now that the enterprise connection is configured in Clerk and the **Reply URL** and **Identifier** are known, the customer's Microsoft application needs to be configured. At a high level, the process is:

  - Create a new enterprise app in Microsoft Azure.
  - Assign selected users or groups to that Microsoft application.
  - Add the **Reply URL** and **Identifier** from Clerk to the Microsoft application's SAML configuration.
  - Verify that the attribute mappings are correct.
  - Obtain and share the application's metadata URL.

  You are welcome the use the below email template with detailed instructions. They contain the following
  template strings that you should replace with your actual values:

  - \[YOUR\_APPLICATION\_NAME]
  - \[YOUR\_CLERK\_ENTITY\_ID]
  - \[YOUR\_CLERK\_REPLY\_URL]

  <Copyable as="html">
    Here are the instructions for setting up SAML SSO with Microsoft Entra ID:

    **Step 1: Create a new enterprise application in Microsoft**

    1. Navigate to the [Microsoft Azure portal](https://azure.microsoft.com/en-us/get-started/azure-portal) and sign in.
    1. Under the **Azure Services** section, find and select **Enterprise applications**. You may have to go to the [**All services**](https://portal.azure.com/#allservices) page and then scroll down to the **Identity** section to find it.
    1. Select **New application**. You'll be redirected to the **Browse Microsoft Entra Gallery** page.
    1. Select **Create your own application**.
    1. In the modal that opens:
       - **Name** of your application (likely \[YOUR\_APPLICATION\_NAME]).
       - Select **Integrate any other application you don't find in the gallery (Non-gallery)**.
       - Select **Create**.

    **Step 2: Assign your users or groups in Microsoft**

    Now that you have created the enterprise app, you need to assign users or groups before they can use it to log in. Below are instructions for assigning an individual user, but for more options and instructions for groups, see Microsoft's docs [here](https://learn.microsoft.com/en-us/entra/identity/enterprise-apps/assign-user-or-group-access-portal?pivots=portal).

    1. In the **Getting Started** section, select the **Assign users and groups** link.
    1. Select **Add user/group**. You'll be redirected to the **Add Assignment** page.
    1. Select the **None Selected** link.
    1. To assign a user to the enterprise app, you can either use the search field to find a user or select the checkbox next to the user in the table.
    1. Select **Select** at the bottom of the page. You'll be redirected to the **Add Assignment** page.
    1. Select **Assign** at the bottom of the page.

    **Step 3: Set Basic SAML Configuration**

    1. In the navigation sidenav, open the **Manage** dropdown and select **Single sign-on**.
    1. In the **Select a single sign-on method** section, select **SAML**. You'll be redirected to the **Set up Single Sign-On with SAML** page.
    1. Find the **Basic SAML Configuration** section.
    1. Select **Edit**. The **Basic SAML Configuration** panel will open.
    1. Add the following **Identifier (Entity ID)** and **Reply URL (Assertion Consumer Service URL)** values. These values will be saved automatically.
       - **Identifier (Entity ID)**: `[YOUR_CLERK_ENTITY_ID]`
       - **Reply URL (Assertion Consumer Service URL)**: `[YOUR_CLERK_REPLY_URL]`
    1. Select **Save** at the top of the panel. Close the panel.

    **Step 4: Verify correct configuration of attributes and claims**

    We expect your SAML responses to have the following specific attributes:

    Email address (required). This is the email address that your users will use to authenticate into your app:

    - Claim name: `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress`
    - Value: `user.mail`

    First name (optional):

    - Claim name: `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname`
    - Value: `user.givenname`

    Last name (optional):

    - Claim name: `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname`
    - Value: `user.surname`

    These are the defaults, and probably won't need you to change them. However, many SAML configuration errors are due to incorrect attribute mappings, so it's worth double-checking. Here's how:

    1. Still on the **Set up Single Sign-On with SAML** page, find the **Attributes & Claims** section.
    1. Select **Edit**.
    1. Verify that the above three attributes and values are present.

    **Step 5: Share the application's metadata URL**

    1. Still on the **Set up Single Sign-On with SAML** page, find the **SAML Certificates** section.
    1. Copy the **App Federation Metadata Url**, and reply to this email with it. This is the final piece of information we need to enable SAML.
  </Copyable>

  ## Add App Federation Metadata URL in the Clerk Dashboard

  After following the instructions in the email, your customer should have sent you the Microsoft app's **App Federation Metadata URL**. Now, you're going to add it to the Clerk connection, completing the SAML connection configuration.

  1. Navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page in the Clerk Dashboard.
  1. Select the SAML connection.
  1. In the **Identity Provider Configuration** section, under **App Federation Metadata Url**, paste the **App Federation Metadata URL**.
  1. Select **Fetch & save**. Keep the page open for the next step.

  ## Enable the connection in Clerk

  The SAML connection is ready to enable! Once enabled, all users with email addresses ending in the domain will be redirected to Microsoft at sign-up and sign-in.

  > [!WARNING]
  > If there are existing users with email domains that match the SAML connection, and there is an error in the SAML configuration in Clerk or Microsoft, those users will be **unable to sign in** when the connection is enabled. If this is a concern, we recommend coordinating with your counterpart to test the connection at an off-peak time.

  To make the connection available for users to authenticate with:

  1. Navigate back to the Clerk Dashboard where you should still have the connection's configuration page open. If not, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page and select the connection.
  1. At the top of the page, toggle on **Enable connection** and select **Save**.
</Steps>

---
title: Add Notion as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Notion account using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A Notion Developer account is required.",
      link: "https://developers.notion.com/",
      icon: "user-circle",
    }
  ]}
/>

Enabling OAuth with Notion allows your users to sign up and sign in to your Clerk app with their Notion account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **Notion**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Notion Developer](https://developers.notion.com) page.

<Steps>
  ### Enable Notion as a social connection

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Notion**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Authorization URL** somewhere secure. Keep this modal and page open.

  ### Create a Notion app

  1. In the top-right of the [Notion Developer](https://developers.notion.com) home page, select **View my integrations**. You'll be redirected to the **Integrations** page.
  1. Select **New integration**.
  1. Fill out the necessary information. In the **Type** dropdown, select **Public**. Under **Authorization URL**, paste the **Authorization URL** value you saved from the Clerk Dashboard and then select it.
  1. Select **Save**. The **Integration successfully created** modal will open. Select **Configure integration settings**. You'll be redirected to the app's **Configuration** page.
  1. Save the **OAuth Client ID** and **OAuth Client Secret** somewhere secure.

  ### Set the Client ID and Client Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add Okta Workforce as a SAML connection
description: Learn how to integrate Okta Workforce with Clerk using SAML SSO.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Add the Enhanced authentication add-on to your Pro plan",
      link: "/pricing",
      icon: "plus-circle",
    },
    {
      title: "Enable email address as an identifier for your application.",
      link: "/docs/authentication/configuration/sign-up-sign-in-options#identifiers",
      icon: "key",
    }
  ]}
/>

Enabling SAML with Okta Workforce allows your users to sign up and sign in to your Clerk application with their Okta account.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for the [Okta dashboard](https://www.okta.com/).

<Steps>
  ## Enable Okta as a SAML connection in Clerk

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For specific domains or organizations**.
  1. Under **SAML**, select **Okta Workforce**.
  1. Enter the **Domain**. This is the email domain of the users you want to allow to sign in to your application. Optionally, select an **Organization**.
  1. Enter the **Name**. This will be displayed on the sign-in form.
  1. Select **Add connection**. You'll be redirected to the connection's configuration page.
  1. In the **Service Provider Configuration** section, save the **Single sign-on URL** and **Audience URI (SP Entity ID)** values somewhere secure. Keep this page open.

  ## Create a new enterprise application in Okta

  1. Navigate to [Okta](https://www.okta.com/) and sign in.
  1. In the Okta dashboard, select **Admin** in the top right corner.
  1. In the navigation sidenav, select the **Applications** dropdown and select **Applications**.
  1. Select **Create App Integration**.
  1. In the **Create a new app integration** modal, select the **SAML 2.0** option and select the **Next** button.
  1. Once redirected to the **Create SAML Integration** page, complete the **General Settings** fields. An **App name** is required.
  1. Select **Next**. You'll be redirected to the **Configure SAML** page.
  1. Paste the **Single sign-on URL** and the **Audience URI (SP Entity ID)** values that you saved from the Clerk Dashboard into their respective fields.

  ## Map Okta claims to Clerk attributes

  Mapping the claims in your IdP to the attributes in Clerk ensures that the data from your IdP is correctly mapped to the data in Clerk.

  | Clerk attribute | Okta claim |
  | - | - |
  | `mail` | `user.email` |
  | `firstName` | `user.firstName` |
  | `lastName` | `user.lastName` |

  1. In the Okta dashboard, find the **Attribute Statements (optional)** section.
  1. For the **Name** field, enter `mail`.
  1. For the **Value** field, choose `user.email` from the dropdown.
  1. Select the **Add Another** button to add another attribute.
  1. For the **Name** field, enter `firstName`.
  1. For the **Value** field, choose `user.firstName` from the dropdown.
  1. Select the **Add Another** button to add another attribute.
  1. For the **Name** field, enter `lastName`.
  1. For the **Value** field, choose `user.lastName` from the dropdown.
  1. Scroll to the bottom of the page and select the **Next** button to continue.
  1. You will be redirected to the **Feedback** page. Fill out the feedback however you would like and select the **Finish** button to complete the setup.

  ## Assign selected user or group in Okta

  You need to assign your users/user groups to your enterprise application. For example, if you were part of the Clerk organization, you would have access to users and groups in the Clerk organization. In this case, you could assign one or more users or entire groups to the enterprise application you just created.

  1. In the Okta dashboard, select the **Assignments** tab.
  1. Select the **Assign** dropdown. You can either select **Assign to people** or **Assign to groups**.
  1. In the search field, enter the user or group of users that you want to assign to the enterprise application.
  1. Select the **Assign** button next to the user or group that you want to assign.
  1. Select the **Done** button to complete the assignment.

  ## Configure Okta as your Identity Provider

  Once you have completed the setup in Okta, you will be redirected to the application instances page with the **Sign On** tab selected.

  1. Under **Sign on methods**, copy the **Metadata URL**.
  1. Navigate back to the Clerk Dashboard and find the **Identity Provider configuration** section.
  1. Under the **Metadata configuration** option, paste the **Metadata URL**.
  1. Select the **Fetch & save** button to complete the setup.

  ## Enable the connection in Clerk

  <Include src="_partials/authentication/saml/enable-connection" />
</Steps>

---
title: Add React Router to your Clerk-powered Chrome Extension
description: Learn how to add React Router to your React app using their Data API router.
---

<TutorialHero
  exampleRepo={[
    {
      title: "Clerk Chrome Extension Repo",
      link: "https://github.com/clerk/clerk-chrome-extension-quickstart"
    }
  ]}
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk"
    },
    {
      title: "Add auth and user management to your Chrome Extension with Clerk",
      link: "/docs/quickstarts/chrome-extension",
      icon: "react"
    },
  ]}
/>

This tutorial demonstrates how to integrate React Router into your Chrome Extension application. It assumes you're using Plasmo to build your Chrome Extension.

<Steps>
  ## Install `react-router`

  React Router is a lightweight, fully-featured routing library. To install it in your project, run the following command:

  ```bash {{ filename: 'terminal' }}
  pnpm add react-router
  ```

  > [!IMPORTANT]
  > This guide assumes you're using Plasmo to build your Chrome Extension, so you must use `pnpm` as your package manager.

  ## Create routes

  1. In the `src/` directory, create a `popup/` directory.
  1. In the `popup/` directory, create a `routes/` directory.
  1. In the `routes/` directory, create the `home.tsx`, `sign-in.tsx`, `sign-up.tsx`, and `settings.tsx` files.
  1. Use the following tabs to view the code necessary for each file.

  <CodeBlockTabs options={["Home", "Sign-in", "Sign-up", "Settings"]}>
    ```tsx {{ filename: 'src/popup/routes/home.tsx' }}
    export const Home = () => {
      return (
        <>
          <h1>Clerk + Chrome Extension + React Router</h1>
        </>
      )
    }
    ```

    ```tsx {{ filename: 'src/popup/routes/sign-in.tsx' }}
    import { SignIn } from '@clerk/chrome-extension'

    export const SignInPage = () => {
      return (
        <>
          <p>Sign In</p>
          <SignIn routing="virtual" />
        </>
      )
    }
    ```

    ```tsx {{ filename: 'src/popup/routes/sign-up.tsx' }}
    import { SignUp } from '@clerk/chrome-extension'

    export const SignUpPage = () => {
      return (
        <>
          <p>Sign Up</p>
          <SignUp routing="virtual" />
        </>
      )
    }
    ```

    ```tsx {{ filename: 'src/popup/routes/settings.tsx' }}
    import { UserProfile } from '@clerk/chrome-extension'

    export const Settings = () => {
      return (
        <>
          <h1>Settings</h1>
          <UserProfile routing="virtual" />
        </>
      )
    }
    ```
  </CodeBlockTabs>

  ## Create layouts

  1. Delete your `src/popup.tsx` file.
  1. In your `src/popup/` directory, create a `layouts/` directory.
  1. In the `layouts/` directory, create a `root-layout.tsx` file.
  1. In the `root-layout.tsx` file, paste the following code to create a layout for your app.
     - The layout contains an [`<Outlet />`](https://reactrouter.com/en/main/components/outlet) component from `react-router`. This behaves similar to `{children}` in Next.js or more generic React components.
     - The footer includes Clerk's [`<UserButton />`](/docs/components/user/user-button) component and a link to the `/settings` page, which renders Clerk's [`<UserProfile />`](/docs/components/user/user-profile) component. Clerk's [`<SignedIn>`](/docs/components/control/signed-in) and [`<SignedOut>`](/docs/components/control/signed-out) control components determine what's displayed based on the user's authentication state.

  <CodeBlockTabs options={["Root Layout"]}>
    ```tsx {{ filename: 'src/popup/layouts/root-layout.tsx' }}
    import { Link, Outlet, useNavigate } from 'react-router'
    import { ClerkProvider, SignedIn, SignedOut, UserButton } from '@clerk/chrome-extension'

    const PUBLISHABLE_KEY = process.env.PLASMO_PUBLIC_CLERK_PUBLISHABLE_KEY

    if (!PUBLISHABLE_KEY) {
      throw new Error('Please add the PLASMO_PUBLIC_CLERK_PUBLISHABLE_KEY to the .env.development file')
    }

    export const RootLayout = () => {
      const navigate = useNavigate()

      return (
        <ClerkProvider
          routerPush={(to) => navigate(to)}
          routerReplace={(to) => navigate(to, { replace: true })}
          publishableKey={PUBLISHABLE_KEY}
          afterSignOutUrl="/"
        >
          <div className="plasmo-w-[785px] plasmo-h-[600px]">
            <main>
              <Outlet />
            </main>
            <footer>
              <SignedIn>
                <Link to="/settings">Settings</Link>
                <UserButton />
              </SignedIn>
              <SignedOut>
                <Link to="/">Home</Link>
                <Link to="/sign-in">Sign In</Link>
                <Link to="/sign-up">Sign Up</Link>
              </SignedOut>
            </footer>
          </div>
        </ClerkProvider>
      )
    }
    ```
  </CodeBlockTabs>

  ## Configure layouts and routes with `createMemoryRouter`

  [React Router's `createMemoryRouter`](https://reactrouter.com/en/main/routers/create-memory-router) is a router that uses memory to store the state of the router instead of the browser's history. This is useful for creating a router in a non-browser environment like a Chrome Extension.

  1. In the `src/popup/` directory, create an `index.tsx` file.
  1. In the `index.tsx` file, paste the following code to configure your routes with `createMemoryRouter`.

  ```ts {{ filename: 'src/popup/index.tsx' }}
  import React from 'react'

  import '../style.css'

  import { createMemoryRouter, RouterProvider } from 'react-router'

  import { RootLayout } from './layouts/root-layout'
  import { Home } from './routes/home'
  import { Settings } from './routes/settings'
  import { SignInPage } from './routes/sign-in'
  import { SignUpPage } from './routes/sign-up'

  const router = createMemoryRouter([
    {
      // Wraps the entire app in the root layout
      element: <RootLayout />,
      // Mounted where the <Outlet /> component is inside the root layout
      children: [
        { path: '/', element: <Home /> },
        { path: '/sign-in', element: <SignInPage /> },
        { path: '/sign-up', element: <SignUpPage /> },
        { path: '/settings', element: <Settings /> },
      ],
    },
  ])

  export default function PopupIndex() {
    return <RouterProvider router={router} />
  }
  ```

  ## Test the integration

  1. Run your project with the following command:
     ```bash {{ filename: 'terminal' }}
     pnpm dev
     ```
  1. In your Chrome browser, open the extension popup. Ensure that the home page displays with a footer containing the **Home**, **Sign In**, and **Sign Up** links.
  1. Visit the **Sign Up** link and ensure the `<SignUp />` component is rendered.
  1. Visit the **Sign In** link and ensure the `<SignIn />` component is rendered. Sign in with your account. You'll be redirected to the home page and the footer will display the **Settings** link and the `<UserButton />` component.
  1. Select the `<UserButton />` component to open the user menu.
  1. Visit the **Settings** link and ensure the `<UserProfile />` component is rendered.
</Steps>

---
title: Add reverification for sensitive actions
description: Learn how to implement Clerk's reverification feature to protect sensitive actions in your application.
---

> [!WARNING]
>
> Depending on the SDK you're using, this feature requires `@clerk/nextjs@6.12.7` or later, `@clerk/clerk-sdk-ruby@3.3.0` or later, and `@clerk/clerk-js@5.57.1` or later.

Reverification allows you to prompt a user to verify their credentials before performing sensitive actions, even if they're already authenticated. For example, in a banking application, transferring money is considered a "sensitive action." Reverification can be used to confirm the user's identity.

Clerk's prebuilt components handle reverification for certain [sensitive actions](#sensitive-actions-that-require-reverification), out of the box. However, this guide will show you how to implement reverification for sensitive actions that are unique to your application.

## Sensitive actions that require reverification

The following table shows the sensitive actions that require reverification along with the required strategy and timeframe for each action. When using Clerk's prebuilt components, reverification is automatically handled for these actions.

| Action | Strategy | Timeframe |
| - | - | - |
| Update username | Strongest available | 10m |
| Set/update password | Strongest available | 10m |
| Add/remove email address | Strongest available | 10m |
| Add/remove phone number | Strongest available | 10m |
| Add/remove Web3 Wallet | Strongest available | 10m |
| Add/remove passkey | Strongest available | 10m |
| Set primary identification | Strongest available | 10m |
| Connect/remove external account | Strongest available | 10m |
| Add/remove MFA (TOTP, phone number, backup codes) | Strongest available | 10m |
| Revoke session | Strongest available | 10m |
| Delete account | Strongest available | 10m |

## Caveats

Before enabling this feature, consider the following:

1. **Available factors for reverification**: Not all authentication factors are supported for reverification. Users can only reverify their credentials using the following factors:
   - First factors: password, email code, phone code
   - Second factors: phone code, authenticator app, backup code
1. **Graceful downgrade of verification level**: If you request a `second_factor` or `multi_factor` level of verification but the user lacks a second factor available, the utilities automatically downgrade the requested level to `first_factor`.
1. **Eligibility for sensitive actions**: Users without any of the above factors cannot reverify. This can be an issue for apps that don't require email addresses to sign up or have disabled email codes in favor of email links.

## How to require reverification

The simplest way to require reverification for a sensitive action is to use the [`useReverification()`](/docs/hooks/use-reverification) hook. This hook will automatically check if the user has verified their credentials within 10 minutes and if not, displays a modal that prompts the user to verify their credentials. See the [reference doc](/docs/hooks/use-reverification) for more information and comprehensive examples.

However, you may have sensitive actions on the server side that you want to require reverification for, such as in a Server Action or Route Handler. In this case, you can use the `auth.has()` helper to check if the user has verified their credentials within a specific time period. This only does the check on the server side, so you still need to handle reverification on the client side in order for your users to be able to verify their credentials. See the examples below for more information.

### Handle reverification server-side

To handle reverification server-side, use the [`auth.has()`](/docs/references/backend/types/auth-object#has) helper to check if the user has verified their credentials within a specific time period. Pass a configuration to set the time period you would like. You can pass one of the following configurations: `strict_mfa`, `strict`, `moderate`, and `lax`. See the [reference doc](/docs/references/backend/types/auth-object#has) for details on each configuration.

If the user hasn't verified their credentials within that time period, return either `reverificationError` or `reverificationErrorResponse`, depending on the framework you're using. Use the following tabs to see examples for different frameworks.

<Tabs items={["Next.js Server Action", "Next.js Route Handler", "Ruby on Rails", "Other"]}>
  <Tab>
    The following example uses the [`has()`](/docs/references/backend/types/auth-object#has) helper to check if the user has verified their credentials within a specific time period. The `strict` configuration sets the time period to 10 minutes. If the user hasn't verified their credentials within 10 minutes, the `reverificationError` utility is used to return an error.

    ```ts {{ filename: 'app/actions.ts' }}
    'use server'

    import { auth, reverificationError } from '@clerk/nextjs/server'

    export const myAction = async () => {
      const { has } = await auth.protect()

      // Check if the user has *not* verified their credentials within the past 10 minutes
      const shouldUserRevalidate = !has({ reverification: 'strict' })

      // If the user hasn't reverified, return an error with the matching configuration (e.g. `strict`)
      if (shouldUserRevalidate) {
        return reverificationError('strict')
      }

      // If the user has verified credentials, return a successful response
      return { success: true }
    }
    ```
  </Tab>

  <Tab>
    <Include src="_partials/nextjs/reverification-route-handler" />
  </Tab>

  <Tab>
    The following example uses the `clerk_user_needs_reverification` helper to check if the user has verified their credentials within a specific time period. The `moderate` configuration sets the time period to 1 hour. If the user hasn't verified their credentials within 1 hour, the `clerk_render_reverification` utility is used to return a `403 forbidden` error that the client reads to initiate the reverification flow. Once the user completes the reverification on the client-side, they can access the `foo` action, which returns a success response.

    ```ruby {{ filename: 'app/controllers/home_controller.rb' }}
    class HomeController < ApplicationController
      before_action :require_reverification, only: :foo

      def foo
        render json: { success: "true" }
      end

      private

      # will halt the request and respond with a JSON that Clerk.js
      # will read and kickstart a reverification flow
      def require_reverification
        clerk_render_reverification(Clerk::StepUp::PRESETS[:moderate]) if clerk_user_needs_reverification?(Clerk::StepUp::PRESETS[:moderate])
      end
    end
    ```
  </Tab>

  <Tab>
    > [!WARNING]
    > `reverificationErrorResponse` and `reverificationError` requires `@clerk/shared@2.17.0` or later, and `@clerk/clerk-js@5.35.0` or later.

    - For a JavaScript or Typescript framework that supports the [Fetch API `Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response), use the `reverificationErrorResponse` to trigger reverification. For example:
      <CodeBlockTabs options={["Astro"]}>
        ```typescript {{ filename: 'src/api/reverification-example.ts' }}
        import type { APIRoute } from 'astro'
        import { reverificationErrorResponse } from '@clerk/shared/authorization-errors'

        export const GET: APIRoute = async ({ locals }) => {
          const { has } = locals.auth()

          // Check if the user has *not* verified their credentials within the past 10 minutes
          const shouldUserRevalidate = !has({ reverification: 'strict' })

          // If the user hasn't reverified, return an error with the matching configuration (e.g. `strict`)
          if (shouldUserRevalidate) {
            return reverificationErrorResponse('strict')
          }

          return new Response('success', { status: 200 })
        }
        ```
      </CodeBlockTabs>
    - For a JavaScript or Typescript framework that provides its own utilities to handle responses, use `reverificationError`. For example:
      <CodeBlockTabs options={["Hono"]}>
        ```typescript {{ filename: 'src/api/hello.ts' }}
        import { Hono } from 'hono'

        const app = new Hono()

        // POST request route
        app.post('/api/hello', async (c) => {
          return c.json(reverificationError('strict'))
        })
        ```
      </CodeBlockTabs>
    - Alternatively, if you're not using JavaScript or TypeScript, you can create a custom helper that returns the following JSON response (it's recommended to use a `403 Forbidden` status code in your response):
      ```json
      {
        "clerk_error": {
          "type": "forbidden",
          "reason": "reverification-error"
        }
      }
      ```
  </Tab>
</Tabs>

### Handle reverification client-side

After setting up reverification on the server-side, you must handle reverification on the client-side so that your users can verify their credentials.

The following example demonstrates how to use the [`useReverification()`](/docs/hooks/use-reverification) hook to detect authorization errors and automatically display a modal that allows the user to verify their identity. Upon successful verification, the previously failed request is automatically retried.

<Tabs items={["Next.js Server Action", "Next.js Route Handler", "React"]}>
  <Tab>
    ```tsx {{ filename: 'app/perform-action/page.tsx' }}
    'use client'

    import { useReverification } from '@clerk/nextjs'
    import { myAction } from '../actions'

    export default function Page() {
      const performAction = useReverification(myAction)

      const handleClick = async () => {
        const myData = await performAction()
        // If `myData` is null, the user cancelled the reverification process
        // You can choose how your app responds. This example returns null.
        if (!myData) return
      }

      return <button onClick={handleClick}>Perform action</button>
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/transfer/page.tsx' }}
    'use client'

    import { useReverification } from '@clerk/nextjs'

    export default function Page({ amount_in_cents }: { amount_in_cents: number }) {
      const transferMoney = useReverification(
        async () =>
          await fetch('/api/reverification-example', {
            method: 'POST',
            body: JSON.stringify({ amount_in_cents }),
          }),
      )

      return <button onClick={transferMoney}>Transfer</button>
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: '/src/components/TransferButton.js' }}
    import { useReverification } from '@clerk/react'

    export function TransferButton({ amount_in_cents }: { amount_in_cents: number }) {
      const transferMoney = useReverification(() =>
        fetch('/api/reverification-example', {
          method: 'POST',
          body: JSON.stringify({ amount_in_cents }),
        }),
      )

      return <button onClick={transferMoney}>Transfer</button>
    }
    ```
  </Tab>
</Tabs>

---
title: Add Slack as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Slack account using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A Slack account is required.",
      link: "https://slack.com/get-started#/createnew",
      icon: "user-circle",
    },
  ]}
/>

Enabling OAuth with [Slack](https://api.slack.com/authentication) allows your users to sign up and sign in to your Clerk app with their Slack account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **Slack**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Slack's API Platform](https://api.slack.com/).

<Steps>
  ### Enable Slack as a social connection in Clerk

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Slack**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Redirect URL** somewhere secure. Keep the modal and page open.

  ### Create a Slack app

  1. In the Slack API Platform, navigate to the [**Your Apps**](https://api.slack.com/apps) page and select **Create New App**.
  1. The **Create an app** modal will open. Depending on your app needs, select either **From a manifest** or **From scratch**. For more information on which to choose, refer to [Slack's doc on manifests](https://api.slack.com/reference/manifests).
  1. After following the respective steps for either option, you'll be redirected to the **App Credentials** page. Save the **Client ID** and **Client Secret** somewhere secure. Keep this page open.
  1. In the sidenav, navigate to the **OAuth & Permissions** page.
  1. Scroll down to the **Redirect URLs** section and select **Add New Redirect URL**. Paste the **Redirect URL** you saved from the Clerk Dashboard. Select **Add**, then select **Save URLs**.

  ### Set the Client ID and Client Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add Spotify as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Spotify account using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A Spotify account is required.",
      link: "https://developer.spotify.com",
      icon: "user-circle",
    },
  ]}
/>

Enabling OAuth with [Spotify](https://developer.spotify.com/documentation/web-api/concepts/authorization) allows your users to sign up and sign in to your Clerk application with their Spotify account.

> [!CAUTION]
> For **development** instances, [Spotify](https://developer.spotify.com/documentation/web-api/concepts/quota-modes) requires users to be added to the app's allowlist in order to use Spotify as a social provider in your Clerk app. If they are not allowlisted, any API requests made with an access token associated with that user and the Spotify app will receive a 403 status code.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Spotify Developer Dashboard](https://developer.spotify.com/).

<Steps>
  ## Enable Spotify as a social connection in Clerk

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Spotify**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Redirect URI** somewhere secure. Keep the modal and page open.

  ## Create a Spotify app

  1. In the top-right of the [Spotify Developer Dashboard](https://developer.spotify.com/), select **Create app**.
  1. Complete the required fields. For **Redirect URIs**, paste the **Redirect URI** that you saved from Clerk Dashboard.
  1. Select **Save**. You'll be redirected to your app's **All Stats** page.
  1. Select **Settings**.
  1. Save the **Client ID** and **Client secret** somewhere secure. To get the **Client secret**, select **View client secret**.

  ## Set the Client ID and Client Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ## Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add TikTok as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their TikTok account using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A TikTok Developer account is required.",
      link: "https://developers.tiktok.com",
      icon: "user-circle",
    }
  ]}
/>

Enabling OAuth with [TikTok](https://developers.tiktok.com/doc/login-kit-manage-user-access-tokens) allows your users to sign up and sign in to your Clerk app with their TikTok account.

## Configure for your development instance

Due to TikTok's requirement to verify URL ownership for all redirect URLs, **TikTok cannot be used with shared credentials in development environments.** This is because individual users can't verify ownership of the Clerk development URL (`accounts.dev`).

However, TikTok can still be used in development environments if you create a sandbox app and configure custom credentials. In this case, there is no need to verify redirect URLs in the [sandbox environment](https://developers.tiktok.com/blog/introducing-sandbox). Instead, you can invite users who are allowed to sign in.

It is recommended to test this integration in a staging or preview environment, as shared credentials require URL verification to function properly.

## Configure for your production instance

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [TikTok Developer Portal](https://developers.tiktok.com/).

<Steps>
  ### Enable TikTok as a social connection in Clerk

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **TikTok**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on. Keep the modal and page open.

  ### Create your app in TikTok

  > [!TIP]
  > If you're creating an app as an organization rather than as an individual developer, you must first [create an organization](https://developers.tiktok.com/organizations). For guidance on which option to choose, refer to [TikTok's guide on working with organizations](https://developers.tiktok.com/doc/working-with-organizations/)**.**

  1. On a separate page, go to the [TikTok Developer Portal](https://developers.tiktok.com/) and sign in.
  1. In the top-right, select [**Developer Portal**](https://developers.tiktok.com/apps), then select **Manage apps**. You'll be redirected to the **Manage apps** page.
  1. Select **Connect an app**. Complete the form then select **Confirm**. You'll be redirected to your **App details** page.
  1. In the **Basic information** section, complete the form.
  1. Select **Verify URL properties** under any of the URL fields to verify your app URL. A modal will open.
  1. Select **Verify properties**. For the property type, select either **Domain** to verify ownership of the enter website, including subdomains, or **URL prefix** to verify ownership of a specific part of the website (e.g., `example.com/shop/`). See [the TikTok guide](https://developers.tiktok.com/doc/getting-started-create-an-app#verify_url_ownership) for more information.
  1. Enter your website and select **Verify**.
  1. Follow the instructions in the modal to verify your domain with your host provider. After entering the necessary information in your hosting provider's DNS settings, select **Verified**. Once your property is verified, select **Ok**.
  1. Select **Submit for review**.
  1. On the **App details** page, select the icons next to the **Client key** and **Client secret** to reveal them. Save these values somewhere secure.

  > [!NOTE]
  > Your app needs to be reviewed by TikTok before the registration completes. This process may take a few days.

  ### Set the Client ID and Client Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add Twitch as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Twitch account with OAuth.
---

<TutorialHero
  beforeYouStart={[
  {
    title: "A Clerk app is required.",
    link: "/docs/quickstarts/setup-clerk",
    icon: "clerk",
  },
  {
    title: "A Twitch account is required.",
    link: "https://www.twitch.tv/signup",
    icon: "user-circle",
  }
]}
/>

Enabling OAuth with [Twitch](https://dev.twitch.tv/docs/api/reference#oauth-client-credentials-flow) allows your users to sign up and sign in to your Clerk application with their Twitch account.

You must have Two-Factor Authentication (2FA) enabled on your Twitch account to setup OAuth. To enable 2FA:

1. In the top-right of the [Twitch Developer console](https://dev.twitch.tv/console), select your avatar and select **Account Settings**.
1. Select the **Security & Privacy** tab.
1. Under **Security**, select **Set Up Two-Factor Authentication**.
1. Select **Enable 2FA**. A modal will open.
1. Enter your phone number and select **Continue**.
1. Enter the code sent to your phone and select **Continue**.
1. If you want to use an authenticator app, follow the instructions on the screen. Otherwise, select **Skip & Use SMS**.
1. Select **Done**.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **Twitch**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Twitch Developer Console](https://dev.twitch.tv/console).

<Steps>
  ### Enable Twitch as a social connection in Clerk

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Twitch**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **OAuth Redirect URL** somewhere secure. Keep the modal and page open.

  ### Create a Twitch Developer app

  1. In the left sidenav of the [Twitch Developer Console](https://dev.twitch.tv/console), select **Applications**.
  1. Select **Register Your Application**. You'll be redirected to the [**Register Your Application**](https://dev.twitch.tv/console/apps/create) page.
  1. Complete the required fields. Under **OAuth Redirect URLs**, paste the **OAuth Redirect URL** you saved from the Clerk Dashboard.
  1. Select **Create**. You'll be redirected to the **Developer Applications** page where you can see your new application listed.
  1. Select **Manage** next to the application you created. You'll be redirected to your app's settings page.
  1. Select **New Secret**. Save the **Client Secret** and **Client ID** somewhere secure.

  ### Set the Client ID and Client Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add X/Twitter v2 as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their X/Twitter account using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: 'A Clerk application is required',
      link: 'https://clerk.com/docs/quickstarts/setup-clerk',
      icon: 'clerk',
    },
    {
      title: 'An X/Twitter developer account is required',
      link: 'https://developer.twitter.com/en/docs/apps/overview',
      icon: 'x',
    },
  ]}
/>

Enabling OAuth with [X/Twitter](https://developer.twitter.com/en/docs/x/overview) allows your users to sign up and sign in to your Clerk app with their X/Twitter account.

Clerk doesn't currently support preconfigured shared OAuth credentials for X/Twitter on development instances. You must provide custom credentials for both development _and_ production instances, which involves generating your own **Client ID** and **Client Secret** using your X/Twitter Developer account.

## Configure for your production instance

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [X/Twitter Developer Portal](https://developer.twitter.com/en/portal/dashboard).

> [!WARNING]
> X/Twitter v2 doesn't currently provide users' email addresses. Users must manually enter their email address when they return to your application after authenticating with X/Twitter.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [X/Twitter Developer Portal](https://developer.twitter.com/en/portal/dashboard).

<Steps>
  ## Enable X/Twitter as a social connection

  To enable X/Twitter as a social connection for your Clerk application:

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select the **Add connection** button, and select **For all users**.
  1. In the **Choose provider** dropdown, select **X/Twitter**.
  1. Save the **Redirect URI** somewhere secure. Keep the modal and page open.

  ## Create an X/Twitter application

  When signing up for a new X/Twitter Developer account, you'll be required to describe your app's use cases. After completing this step, you'll be redirected to the **Dashboard** page. Under **Projects**, you'll see an automatically generated app with a randomly generated string as its name.

  If you want to create a new X/Twitter application, follow these steps:

  1. In the X/Twitter Developer Portal, under [**Projects**](https://developer.twitter.com/en/portal/projects-and-apps), select **Add App**. You'll be redirected to the **App name** tab. If you have a **Free** account, you can only have one app at a time, so you'll need to delete the existing app before being able to create a new one.
  1. Enter your application name and select **Next**. You'll be redirected to the **Keys & Tokens** tab where your app's credentials are displayed. However, these credentials aren't needed to set up the X/Twitter social connection with Clerk, as the setup uses the OAuth 2.0 flow, which relies on different credentials.
  1. Select **App settings**. You'll be redirected to your app's **Settings** tab.
  1. Under **User authentication settings**, next to **User authentication not set up**, select **Set up**. You'll be redirected to the **User authentication settings** page.
  1. Under **App permissions**, choose the permissions you want to request from your user. At minimum, select the **Read** permission.
  1. Under **Type of App**, select **Web App, Automated App or Bot**.
  1. Under **App info**, in the **Callback URI / Redirect URL** field, paste the **Callback URI / Redirect URL** value you copied from the Clerk Dashboard.
  1. Complete any other required fields, such as the **Website URL**.
  1. Select **Save**. You'll be redirected to a page that shows your app's **Client ID** and **Client Secret**. Save these values somewhere secure.

  ## Set the Client ID and Client Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ## Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Add Xero as a social connection
description: Learn how to allow users to sign up and sign in to your Clerk app with their Xero account using OAuth.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "A Xero Developer account is required.",
      link: "https://developer.xero.com/",
      icon: "user-circle",
    }
  ]}
/>

Enabling OAuth with Xero allows your users to sign up and sign in to your Clerk app with their Xero account.

## Configure for your development instance

For _development instances_, Clerk uses preconfigured shared OAuth credentials and redirect URIsno other configuration is needed.

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For all users**.
1. In the **Choose provider** dropdown, select **Xero**.
1. Select **Add connection**.

## Configure for your production instance

For _production instances_, you must provide custom credentials.

To make the setup process easier, it's recommended to keep two browser tabs open: one for the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Xero Developer](https://developer.xero.com) page.

<Steps>
  ### Enable Xero as a social connection

  1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Xero**.
  1. Ensure that both **Enable for sign-up and sign-in** and **Use custom credentials** are toggled on.
  1. Save the **Redirect URI** somewhere secure. Keep this modal and page open.

  ### Create a Xero app

  1. In the top-right of the [Xero Developer](https://developer.xero.com/app/manage/) home page, select **New app**. The **Add a new app** modal will open.
  1. Fill out the necessary information. In the **Redirect URI** field, paste the **Redirect URI** value you saved from the Clerk Dashboard.
  1. Select **Create app**. You'll be redirected to the app's **App details** page.
  1. In the left sidenav, select **Configuration**.
  1. Select **Generate a secret**. Save the **Client ID** and **Client Secret** somewhere secure.

  ### Set the Client ID and Client Secret in the Clerk Dashboard

  <Include src="_partials/authentication/social-connections/set-client-id-secret" />

  ### Test your connection

  <Include src="_partials/authentication/social-connections/test-your-connection" />
</Steps>

---
title: Allowlist identifiers errors
description: An index of Clerk errors related to allowlist identifiers.
type: reference
---

An index of Clerk errors related to allowlist identifiers.

## `AllowlistIdentifierNotFound`

```json
{
  "shortMessage": "Identifier not found",
  "longMessage": "No identifier was found with id <identifierID>",
  "code": "resource_not_found_code"
}
```

## `DuplicateAllowlistIdentifier`

```json
{
  "shortMessage": "duplicate allowlist identifier",
  "longMessage": "the identifier <identifier> already exists",
  "code": "duplicate_record_code"
}
```

---
title: Application errors
description: An index of Clerk errors related to an application.
type: reference
---

An index of Clerk errors related to an application, such as when an application is not found, or when a user tries to perform an action that they are not authorized to do.

## `ApplicationNotFound`

Signifies an error when no application with the given `appID` was found.

```json
{
  "shortMessage": "Application not found",
  "longMessage": "No application was found with id <appID>",
  "code": "resource_not_found_code"
}
```

## <code>NotAuthorizedToDelete<wbr />SystemApplication</code>

Signifies an error when a user tries to delete a system application that they are not authorized to delete.

```json
{
  "shortMessage": "Unauthorized request",
  "longMessage": "You are not authorized to delete system application <applicationID>",
  "code": "authorization_invalid_code"
}
```

## <code>NotAuthorizedToMove<wbr />ApplicationToOrganization</code>

Signifies an error when trying to move an application to an organization that the requesting user does not belong to.

```json
{
  "shortMessage": "unauthorized request",
  "longMessage": "You need to be a member of organization <OrgID>, in order to move application <AppID>.",
  "code": "authorization_invalid_code"
}
```

## <code>ApplicationAlready<wbr />BelongsToOrganization</code>

```json
{
  "shortMessage": "already belongs to organization",
  "longMessage": "Application already belongs to the selected organization.",
  "code": "application_already_belongs_to_organization_code"
}
```

## <code>ApplicationAlready<wbr />BelongsToUser</code>

```json
{
  "shortMessage": "already belongs to user",
  "longMessage": "Application already belongs to the given user.",
  "code": "application_already_belongs_to_user_code"
}
```

## `InvalidPlanForResource`

Returned when an invalid plan is selected for a resource.

```json
{
  "shortMessage": "Invalid plan",
  "longMessage": "Plan <planID> can't be selected for <resourceType> <resourceID>",
  "code": "invalid_plan"
}
```

## <code>CannotTransferPaidApp<wbr />ToAccountWithout<wbr />BillingInformation</code>

```json
{
  "shortMessage": "cannot transfer paid application, missing billing info",
  "longMessage": "Paid applications can only be transferred to personal workspaces or organizations with billing info. Add the necessary billing info and try again.",
  "code": "transfer_paid_app_to_free_account_code"
}
```

- [Learn how to fix this error](/docs/organizations/organization-workspaces#transfer-ownership-of-an-application).

## <code>CannotTransferToAccount<wbr />WithoutPaymentMethod</code>

```json
{
  "shortMessage": "cannot transfer paid application, missing payment method",
  "longMessage": "The selected account doesn't have any payment methods associated with it.",
  "code": "transfer_paid_app_to_account_with_no_payment_method_code"
}
```

- [Learn how to fix this error](/docs/organizations/organization-workspaces#transfer-ownership-of-an-application).

---
title: Astro hybrid rendering
description: Clerk's Astro SDK supports Astro's on-demand rendering output modes (`server` and `hybrid`).
---

Astro's on-demand rendering output modes (`server` and `hybrid`) allow you to pre-render certain pages while keeping others server-rendered. The Clerk Astro SDK supports these output modes out-of-the-box; no additional configuration is required. However, you may need to make some adjustments to your code to ensure that the [control components](/docs/components/overview#control-components) are rendered correctly in hybrid mode.

## Server output mode

In `server` output mode, pages and control components are server-rendered by default, but you can opt-in to pre-rendering specific pages by adding `export const prerender = true` to the page. When you opt-in to pre-rendering a page, you must add `isStatic={true}` to any control components used on that page. This specifies that the component should use the client-side version, which relies on [client nanostores](/docs/references/astro/auth-store).

The following example shows how to opt-in to pre-rendering a page and specify that the control components used on that page should use the client-side version.

```astro {{ filename: 'src/pages/index.astro' }}
---
export const prerender = true
---

<SignedIn isStatic={true}> You are signed in! </SignedIn>
```

## Hybrid output mode

In `hybrid` output mode, pages and control components are pre-rendered by default, but you can opt-out of pre-rendering for specific pages by adding `export const prerender = false`. When you opt-out of pre-rendering a page, you must add the `isStatic={false}` prop to any control components used on that page. This specifies that the component should use the server-side version which relies on the [locals](/docs/references/astro/locals) injected by the middleware.

The following example shows how to opt-out of pre-rendering a page and specify that the control components used on that page should use the server-side version.

```astro {{ filename: 'src/pages/index.astro' }}
---
export const prerender = false
---

<SignedIn isStatic={false}> You are signed in! </SignedIn>
```

## Styling considerations

If you pass `isStatic={true}` to a control component and you want to style the component, be aware that the component is wrapped in a custom element.

For example, say you were trying to align the content inside a `<SignedIn>` component using `flex`, as shown in the following code:

```jsx
<div className="flex items-center">
  <SignedIn isStatic={true}>
    <span>You are signed in!</span>
  </SignedIn>
  <span>This content is always visible.</span>
</div>
```

It would be rendered as:

```html {{ mark: [2, 4] }}
<div className="flex items-center">
  <clerk-signed-in>
    <span>You are signed in!</span>
  </clerk-signed-in>
  <span>This content is always visible.</span>
</div>
```

The `clerk-signed-in` wrapper wouldn't be a flex item by default, potentially misaligning the content. To fix this, you would need to apply flex properties to the `<SignedIn>` component itself by using a selector, as shown in the following example:

```jsx {{ mark: [2] }}
<div class="flex items-center">
  <SignedIn isStatic={true} class="flex items-center">
    <span>User</span>
  </SignedIn>
  <span>Always visible</span>
</div>
```

---
title: Astro Quickstart
description: Add authentication and user management to your Astro app with Clerk.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Create an Astro application",
      link: "https://docs.astro.build/en/install-and-setup",
      icon: "astro",
    },
  ]}
  exampleRepo={[
    {
      title: "Astro Quickstart Repo",
      link: "https://github.com/clerk/clerk-astro-quickstart"
    }
  ]}
/>

<Steps>
  ## Install `@clerk/astro`

  The [Clerk Astro SDK](/docs/references/astro/overview) provides a set of components, hooks, and stores that make it easy to build authentication and user management features in your Astro app.

  Run the following command to install the SDK:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/astro
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/astro
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/astro
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @clerk/astro
    ```
  </CodeBlockTabs>

  ## Set your Clerk API keys

  <SignedIn>
    Add the following keys to your `.env` file. These keys can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
  </SignedIn>

  <SignedOut>
    1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
    1. In the **Quick Copy** section, copy your Clerk Publishable and Secret Keys.
    1. Paste your keys into your `.env` file.

    The final result should resemble the following:
  </SignedOut>

  ```env {{ filename: '.env' }}
  PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
  CLERK_SECRET_KEY={{secret}}
  ```

  ## Update `astro.config.mjs`

  To configure Clerk in your Astro app, you will need to update your `astro.config.mjs`.

  - Add the Clerk integration to the `integrations` list.
  - Install an [SSR adapter](https://docs.astro.build/en/guides/server-side-rendering/#official-adapters). This quickstart uses the [`@astrojs/node`](https://docs.astro.build/en/guides/integrations-guide/node/) adapter.
  - Set `output` to `server`. This is required when deploying to a host supporting SSR.

  ```ts {{ filename: 'astro.config.mjs', mark: [2, 3, [6, 8]] }}
  import { defineConfig } from 'astro/config'
  import node from '@astrojs/node'
  import clerk from '@clerk/astro'

  export default defineConfig({
    integrations: [clerk()],
    adapter: node({ mode: 'standalone' }),
    output: 'server',
  })
  ```

  ## Add `clerkMiddleware()` to your app

  [`clerkMiddleware()`](/docs/references/astro/clerk-middleware) grants you access to user authentication state throughout your app, on any route or page. It also allows you to protect specific routes from unauthenticated users. To add `clerkMiddleware()` to your app, follow these steps:

  1. Create a `middleware.ts` file.
     - If you're using the `/src` directory, create `middleware.ts` in the `/src` directory.
     - If you're not using the `/src` directory, create `middleware.ts` in the root directory alongside `.env`.
  1. In your `middleware.ts` file, export an `onRequest` constant and assign the result of the `clerkMiddleware()` function to it.
     ```tsx {{ filename: 'src/middleware.ts' }}
     import { clerkMiddleware } from '@clerk/astro/server'

     export const onRequest = clerkMiddleware()
     ```
  1. By default, `clerkMiddleware()` will not protect any routes. All routes are public and you must opt-in to protection for routes. See the [`clerkMiddleware()` reference](/docs/references/astro/clerk-middleware) to learn how to require authentication for specific routes.

  ## Add Clerk components to your app

  You can control which content signed-in and signed-out users can see with Clerk's [prebuilt control components](/docs/components/overview#control-components). Create a header using the following components:

  - [`<SignedIn>`](/docs/components/control/signed-in): Children of this component can only be seen while **signed in**.
  - [`<SignedOut>`](/docs/components/control/signed-out): Children of this component can only be seen while **signed out**.
  - [`<UserButton />`](/docs/components/user/user-button): Shows the signed-in user's avatar. Selecting it opens a dropdown menu with account management options.
  - [`<SignInButton />`](/docs/components/unstyled/sign-in-button): An unstyled component that links to the sign-in page. In this example, since no props or [environment variables](/docs/deployments/clerk-environment-variables) are set for the sign-in URL, this component links to the [Account Portal sign-in page](/docs/account-portal/overview#sign-in).

  ```astro {{ filename: 'src/layouts/SiteLayout.astro' }}
  ---
  import { SignedIn, SignedOut, UserButton, SignInButton } from '@clerk/astro/components'

  const { title } = Astro.props
  ---

  <html lang="en">
    <head>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
      <meta name="generator" content={Astro.generator} />
    </head>
    <body>
      <header>
        <h1>{title}</h1>
        <nav>
          <SignedOut>
            <SignInButton mode="modal" />
          </SignedOut>
          <SignedIn>
            <UserButton />
          </SignedIn>
        </nav>
      </header>
      <article>
        <slot />
      </article>
    </body>
  </html>
  ```

  Then, use the layout on your homepage:

  ```astro {{ filename: 'src/pages/index.astro' }}
  ---
  import SiteLayout from '../layouts/SiteLayout.astro'
  ---

  <SiteLayout title="Clerk + Astro">
    <p>Sign in to try Clerk out!</p>
  </SiteLayout>
  ```

  ## Create your first user

  Run your project with the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun dev
    ```
  </CodeBlockTabs>

  Now visit your app's homepage at [`http://localhost:4321`](http://localhost:4321). Sign up to create your first user.
</Steps>

## Next steps

<Cards>
  - [Protect routes using Clerk Middleware](/docs/references/astro/clerk-middleware)
  - Learn how to protect specific routes from unauthenticated users.

  ---

  - [Read session and user data](/docs/references/astro/read-session-data)
  - Learn how to use Clerk's stores and helpers to access the active session and user data in your Astro app.

  ---

  - [Clerk + Astro Quickstart Repo](https://github.com/clerk/clerk-astro-quickstart)
  - The official companion repo for Clerk's Astro Quickstart.
</Cards>

---
title: Auth object
description: The Auth object contains information about the current user's session.
---

The `Auth` object contains important information like the current user's session ID, user ID, and organization ID. It also contains methods to check for permissions and retrieve the current user's session token.

## How to access the `Auth` object

<Include src="_partials/auth-object-table" />

## Properties

<Properties>
  - `sessionId`
  - `string`

  The ID of the current session.

  ---

  - `userId`
  - `string`

  The ID of the current user.

  ---

  - `orgId`
  - `string | undefined`

  The ID of the user's active organization.

  ---

  - `orgRole`
  - <code>[OrganizationCustomRoleKey](/docs/references/javascript/types/organization-custom-role-key) | undefined</code>

  The current user's role in their active organization.

  ---

  - `orgSlug`
  - `string | undefined`

  The URL-friendly identifier of the user's active organization.

  ---

  - `orgPermissions`
  - <code>[OrganizationCustomPermissionKey](/docs/references/javascript/types/organization-custom-permission-key)\[] | undefined</code>

  The current user's active organization permissions.

  ---

  - `sessionClaims`
  - `JwtPayload`

  The current user's [session claims](/docs/backend-requests/resources/session-tokens).

  ---

  - `actor`
  - `ActClaim | undefined`

  Holds identifier for the user that is impersonating the current user. Read more about [impersonation](/docs/users/user-impersonation).

  ---

  - [`has()`](#has)
  - <code>(isAuthorizedParams: [CheckAuthorizationParamsWithCustomPermissions](#check-authorization-params-with-custom-permissions)) => boolean</code>

  A function that checks if the user has an organization role or custom permission.

  ---

  - `factorVerificationAge`
  - `[number, number] | null`

  An array where each item represents the number of minutes since the last verification of a first or second factor: `[firstFactorAge, secondFactorAge]`.

  ---

  - [`getToken()`](#get-token)
  - `ServerGetToken`

  A function that gets the current user's [session token](/docs/backend-requests/resources/session-tokens) or a [custom JWT template](/docs/backend-requests/jwt-templates).

  ---

  - `debug`
  - `AuthObjectDebug`

  Used to help debug issues when using Clerk in development.
</Properties>

### `has()`

`has()` determines if the user _has_ a role or permission and returns a boolean value.

```ts
function has(isAuthorizedParams: CheckAuthorizationParamsWithCustomPermissions): boolean
```

#### `CheckAuthorizationParamsWithCustomPermissions`

`CheckAuthorizationParamsWithCustomPermissions` has the following properties:

<Properties>
  - `role`
  - `string`

  The role to check for.

  ---

  - `permission`
  - `string`

  The permission to check for.

  ---

  - `reverification?`
  - <code>[ReverificationConfig](#reverification-config)</code>

  The reverification configuration to check for. This feature is currently in public beta. **It is not recommended for production use**.
</Properties>

##### `ReverificationConfig`

```ts
type ReverificationConfig =
  | SessionVerificationTypes
  | {
      level: SessionVerificationLevel
      afterMinutes: SessionVerificationAfterMinutes
    }

type SessionVerificationTypes = 'strict_mfa' | 'strict' | 'moderate' | 'lax'
```

The `ReverificationConfig` type has the following properties:

<Properties>
  - `strict_mfa`

  Requires the user to verify their credentials within the past 10 minutes. If not verified, prompt for both the first and second factors.

  ---

  - `strict`

  Requires the user to verify their credentials within the past 10 minutes. If not verified, prompt for the second factor.

  ---

  - `moderate`

  Requires the user to verify their credentials within the past hour. If not verified, prompt for the second factor.

  ---

  - `lax`

  Requires the user to verify their credentials within the past day. If not verified, prompt for the second factor.

  ---

  - `level`
  - `"first_factor" | "second_factor" | "multi_factor"`

  The reverification level of credentials to check for.

  ---

  - `afterMinutes`
  - `number`

  The age of the factor level to check for. Value should be greater than or equal to 1 and less than 99,999.
</Properties>

#### `has()` authorization example

You can use `has()` to check if a user is authorized to access a component.

<Include src="_partials/has-warning" />

In the following example, `has()` is used to check if the user has the `org:team_settings:manage` permission. If the user doesn't have the permission, `null` is returned and the page isn't rendered. This example is written for Next.js App Router, but can be adapted to other frameworks by using the appropriate method for accessing the `Auth` object.

```tsx {{ filename: 'app/page.tsx' }}
import { auth } from '@clerk/nextjs/server'

export default async function Page() {
  const { has } = await auth()

  const canManage = has({ permission: 'org:team_settings:manage' })

  if (!canManage) return null

  return <h1>Team Settings</h1>
}
```

#### `has()` reverification example

> [!IMPORTANT]
> This example demonstrates how to handle reverification **server-side**. For information on how to handle reverification on the **client-side**, see the [guide on reverification](/docs/guides/reverification).

You can use `has()` to check if a user has verified their credentials within a certain time frame.

<Include src="_partials/nextjs/reverification-route-handler" />

### `getToken()`

`getToken()` retrieves the current user's [session token](/docs/backend-requests/resources/session-tokens) or a [custom JWT template](/docs/backend-requests/jwt-templates).

> [!NOTE]
> Providing a `template` will perform a network request and will count towards [rate limits](/docs/backend-requests/resources/rate-limits#backend-api-requests).

```typescript
const getToken: ServerGetToken

type ServerGetToken = (options?: ServerGetTokenOptions) => Promise<string | null>

type ServerGetTokenOptions = {
  template?: string // The name of the custom JWT template to retrieve.
}
```

#### Use `getToken()` in the frontend

The `Auth` object is not available in the frontend. To use the `getToken()` method in the frontend:

- For React-based applications, you can use the `useAuth()` hook. See the [reference documentation](/docs/hooks/use-auth#how-to-use-the-use-auth-hook) for example usage.
- For JavaScript applications, see the [reference documentation](/docs/references/javascript/session#get-token) for example usage.

#### Use `getToken()` in the backend

<Tabs items={["Next.js", "Tanstack React Start", "Express", "Remix"]}>
  <Tab>
    To use the `getToken()` method in the backend:

    - In App Router applications, use the [`auth()`](/docs/references/nextjs/auth) helper.
    - In Pages Router applications, use the [`getAuth()`](/docs/references/nextjs/get-auth) helper.

    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```js {{ filename: 'app/api/get-token-example/route.ts' }}
      import { auth } from '@clerk/nextjs/server'

      export async function GET() {
        const { getToken } = await auth()

        const template = 'supabase'

        const token = await getToken({ template })

        return Response.json({ token })
      }
      ```

      ```ts {{ filename: 'pages/api/getToken.ts' }}
      import { getAuth } from '@clerk/nextjs/server'
      import type { NextApiRequest, NextApiResponse } from 'next'

      export default async function handler(req: NextApiRequest, res: NextApiResponse) {
        const { getToken } = getAuth(req)

        const template = 'test'

        const token = await getToken({ template })

        return res.json({ token })
      }
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    ```ts {{ filename: 'app/routes/api/example.ts' }}
    import { getAuth } from '@clerk/tanstack-react-start/server'
    import { json } from '@tanstack/react-start'
    import { createAPIFileRoute } from '@tanstack/react-start/api'

    export const Route = createAPIFileRoute('/api/example')({
      GET: async ({ req, params }) => {
        const { userId, getToken } = await getAuth(req)

        if (!userId) {
          return json({ error: 'Unauthorized' }, { status: 401 })
        }

        const token = await getToken({ template: 'supabase' })

        // Add logic that retrieves the data
        // from your database using the token

        return json({
          // ...
        })
      },
    })
    ```
  </Tab>

  <Tab>
    To use the `getToken()` method in the backend, you can access it using the `Auth` object returned by the `request` object.

    ```js {{ filename: 'getToken.ts' }}
    app.get('/api/get-token', async (req, res) => {
      const getToken = req.auth.getToken

      const template = 'test'

      const token = await getToken({ template })

      res.json({ token })
    })
    ```
  </Tab>

  <Tab>
    To use the `getToken()` method in the backend, you can access it using the [`getAuth()`](/docs/references/nextjs/get-auth) function.

    ```ts {{ filename: 'app/routes/get-token.ts' }}
    import { getAuth } from '@clerk/remix/ssr.server'
    import { ActionFunction, json } from '@remix-run/node'

    export const action: ActionFunction = async (req) => {
      const { getToken } = await getAuth(req)

      const template = 'test'

      const token = await getToken({ template })

      return json({ token })
    }
    ```
  </Tab>
</Tabs>

## `Auth` object example without active organization

The following is an example of the `Auth` object without an active organization. Notice that there is no `o` claim. Read more about token claims in the [guide on session tokens](/docs/backend-requests/resources/session-tokens).

<Tabs items={["Version 2", "Version 1"]}>
  <Tab>
    > [!IMPORTANT]
    > This example is for version 2 of Clerk's session token. To see an example of version 1, select the respective tab above.

    ```js {{ prettier: false }}
    {
      azp: 'http://localhost:3000',
      email: 'email@example.com',
      exp: 1744735488,
      fva: [ 9, -1 ],
      iat: 1744735428,
      iss: 'https://renewing-bobcat-00.clerk.accounts.dev',
      jti: 'aee4d4a5071bdd66e21b',
      nbf: 1744735418,
      role: 'authenticated',
      sid: 'sess_123',
      sub: 'user_123',
      v: 2
    }
    ```
  </Tab>

  <Tab>
    > [!IMPORTANT]
    > Version 1 of Clerk's session token was deprecated on April 14, 2025. To upgrade to version 2, go to the [**Updates**](https://dashboard.clerk.com/last-active?path=updates) page in the Clerk Dashboard.

    ```js {{ prettier: false }}
    {
      sessionId: 'sess_123',
      userId: 'user_123',
      orgId: null,
      orgRole: null,
      orgSlug: null,
      orgPermissions: null,
      has: [Function (anonymous)],
      getToken: [AsyncFunction (anonymous)],
      claims: {
        azp: 'http://localhost:3000',
        exp: 1666622607,
        iat: 1666622547,
        iss: 'https://renewing-bobcat-00.clerk.accounts.dev',
        nbf: 1666622537,
        sid: 'sess_123',
        sub: 'user_123',
      },
    }
    ```
  </Tab>
</Tabs>

## `Auth` object example with active organization

The following is an example of the `Auth` object with an active organization. Notice the addition of the `o` claim. Read more about token claims in the [guide on session tokens](/docs/backend-requests/resources/session-tokens).

<Tabs items={["Version 2", "Version 1"]}>
  <Tab>
    > [!IMPORTANT]
    > This example is for version 2 of Clerk's session token. To see an example of version 1, select the respective tab above.

    ```js {{ prettier: false }}
    {
      azp: 'http://localhost:3000',
      email: 'email@example.com',
      exp: 1744734948,
      fea: 'o:example-feature',
      fva: [ 0, -1 ],
      iat: 1744734888,
      iss: 'https://renewing-bobcat-00.clerk.accounts.dev',
      jti: '004f0096e5cd44911924',
      nbf: 1744734878,
      o: {
        fpm: '1',
        id: 'org_123',
        per: 'example-perm',
        rol: 'admin',
        slg: 'example-org'
      },
      role: 'authenticated',
      sid: 'sess_123',
      sub: 'user_123',
      v: 2
    }
    ```
  </Tab>

  <Tab>
    > [!IMPORTANT]
    > Version 1 of Clerk's session token was deprecated on April 14, 2025. To upgrade to version 2, go to the [**Updates**](https://dashboard.clerk.com/last-active?path=updates) page in the Clerk Dashboard.

    ```js {{ prettier: false }}
    {
      sessionId: 'sess_123',
      userId: 'user_123',
      orgId: 'org_123',
      orgRole: 'org:admin',
      orgSlug: undefined,
      orgPermissions: ['org:example-feature:example-perm'], // Custom permissions
      has: [Function (anonymous)],
      getToken: [AsyncFunction (anonymous)],
      claims: {
        azp: 'http://localhost:3000',
        exp: 1666622607,
        iat: 1666622547,
        iss: 'https://renewing-bobcat-00.clerk.accounts.dev',
        nbf: 1666622537,
        sid: 'sess_123',
        sub: 'user_123',
      },
    }
    ```
  </Tab>
</Tabs>

## `Auth` object example with valid factor age

The following is an example of the `Auth` object with a valid factor age. Notice the addition of the `fva` claim with a value of `[0, 0]`, indicating that the first and second factors have been verified within the past minute. Read more about token claims in the [guide on session tokens](/docs/backend-requests/resources/session-tokens).

<Tabs items={["Version 2", "Version 1"]}>
  <Tab>
    > [!IMPORTANT]
    > This example is for version 2 of Clerk's session token. To see an example of version 1, select the respective tab above.

    ```js {{ mark: [5], prettier: false }}
    {
      azp: 'http://localhost:3000',
      email: 'email@example.com',
      exp: 1744735488,
      fva: [ 0,0 ],
      iat: 1744735428,
      iss: 'https://renewing-bobcat-00.clerk.accounts.dev',
      jti: 'aee4d4a5071bdd66e21b',
      nbf: 1744735418,
      role: 'authenticated',
      sid: 'sess_123',
      sub: 'user_123',
      v: 2
    }
    ```
  </Tab>

  <Tab>
    > [!IMPORTANT]
    > Version 1 of Clerk's session token was deprecated on April 14, 2025. To upgrade to version 2, go to the [**Updates**](https://dashboard.clerk.com/last-active?path=updates) page in the Clerk Dashboard.

    ```js {{ mark: [8], prettier: false }}
    {
      sessionId: 'sess_123',
      userId: 'user_123',
      orgId: null,
      orgRole: null,
      orgSlug: null,
      orgPermissions: null,
      factorVerificationAge: [0,0],
      has: [Function (anonymous)],
      getToken: [AsyncFunction (anonymous)],
      claims: {
        azp: 'http://localhost:3000',
        exp: 1666622607,
        iat: 1666622547,
        iss: 'https://renewing-bobcat-00.clerk.accounts.dev',
        nbf: 1666622537,
        sid: 'sess_123',
        sub: 'user_123',
      },
    }
    ```
  </Tab>
</Tabs>

## `Auth` object example of a user without an MFA method registered

The following is an example of the `Auth` object of a user without an MFA method registered. Notice the addition of the `fva` claim, but the value is `[0, -1]`. `0` indicates that the first factor has been verified within the past minute, and `-1` indicates that there is no second factor registered for the user. Read more about token claims in the [guide on session tokens](/docs/backend-requests/resources/session-tokens).

<Tabs items={["Version 2", "Version 1"]}>
  <Tab>
    > [!IMPORTANT]
    > This example is for version 2 of Clerk's session token. To see an example of version 1, select the respective tab above.

    ```js {{ mark: [5], prettier: false }}
    {
      azp: 'http://localhost:3000',
      email: 'email@example.com',
      exp: 1744735488,
      fva: [ 0,-1 ],
      iat: 1744735428,
      iss: 'https://renewing-bobcat-00.clerk.accounts.dev',
      jti: 'aee4d4a5071bdd66e21b',
      nbf: 1744735418,
      role: 'authenticated',
      sid: 'sess_123',
      sub: 'user_123',
      v: 2
    }
    ```
  </Tab>

  <Tab>
    > [!IMPORTANT]
    > Version 1 of Clerk's session token was deprecated on April 14, 2025. To upgrade to version 2, go to the [**Updates**](https://dashboard.clerk.com/last-active?path=updates) page in the Clerk Dashboard.

    ```js {{ mark: [8], prettier: false }}
    {
      sessionId: 'sess_123',
      userId: 'user_123',
      orgId: null,
      orgRole: null,
      orgSlug: null,
      orgPermissions: null,
      factorVerificationAge: [0, -1],
      has: [Function (anonymous)],
      getToken: [AsyncFunction (anonymous)],
      claims: {
        azp: 'http://localhost:3000',
        exp: 1666622607,
        iat: 1666622547,
        iss: 'https://renewing-bobcat-00.clerk.accounts.dev',
        nbf: 1666622537,
        sid: 'sess_123',
        sub: 'user_123',
        },
      }
    ```
  </Tab>
</Tabs>

---
title: Authentication across different domains
description: Learn how to share sessions across different domains by adding satellite domains to your application.
---

> [!WARNING]
> This guide addresses authentication across different domains with shared sessions. For example, `example-site.com` and `example-site-admin.com`.
>
> [Authentication across subdomains](/docs/deployments/overview#authentication-across-subdomains) with shared sessions works by default with Clerk.

Clerk supports sharing sessions across different domains by adding one or many satellite domains to an application.

Your "primary" domain is where the authentication state lives, and satellite domains are able to securely read that state from the primary domain, enabling a seamless authentication flow across domains.

Users must complete both the sign-in and sign-up flows on the primary domain by using the [`<SignIn />`](/docs/components/authentication/sign-in) component or [`useSignIn()`](/docs/hooks/use-sign-in) hook for sign-in and [`<SignUp />`](/docs/components/authentication/sign-up) component or [`useSignUp()`](/docs/hooks/use-sign-up) hook for sign-up.

To access authentication state from a satellite domain, users will be transparently redirected to the primary domain. If users need to sign in, they must be redirected to a sign in flow hosted on the primary domain, then redirected back to the originating satellite domain. The same redirection process applies to sign-up flows.

## How to add satellite domains

> [!WARNING]
> This feature is not available in production for free plans, though you can try it out free in development to see if it works for you. See the [pricing](/pricing){{ target: '_blank' }} page for more information.

<Steps>
  ### Create your application and install Clerk

  > [!WARNING]
  > Currently, multi-domain can be added to any Next.js or Remix application. For other React frameworks, multi-domain is still supported as long as you do not use server rendering or hydration.

  To get started, you need to create an application from the [Clerk Dashboard](https://dashboard.clerk.com/). Once you create an instance via the Clerk Dashboard, you will be prompted to choose a domain. This is your primary domain. For the purposes of this guide:

  - In production, the primary domain will be `primary.dev`
  - In development, the primary domain will be `localhost:3000`.

  When building your sign-in flow, you must configure it to run within your primary application, e.g. on `/sign-in`.

  > [!NOTE]
  > For more information about creating your application, see the [setup guide](/docs/quickstarts/setup-clerk).

  ### Add your first satellite domain

  To add a satellite domain:

  1. In the Clerk Dashboard, navigate to the [**Domains**](https://dashboard.clerk.com/last-active?path=domains) page.
  1. Select the **Satellites** tab.
  1. Select the **Add satellite domain** button and follow the instructions provided.

  For the purposes of this guide:

  - In production, the satellite domain will be `satellite.dev`.
  - In development, the satellite domain will be `localhost:3001`.

  ### Configure your satellite app

  There are two ways that you can configure your Clerk satellite application to work with the primary domain:

  - Using environment variables
  - Using properties

  Use the following tabs to select your preferred method. Clerk recommends using environment variables.

  <Tabs items={["Environment variables", "Properties"]}>
    <Tab>
      You can configure your satellite application by setting the following environment variables:

      > [!NOTE]
      > In development, your Publishable and Secret Keys will start with `pk_test_` and `sk_test` respectively.

      - In the `.env` file associated with your primary domain:

        <CodeBlockTabs options={["Next.js", "Remix"]}>
          ```env {{ filename: '.env' }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
          CLERK_SECRET_KEY={{secret}}
          NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
          NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
          ```

          ```env {{ filename: '.env' }}
          CLERK_PUBLISHABLE_KEY={{pub_key}}
          CLERK_SECRET_KEY={{secret}}
          CLERK_SIGN_IN_URL=/sign-in
          ```
        </CodeBlockTabs>
      - In the `.env` file associated with your other (satellite) domain:

        <CodeBlockTabs options={["Next.js", "Remix"]}>
          ```env {{ filename: '.env' }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
          CLERK_SECRET_KEY={{secret}}
          NEXT_PUBLIC_CLERK_IS_SATELLITE=true
          # Production example:
          NEXT_PUBLIC_CLERK_DOMAIN=satellite.dev
          NEXT_PUBLIC_CLERK_SIGN_IN_URL=https://primary.dev/sign-in
          NEXT_PUBLIC_CLERK_SIGN_UP_URL=https://primary.dev/sign-up

          # Development example:
          # NEXT_PUBLIC_CLERK_DOMAIN=http://localhost:3001
          # NEXT_PUBLIC_CLERK_SIGN_IN_URL=http://localhost:3000/sign-in
          # NEXT_PUBLIC_CLERK_SIGN_UP_URL=http://localhost:3000/sign-up
          ```

          ```env {{ filename: '.env' }}
          CLERK_PUBLISHABLE_KEY={{pub_key}}
          CLERK_SECRET_KEY={{secret}}
          CLERK_IS_SATELLITE=true
          # Production example:
          CLERK_DOMAIN=satellite.dev
          CLERK_SIGN_IN_URL=https://primary.dev/sign-in
          CLERK_SIGN_UP_URL=https://primary.dev/sign-up

          # Development example:
          # CLERK_DOMAIN=http://localhost:3001
          # CLERK_SIGN_IN_URL=http://localhost:3000/sign-in
          # CLERK_SIGN_UP_URL=http://localhost:3000/sign-up
          ```
        </CodeBlockTabs>
      - You will also need to add the `allowedRedirectOrigins` property to `<ClerkProvider>` on your _primary domain app_ to ensure that the redirect back from primary to satellite domain works correctly. For example:

        <CodeBlockTabs options={["Development", "Production"]}>
          ```tsx {{ filename: 'app/layout.tsx' }}
          import { ClerkProvider } from '@clerk/nextjs'

          export default function RootLayout({ children }: { children: React.ReactNode }) {
            return (
              <html lang="en">
                <body>
                  <ClerkProvider allowedRedirectOrigins={['http://localhost:3001']}>{children}</ClerkProvider>
                </body>
              </html>
            )
          }
          ```

          ```tsx {{ filename: 'app/layout.tsx' }}
          import { ClerkProvider } from '@clerk/nextjs'

          export default function RootLayout({ children }: { children: React.ReactNode }) {
            return (
              <html lang="en">
                <body>
                  <ClerkProvider allowedRedirectOrigins={['https://satellite.dev']}>{children}</ClerkProvider>
                </body>
              </html>
            )
          }
          ```
        </CodeBlockTabs>
    </Tab>

    <Tab>
      You can configure your satellite application by setting the following properties:

      - `isSatellite` - Defines the app as a satellite app when `true`.
      - `domain` - Sets the domain of the satellite application. This is required since we cannot figure this out by your Publishable Key, since it is the same for all of your multi-domain apps.
      - `signInUrl` - This url will be used when signing in on your satellite application and needs to point to your primary application. This option is optional for production instances and required for development instances.
      - `signUpUrl` - This url will be used for signing up on your satellite application and needs to point to your primary application. This option is optional for production instances and required for development instances.
      - `allowedRedirectOrigins` - This is a list of origins that are allowed to redirect back to from the primary domain.

      > [!TIP]
      > The `URL` parameter that can be passed to `isSatellite` and `domain` is the request url for server-side usage or the current location for client usage.

      <Tabs items={["Next.js", "Remix"]}>
        <Tab>
          In a Next.js application, you must set the properties in the [`<ClerkProvider>`](/docs/components/clerk-provider) component _and_ in your [`clerkMiddleware()`](/docs/references/nextjs/clerk-middleware).

          - In the Next project associated with your primary domain, only the `signInUrl` prop needs to be configured as shown in the following example:

            > [!IMPORTANT]
            > You should set your `CLERK_PUBLISHABLE_KEY` and `CLERK_SECRET_KEY` in your environment variables even if you're using props to configure satellite domains.

            <CodeBlockTabs options={["App Router", "Pages Router"]}>
              ```tsx {{ filename: 'app/layout.tsx' }}
              import { ClerkProvider } from '@clerk/nextjs'

              export default function RootLayout({ children }: { children: React.ReactNode }) {
                const primarySignInUrl = '/sign-in'
                const primarySignUpUrl = '/sign-up'
                const satelliteUrl = 'https://satellite.dev'

                return (
                  <html lang="en">
                    <body>
                      <ClerkProvider
                        signInUrl={primarySignInUrl}
                        signUpUrl={primarySignUpUrl}
                        allowedRedirectOrigins={[satelliteUrl]}
                      >
                        <p>Satellite Next.js app</p>
                        {children}
                      </ClerkProvider>
                    </body>
                  </html>
                )
              }
              ```

              ```jsx {{ filename: '_app.tsx' }}
              import { ClerkProvider } from '@clerk/nextjs'
              import Head from 'next/head'

              export default function App({ Component, pageProps }) {
                const primarySignInUrl = '/sign-in'
                const primarySignUpUrl = '/sign-up'
                const satelliteUrl = 'https://satellite.dev'

                return (
                  <ClerkProvider
                    signInUrl={primarySignInUrl}
                    signUpUrl={primarySignUpUrl}
                    allowedRedirectOrigins={[satelliteUrl]}
                    {...pageProps}
                  >
                    <Head>
                      <title>Satellite Next.js app</title>
                      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                    </Head>
                    <Component {...pageProps} />
                  </ClerkProvider>
                )
              }
              ```
            </CodeBlockTabs>

          - In the Next project associated with your satellite domain, configure your `<ClerkProvider>` as shown in the following example:

            <CodeBlockTabs options={["App Router", "Pages Router"]}>
              ```tsx {{ filename: 'app/layout.tsx' }}
              import { ClerkProvider } from '@clerk/nextjs'

              export default function RootLayout({ children }: { children: React.ReactNode }) {
                const primarySignInUrl = 'https://primary.dev/sign-in'
                const primarySignUpUrl = 'https://primary.dev/sign-up'
                // Or, in development:
                // const primarySignInUrl = 'http:localhost:3000/sign-in';
                // const primarySignUpUrl = 'http:localhost:3000/sign-up';

                return (
                  <html lang="en">
                    <body>
                      <ClerkProvider
                        isSatellite
                        domain={(url) => url.host}
                        signInUrl={primarySignInUrl}
                        signUpUrl={primarySignUpUrl}
                      >
                        <title>Satellite Next.js app</title>
                        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                        {children}
                      </ClerkProvider>
                    </body>
                  </html>
                )
              }
              ```

              ```jsx {{ filename: '_app.tsx' }}
              import { ClerkProvider } from '@clerk/nextjs'
              import Head from 'next/head'

              export default function App({ Component, pageProps }) {
                const primarySignInUrl = 'https://primary.dev/sign-in'
                const primarySignUpUrl = 'https://primary.dev/sign-up'
                // Or, in development:
                // const primarySignInUrl = 'http:localhost:3000/sign-in';
                // const primarySignUpUrl = 'http:localhost:3000/sign-up';

                return (
                  <ClerkProvider
                    isSatellite
                    domain={(url) => url.host}
                    signInUrl={primarySignInUrl}
                    signUpUrl={primarySignUpUrl}
                    {...pageProps}
                  >
                    <Head>
                      <title>Satellite Next.js app</title>
                      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                    </Head>
                    <Component {...pageProps} />
                  </ClerkProvider>
                )
              }
              ```
            </CodeBlockTabs>

          And the middleware associated with your satellite domain should look like this:

          ```ts {{ filename: 'middleware.ts' }}
          import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

          // Set the homepage as a public route
          const isPublicRoute = createRouteMatcher(['/'])

          // Set the necessary options for a satellite application
          const options = {
            isSatellite: true,
            signInUrl: 'https://primary.dev/sign-in',
            signUpUrl: 'https://primary.dev/sign-up',
            // Or, in development:
            // signInUrl: 'http://localhost:3000/sign-in',
            // signUpUrl: 'http://localhost:3000/sign-up',
            domain: 'https://satellite.dev',
            // Or, in development:
            // domain: 'http://localhost:3001',
          }

          export default clerkMiddleware(async (auth, req) => {
            if (isPublicRoute(req)) return // if it's a public route, do nothing
            await auth.protect() // for any other route, require auth
          }, options)

          export const config = {
            matcher: [
              // Skip Next.js internals and all static files, unless found in search params
              '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
              // Always run for API routes
              '/(api|trpc)(.*)',
            ],
          }
          ```
        </Tab>

        <Tab>
          In a Remix application, you must set the properties in the [`ClerkApp`](/docs/references/remix/clerk-app) wrapper.

          - In the root file associated with your primary domain, you only need to configure the `signInUrl` prop:

            ```ts {{ filename: 'root.tsx' }}
            export const loader = (args) => {
              return rootAuthLoader(
                args,
                ({ req }) => {
                  const { userId, sessionId, getToken } = req.auth
                  return json({
                    message: `Hello from the root loader :)`,
                    ENV: getBrowserEnvironment(),
                  })
                },
                {
                  loadUser: true,
                  signInUrl: '/sign-in',
                  signUpUrl: '/sign-up',
                  allowedRedirectOrigins: ['https://satellite.dev'],
                } as const,
              )
            }

            export default ClerkApp(App, {
              signInUrl: '/sign-in',
              signUpUrl: '/sign-up',
            })
            ```

          - In the root file associated with your satellite domain, configure `ClerkApp` as shown in the following example:

            ```ts {{ filename: 'root.tsx' }}
            export const loader = (args) => {
              return rootAuthLoader(
                args,
                ({ req }) => {
                  const { userId, sessionId, getToken } = req.auth
                  return json({
                    message: `Hello from the root loader :)`,
                    ENV: getBrowserEnvironment(),
                  })
                },
                {
                  loadUser: true,
                  signInUrl: 'https://primary.dev/sign-in',
                  signUpUrl: 'https://primary.dev/sign-up',
                  // Or, in development:
                  // signInUrl: 'http:localhost:3000/sign-in',
                  // signUpUrl: 'http:localhost:3000/sign-up',
                  isSatellite: true,
                  domain: (url) => url.host,
                } as const,
              )
            }

            export default ClerkApp(App, {
              isSatellite: true,
              domain: (url) => url.host,
              signInUrl: 'https://primary.dev/sign-in',
              signUpUrl: 'https://primary.dev/sign-up',
              // Or, in development:
              // signInUrl: 'http:localhost:3000/sign-in',
              // signUpUrl: 'http:localhost:3000/sign-up',
            })
            ```
        </Tab>
      </Tabs>
    </Tab>
  </Tabs>

  ### Ready to go 

  Your satellite application should now be able to access the authentication state from your satellite domain!

  You can see it in action by:

  1. Visiting the primary domain and signing in.
  1. Visiting the satellite domain.
  1. You now have an active session in the satellite domain, so you can see the [`<UserProfile />`](/docs/components/user/user-profile) component and update your information.

  You can repeat this process and create as many satellite applications as you need.
</Steps>

If you have any questions about satellite domains, or you're having any trouble setting this up, contact [support@clerk.com](mailto:support@clerk.com)

---
title: Authentication errors
description: An index of Clerk errors related to authentication, such as when a Clerk Secret Key is invalid, or when a request is not authenticated.
type: reference
---

An index of Clerk errors related to authentication, such as when a Clerk Secret Key is invalid, or when a request is not authenticated.

## `InvalidClerkSecretKey`

Signifies an error when the supplied client key is invalid.

```json
{
  "shortMessage": "The provided Clerk Secret Key is invalid. Make sure that your Clerk Secret Key is correct.",
  "code": "clerk_key_invalid_code"
}
```

## `InvalidAuthentication`

Signifies an error when the request is not authenticated.

```json
{
  "shortMessage": "Invalid authentication",
  "longMessage": "Unable to authenticate the request, you need to supply an active session",
  "code": "authentication_invalid_code"
}
```

## <code>InvalidAuthorization<wbr />HeaderFormat</code>

Signifies an error when the Authorization header has no proper format.

```json
{
  "shortMessage": "Invalid Authorization header format",
  "longMessage": "Invalid Authorization header format. Must be 'Bearer <YOUR_API_KEY>'",
  "code": "authorization_header_format_invalid_code"
}
```

## `InvalidAuthorization`

Signifies an error when the request is not authorized to perform the given operation.

```json
{
  "shortMessage": "Unauthorized request",
  "longMessage": "You are not authorized to perform this request",
  "code": "authorization_invalid_code"
}
```

## `InvalidCSRFToken`

Signifies an error when the request does not contain a CSRF token or the given token is invalid.

```json
{
  "shortMessage": "Invalid or missing CSRF token",
  "longMessage": "To protect against CSRF attacks, the given request must include a valid CSRF token.",
  "code": "invalid_csrf_token_code"
}
```

## `MissingRequestHeaders`

Signifies an error when the incoming request is missing mandatory headers.

### For standard browsers

```json
{
  "shortMessage": "Invalid request headers",
  "longMessage": "Your Clerk Frontend API is accessible from browsers and native applications. To protect against standard web attacks, the HTTP Origin header is required in browser requests. If you see this error, you probably accessed Clerk Frontend API directly from the address bar or a browser extension is intercepting your browser requests, removing the HTTP Origin header. For more information refer to https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin.",
  "code": "request_header_missing_code"
}
```

### For non-standard browsers

```json
{
  "shortMessage": "Invalid request headers",
  "longMessage": "Your Clerk Frontend API is accessible from browsers and native applications. To protect against common web attacks, we require the HTTP Authorization header to be present in native application requests. Make sure the HTTP Authorization header is set a valid Clerk client JWT or set it to an empty string for your first Frontend API request that will return your Clerk client JWT.",
  "code": "request_header_missing_code"
}
```

## `InvalidOriginHeader`

Signifies an error when the origin header of the incoming request is invalid.

```json
{
  "shortMessage": "Invalid HTTP Origin header",
  "longMessage": "The Request HTTP Origin header must be equal to or a subdomain of the requesting URL.",
  "code": "origin_invalid_code"
}
```

## `DevBrowserUnauthenticated`

Signifies an error when the dev browser is not authenticated.

```json
{
  "shortMessage": "Browser unauthenticated",
  "longMessage": "Unable to authenticate this browser for your development instance. Check your Clerk cookies and try again. If the issue persists reach out to support@clerk.com.",
  "code": "dev_browser_unauthenticated_code"
}
```

## <code>URLBasedSession<wbr />SyncingDisabled</code>

Signifies an error when the incoming request attempts to use an endpoint with URL-based session syncing, when the instance operates with third-party cookies instead.

```json
{
  "shortMessage": "URL-based session syncing is disabled for this instance",
  "longMessage": "This is a development instance operating with legacy, third-party cookies. To enable URL-based session syncing refer to https://clerk.com/docs/upgrade-guides/url-based-session-syncing.",
  "code": "url_based_session_syncing_disabled_code"
}
```

## `InvalidRequestForEnvironment`

Signifies an error when the incoming request is invalid for given environment(s).

```json
{
  "shortMessage": "Invalid request for environment",
  "longMessage": "Request only valid for <envTypesAsString> instances.",
  "code": "request_invalid_for_environment_code"
}
```

## `RequestInvalidForInstance`

Signifies an error when the incoming request is invalid for the given instance, due to the `auth_config`.

```json
{
  "shortMessage": "Invalid request for instance",
  "longMessage": "This request is not valid for your instance. Modify your instance settings to use this request.",
  "code": "request_invalid_for_instance_code"
}
```

## `InvalidHost`

Signifies an error when the incoming request has an invalid host.

```json
{
  "shortMessage": "Invalid host",
  "longMessage": "We were unable to attribute this request to an instance running on Clerk. Make sure that your Clerk Publishable Key is correct.",
  "code": "host_invalid_code"
}
```

## `IdentificationExists`

Signifies an error when the identifier already exists.

### External account exists

```json
{
  "shortMessage": "already exists",
  "longMessage": "This external account already exists.",
  "code": "external_account_exists_code"
}
```

### Email address exists

```json
{
  "shortMessage": "already exists",
  "longMessage": "This email address already exists.",
  "code": "email_address_exists_code"
}
```

### Phone number exists

```json
{
  "shortMessage": "already exists",
  "longMessage": "This phone number already exists.",
  "code": "phone_number_exists_code"
}
```

### Username exists

```json
{
  "shortMessage": "already exists",
  "longMessage": "This username already exists.",
  "code": "username_exists_code"
}
```

### SAML account exists

```json
{
  "shortMessage": "already exists",
  "longMessage": "This SAML account already exists.",
  "code": "external_account_exists_code"
}
```

## `IdentifierNotAllowedAccess`

Signifies an error when the identifier provided is not allowed to access the application.

```json
{
  "shortMessage": "Access not allowed.",
  "longMessage": "You are not allowed to access this application.",
  "code": "identifier_not_allowed_access_code"
}
```

## `SignedOut`

Signifies an error when a user is signed out.

```json
{
  "shortMessage": "Signed out",
  "longMessage": "You are signed out",
  "code": "signed_out_code"
}
```

## `InvalidUserSettings`

Signifies an error where the auth settings of the instance are not well configured, which results in sign in and sign up endpoints to be restricted.

```json
{
  "shortMessage": "invalid auth configuration",
  "longMessage": "The authentication settings are invalid.",
  "code": "invalid_user_settings_code"
}
```

## `InvalidHandshake`

Signifies an error when the handshake request is invalid.

```json
{
  "shortMessage": "invalid handshake",
  "longMessage": "The handshake request is invalid: <REASON>",
  "code": "invalid_handshake_code"
}
```

---
title: Available versions
description: A list of the available API versions and their breaking changes.
---

Below is a list of all the available API versions with their respective breaking changes. For information on how to apply the appropriate version, see [Versioning overview](/docs/versioning/overview).

### 2025-04-10

Adds support for [version 2 of Clerk session tokens](/docs/backend-requests/resources/session-tokens).
The following SDKs are compatible with this version:

| SDK | Version |
| - | - |
| Clerk.js | @clerk/clerk-js v5.61.0 or higher |
| Next.js | @clerk/nextjs v6.15.0 or higher |
| Astro | @clerk/astro v2.6.4 or higher |
| Expo | @clerk/expo v2.9.12 or higher |
| Express | @clerk/express v1.4.5 or higher |
| Fastify | @clerk/fastify v2.2.5 or higher |
| Go | clerk-sdk-go v2.3.1 or higher |
| JavaScript Backend | @clerk/backend v1.28.0 or higher |
| Nuxt.js | @clerk/nuxt v1.5.5 or higher |
| React Router | @clerk/react-router v1.2.5 or higher |
| Remix | @clerk/remix v4.5.17 or higher |
| Ruby | clerk-sdk-ruby v4.1.0 or higher |
| TanStack React Start | @clerk/tanstack-react-start v0.13.5 or higher |

### 2024-10-01

- Notification for new sign-ins to users' accounts feature becomes available.
- The response for sign-ins with an email address that matches a **SAML connection** is updated:
  - Instead of responding with a status of `needs_identifier`, the API now returns a status of `needs_first_factor`.
  - The email address that matched will be returned in the identifier field.
  - The only strategy that will be included in supported first factors is `enterprise_sso`.

### 2021-02-05

The initial API version was released on 2021-02-05 as part of the first Clerk release. It predates the versioning system. All changes made to it since then are backwards compatible.

---
title: Backend-only SDK
description: A reference for implementing a backend-only Clerk SDK
---

When creating a backend-only SDK, you have two options for implementing the [BAPI](/docs/references/sdk/terminology) endpoints: either [develop a backend SDK that encompasses all BAPI endpoints](#implementation-bapi) or [create an SDK tailored for an existing backend framework](#implementation-node-js-backend-framework).

The source of truth for all BAPI endpoints is the [BAPI reference docs](/docs/reference/backend-api){{ target: '_blank' }}. For Node.js backend frameworks, you can build on top of the [JavaScript Backend SDK](/docs/references/backend/overview).

## Expected features

- User only needs to provide their [Secret Key](/docs/references/sdk/terminology)
- Centralized request authentication (e.g. in a middleware or plugin)
- Give access to the instance of BAPI client (so that users can use all methods)
- User should be able to limit access to routes by checking for [roles and permissions](/docs/organizations/roles-permissions)

> [!IMPORTANT]
> BAPI has [rate limits](/docs/backend-requests/resources/rate-limits) to help protect users against brute-force attacks or stop abuse of Clerk's platform. Be sure to include a backoff mechanism into your fetching logic and respect the `Retry-After` header to gracefully handle any active rate limits.

If you're using `@clerk/backend` to build an SDK for an existing framework, these additional features are expected:

- User should be able to use all `@clerk/backend` options

## Optional features

- User should be able to enforce authentication on individual routes (e.g. with a [`requireAuth`](/docs/references/sdk/backend-only#create-a-require-auth-helper) helper)
- Use singleton pattern to only create a pre-configured instance of Clerk backend client

## Implementation: BAPI

You can manually create a wrapper library around the [BAPI OpenAPI](https://clerk.com/docs/reference/backend-api) or use one the many automatic SDK generation tools that take in OpenAPI definitions.

> [!NOTE]
> If you're looking for a real-world example, have a look at [`clerk-sdk-go`](https://github.com/clerk/clerk-sdk-go).

## Implementation: Node.js backend framework

`@clerk/backend` is built for Node.js/V8 isolates (Cloudflare Workers, Vercel Edge Runtime, etc.). Its the foundational package for all JavaScript Backend SDKs and works across all JavaScript runtimes. By using `@clerk/backend` you can be sure to communicate with Clerks BAPI in a correct and secure way.

> [!NOTE]
> The code blocks below will be written in pseudo-code. If you're looking for real-world examples, have a look at [`@clerk/fastify`](https://github.com/clerk/javascript/tree/main/packages/fastify) and [`@clerk/express`](https://github.com/clerk/javascript/tree/main/packages/express).

<Steps>
  ### Create a Clerk client

  Use [`createClerkClient`](/docs/references/backend/overview#usage) from `@clerk/backend` to create your default Clerk client which will be used for the middleware.

  ```ts {{ filename: 'client.ts' }}
  import { createClerkClient } from '@clerk/backend'

  const API_VERSION = process.env.CLERK_API_VERSION || 'v1'
  const SECRET_KEY = process.env.CLERK_SECRET_KEY || ''
  const PUBLISHABLE_KEY = process.env.CLERK_PUBLISHABLE_KEY || ''
  const API_URL = process.env.CLERK_API_URL || ''
  const JWT_KEY = process.env.CLERK_JWT_KEY || ''
  const SDK_METADATA = {
    name: PACKAGE_NAME,
    version: PACKAGE_VERSION,
    environment: process.env.NODE_ENV,
  }

  export const clerkClient = createClerkClient({
    secretKey: SECRET_KEY,
    apiUrl: API_URL,
    apiVersion: API_VERSION,
    jwtKey: JWT_KEY,
    userAgent: `${PACKAGE_NAME}@${PACKAGE_VERSION}`,
    sdkMetadata: SDK_METADATA,
  })
  ```

  ### Create your middleware/plugin

  Inside the middleware, youll use the user-provided Clerk client (or use the default one created in the previous step) and authenticate the request. [`authenticateRequest`](/docs/references/backend/authenticate-request) returns `Promise<RequestState>`. The middleware should set `requestState.toAuth()` into its context as this will contain the resolved signed-in/signed-out [`Auth`](/docs/references/backend/types/auth-object) object. This way other helpers can access it later in the chain.

  ```ts {{ filename: 'clerk-middleware.ts' }}
  import { clerkClient as defaultClerkClient } from './client.ts'

  const clerkMiddleware = (options) => {
    return async (context, next) => {
      const clerkClient = options.clerkClient || defaultClerkClient

      const requestState = await clerkClient.authenticateRequest(context.req, {
        authorizedParties: ['https://example.com'],
      })

      context.set('clerkAuth', requestState.toAuth())
      context.set('clerk', clerkClient)

      await next()
    }
  }
  ```

  ### Create a `getAuth` helper

  This utility will access the stored `requestState` (in the example above saved as `clerkAuth`) and return it.

  ```ts {{ filename: 'get-auth.ts' }}
  export const getAuth = (context) => context.get('clerkAuth')
  ```

  Your end-users can use this utility in cases like these:

  ```ts {{ filename: 'index.ts', mark: [5, [7, 9]] }}
  const app = new Framework()

  app.use('*', clerkMiddleware())
  app.get('/', (context) => {
    const auth = getAuth(context)

    if (!auth?.userId) {
      return context.json({ message: 'Not logged in' })
    }

    return context.json({ message: 'Logged in', userId: auth.userId })
  })
  ```

  > [!TIP]
  > See the Next.js [`getAuth()`](/docs/references/nextjs/get-auth) reference to see how it's implemented.

  ### Create a `requireAuth` helper

  This utility will require auth requests for user authenticated or authorized requests. An HTTP `401` status code is returned for unauthorized requests.

  ```ts {{ filename: 'require-auth.ts' }}
  export const requireAuth = (context, next) => {
    if (!hasAuthObject(context)) {
      throw new Error('Middleware required')
    }
    if (!getAuth(context).userId) {
      context.status = 401
      return
    }
    return next()
  }
  ```

  Your end-users can use this utility in cases like these:

  ```ts {{ filename: 'index.ts' }}
  const app = new Framework()

  app.get('/path', requireAuth())
  ```

  Your end-users will also have access to a [`has()`](/docs/references/backend/types/auth-object#has) function on the [`Auth`](/docs/references/backend/types/auth-object) object. They can combine it with `requireAuth()` like so:

  ```ts {{ filename: 'index.ts' }}
  const app = new Framework()

  const hasPermission = (context, next) => {
    const auth = getAuth(context)
    if (!auth.has({ permission: 'permission' })) {
      context.status = 403
      return
    }
    return next()
  }

  app.get('/path', requireAuth(), hasPermission())
  ```
</Steps>

---
title: Backup code errors
description: An index of Clerk errors related to backup codes.
type: reference
---

An index of Clerk errors related to backup codes.

## `BackupCodesNotAvailable`

```json
{
  "shortMessage": "Backup codes not available",
  "longMessage": "In order to use backup codes, you have to enable any other Multi-factor method",
  "code": "backup_codes_not_available_code"
}
```

---
title: Basic geo blocking
description: Learn how to add geo blocking to your Next.js + Clerk application.
---

While Clerk does not provide a geo blocking feature, deployment platforms, such as Vercel and Render, expose geolocation data through request headers. This allows you to implement custom geo blocking logic by accessing the client's location data at runtime and conditionally allowing or blocking requests based on your requirements.

<Tabs items={["Vercel", "Render"]}>
  <Tab>
    The following example shows how to implement geo blocking in your [`clerkMiddleware()`](/docs/references/nextjs/clerk-middleware) using [Vercel's `geolocation()` function](https://vercel.com/guides/geo-ip-headers-geolocation-vercel-functions). If a user visits any route that is not a `/block` route, the middleware checks the client's country and redirects to the `/block` route if the country is not allowed. If that route is protected, the middleware also checks if the user is authenticated.

    ```tsx {{ filename: 'middleware.ts' }}
    import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'
    import { geolocation } from '@vercel/functions'
    import { NextResponse } from 'next/server'

    // Define your protected and blocked routes
    const isProtectedRoute = createRouteMatcher(['/dashboard(.*)'])
    const isBlockRoute = createRouteMatcher(['/block(.*)'])

    // Define the countries you want to allow
    const allowedCountries = ['US']

    export default clerkMiddleware(async (auth, req) => {
      if (isBlockRoute(req)) {
        return
      }

      // Use Vercel's `geolocation()` function to get the client's country
      const { country } = geolocation(req)

      // Redirect if the client's country is not allowed
      if (country && !allowedCountries.includes(country)) {
        return NextResponse.redirect(new URL('/block', req.url))
      }

      // Protect routes based on authentication status
      if (isProtectedRoute(req)) await auth.protect()
    })

    export const config = {
      matcher: [
        // Skip Next.js internals and all static files, unless found in search params
        '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
        // Always run for API routes
        '/(api|trpc)(.*)',
      ],
    }
    ```
  </Tab>

  <Tab>
    The following example shows how to implement geo blocking in your [`clerkMiddleware()`](/docs/references/nextjs/clerk-middleware) using Render's `cf-ipcountry` header. If a user visits any route that is not a `/block` route, the middleware checks the client's country and redirects to the `/block` route if the country is not allowed. If that route is protected, the middleware also checks if the user is authenticated.

    ```tsx {{ filename: 'middleware.ts' }}
    import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'
    import { NextResponse } from 'next/server'

    const isProtectedRoute = createRouteMatcher(['/dashboard(.*)'])
    const isBlockRoute = createRouteMatcher(['/block(.*)'])

    const allowedCountries = ['US']

    export default clerkMiddleware(async (auth, req) => {
      if (isBlockRoute(req)) {
        return
      }

      // Use Render's `cf-ipcountry` header to get the client's country
      const country = req.headers.get('cf-ipcountry')

      // Redirect if the client's country is not allowed
      if (country && !allowedCountries.includes(country)) {
        return NextResponse.redirect(new URL('/block', req.url))
      }

      // Protect routes based on authentication status
      if (isProtectedRoute(req)) await auth.protect()
    })

    export const config = {
      matcher: [
        // Skip Next.js internals and all static files, unless found in search params
        '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
        // Always run for API routes
        '/(api|trpc)(.*)',
      ],
    }
    ```
  </Tab>
</Tabs>

---
title: Billing account errors
description: An index of Clerk errors related to billing accounts.
type: reference
---

An index of Clerk errors related to billing accounts.

## `BillingAccountNotFound`

```json
{
  "shortMessage": "Billing account not found",
  "longMessage": "No billing account was found with ID <baID>",
  "code": "resource_not_found_code"
}
```

## `BillingAccountNotAccessible`

```json
{
  "shortMessage": "Billing account not accessible",
  "longMessage": "Billing account <baID> is not accessible by user <userID>",
  "code": "billing_account_not_accessible_code"
}
```

## <code>BillingAccount<wbr />WithoutCustomerID</code>

```json
{
  "shortMessage": "Billing account without customer ID",
  "longMessage": "Billing account <baID> does not have a Stripe Customer ID",
  "code": "billing_account_without_customer_id_code"
}
```

---
title: Billing errors
description: An index of Clerk errors related to billing.
type: reference
---

An index of Clerk errors related to billing.

## `CheckoutLocked`

```json
{
  "shortMessage": "Checkout is still processing",
  "longMessage": "Checkout is still processing for application ID <appID>",
  "code": "checkout_locked_code"
}
```

## `CheckoutSessionMismatch`

```json
{
  "shortMessage": "Checkout session ID mismatch",
  "longMessage": "Application ID <APPID> has no matching checkout session ID <SESSID>",
  "code": "checkout_session_mismatch_code"
}
```

## <code>UnsupportedSubscription<wbr />PlanFeatures</code>

```json
{
  "shortMessage": "Unsupported plan features",
  "longMessage": "Some features are not supported in your current plan. Upgrade your subscription to unlock them.",
  "code": "unsupported_subscription_plan_features_code"
}
```

## `InvalidSubscriptionPlanSwitch`

```json
{
  "shortMessage": "Unsupported plan features",
  "longMessage": "Some application features are not supported in your new plan. Stay with your current plan to avoid breaking changes.",
  "code": "invalid_subscription_plan_switch_code"
}
```

---
title: Blocklist identifier errors
description: An index of Clerk errors related to blocklist identifiers.
type: reference
---

An index of Clerk errors related to blocklist identifiers.

## `DuplicateBlocklistIdentifier`

```json
{
  "shortMessage": "duplicate blocklist identifier",
  "longMessage": "the identifier <identifier> already exists",
  "code": "duplicate_record_code"
}
```

## `BlocklistIdentifierNotFound`

```json
{
  "shortMessage": "Identifier not found",
  "longMessage": "No identifier was found with id <identifierID>",
  "code": "resource_not_found_code"
}
```

---
title: Bot protection
description: Protect your sign-ups from bots.
---

To protect your sign-ups from bots, Clerk leverages data from our CDN to determine whether a user attempting to sign up might be a bot or not.

## Enable bot sign-up protection

1. In the Clerk Dashboard, navigate to the [**Attack protection**](https://dashboard.clerk.com/last-active?path=user-authentication/attack-protection) page.
1. In the **Bot sign-up protection** section, enable the feature and choose the **CAPTCHA type** you want to use:
   - **Smart**: The CAPTCHA widget will only be shown if the client is suspected to be a bot. Users suspected of being a bot will be shown a interactive challenge (like clicking a checkbox), in an attempt to verify they are human.
   - **Invisible**: Bot traffic will be automatically blocked. No CAPTCHA widget will be displayed. Users suspected of being a bot will not be allowed to sign up, and are shown an error message instructing them to reach out to your configured support email address.

## Limitations

- Device emulation in a browser is [not supported by Cloudflare](https://developers.cloudflare.com/waf/reference/cloudflare-challenges/#mobile-device-emulation), which Clerk uses for bot detection.
- If you're building a custom sign-up flow using the Clerk API, instead of using Clerk components, and you have enabled **Bot sign-up protection**, then you need to ensure you have added a DOM node to render the CAPTCHA widget. Refer to the [Add bot protection to your custom sign-up flow](/docs/custom-flows/bot-sign-up-protection) guide for more information.

---
title: Brute force attacks and locking user accounts
description: User information is aprime target for malicious activity. Clerk protects your users against brute force attacks by locking out accounts with too many sign-in attempts until a set period of time has passed.
---

User accounts are a vector for malicious attacks for many reasons, from impersonation to collecting personally identifiable information (PII). One method is a "brute force" attack, where a script will attempt many different passwords to sign into an account. One line of defense against these attacks is to temporarily deny attempts to sign into accounts that attempt too many failed sign-ins in a short period of time. Locking out sign-in attempts disrupts the attack and makes the account a less attractive target.

## How Clerk protects against brute force attacks

**Account lockout** is a Clerk feature that enables you to protect your users from brute-force attacks on static credentials. If enabled on your instance, Clerk will automatically track users' failed verification attempts when they try to authenticate via password on backup code.

### How account lockout works

If the maximum allowed attempts are reached, the user will be locked out from signing in again until the lockout duration lapses. Lockout can also be [configured to never expire](/docs/security/customize-user-lockout), in which case the user will not be able to sign in unless an admin unlocks them.

An admin can [unlock a user before the expiry of the lockout period via the Clerk Dashboard](/docs/security/unlock-user-accounts).

### Defaults

By default, Clerk applications will lock user accounts after 100 failed sign-in attempts and require a one hour cool down period before anyone can attempt to sign into that account again. (While 100 attempts may seem like a lot to a human, it is very easy to reach this maximum for a bot!)

You can [customize the number of times a sign-in can be attempted before the account is locked, and how long lockouts last](/docs/security/customize-user-lockout).

#### Actions

Clerk measures the following actions as part of account lockout:

- Password attempts
- Password resets
- Backup code requests
- Email & Phone codes
- TOTP attempts

## What a locked out user sees

When a user exceeds the maximum sign-in attempts, the Clerk [`<SignIn />`](/docs/components/authentication/sign-in) component will inform them of how long they have been locked out for and to contact support for more information.

![The Clerk component sign-in form with a red alert stating 'Your account is locked. You will be able to try again in 59 minutes. For more information, contact support.'](/docs/images/security/userlock_login.png)

> [!NOTE]
> Currently, users cannot unlock their own account or submit a request to the admin to be unlocked ("self-service unlock"). This is an upcoming feature, so see the [changelog](https://clerk.com/changelog){{ target: '_blank' }} periodically to find out when it is available. Until then, you can [programmatically lock and unlock user accounts with a custom flow](/docs/security/programmatically-lock-user-accounts).

---
title: Build a custom authentication flow using passkeys
description: Learn how to use the Clerk API to build a custom authentication flow using passkeys.
---

<Include src="_partials/custom-flows-callout" />

Clerk supports passwordless authentication via [passkeys](/docs/authentication/configuration/sign-up-sign-in-options#passkeys), enabling users to sign in without having to remember a password. Instead, users select a passkey associated with their device, which they can use to authenticate themselves.

This guide demonstrates how to use the Clerk API to build a custom user interface for creating, signing users in with, and managing passkeys.

## Enable passkeys

To use passkeys, first enable the strategy in the Clerk Dashboard.

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. In the **Authentication strategies** section of this page, ensure **Passkeys** is enabled.

## Domain restrictions for passkeys in development

<Include src="_partials/authentication/passkeys-restriction" />

## Create user passkeys

To create a passkey for a user, you must call [`User.createPasskey()`](/docs/references/javascript/user#create-passkey), as shown in the following example:

```tsx {{ filename: 'app/components/CustomCreatePasskeysButton.tsx' }}
export function CreatePasskeyButton() {
  const { user } = useUser()

  const createClerkPasskey = async () => {
    if (!user) return

    try {
      await user?.createPasskey()
    } catch (err) {
      // See https://clerk.com/docs/custom-flows/error-handling
      // for more info on error handling
      console.error('Error:', JSON.stringify(err, null, 2))
    }
  }

  return <button onClick={createClerkPasskey}>Create a passkey</button>
}
```

## Sign a user in with a passkey

To sign a user into your Clerk app with a passkey, you must call [`SignIn.authenticateWithPasskey()`](/docs/references/javascript/sign-in#authenticate-with-passkey). This method allows users to choose from their discoverable passkeys, such as hardware keys or passkeys in password managers.

```tsx {{ filename: 'components/SignInWithPasskeyButton.tsx' }}
export function SignInWithPasskeyButton() {
  const { signIn } = useSignIn()
  const router = useRouter()

  const signInWithPasskey = async () => {
    // 'discoverable' lets the user choose a passkey
    // without auto-filling any of the options
    try {
      const signInAttempt = await signIn?.authenticateWithPasskey({
        flow: 'discoverable',
      })

      if (signInAttempt?.status === 'complete') {
        await setActive({ session: signInAttempt.createdSessionId })
        router.push('/')
      } else {
        // If the status is not complete, check why. User may need to
        // complete further steps.
        console.error(JSON.stringify(signInAttempt, null, 2))
      }
    } catch (err) {
      // See https://clerk.com/docs/custom-flows/error-handling
      // for more info on error handling
      console.error('Error:', JSON.stringify(err, null, 2))
    }
  }

  return <button onClick={signInWithPasskey}>Sign in with a passkey</button>
}
```

## Rename user passkeys

Clerk generates a name based on the device associated with the passkey when it's created. Sometimes users may want to rename a passkey to make it easier to identify.

To rename a user's passkey in your Clerk app, you must call the [`update()`](/docs/references/javascript/types/passkey-resource#update) method of the passkey object, as shown in the following example:

```tsx {{ filename: 'components/RenamePasskeyUI.tsx' }}
export function RenamePasskeyUI() {
  const { user } = useUser()
  const { passkeys } = user

  const passkeyToUpdateId = useRef<HTMLInputElement>(null)
  const newPasskeyName = useRef<HTMLInputElement>(null)
  const [success, setSuccess] = useState(false)

  const renamePasskey = async () => {
    try {
      const passkeyToUpdate = passkeys?.find(
        (pk: PasskeyResource) => pk.id === passkeyToUpdateId.current?.value,
      )

      await passkeyToUpdate?.update({
        name: newPasskeyName.current?.value,
      })

      setSuccess(true)
    } catch (err) {
      // See https://clerk.com/docs/custom-flows/error-handling
      // for more info on error handling
      console.error('Error:', JSON.stringify(err, null, 2))
      setSuccess(false)
    }
  }

  return (
    <>
      <p>Passkeys:</p>
      <ul>
        {passkeys?.map((pk: PasskeyResource) => {
          return (
            <li key={pk.id}>
              Name: {pk.name} | ID: {pk.id}
            </li>
          )
        })}
      </ul>
      <input ref={passkeyToUpdateId} type="text" placeholder="Enter the passkey ID" />
      <input type="text" placeholder="Enter the passkey's new name" ref={newPasskeyName} />
      <button onClick={renamePasskey}>Rename passkey</button>
      <p>Passkey updated: {success ? 'Yes' : 'No'}</p>
    </>
  )
}
```

## Delete user passkeys

To delete a user's passkey from your Clerk app, you must call the [`delete()`](/docs/references/javascript/types/passkey-resource#delete) method of the passkey object, as shown in the following example:

```tsx {{ filename: 'components/DeletePasskeyUI.tsx' }}
export function DeletePasskeyUI() {
  const { user } = useUser()
  const { passkeys } = user

  const passkeyToDeleteId = useRef<HTMLInputElement>(null)
  const [success, setSuccess] = useState(false)

  const deletePasskey = async () => {
    const passkeyToDelete = passkeys?.find((pk: any) => pk.id === passkeyToDeleteId.current?.value)
    try {
      await passkeyToDelete?.delete()

      setSuccess(true)
    } catch (err) {
      // See https://clerk.com/docs/custom-flows/error-handling
      // for more info on error handling
      console.error('Error:', JSON.stringify(err, null, 2))
      setSuccess(false)
    }
  }

  return (
    <>
      <p>Passkeys:</p>
      <ul>
        {passkeys?.map((pk: any) => {
          return (
            <li key={pk.id}>
              Name: {pk.name} | ID: {pk.id}
            </li>
          )
        })}
      </ul>
      <input ref={passkeyToDeleteId} type="text" placeholder="Enter the passkey ID" />
      <button onClick={deletePasskey}>Delete passkey</button>
      <p>Passkey deleted: {success ? 'Yes' : 'No'}</p>
    </>
  )
}
```

---
title: Build a custom email or SMS OTP authentication flow
description: Learn how build a custom email or SMS one time code (OTP) authentication flow using the Clerk API.
---

<Include src="_partials/custom-flows-callout" />

Clerk supports passwordless authentication, which lets users sign in and sign up without having to remember a password. Instead, users receive a one-time password (OTP), also known as a one-time code, via email or SMS, which they can use to authenticate themselves.

This guide will walk you through how to build a custom SMS OTP sign-up and sign-in flow. The process for using email OTP is similar, and the differences will be highlighted throughout.

<Include src="_partials/custom-flows/phone-number" />

<Steps>
  ## Enable SMS OTP

  To use SMS OTP as an authentication strategy, you first need to enable it in the Clerk Dashboard.

  1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
  1. Ensure that _only_ **Phone number** is required. If **Email address** or **Username** are enabled, ensure they are not required. Use the settings icon to check if a setting is required or optional. If you would like to require **Username**, you must collect the username and pass it to the `create()` method in your custom flow. For this guide, if you would like to use email OTP instead, require the **Email address** option instead of the **Phone number** option.
  1. In the **Authentication strategies** section of this page, ensure **SMS verification code** is enabled. Ensure **Password** is toggled off, as you are prioritizing passwordless, SMS OTP-only authentication in this guide. If you would like to use email OTP instead, enable the **Email verification code** strategy instead of the **SMS verification code** strategy.

  ## Sign-up flow

  To sign up a user using an OTP, you must:

  1. Initiate the sign-up process by collecting the user's identifier, which for this example is a phone number.
  1. Prepare the verification, which sends a one-time code to the given identifier.
  1. Attempt to complete the verification with the code the user provides.
  1. If the verification is successful, set the newly created session as the active session.

  <Tabs items={["Next.js", "JavaScript", "iOS"]}>
    <Tab>
      This example is written for Next.js App Router but it can be adapted to any React-based framework.

      ```tsx {{ filename: 'app/sign-up/[[...sign-up]]/page.tsx', collapsible: true }}
      'use client'

      import * as React from 'react'
      import { useSignUp } from '@clerk/nextjs'
      import { useRouter } from 'next/navigation'

      export default function Page() {
        const { isLoaded, signUp, setActive } = useSignUp()
        const [verifying, setVerifying] = React.useState(false)
        const [phone, setPhone] = React.useState('')
        const [code, setCode] = React.useState('')
        const router = useRouter()

        async function handleSubmit(e: React.FormEvent) {
          e.preventDefault()

          if (!isLoaded && !signUp) return null

          try {
            // Start the sign-up process using the phone number method
            await signUp.create({
              phoneNumber: phone,
            })

            // Start the verification - a SMS message will be sent to the
            // number with a one-time code
            await signUp.preparePhoneNumberVerification()

            // Set verifying to true to display second form and capture the OTP code
            setVerifying(true)
          } catch (err) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error('Error:', JSON.stringify(err, null, 2))
          }
        }

        async function handleVerification(e: React.FormEvent) {
          e.preventDefault()

          if (!isLoaded && !signUp) return null

          try {
            // Use the code provided by the user and attempt verification
            const signUpAttempt = await signUp.attemptPhoneNumberVerification({
              code,
            })

            // If verification was completed, set the session to active
            // and redirect the user
            if (signUpAttempt.status === 'complete') {
              await setActive({ session: signUpAttempt.createdSessionId })

              router.push('/')
            } else {
              // If the status is not complete, check why. User may need to
              // complete further steps.
              console.error(signUpAttempt)
            }
          } catch (err) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error('Error:', JSON.stringify(err, null, 2))
          }
        }

        if (verifying) {
          return (
            <>
              <h1>Verify your phone number</h1>
              <form onSubmit={handleVerification}>
                <label htmlFor="code">Enter your verification code</label>
                <input value={code} id="code" name="code" onChange={(e) => setCode(e.target.value)} />
                <button type="submit">Verify</button>
              </form>
            </>
          )
        }

        return (
          <>
            <h1>Sign up</h1>
            <form onSubmit={handleSubmit}>
              <label htmlFor="phone">Enter phone number</label>
              <input
                value={phone}
                id="phone"
                name="phone"
                type="tel"
                onChange={(e) => setPhone(e.target.value)}
              />
              <button type="submit">Continue</button>
            </form>
          </>
        )
      }
      ```
    </Tab>

    <Tab>
      <CodeBlockTabs options={["index.html", "main.js"]}>
        ```html {{ filename: 'index.html', collapsible: true }}
        <!doctype html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <title>Clerk + JavaScript App</title>
          </head>
          <body>
            <div id="signed-in"></div>

            <div id="sign-up">
              <h2>Sign up</h2>
              <form id="sign-up-form">
                <label for="phone">Enter phone number</label>
                <input type="tel" name="phone" id="sign-up-phone" />
                <button type="submit">Continue</button>
              </form>
            </div>

            <form id="verifying" hidden>
              <h2>Verify your phone number</h2>
              <label for="code">Enter your verification code</label>
              <input id="code" name="code" />
              <button type="submit" id="verify-button">Verify</button>
            </form>

            <script type="module" src="/src/main.js" async crossorigin="anonymous"></script>
          </body>
        </html>
        ```

        ```js {{ filename: 'main.js', collapsible: true }}
        import { Clerk } from '@clerk/clerk-js'

        const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

        const clerk = new Clerk(pubKey)
        await clerk.load()

        if (clerk.user) {
          // Mount user button component
          document.getElementById('signed-in').innerHTML = `
            <div id="user-button"></div>
          `

          const userbuttonDiv = document.getElementById('user-button')

          clerk.mountUserButton(userbuttonDiv)
        } else {
          // Handle the sign-up form
          document.getElementById('sign-up-form').addEventListener('submit', async (e) => {
            e.preventDefault()

            const formData = new FormData(e.target)
            const phoneNumber = formData.get('phone')

            try {
              // Start the sign-up process using the phone number method
              await clerk.client.signUp.create({ phoneNumber })
              await clerk.client.signUp.preparePhoneNumberVerification()
              // Hide sign-up form
              document.getElementById('sign-up').setAttribute('hidden', '')
              // Show verification form
              document.getElementById('verifying').removeAttribute('hidden')
            } catch (error) {
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.error(error)
            }
          })

          // Handle the verification form
          document.getElementById('verifying').addEventListener('submit', async (e) => {
            const formData = new FormData(e.target)
            const code = formData.get('code')

            try {
              // Verify the phone number
              const verify = await clerk.client.signUp.attemptPhoneNumberVerification({
                code,
              })

              // Now that the user is created, set the session to active.
              await clerk.setActive({ session: verify.createdSessionId })
            } catch (error) {
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.error(error)
            }
          })
        }
        ```
      </CodeBlockTabs>
    </Tab>

    <Tab>
      ```swift {{ filename: 'SMSOTPSignUpView.swift', collapsible: true }}
      import SwiftUI
      import Clerk

      struct SMSOTPSignUpView: View {
        @State private var phoneNumber = ""
        @State private var code = ""
        @State private var isVerifying = false

        var body: some View {
          if isVerifying {
            TextField("Enter your verification code", text: $code)
            Button("Verify") {
              Task { await verify(code: code) }
            }
          } else {
            TextField("Enter phone number", text: $phoneNumber)
            Button("Continue") {
              Task { await submit(phoneNumber: phoneNumber) }
            }
          }
        }
      }

      extension SMSOTPSignUpView {

        func submit(phoneNumber: String) async {
          do {
            // Start the sign-up process using the phone number method.
            let signUp = try await SignUp.create(strategy: .standard(phoneNumber: phoneNumber))

            // Start the verification - a SMS message will be sent to the
            // number with a one-time code.
            try await signUp.prepareVerification(strategy: .phoneCode)

            // Set isVerifying to true to display second form and capture the OTP code.
            isVerifying = true
          } catch {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            dump(error)
          }
        }

        func verify(code: String) async {
          do {
            // Access the in progress sign up stored on the client object.
            guard let inProgressSignUp = Clerk.shared.client?.signUp else { return }

            // Use the code provided by the user and attempt verification.
            let signUp = try await inProgressSignUp.attemptVerification(strategy: .phoneCode(code: code))

            switch signUp.status {
            case .complete:
              // If verification was completed, navigate the user as needed.
              dump(Clerk.shared.session)
            default:
              // If the status is not complete, check why. User may need to
              // complete further steps.
              dump(signUp.status)
            }
          } catch {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            dump(error)
          }
        }
      }
      ```
    </Tab>
  </Tabs>

  To create a sign-up flow for email OTP, use the [`prepareEmailAddressVerification`](/docs/references/javascript/sign-up#prepare-email-address-verification) and [`attemptEmailAddressVerification`](/docs/references/javascript/sign-up#attempt-email-address-verification). These helpers work the same way as their phone number counterparts do in the previous example. You can find all available methods in the [`SignUp`](/docs/references/javascript/sign-in) object documentation.

  ## Sign-in flow

  To authenticate a user with an OTP, you must:

  1. Initiate the sign-in process by creating a `SignIn` using the identifier provided, which for this example is a phone number.
  1. Prepare the first factor verification.
  1. Attempt verification with the code the user provides.
  1. If the attempt is successful, set the newly created session as the active session.

  <Tabs items={["Next.js","JavaScript", "iOS"]}>
    <Tab>
      This example is written for Next.js App Router but it can be adapted to any React-based framework.

      ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx', collapsible: true }}
      'use client'

      import * as React from 'react'
      import { useSignIn } from '@clerk/nextjs'
      import { PhoneCodeFactor, SignInFirstFactor } from '@clerk/types'
      import { useRouter } from 'next/navigation'

      export default function Page() {
        const { isLoaded, signIn, setActive } = useSignIn()
        const [verifying, setVerifying] = React.useState(false)
        const [phone, setPhone] = React.useState('')
        const [code, setCode] = React.useState('')
        const router = useRouter()

        async function handleSubmit(e: React.FormEvent) {
          e.preventDefault()

          if (!isLoaded && !signIn) return null

          try {
            // Start the sign-in process using the phone number method
            const { supportedFirstFactors } = await signIn.create({
              identifier: phone,
            })

            // Filter the returned array to find the 'phone_code' entry
            const isPhoneCodeFactor = (factor: SignInFirstFactor): factor is PhoneCodeFactor => {
              return factor.strategy === 'phone_code'
            }
            const phoneCodeFactor = supportedFirstFactors?.find(isPhoneCodeFactor)

            if (phoneCodeFactor) {
              // Grab the phoneNumberId
              const { phoneNumberId } = phoneCodeFactor

              // Send the OTP code to the user
              await signIn.prepareFirstFactor({
                strategy: 'phone_code',
                phoneNumberId,
              })

              // Set verifying to true to display second form
              // and capture the OTP code
              setVerifying(true)
            }
          } catch (err) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error('Error:', JSON.stringify(err, null, 2))
          }
        }

        async function handleVerification(e: React.FormEvent) {
          e.preventDefault()

          if (!isLoaded && !signIn) return null

          try {
            // Use the code provided by the user and attempt verification
            const signInAttempt = await signIn.attemptFirstFactor({
              strategy: 'phone_code',
              code,
            })

            // If verification was completed, set the session to active
            // and redirect the user
            if (signInAttempt.status === 'complete') {
              await setActive({ session: signInAttempt.createdSessionId })

              router.push('/')
            } else {
              // If the status is not complete, check why. User may need to
              // complete further steps.
              console.error(signInAttempt)
            }
          } catch (err) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error('Error:', JSON.stringify(err, null, 2))
          }
        }

        if (verifying) {
          return (
            <>
              <h1>Verify your phone number</h1>
              <form onSubmit={handleVerification}>
                <label htmlFor="code">Enter your verification code</label>
                <input value={code} id="code" name="code" onChange={(e) => setCode(e.target.value)} />
                <button type="submit">Verify</button>
              </form>
            </>
          )
        }

        return (
          <>
            <h1>Sign in</h1>
            <form onSubmit={handleSubmit}>
              <label htmlFor="phone">Enter phone number</label>
              <input
                value={phone}
                id="phone"
                name="phone"
                type="tel"
                onChange={(e) => setPhone(e.target.value)}
              />
              <button type="submit">Continue</button>
            </form>
          </>
        )
      }
      ```
    </Tab>

    <Tab>
      <CodeBlockTabs options={["index.html", "main.js"]}>
        ```html {{ filename: 'index.html', collapsible: true }}
        <!doctype html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <title>Clerk + JavaScript App</title>
          </head>
          <body>
            <div id="signed-in"></div>

            <div id="sign-in">
              <h2>Sign in</h2>
              <form id="sign-in-form">
                <label for="phone">Enter phone number</label>
                <input type="tel" name="phone" id="sign-in-phone" />
                <button type="submit">Continue</button>
              </form>
            </div>

            <form id="verifying" hidden>
              <h2>Verify your phone number</h2>
              <label for="code">Enter your verification code</label>
              <input id="code" name="code" />
              <button type="submit" id="verify-button">Verify</button>
            </form>

            <script type="module" src="/src/main.js" async crossorigin="anonymous"></script>
          </body>
        </html>
        ```

        ```js {{ filename: 'main.js', collapsible: true }}
        import { Clerk } from '@clerk/clerk-js'

        const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

        const clerk = new Clerk(pubKey)
        await clerk.load()

        if (clerk.user) {
          // Mount user button component
          document.getElementById('signed-in').innerHTML = `
            <div id="user-button"></div>
          `

          const userbuttonDiv = document.getElementById('user-button')

          clerk.mountUserButton(userbuttonDiv)
        } else {
          // Handle the sign-in form
          document.getElementById('sign-in-form').addEventListener('submit', async (e) => {
            e.preventDefault()

            const formData = new FormData(e.target)
            const phone = formData.get('phone')

            try {
              // Start the sign-in process using the user's identifier.
              // In this case, it's their phone number.
              const { supportedFirstFactors } = await clerk.client.signIn.create({
                identifier: phone,
              })

              // Find the phoneNumberId from all the available first factors for the current sign-in
              const firstPhoneFactor = supportedFirstFactors.find((factor) => {
                return factor.strategy === 'phone_code'
              })

              const { phoneNumberId } = firstPhoneFactor

              // Prepare first factor verification, specifying
              // the phone code strategy.
              await clerk.client.signIn.prepareFirstFactor({
                strategy: 'phone_code',
                phoneNumberId,
              })

              // Hide sign-in form
              document.getElementById('sign-in').setAttribute('hidden', '')
              // Show verification form
              document.getElementById('verifying').removeAttribute('hidden')
            } catch (error) {
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.error(error)
            }
          })

          // Handle the verification form
          document.getElementById('verifying').addEventListener('submit', async (e) => {
            const formData = new FormData(e.target)
            const code = formData.get('code')

            try {
              // Verify the phone number
              const verify = await clerk.client.signIn.attemptFirstFactor({
                strategy: 'phone_code',
                code,
              })

              // Now that the user is created, set the session to active.
              await clerk.setActive({ session: verify.createdSessionId })
            } catch (error) {
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.error(error)
            }
          })
        }
        ```
      </CodeBlockTabs>
    </Tab>

    <Tab>
      ```swift {{ filename: 'SMSOTPSignInView.swift', collapsible: true }}
      import SwiftUI
      import Clerk

      struct SMSOTPSignInView: View {
        @State private var phoneNumber = ""
        @State private var code = ""
        @State private var isVerifying = false

        var body: some View {
          if isVerifying {
            TextField("Enter your verification code", text: $code)
            Button("Verify") {
              Task { await verify(code: code) }
            }
          } else {
            TextField("Enter phone number", text: $phoneNumber)
            Button("Continue") {
              Task { await submit(phoneNumber: phoneNumber) }
            }
          }
        }
      }

      extension SMSOTPSignInView {

        func submit(phoneNumber: String) async {
          do {
            // Start the sign-in process using the phone number method.
            let signIn = try await SignIn.create(strategy: .identifier(phoneNumber))

            // Send the OTP code to the user.
            try await signIn.prepareFirstFactor(strategy: .phoneCode())

            // Set isVerifying to true to display second form
            // and capture the OTP code.
            isVerifying = true
          } catch {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            dump(error)
          }
        }

        func verify(code: String) async {
          do {
            // Access the in progress sign in stored on the client object.
            guard let inProgressSignIn = Clerk.shared.client?.signIn else { return }

            // Use the code provided by the user and attempt verification.
            let signIn = try await inProgressSignIn.attemptFirstFactor(strategy: .phoneCode(code: code))

            switch signIn.status {
            case .complete:
              // If verification was completed, navigate the user as needed.
              dump(Clerk.shared.session)
            default:
              // If the status is not complete, check why. User may need to
              // complete further steps.
              dump(signIn.status)
            }
          } catch {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            dump(error)
          }
        }
      }
      ```
    </Tab>
  </Tabs>

  To create a sign-in flow for email OTP, pass the value `email_code` as the first factor strategy. You can find all available methods in the [`SignIn`](/docs/references/javascript/sign-in) object documentation.
</Steps>

---
title: Build a custom email/password authentication flow
description: Learn how to build a custom email/password sign-up and sign-in flow using the Clerk API.
---

<Include src="_partials/custom-flows-callout" />

This guide will walk you through how to build a custom email/password sign-up and sign-in flow.

<Steps>
  ## Enable email and password authentication

  To use email and password authentication, you first need to enable these [authentication strategies](/docs/authentication/configuration/sign-up-sign-in-options#authentication-strategies) in the Clerk Dashboard.

  1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
  1. Ensure that _only_ **Email address** is required. If **Phone number** and **Username** are enabled, ensure they are not required. Use the settings icon next to each option to verify if a setting is required or optional. If you would like to require **Username**, you must collect the username and pass it to the `create()` method in your custom flow.
  1. In the **Authentication strategies** section of this page, ensure **Password** is enabled.

  > [!NOTE]
  > By default, the [verification method](/docs/authentication/configuration/sign-up-sign-in-options#verification-methods) for the **Email address** strategy is set to **Email verification code**. This means that when a user signs up using their email address and password, Clerk sends a one-time code to their email address. The user must then enter this code to verify their email and complete the sign-up process.

  ## Sign-up flow

  To sign up a user using their email, password, and email verification code, you must:

  1. Initiate the sign-up process by collecting the user's email address and password.
  1. Prepare the email address verification, which sends a one-time code to the given address.
  1. Collect the one-time code and attempt to complete the email address verification with it.
  1. If the email address verification is successful, set the newly created session as the active session.

  <Tabs items={["Next.js", "JavaScript", "Expo", "iOS"]}>
    <Tab>
      This example is written for Next.js App Router but it can be adapted for any React-based framework.

      ```tsx {{ filename: 'app/sign-up/[[...sign-up]]/page.tsx', collapsible: true }}
      'use client'

      import * as React from 'react'
      import { useSignUp } from '@clerk/nextjs'
      import { useRouter } from 'next/navigation'

      export default function Page() {
        const { isLoaded, signUp, setActive } = useSignUp()
        const [emailAddress, setEmailAddress] = React.useState('')
        const [password, setPassword] = React.useState('')
        const [verifying, setVerifying] = React.useState(false)
        const [code, setCode] = React.useState('')
        const router = useRouter()

        // Handle submission of the sign-up form
        const handleSubmit = async (e: React.FormEvent) => {
          e.preventDefault()

          if (!isLoaded) return

          // Start the sign-up process using the email and password provided
          try {
            await signUp.create({
              emailAddress,
              password,
            })

            // Send the user an email with the verification code
            await signUp.prepareEmailAddressVerification({
              strategy: 'email_code',
            })

            // Set 'verifying' true to display second form
            // and capture the OTP code
            setVerifying(true)
          } catch (err: any) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error(JSON.stringify(err, null, 2))
          }
        }

        // Handle the submission of the verification form
        const handleVerify = async (e: React.FormEvent) => {
          e.preventDefault()

          if (!isLoaded) return

          try {
            // Use the code the user provided to attempt verification
            const signUpAttempt = await signUp.attemptEmailAddressVerification({
              code,
            })

            // If verification was completed, set the session to active
            // and redirect the user
            if (signUpAttempt.status === 'complete') {
              await setActive({ session: signUpAttempt.createdSessionId })
              router.push('/')
            } else {
              // If the status is not complete, check why. User may need to
              // complete further steps.
              console.error(JSON.stringify(signUpAttempt, null, 2))
            }
          } catch (err: any) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error('Error:', JSON.stringify(err, null, 2))
          }
        }

        // Display the verification form to capture the OTP code
        if (verifying) {
          return (
            <>
              <h1>Verify your email</h1>
              <form onSubmit={handleVerify}>
                <label id="code">Enter your verification code</label>
                <input value={code} id="code" name="code" onChange={(e) => setCode(e.target.value)} />
                <button type="submit">Verify</button>
              </form>
            </>
          )
        }

        // Display the initial sign-up form to capture the email and password
        return (
          <>
            <h1>Sign up</h1>
            <form onSubmit={handleSubmit}>
              <div>
                <label htmlFor="email">Enter email address</label>
                <input
                  id="email"
                  type="email"
                  name="email"
                  value={emailAddress}
                  onChange={(e) => setEmailAddress(e.target.value)}
                />
              </div>
              <div>
                <label htmlFor="password">Enter password</label>
                <input
                  id="password"
                  type="password"
                  name="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                />
              </div>
              <div>
                <button type="submit">Continue</button>
              </div>
            </form>
          </>
        )
      }
      ```
    </Tab>

    <Tab>
      <CodeBlockTabs options={["index.html", "main.js"]}>
        ```html {{ filename: 'index.html', collapsible: true }}
        <!doctype html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <title>Clerk + JavaScript App</title>
          </head>
          <body>
            <div id="signed-in"></div>

            <div id="sign-up">
              <h2>Sign up</h2>
              <form id="sign-up-form">
                <label for="email">Enter email address</label>
                <input type="email" name="email" id="sign-up-email" />
                <label for="password">Enter password</label>
                <input type="password" name="password" id="sign-up-password" />
                <button type="submit">Continue</button>
              </form>
            </div>

            <form id="verifying" hidden>
              <h2>Verify your email</h2>
              <label for="code">Enter your verification code</label>
              <input id="code" name="code" />
              <button type="submit" id="verify-button">Verify</button>
            </form>

            <script type="module" src="/src/main.js" async crossorigin="anonymous"></script>
          </body>
        </html>
        ```

        ```js {{ filename: 'main.js', collapsible: true }}
        import { Clerk } from '@clerk/clerk-js'

        const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

        const clerk = new Clerk(pubKey)
        await clerk.load()

        if (clerk.user) {
          // Mount user button component
          document.getElementById('signed-in').innerHTML = `
            <div id="user-button"></div>
          `

          const userbuttonDiv = document.getElementById('user-button')

          clerk.mountUserButton(userbuttonDiv)
        } else {
          // Handle the sign-up form
          document.getElementById('sign-up-form').addEventListener('submit', async (e) => {
            e.preventDefault()

            const formData = new FormData(e.target)
            const emailAddress = formData.get('email')
            const password = formData.get('password')

            try {
              // Start the sign-up process using the email and password provided
              await clerk.client.signUp.create({ emailAddress, password })
              await clerk.client.signUp.prepareEmailAddressVerification()
              // Hide sign-up form
              document.getElementById('sign-up').setAttribute('hidden', '')
              // Show verification form
              document.getElementById('verifying').removeAttribute('hidden')
            } catch (error) {
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.error(error)
            }
          })

          // Handle the verification form
          document.getElementById('verifying').addEventListener('submit', async (e) => {
            const formData = new FormData(e.target)
            const code = formData.get('code')

            try {
              // Use the code the user provided to attempt verification
              const signUpAttempt = await clerk.client.signUp.attemptEmailAddressVerification({
                code,
              })

              // Now that the user is created, set the session to active.
              await clerk.setActive({ session: signUpAttempt.createdSessionId })
            } catch (error) {
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.error(error)
            }
          })
        }
        ```
      </CodeBlockTabs>
    </Tab>

    <Tab>
      1. Create the `(auth)` route group. This groups your sign-up and sign-in pages.
      1. In the `(auth)` group, create a `_layout.tsx` file with the following code. The [`useAuth()`](/docs/hooks/use-auth) hook is used to access the user's authentication state. If the user's already signed in, they'll be redirected to the home page.

      ```tsx {{ filename: 'app/(auth)/_layout.tsx' }}
      import { Redirect, Stack } from 'expo-router'
      import { useAuth } from '@clerk/clerk-expo'

      export default function GuestLayout() {
        const { isSignedIn } = useAuth()

        if (isSignedIn) {
          return <Redirect href={'/dashboard'} />
        }

        return <Stack />
      }
      ```

      In the `(auth)` group, create a `sign-up.tsx` file with the following code. The [`useSignUp()`](/docs/hooks/use-sign-up) hook is used to create a sign-up flow. The user can sign up using their email and password and will receive an email verification code to confirm their email.

      ```tsx {{ filename: 'app/(auth)/sign-up.tsx', collapsible: true }}
      import * as React from 'react'
      import { Text, TextInput, Button, View } from 'react-native'
      import { useSignUp } from '@clerk/clerk-expo'
      import { Link, useRouter } from 'expo-router'

      export default function Page() {
        const { isLoaded, signUp, setActive } = useSignUp()
        const router = useRouter()

        const [emailAddress, setEmailAddress] = React.useState('')
        const [password, setPassword] = React.useState('')
        const [pendingVerification, setPendingVerification] = React.useState(false)
        const [code, setCode] = React.useState('')

        // Handle submission of sign-up form
        const onSignUpPress = async () => {
          if (!isLoaded) return

          // Start sign-up process using email and password provided
          try {
            await signUp.create({
              emailAddress,
              password,
            })

            // Send user an email with verification code
            await signUp.prepareEmailAddressVerification({ strategy: 'email_code' })

            // Set 'pendingVerification' to true to display second form
            // and capture OTP code
            setPendingVerification(true)
          } catch (err) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error(JSON.stringify(err, null, 2))
          }
        }

        // Handle submission of verification form
        const onVerifyPress = async () => {
          if (!isLoaded) return

          try {
            // Use the code the user provided to attempt verification
            const signUpAttempt = await signUp.attemptEmailAddressVerification({
              code,
            })

            // If verification was completed, set the session to active
            // and redirect the user
            if (signUpAttempt.status === 'complete') {
              await setActive({ session: signUpAttempt.createdSessionId })
              router.replace('/')
            } else {
              // If the status is not complete, check why. User may need to
              // complete further steps.
              console.error(JSON.stringify(signUpAttempt, null, 2))
            }
          } catch (err) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error(JSON.stringify(err, null, 2))
          }
        }

        if (pendingVerification) {
          return (
            <>
              <Text>Verify your email</Text>
              <TextInput
                value={code}
                placeholder="Enter your verification code"
                placeholderTextColor="#666666"
                onChangeText={(code) => setCode(code)}
              />
              <Button title="Verify" onPress={onVerifyPress} />
            </>
          )
        }

        return (
          <View>
            <>
              <Text>Sign up</Text>
              <TextInput
                autoCapitalize="none"
                value={emailAddress}
                placeholder="Enter email"
                placeholderTextColor="#666666"
                onChangeText={(email) => setEmailAddress(email)}
              />
              <TextInput
                value={password}
                placeholder="Enter password"
                placeholderTextColor="#666666"
                secureTextEntry={true}
                onChangeText={(password) => setPassword(password)}
              />
              <Button title="Continue" onPress={onSignUpPress} />
              <View style={{ flexDirection: 'row', gap: 4 }}>
                <Text>Have an account?</Text>
                <Link href="/sign-in">
                  <Text>Sign in</Text>
                </Link>
              </View>
            </>
          </View>
        )
      }
      ```
    </Tab>

    <Tab>
      ```swift {{ filename: 'EmailPasswordSignUpView.swift', collapsible: true }}
      import SwiftUI
      import Clerk

      struct EmailPasswordSignUpView: View {
        @State private var email = ""
        @State private var password = ""
        @State private var code = ""
        @State private var isVerifying = false

        var body: some View {
          if isVerifying {
            // Display the verification form to capture the OTP code
            TextField("Enter your verification code", text: $code)
            Button("Verify") {
              Task { await verify(code: code) }
            }
          } else {
            // Display the initial sign-up form to capture the email and password
            TextField("Enter email address", text: $email)
            SecureField("Enter password", text: $password)
            Button("Next") {
              Task { await submit(email: email, password: password) }
            }
          }
        }
      }

      extension EmailPasswordSignUpView {

        func submit(email: String, password: String) async {
          do {
            // Start the sign-up process using the email and password provided
            let signUp = try await SignUp.create(strategy: .standard(emailAddress: email, password: password))

            // Send the user an email with the verification code
            try await signUp.prepareVerification(strategy: .emailCode)

            // Set 'isVerifying' true to display second form
            // and capture the OTP code
            isVerifying = true
          } catch {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            dump(error)
          }
        }

        func verify(code: String) async {
          do {
            // Access the in progress sign up stored on the client
            guard let inProgressSignUp = Clerk.shared.client?.signUp else { return }

            // Use the code the user provided to attempt verification
            let signUp = try await inProgressSignUp.attemptVerification(strategy: .emailCode(code: code))

            switch signUp.status {
            case .complete:
              // If verification was completed, navigate the user as needed.
              dump(Clerk.shared.session)
            default:
              // If the status is not complete, check why. User may need to
              // complete further steps.
              dump(signUp.status)
            }
          } catch {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            dump(error)
          }
        }
      }
      ```
    </Tab>
  </Tabs>

  ## Sign-in flow

  To authenticate a user using their email and password, you must:

  1. Initiate the sign-in process by creating a `SignIn` using the email address and password provided.
  1. If the attempt is successful, set the newly created session as the active session.

  <Tabs items={["Next.js", "JavaScript", "Expo", "iOS"]}>
    <Tab>
      This example is written for Next.js App Router but it can be adapted for any React-based framework.

      ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx', collapsible: true }}
      'use client'

      import * as React from 'react'
      import { useSignIn } from '@clerk/nextjs'
      import { useRouter } from 'next/navigation'

      export default function SignInForm() {
        const { isLoaded, signIn, setActive } = useSignIn()
        const [email, setEmail] = React.useState('')
        const [password, setPassword] = React.useState('')
        const router = useRouter()

        // Handle the submission of the sign-in form
        const handleSubmit = async (e: React.FormEvent) => {
          e.preventDefault()

          if (!isLoaded) return

          // Start the sign-in process using the email and password provided
          try {
            const signInAttempt = await signIn.create({
              identifier: email,
              password,
            })

            // If sign-in process is complete, set the created session as active
            // and redirect the user
            if (signInAttempt.status === 'complete') {
              await setActive({ session: signInAttempt.createdSessionId })
              router.push('/')
            } else {
              // If the status is not complete, check why. User may need to
              // complete further steps.
              console.error(JSON.stringify(signInAttempt, null, 2))
            }
          } catch (err: any) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error(JSON.stringify(err, null, 2))
          }
        }

        // Display a form to capture the user's email and password
        return (
          <>
            <h1>Sign in</h1>
            <form onSubmit={(e) => handleSubmit(e)}>
              <div>
                <label htmlFor="email">Enter email address</label>
                <input
                  onChange={(e) => setEmail(e.target.value)}
                  id="email"
                  name="email"
                  type="email"
                  value={email}
                />
              </div>
              <div>
                <label htmlFor="password">Enter password</label>
                <input
                  onChange={(e) => setPassword(e.target.value)}
                  id="password"
                  name="password"
                  type="password"
                  value={password}
                />
              </div>
              <button type="submit">Sign in</button>
            </form>
          </>
        )
      }
      ```
    </Tab>

    <Tab>
      <CodeBlockTabs options={["index.html", "main.js"]}>
        ```html {{ filename: 'index.html', collapsible: true }}
        <!doctype html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <title>Clerk + JavaScript App</title>
          </head>
          <body>
            <div id="signed-in"></div>

            <div id="sign-in">
              <h2>Sign in</h2>
              <form id="sign-in-form">
                <label for="email">Enter email address</label>
                <input name="email" id="sign-in-email" />
                <label for="password">Enter password</label>
                <input name="password" id="sign-in-password" />
                <button type="submit">Continue</button>
              </form>
            </div>

            <script type="module" src="/src/main.js" async crossorigin="anonymous"></script>
          </body>
        </html>
        ```

        ```js {{ filename: 'main.js', collapsible: true }}
        import { Clerk } from '@clerk/clerk-js'

        const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

        const clerk = new Clerk(pubKey)
        await clerk.load()

        if (clerk.user) {
          // Mount user button component
          document.getElementById('signed-in').innerHTML = `
            <div id="user-button"></div>
          `

          const userbuttonDiv = document.getElementById('user-button')

          clerk.mountUserButton(userbuttonDiv)
        } else {
          // Handle the sign-in form
          document.getElementById('sign-in-form').addEventListener('submit', async (e) => {
            e.preventDefault()

            const formData = new FormData(e.target)
            const emailAddress = formData.get('email')
            const password = formData.get('password')

            try {
              // Start the sign-in process
              const signInAttempt = await clerk.client.signIn.create({
                identifier: emailAddress,
                password,
              })

              // If the sign-in is complete, set the user as active
              if (signInAttempt.status === 'complete') {
                await clerk.setActive({ session: signInAttempt.createdSessionId })

                location.reload()
              } else {
                // If the status is not complete, check why. User may need to
                // complete further steps.
                console.error(JSON.stringify(signInAttempt, null, 2))
              }
            } catch (error) {
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.error(error)
            }
          })
        }
        ```
      </CodeBlockTabs>
    </Tab>

    <Tab>
      In the `(auth)` group, create a `sign-in.tsx` file with the following code. The [`useSignIn()`](/docs/hooks/use-sign-in) hook is used to create a sign-in flow. The user can sign in using email address and password, or navigate to the sign-up page.

      ```tsx {{ filename: 'app/(auth)/sign-in.tsx', collapsible: true }}
      import { useSignIn } from '@clerk/clerk-expo'
      import { Link, useRouter } from 'expo-router'
      import { Text, TextInput, Button, View } from 'react-native'
      import React from 'react'

      export default function Page() {
        const { signIn, setActive, isLoaded } = useSignIn()
        const router = useRouter()

        const [emailAddress, setEmailAddress] = React.useState('')
        const [password, setPassword] = React.useState('')

        // Handle the submission of the sign-in form
        const onSignInPress = React.useCallback(async () => {
          if (!isLoaded) return

          // Start the sign-in process using the email and password provided
          try {
            const signInAttempt = await signIn.create({
              identifier: emailAddress,
              password,
            })

            // If sign-in process is complete, set the created session as active
            // and redirect the user
            if (signInAttempt.status === 'complete') {
              await setActive({ session: signInAttempt.createdSessionId })
              router.replace('/')
            } else {
              // If the status is not complete, check why. User may need to
              // complete further steps.
              console.error(JSON.stringify(signInAttempt, null, 2))
            }
          } catch (err) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error(JSON.stringify(err, null, 2))
          }
        }, [isLoaded, emailAddress, password])

        return (
          <View>
            <Text>Sign in</Text>
            <TextInput
              autoCapitalize="none"
              value={emailAddress}
              placeholder="Enter email"
              placeholderTextColor="#666666"
              onChangeText={(emailAddress) => setEmailAddress(emailAddress)}
            />
            <TextInput
              value={password}
              placeholder="Enter password"
              placeholderTextColor="#666666"
              secureTextEntry={true}
              onChangeText={(password) => setPassword(password)}
            />
            <Button title="Sign in" onPress={onSignInPress} />
            <View style={{ flexDirection: 'row', gap: 4 }}>
              <Text>Don't have an account?</Text>
              <Link href="/sign-up">
                <Text>Sign up</Text>
              </Link>
            </View>
          </View>
        )
      }
      ```
    </Tab>

    <Tab>
      ```swift {{ filename: 'EmailPasswordSignInView.swift', collapsible: true }}
      import SwiftUI
      import Clerk

      struct EmailPasswordSignInView: View {
        @State private var email = ""
        @State private var password = ""

        var body: some View {
          TextField("Enter email address", text: $email)
          SecureField("Enter password", text: $password)
          Button("Sign In") {
            Task { await submit(email: email, password: password) }
          }
        }
      }

      extension EmailPasswordSignInView {

        func submit(email: String, password: String) async {
          do {
            // Start the sign-in process using the email and password provided
            let signIn = try await SignIn.create(strategy: .identifier(email, password: password))

            switch signIn.status {
            case .complete:
              // If sign-in process is complete, navigate the user as needed.
              dump(Clerk.shared.session)
            default:
              // If the status is not complete, check why. User may need to
              // complete further steps.
              dump(signIn.status)
            }
          } catch {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            dump(error)
          }
        }
      }
      ```
    </Tab>
  </Tabs>
</Steps>

---
title: Build a custom flow for adding a phone number to a user's account
description: Learn how to use the Clerk API to build a custom flow for adding a phone number to a user's account.
---

<Include src="_partials/custom-flows-callout" />

Users are able to add multiple phone numbers to their account.

Every user has a [`User`](/docs/references/javascript/user) object that represents their account. The `User` object has a `phoneNumbers` property that contains all the phone numbers associated with the user.

The following example demonstrates how to build a custom user interface that allows users to add a phone number to their account. The example:

1. Uses the [`useUser()`](/docs/hooks/use-user) hook to get the `User` object.
1. Passes the [`User.createPhoneNumber()`](/docs/references/javascript/user#create-phone-number) method to the [`useReverification()`](/docs/hooks/use-reverification) hook to require the user to reverify their credentials before being able to add a phone number to their account.
1. If the `createPhoneNumber()` function is successful, a new [`PhoneNumber`](/docs/references/javascript/types/phone-number) object is created and stored in `User.phoneNumbers`.
1. Uses the `prepareVerification()` method on the newly created `PhoneNumber` object to send a verification code to the user.
1. Uses the `attemptVerification()` method on the same `PhoneNumber` object with the verification code provided by the user to verify the phone number.

<Include src="_partials/custom-flows/phone-number" />

<Tabs items={["Next.js", "iOS"]}>
  <Tab>
    ```tsx {{ filename: 'app/account/add-phone/page.tsx', collapsible: true }}
    'use client'

    import * as React from 'react'
    import { useUser, useReverification } from '@clerk/nextjs'
    import { PhoneNumberResource } from '@clerk/types'

    export default function Page() {
      const { isLoaded, user } = useUser()
      const [phone, setPhone] = React.useState('')
      const [code, setCode] = React.useState('')
      const [isVerifying, setIsVerifying] = React.useState(false)
      const [successful, setSuccessful] = React.useState(false)
      const [phoneObj, setPhoneObj] = React.useState<PhoneNumberResource | undefined>()
      const createPhoneNumber = useReverification((phone: string) =>
        user?.createPhoneNumber({ phoneNumber: phone }),
      )

      if (!isLoaded) return null

      if (isLoaded && !user?.id) {
        return <p>You must be logged in to access this page</p>
      }

      // Handle addition of the phone number
      const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault()

        try {
          // Add unverified phone number to user
          const res = await createPhoneNumber(phone)
          // Reload user to get updated User object
          await user.reload()

          // Create a reference to the new phone number to use related methods
          const phoneNumber = user.phoneNumbers.find((a) => a.id === res?.id)
          setPhoneObj(phoneNumber)

          // Send the user an SMS with the verification code
          phoneNumber?.prepareVerification()

          // Set to true to display second form
          // and capture the OTP code
          setIsVerifying(true)
        } catch (err) {
          // See https://clerk.com/docs/custom-flows/error-handling
          // for more info on error handling
          console.error(JSON.stringify(err, null, 2))
        }
      }

      // Handle the submission of the verification form
      const verifyCode = async (e: React.FormEvent) => {
        e.preventDefault()
        try {
          // Verify that the provided code matches the code sent to the user
          const phoneVerifyAttempt = await phoneObj?.attemptVerification({ code })

          if (phoneVerifyAttempt?.verification.status === 'verified') {
            setSuccessful(true)
          } else {
            // If the status is not complete, check why. User may need to
            // complete further steps.
            console.error(JSON.stringify(phoneVerifyAttempt, null, 2))
          }
        } catch (err) {
          console.error(JSON.stringify(err, null, 2))
        }
      }

      // Display a success message if the phone number was added successfully
      if (successful) {
        return (
          <>
            <h1>Phone added</h1>
          </>
        )
      }

      // Display the verification form to capture the OTP code
      if (isVerifying) {
        return (
          <>
            <h1>Verify phone</h1>
            <div>
              <form onSubmit={(e) => verifyCode(e)}>
                <div>
                  <label htmlFor="code">Enter code</label>
                  <input
                    onChange={(e) => setCode(e.target.value)}
                    id="code"
                    name="code"
                    type="text"
                    value={code}
                  />
                </div>
                <div>
                  <button type="submit">Verify</button>
                </div>
              </form>
            </div>
          </>
        )
      }

      // Display the initial form to capture the phone number
      return (
        <>
          <h1>Add phone</h1>
          <div>
            <form onSubmit={(e) => handleSubmit(e)}>
              <div>
                <label htmlFor="phone">Enter phone number</label>
                <input
                  onChange={(e) => setPhone(e.target.value)}
                  id="phone"
                  name="phone"
                  type="phone"
                  value={phone}
                />
              </div>
              <div>
                <button type="submit">Continue</button>
              </div>
            </form>
          </div>
        </>
      )
    }
    ```
  </Tab>

  <Tab>
    ```swift {{ filename: 'AddPhoneView.swift', collapsible: true }}
    import SwiftUI
    import Clerk

    struct AddPhoneView: View {
      @State private var phone = ""
      @State private var code = ""
      @State private var isVerifying = false
      // Create a reference to the phone number that we'll be creating
      @State private var newPhoneNumber: PhoneNumber?

      var body: some View {
        if newPhoneNumber?.verification?.status == .verified {
          Text("Phone added!")
        }

        if isVerifying {
          TextField("Enter code", text: $code)
          Button("Verify") {
            Task { await verifyCode(code) }
          }
        } else {
          TextField("Enter phone number", text: $phone)
          Button("Continue") {
            Task { await createPhone(phone) }
          }
        }
      }
    }

    extension AddPhoneView {

      func createPhone(_ phone: String) async {
        do {
          guard let user = Clerk.shared.user else { return }

          // Add an unverified phone number to user,
          // then send the user an sms message with the verification code
          self.newPhoneNumber = try await user
            .createPhoneNumber(phone)
            .prepareVerification()

          // Set to true to display second form
          // and capture the OTP code
          isVerifying = true
        } catch {
          // See https://clerk.com/docs/custom-flows/error-handling
          // for more info on error handling
          dump(error)
        }
      }

      func verifyCode(_ code: String) async {
        do {
          guard let newPhoneNumber else { return }

          // Verify that the code entered matches the code sent to the user
          self.newPhoneNumber = try await newPhoneNumber.attemptVerification(code: code)

          // If the status is not complete, check why. User may need to
          // complete further steps.
          dump(self.newPhoneNumber?.verification?.status)
        } catch {
          // See https://clerk.com/docs/custom-flows/error-handling
          // for more info on error handling
          dump(error)
        }
      }
    }
    ```
  </Tab>
</Tabs>

---
title: Build a custom flow for adding an email to a user's account
description: Learn how to use the Clerk API to build a custom flow for adding an email to a user's account.
---

<Include src="_partials/custom-flows-callout" />

Users are able to add multiple email addresses to their account. Adding an email address requires the user to verify the email address before it can be added to the user's account.

This guide demonstrates how to build a custom user interface that allows users to add and verify an email address for their account.

## Configure email verification

There are two verification methods available for email addresses:

- Email code verification: Users receive an email with a **verification code** to verify their email address.
- Email link verification: Users receive an email with a **verification link** to verify their email address.

By default, the verification method that is enabled is email code verification. To use email code verification, skip to the [Email code verification](#email-code-verification) section.

To use email links, you must configure the following settings in the Clerk Dashboard:

1. On the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page of the Clerk Dashboard, next to **Email address**, select the settings icon. A modal will open.
1. Under **Verification methods**, enable the **Email verification link** option. By default, **Require the same device and browser** is enabled, which means that email links are required to be verified from the same device and browser on which the sign-up or sign-in was initiated. For this guide, leave this setting enabled.
1. Uncheck the box for **Email verification code**.
1. Select **Continue** to save your changes.

Then skip to the [Email link verification](#email-link-verification) section.

## Email code verification

1. Every user has a [`User`](/docs/references/javascript/user) object that represents their account. The `User` object has a `emailAddresses` property that contains all the email addresses associated with the user. The [`useUser()`](/docs/hooks/use-user) hook is used to get the `User` object.
1. The [`User.createEmailAddress()`](/docs/references/javascript/user#create-email-address) method is passed to the [`useReverification()`](/docs/hooks/use-reverification) hook to require the user to reverify their credentials before being able to add an email address to their account.
1. If the `createEmailAddress()` function is successful, a new [`EmailAddress`](/docs/references/javascript/types/email-address) object is created and stored in `User.emailAddresses`.
1. The `prepareVerification()` method is used on the newly created `EmailAddress` object to send a verification code to the user.
1. The `attemptVerification()` method is used on the same `EmailAddress` object with the verification code provided by the user to verify the email address.

<Tabs items={["Next.js", "iOS"]}>
  <Tab>
    ```tsx {{ filename: 'app/account/add-email/page.tsx', collapsible: true }}
    'use client'

    import * as React from 'react'
    import { useUser, useReverification } from '@clerk/nextjs'
    import { EmailAddressResource } from '@clerk/types'

    export default function Page() {
      const { isLoaded, user } = useUser()
      const [email, setEmail] = React.useState('')
      const [code, setCode] = React.useState('')
      const [isVerifying, setIsVerifying] = React.useState(false)
      const [successful, setSuccessful] = React.useState(false)
      const [emailObj, setEmailObj] = React.useState<EmailAddressResource | undefined>()
      const createEmailAddress = useReverification((email: string) =>
        user?.createEmailAddress({ email }),
      )

      if (!isLoaded) return null

      if (isLoaded && !user?.id) {
        return <p>You must be logged in to access this page</p>
      }

      // Handle addition of the email address
      const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault()

        try {
          // Add an unverified email address to user
          const res = await createEmailAddress(email)
          // Reload user to get updated User object
          await user.reload()

          // Find the email address that was just added
          const emailAddress = user.emailAddresses.find((a) => a.id === res?.id)
          // Create a reference to the email address that was just added
          setEmailObj(emailAddress)

          // Send the user an email with the verification code
          emailAddress?.prepareVerification({ strategy: 'email_code' })

          // Set to true to display second form
          // and capture the OTP code
          setIsVerifying(true)
        } catch (err) {
          // See https://clerk.com/docs/custom-flows/error-handling
          // for more info on error handling
          console.error(JSON.stringify(err, null, 2))
        }
      }

      // Handle the submission of the verification form
      const verifyCode = async (e: React.FormEvent) => {
        e.preventDefault()
        try {
          // Verify that the code entered matches the code sent to the user
          const emailVerifyAttempt = await emailObj?.attemptVerification({ code })

          if (emailVerifyAttempt?.verification.status === 'verified') {
            setSuccessful(true)
          } else {
            // If the status is not complete, check why. User may need to
            // complete further steps.
            console.error(JSON.stringify(emailVerifyAttempt, null, 2))
          }
        } catch (err) {
          console.error(JSON.stringify(err, null, 2))
        }
      }

      // Display a success message if the email was added successfully
      if (successful) {
        return (
          <>
            <h1>Email added!</h1>
          </>
        )
      }

      // Display the verification form to capture the OTP code
      if (isVerifying) {
        return (
          <>
            <h1>Verify email</h1>
            <div>
              <form onSubmit={(e) => verifyCode(e)}>
                <div>
                  <label htmlFor="code">Enter code</label>
                  <input
                    onChange={(e) => setCode(e.target.value)}
                    id="code"
                    name="code"
                    type="text"
                    value={code}
                  />
                </div>
                <div>
                  <button type="submit">Verify</button>
                </div>
              </form>
            </div>
          </>
        )
      }

      // Display the initial form to capture the email address
      return (
        <>
          <h1>Add Email</h1>
          <div>
            <form onSubmit={(e) => handleSubmit(e)}>
              <div>
                <label htmlFor="email">Enter email address</label>
                <input
                  onChange={(e) => setEmail(e.target.value)}
                  id="email"
                  name="email"
                  type="email"
                  value={email}
                />
              </div>
              <div>
                <button type="submit">Continue</button>
              </div>
            </form>
          </div>
        </>
      )
    }
    ```
  </Tab>

  <Tab>
    ```swift {{ filename: 'AddEmailView.swift', collapsible: true }}
    import SwiftUI
    import Clerk

    struct AddEmailView: View {
      @State private var email = ""
      @State private var code = ""
      @State private var isVerifying = false
      // Create a reference to the email address that we'll be creating
      @State private var newEmailAddress: EmailAddress?

      var body: some View {
        if newEmailAddress?.verification?.status == .verified {
          Text("Email added!")
        }

        if isVerifying {
          TextField("Enter code", text: $code)
          Button("Verify") {
            Task { await verifyCode(code) }
          }
        } else {
          TextField("Enter email address", text: $email)
          Button("Continue") {
            Task { await createEmail(email) }
          }
        }
      }
    }

    extension AddEmailView {

      func createEmail(_ email: String) async {
        do {
          guard let user = Clerk.shared.user else { return }

          // Add an unverified email address to user,
          // then send the user an email with the verification code
          self.newEmailAddress = try await user
            .createEmailAddress(email)
            .prepareVerification(strategy: .emailCode)

          // Set to true to display second form
          // and capture the OTP code
          isVerifying = true
        } catch {
          // See https://clerk.com/docs/custom-flows/error-handling
          // for more info on error handling
          dump(error)
        }
      }

      func verifyCode(_ code: String) async {
        do {
          guard let newEmailAddress else { return }

          // Verify that the code entered matches the code sent to the user
          self.newEmailAddress = try await newEmailAddress.attemptVerification(strategy: .emailCode(code: code))

          // If the status is not complete, check why. User may need to
          // complete further steps.
          dump(self.newEmailAddress?.verification?.status)
        } catch {
          // See https://clerk.com/docs/custom-flows/error-handling
          // for more info on error handling
          dump(error)
        }
      }
    }
    ```
  </Tab>
</Tabs>

## Email link verification

<If sdk="expo">
  > [!WARNING]
  > Expo does not support email links. You can request this feature on [Clerk's roadmap](https://feedback.clerk.com/).
</If>

<Include src="_partials/custom-flows/email-link-verification" />

---
title: Build a custom flow for authenticating with enterprise connections
description: Learn how to use the Clerk API to build a custom sign-up and sign-in flow that supports enterprise connections.
---

<Include src="_partials/custom-flows-callout" />

## Before you start

You must configure your application instance through the Clerk Dashboard for the enterprise connection(s) that you want to use. Visit [the appropriate guide for your platform](/docs/authentication/enterprise-connections/overview) to learn how to configure your instance.

## Create the sign-up and sign-in flow

<Tabs items={["Next.js", "Expo"]}>
  <Tab>
    <Include src="_partials/custom-flows/sso-connections" />

    <CodeBlockTabs options={["Sign in page", "SSO callback page"]}>
      ```tsx {{ filename: 'app/sign-in/page.tsx' }}
      'use client'

      import * as React from 'react'
      import { useSignIn } from '@clerk/nextjs'

      export default function Page() {
        const { signIn, isLoaded } = useSignIn()

        const signInWithEnterpriseSSO = (e: React.FormEvent) => {
          e.preventDefault()

          if (!isLoaded) return null

          const email = (e.target as HTMLFormElement).email.value

          signIn
            .authenticateWithRedirect({
              identifier: email,
              strategy: 'enterprise_sso',
              redirectUrl: '/sign-in/sso-callback',
              redirectUrlComplete: '/',
            })
            .then((res) => {
              console.log(res)
            })
            .catch((err: any) => {
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.log(err.errors)
              console.error(err, null, 2)
            })
        }

        return (
          <form onSubmit={(e) => signInWithEnterpriseSSO(e)}>
            <input id="email" type="email" name="email" placeholder="Enter email address" />
            <button>Sign in with Enterprise SSO</button>
          </form>
        )
      }
      ```

      ```jsx {{ filename: 'app/sign-in/sso-callback/page.tsx' }}
      import { AuthenticateWithRedirectCallback } from '@clerk/nextjs'

      export default function Page() {
        // Handle the redirect flow by calling the Clerk.handleRedirectCallback() method
        // or rendering the prebuilt <AuthenticateWithRedirectCallback/> component.
        // This is the final step in the custom Enterprise SSO flow.
        return <AuthenticateWithRedirectCallback />
      }
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    > [!IMPORTANT]
    > Expo supports [SAML](/docs/authentication/enterprise-connections/overview#saml) Enterprise SSO, but does not support [OIDC](/docs/authentication/enterprise-connections/overview#oidc).

    The following example **will both sign up _and_ sign in users**, eliminating the need for a separate sign-up page.

    The following example:

    1. Uses the [`useSSO()`](/docs/references/expo/use-sso) hook to access the `startSSOFlow()` method.
    1. Calls the `startSSOFlow()` method with the `strategy` param set to `enterprise_sso` and the `identifier` param set to the user's email address that they provided. The optional `redirect_url` param is also set in order to redirect the user once they finish the authentication flow.
       - If authentication is successful, the `setActive()` method is called to set the active session with the new `createdSessionId`.
       - If authentication is not successful, you can handle the missing requirements, such as MFA, using the [`signIn`](/docs/references/javascript/sign-in) or [`signUp`](/docs/references/javascript/sign-up) object returned from `startSSOFlow()`, depending on if the user is signing in or signing up. These objects include properties, like `status`, that can be used to determine the next steps. See the respective linked references for more information.

    ```tsx {{ filename: 'app/(auth)/sign-in.tsx', collapsible: true }}
    import React, { useEffect, useState } from 'react'
    import * as WebBrowser from 'expo-web-browser'
    import * as AuthSession from 'expo-auth-session'
    import { useSSO } from '@clerk/clerk-expo'
    import { View, Button, TextInput } from 'react-native'

    export const useWarmUpBrowser = () => {
      useEffect(() => {
        // Preloads the browser for Android devices to reduce authentication load time
        // See: https://docs.expo.dev/guides/authentication/#improving-user-experience
        void WebBrowser.warmUpAsync()
        return () => {
          // Cleanup: closes browser when component unmounts
          void WebBrowser.coolDownAsync()
        }
      }, [])
    }

    // Handle any pending authentication sessions
    WebBrowser.maybeCompleteAuthSession()

    export default function Page() {
      useWarmUpBrowser()

      const [email, setEmail] = useState('')

      // Use the `useSSO()` hook to access the `startSSOFlow()` method
      const { startSSOFlow } = useSSO()

      const onPress = async () => {
        try {
          // Start the authentication process by calling `startSSOFlow()`
          const { createdSessionId, setActive, signIn, signUp } = await startSSOFlow({
            strategy: 'enterprise_sso',
            identifier: email,
            // For web, defaults to current path
            // For native, you must pass a scheme, like AuthSession.makeRedirectUri({ scheme, path })
            // For more info, see https://docs.expo.dev/versions/latest/sdk/auth-session/#authsessionmakeredirecturioptions
            redirectUrl: AuthSession.makeRedirectUri(),
          })

          // If sign in was successful, set the active session
          if (createdSessionId) {
            setActive!({ session: createdSessionId })
          } else {
            // If there is no `createdSessionId`,
            // there are missing requirements, such as MFA
            // Use the `signIn` or `signUp` returned from `startSSOFlow`
            // to handle next steps
          }
        } catch (err) {
          // See https://clerk.com/docs/custom-flows/error-handling
          // for more info on error handling
          console.error(JSON.stringify(err, null, 2))
        }
      }

      return (
        <View>
          <TextInput
            value={email}
            onChangeText={setEmail}
            placeholder="Enter email"
            placeholderTextColor="#666666"
          />
          <Button title="Sign in with SAML" onPress={onPress} />
        </View>
      )
    }
    ```
  </Tab>
</Tabs>

---
title: Build a custom flow for authenticating with OAuth connections
description: Learn how to use the Clerk API to build a custom sign-up and sign-in flow that supports OAuth connections.
---

<Include src="_partials/custom-flows-callout" />

## Before you start

You must configure your application instance through the Clerk Dashboard for the social connection(s) that you want to use. Visit [the appropriate guide for your platform](/docs/authentication/social-connections/oauth) to learn how to configure your instance.

## Create the sign-up and sign-in flow

<Tabs items={["Next.js", "Expo", "iOS"]}>
  <Tab>
    <Include src="_partials/custom-flows/sso-connections" />

    <CodeBlockTabs options={["Sign in page", "SSO callback page"]}>
      ```tsx {{ filename: 'app/sign-in/page.tsx' }}
      'use client'

      import * as React from 'react'
      import { OAuthStrategy } from '@clerk/types'
      import { useSignIn } from '@clerk/nextjs'

      export default function OauthSignIn() {
        const { signIn } = useSignIn()

        if (!signIn) return null

        const signInWith = (strategy: OAuthStrategy) => {
          return signIn
            .authenticateWithRedirect({
              strategy,
              redirectUrl: '/sign-up/sso-callback',
              redirectUrlComplete: '/',
            })
            .then((res) => {
              console.log(res)
            })
            .catch((err: any) => {
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.log(err.errors)
              console.error(err, null, 2)
            })
        }

        // Render a button for each supported OAuth provider
        // you want to add to your app. This example uses only Google.
        return (
          <div>
            <button onClick={() => signInWith('oauth_google')}>Sign in with Google</button>
          </div>
        )
      }
      ```

      ```tsx {{ filename: 'app/sign-in/sso-callback/page.tsx' }}
      import { AuthenticateWithRedirectCallback } from '@clerk/nextjs'

      export default function Page() {
        // Handle the redirect flow by calling the Clerk.handleRedirectCallback() method
        // or rendering the prebuilt <AuthenticateWithRedirectCallback/> component.
        // This is the final step in the custom OAuth flow.
        return <AuthenticateWithRedirectCallback />
      }
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    The following example **will both sign up _and_ sign in users**, eliminating the need for a separate sign-up page.

    The following example:

    1. Uses the [`useSSO()`](/docs/references/expo/use-sso) hook to access the `startSSOFlow()` method.
    1. Calls the `startSSOFlow()` method with the `strategy` param set to `oauth_google`, but you can use any of the [supported OAuth strategies](/docs/references/javascript/types/sso#o-auth-strategy). The optional `redirect_url` param is also set in order to redirect the user once they finish the authentication flow.
       - If authentication is successful, the `setActive()` method is called to set the active session with the new `createdSessionId`.
       - If authentication is not successful, you can handle the missing requirements, such as MFA, using the [`signIn`](/docs/references/javascript/sign-in) or [`signUp`](/docs/references/javascript/sign-up) object returned from `startSSOFlow()`, depending on if the user is signing in or signing up. These objects include properties, like `status`, that can be used to determine the next steps. See the respective linked references for more information.

    ```tsx {{ filename: 'app/(auth)/sign-in.tsx', collapsible: true }}
    import React, { useCallback, useEffect } from 'react'
    import * as WebBrowser from 'expo-web-browser'
    import * as AuthSession from 'expo-auth-session'
    import { useSSO } from '@clerk/clerk-expo'
    import { View, Button } from 'react-native'

    export const useWarmUpBrowser = () => {
      useEffect(() => {
        // Preloads the browser for Android devices to reduce authentication load time
        // See: https://docs.expo.dev/guides/authentication/#improving-user-experience
        void WebBrowser.warmUpAsync()
        return () => {
          // Cleanup: closes browser when component unmounts
          void WebBrowser.coolDownAsync()
        }
      }, [])
    }

    // Handle any pending authentication sessions
    WebBrowser.maybeCompleteAuthSession()

    export default function Page() {
      useWarmUpBrowser()

      // Use the `useSSO()` hook to access the `startSSOFlow()` method
      const { startSSOFlow } = useSSO()

      const onPress = useCallback(async () => {
        try {
          // Start the authentication process by calling `startSSOFlow()`
          const { createdSessionId, setActive, signIn, signUp } = await startSSOFlow({
            strategy: 'oauth_google',
            // For web, defaults to current path
            // For native, you must pass a scheme, like AuthSession.makeRedirectUri({ scheme, path })
            // For more info, see https://docs.expo.dev/versions/latest/sdk/auth-session/#authsessionmakeredirecturioptions
            redirectUrl: AuthSession.makeRedirectUri(),
          })

          // If sign in was successful, set the active session
          if (createdSessionId) {
            setActive!({ session: createdSessionId })
          } else {
            // If there is no `createdSessionId`,
            // there are missing requirements, such as MFA
            // Use the `signIn` or `signUp` returned from `startSSOFlow`
            // to handle next steps
          }
        } catch (err) {
          // See https://clerk.com/docs/custom-flows/error-handling
          // for more info on error handling
          console.error(JSON.stringify(err, null, 2))
        }
      }, [])

      return (
        <View>
          <Button title="Sign in with Google" onPress={onPress} />
        </View>
      )
    }
    ```
  </Tab>

  <Tab>
    ```swift {{ filename: 'OAuthView.swift', collapsible: true }}
    import SwiftUI
    import Clerk

    struct OAuthView: View {
      var body: some View {
        // Render a button for each supported OAuth provider
        // you want to add to your app. This example uses only Google.
        Button("Sign In with Google") {
          Task { await signInWithOAuth(provider: .google) }
        }
      }
    }

    extension OAuthView {

      func signInWithOAuth(provider: OAuthProvider) async {
        do {
          // Start the sign-in process using the selected OAuth provider.
          let result = try await SignIn.authenticateWithRedirect(strategy: .oauth(provider: provider))

          // It is common for users who are authenticating with OAuth to use
          // a sign-in button when they mean to sign-up, and vice versa.
          // Clerk will handle this transfer for you if possible.
          // Therefore, a TransferFlowResult can be either a SignIn or SignUp.

          switch result {
          case .signIn(let signIn):
            switch signIn.status {
            case .complete:
              // If sign-in process is complete, navigate the user as needed.
              dump(Clerk.shared.session)
            default:
              // If the status is not complete, check why. User may need to
              // complete further steps.
              dump(signIn.status)
            }
          case .signUp(let signUp):
            switch signUp.status {
            case .complete:
              // If sign-up process is complete, navigate the user as needed.
              dump(Clerk.shared.session)
            default:
              // If the status is not complete, check why. User may need to
              // complete further steps.
              dump(signUp.status)
            }
          }

        } catch {
          // See https://clerk.com/docs/custom-flows/error-handling
          // for more info on error handling.
          dump(error)
        }
      }
    }
    ```
  </Tab>
</Tabs>

---
title: Build a custom flow for creating and managing organization invitations
description: Learn how to use the Clerk API to build a custom flow for creating and managing organization invitations.
---

<Include src="_partials/custom-flows-callout" />

Organization members with appropriate [permissions](/docs/organizations/roles-permissions) can invite new users to their organization and manage those invitations. The invitation recipient can be either an existing user of your application or a new user. If they are a new user, they will need to sign up in order to accept the invitation.

Users with the appropriate permissions can also revoke organization invitations for users that have not yet joined, which will prevent the user from becoming an organization member.

This guide will demonstrate how to use the Clerk API to build a custom flow for inviting users to an organization and managing an organization's pending invitations.

> [!NOTE]
> This guide is for creating and managing organization invitations client-side. You can also create an organization invitation using the Backend API. See the [organization invitations reference](/docs/organizations/invitations) for more information.
>
> Also, see the [custom flow for accepting organization invitations](/docs/custom-flows/accept-organization-invitations).

<Tabs items={["Next.js", "JavaScript"]}>
  <Tab>
    To invite a user:

    1. Use the [`useOrganization()`](/docs/hooks/use-organization) hook to get `organization`, which is the active organization.
    1. Use `organization` to call the [`inviteMember()`](/docs/references/javascript/organization#invite-member) method, with the recipient's email address and desired role passed as arguments.

    To revoke an invitation:

    1. Use the `useOrganization()` hook to get `invitations`, which is a list of invitations for the active organization.
    1. `invitations` is an array of [`OrganizationInvitation`](/docs/references/javascript/types/organization-invitation) objects. Each `OrganizationInvitation` object has a [`revoke()`](/docs/references/javascript/types/organization-invitation#revoke) method that can be called to revoke the invitation.

    The following example includes:

    - An `<InviteMember />` component that allows administrators to invite new members to their organization.
    - An `<InvitationList />` component that lists all pending invitations and allows administrators to revoke them.

    This example is written for Next.js App Router but can be adapted for any React-based framework.

    ```tsx {{ filename: 'app/components/InvitationList.tsx', collapsible: true }}
    'use client'

    import { useOrganization } from '@clerk/nextjs'
    import { OrganizationCustomRoleKey } from '@clerk/types'
    import { ChangeEventHandler, useEffect, useRef, useState } from 'react'

    export const OrgMembersParams = {
      memberships: {
        pageSize: 5,
        keepPreviousData: true,
      },
    }

    export const OrgInvitationsParams = {
      invitations: {
        pageSize: 5,
        keepPreviousData: true,
      },
    }

    // Form to invite a new member to the organization.
    export const InviteMember = () => {
      const { isLoaded, organization, invitations } = useOrganization(OrgInvitationsParams)
      const [emailAddress, setEmailAddress] = useState('')
      const [disabled, setDisabled] = useState(false)

      if (!isLoaded || !organization) {
        return <>Loading</>
      }

      const onSubmit = async (e: React.ChangeEvent<HTMLFormElement>) => {
        e.preventDefault()

        const submittedData = Object.fromEntries(new FormData(e.currentTarget).entries()) as {
          email: string | undefined
          role: OrganizationCustomRoleKey | undefined
        }

        if (!submittedData.email || !submittedData.role) {
          return
        }

        setDisabled(true)
        await organization.inviteMember({
          emailAddress: submittedData.email,
          role: submittedData.role,
        })
        await invitations?.revalidate?.()
        setEmailAddress('')
        setDisabled(false)
      }

      return (
        <form onSubmit={onSubmit}>
          <input
            name="email"
            type="text"
            placeholder="Email address"
            value={emailAddress}
            onChange={(e) => setEmailAddress(e.target.value)}
          />
          <label>Role</label>
          <SelectRole fieldName={'role'} />
          <button type="submit" disabled={disabled}>
            Invite
          </button>
        </form>
      )
    }

    type SelectRoleProps = {
      fieldName?: string
      isDisabled?: boolean
      onChange?: ChangeEventHandler<HTMLSelectElement>
      defaultRole?: string
    }

    const SelectRole = (props: SelectRoleProps) => {
      const { fieldName, isDisabled = false, onChange, defaultRole } = props
      const { organization } = useOrganization()
      const [fetchedRoles, setRoles] = useState<OrganizationCustomRoleKey[]>([])
      const isPopulated = useRef(false)

      useEffect(() => {
        if (isPopulated.current) return
        organization
          ?.getRoles({
            pageSize: 20,
            initialPage: 1,
          })
          .then((res) => {
            isPopulated.current = true
            setRoles(res.data.map((roles) => roles.key as OrganizationCustomRoleKey))
          })
      }, [organization?.id])

      if (fetchedRoles.length === 0) return null

      return (
        <select
          name={fieldName}
          disabled={isDisabled}
          aria-disabled={isDisabled}
          onChange={onChange}
          defaultValue={defaultRole}
        >
          {fetchedRoles?.map((roleKey) => (
            <option key={roleKey} value={roleKey}>
              {roleKey}
            </option>
          ))}
        </select>
      )
    }

    // List of pending invitations to an organization.
    export const InvitationList = () => {
      const { isLoaded, invitations, memberships } = useOrganization({
        ...OrgInvitationsParams,
        ...OrgMembersParams,
      })

      if (!isLoaded) {
        return <>Loading</>
      }

      return (
        <>
          <table>
            <thead>
              <tr>
                <th>User</th>
                <th>Invited</th>
                <th>Role</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {invitations?.data?.map((inv) => (
                <tr key={inv.id}>
                  <td>{inv.emailAddress}</td>
                  <td>{inv.createdAt.toLocaleDateString()}</td>
                  <td>{inv.role}</td>
                  <td>
                    <button
                      onClick={async () => {
                        await inv.revoke()
                        await Promise.all([memberships?.revalidate, invitations?.revalidate])
                      }}
                    >
                      Revoke
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>

          <div>
            <button
              disabled={!invitations?.hasPreviousPage || invitations?.isFetching}
              onClick={() => invitations?.fetchPrevious?.()}
            >
              Previous
            </button>

            <button
              disabled={!invitations?.hasNextPage || invitations?.isFetching}
              onClick={() => invitations?.fetchNext?.()}
            >
              Next
            </button>
          </div>
        </>
      )
    }
    ```
  </Tab>

  <Tab>
    To check if the current user is an organization admin:

    1. Get the active organization's ID from the `clerk` object.
    1. Call the [`getOrganizationMemberships()`](/docs/references/javascript/user#get-organization-memberships) method to get a list of organizations that the user is a member of. This method returns `data`, which is an array of `OrganizationMembership` objects.
    1. In the list of organizations that the user is a member of, find the `OrganizationMembership` object that has an ID that matches the active organization's ID.
    1. Check the `role` property of the `OrganizationMembership` object to see if the user is an admin.

    To invite a user:

    1. Use the active `organization` object to call the [`inviteMember()`](/docs/references/javascript/organization#invite-member) method, with the recipient's email address and desired role passed as arguments.

    To revoke an invitation:

    1. Use the active `organization` object to call the [`getInvitations()`](/docs/references/javascript/organization#get-invitations) method to get an array of `OrganizationInvitation` objects.
    1. Each `OrganizationInvitation` object has a [`revoke()`](/docs/references/javascript/types/organization-invitation#revoke) method that can be called to revoke the invitation.

    The following example includes:

    - A `renderInvitations()` function that lists all invitations and allows administrators to revoke them.
    - An `checkAdminAndRenderInvitations()` function that gets the current organization, checks if the current user is an admin, renders invitations, and sets up a form that allows administrators to invite new members to their organization.

    Use the tabs to view the code necessary for the `index.html` and `main.js` files.

    <CodeBlockTabs options={["index.html", "main.js"]}>
      ```html {{ filename: 'index.html', collapsible: true }}
      <!doctype html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Clerk + JavaScript App</title>
        </head>
        <body>
          <div id="app"></div>

          <h2>Invitations List</h2>
          <ul id="invitations_list"></ul>

          <h2>Send a new invitation</h2>
          <form id="new_invitation">
            <div>
              <label>Email address</label>

              <input type="email" id="email_address" name="email_address" />
            </div>
            <button>Invite</button>
          </form>

          <script type="module" src="/src/main.js" async crossorigin="anonymous"></script>
        </body>
      </html>
      ```

      ```js {{ filename: 'main.js', collapsible: true }}
      import { Clerk } from '@clerk/clerk-js'

      const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

      if (!pubKey) {
        throw new Error('Add your VITE_CLERK_PUBLISHABLE_KEY to .env file')
      }

      const clerk = new Clerk('{{pub_key}}')
      await clerk.load()

      if (clerk.user) {
        // Check for an active organization
        if (clerk.organization) {
          // Render list of organization invitations
          async function renderInvitations(organization, isAdmin) {
            const list = document.getElementById('invitations_list')
            try {
              const { data } = await organization.getInvitations()

              const invitations = data

              if (invitations.length === 0) {
                list.textContent = 'No invitations'
              }

              invitations.map((invitation) => {
                const li = document.createElement('li')
                li.textContent = `${invitation.emailAddress} - ${invitation.role}`

                // Add administrative actions; revoke invitation
                if (isAdmin) {
                  const revokeBtn = document.createElement('button')
                  revokeBtn.textContent = 'Revoke'
                  revokeBtn.addEventListener('click', async function (e) {
                    e.preventDefault()
                    await invitation.revoke()
                  })
                  li.appendChild(revokeBtn)
                }
                // Add the entry to the list
                list.appendChild(li)
              })
            } catch (err) {
              console.error(err)
            }
          }

          // Gets the current org, checks if the current user is an admin,
          // renders invitations, and sets up the new invitation form.
          async function checkAdminAndRenderInvitations() {
            // This is the current organization ID.
            const organizationId = clerk.organization.id

            const { data } = await clerk.user.getOrganizationMemberships()
            const organizationMemberships = data

            const currentMembership = organizationMemberships.find(
              (membership) => membership.organization.id === organizationId,
            )
            const currentOrganization = currentMembership.organization

            if (!currentOrganization) return

            const isAdmin = currentMembership.role === 'org:admin'

            renderInvitations(currentOrganization, isAdmin)

            if (isAdmin) {
              const form = document.getElementById('new_invitation')
              form.addEventListener('submit', async function (e) {
                e.preventDefault()

                const inputEl = document.getElementById('email_address')

                if (!inputEl) return

                try {
                  await currentOrganization.inviteMember({
                    emailAddress: inputEl.value,
                    role: 'org:member',
                  })
                } catch (err) {
                  console.error(err)
                }
              })
            }
          }

          checkAdminAndRenderInvitations()
        } else {
          // If there is no active organization,
          // mount Clerk's <OrganizationSwitcher />
          // to allow the user to set an organization as active
          document.getElementById('app').innerHTML = `
            <h2>Select an organization to set it as active</h2>
            <div id="org-switcher"></div>
          `

          const orgSwitcherDiv = document.getElementById('org-switcher')

          clerk.mountOrganizationSwitcher(orgSwitcherDiv)
        }
      } else {
        // If there is no active user, mount Clerk's <SignIn />
        document.getElementById('app').innerHTML = `
          <div id="sign-in"></div>
        `

        const signInDiv = document.getElementById('sign-in')

        clerk.mountSignIn(signInDiv)
      }
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

## Next steps

Now that you've created a flow for managing organization invitations, you might want to create a flow for accepting invitations. See the [dedicated custom flow guide](/docs/custom-flows/accept-organization-invitations) for more information.

---
title: Build a custom flow for creating organizations
description: Learn how to use the Clerk API to build a custom flow for creating organizations.
---

<Include src="_partials/custom-flows-callout" />

This guide demonstrates how to use Clerk's API to build a custom flow for creating organizations.

<Tabs items={["Next.js", "JavaScript"]}>
  <Tab>
    The following example uses the [`useOrganizationList()`](/docs/hooks/use-organization-list) hook to access the `createOrganization()` method. This method is used to create a new organization with the provided name.

    This example is written for Next.js App Router but can be adapted for any React-based framework.

    ```tsx {{ filename: 'app/components/CreateOrganization.tsx' }}
    'use client'

    import { useOrganizationList } from '@clerk/nextjs'
    import { FormEventHandler, useState } from 'react'

    export default function CreateOrganization() {
      const { isLoaded, createOrganization } = useOrganizationList()
      const [organizationName, setOrganizationName] = useState('')

      if (!isLoaded) return null

      const handleSubmit: FormEventHandler<HTMLFormElement> = async (e) => {
        e.preventDefault()
        createOrganization({ name: organizationName })
          .then((res) => {
            console.log(res)
          })
          .catch((err) => {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error(JSON.stringify(err, null, 2))
          })
        setOrganizationName('')
      }

      return (
        <form onSubmit={handleSubmit}>
          <input
            type="text"
            name="organizationName"
            value={organizationName}
            onChange={(e) => setOrganizationName(e.currentTarget.value)}
          />
          <button type="submit">Create organization</button>
        </form>
      )
    }
    ```
  </Tab>

  <Tab>
    The following example uses the [`clerk.createOrganization()`](/docs/references/javascript/clerk#create-organization) method to create a new organization with the provided name.

    Use the tabs to view the code necessary for the `index.html` and `main.js` files.

    <CodeBlockTabs options={["index.html", "main.js"]}>
      ```html {{ filename: 'index.html' }}
      <!doctype html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Clerk + JavaScript App</title>
        </head>
        <body>
          <div id="app"></div>

          <h1>Create an organization</h1>
          <form id="create-organization">
            <label for="name">Name</label>
            <input id="name" name="name" />
            <button>Create organization</button>
          </form>

          <script type="module" src="/src/main.js" async crossorigin="anonymous"></script>
        </body>
      </html>
      ```

      ```js {{ filename: 'main.js' }}
      import { Clerk } from '@clerk/clerk-js'

      const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

      if (!pubKey) {
        throw new Error('Add your VITE_CLERK_PUBLISHABLE_KEY to .env file')
      }

      const clerk = new Clerk(pubKey)
      await clerk.load()

      if (clerk.user) {
        const form = document.getElementById('create-organization')

        form.addEventListener('submit', function (e) {
          e.preventDefault()

          const inputEl = document.getElementById('name')

          if (!inputEl) {
            // ... handle empty input
            return
          }

          clerk
            .createOrganization({ name: inputEl.value })
            .then((res) => console.log(res))
            .catch((error) => console.log('An error occurred:', error))
        })
      } else {
        // If there is no active user, mount Clerk's <SignIn />
        document.getElementById('app').innerHTML = `
          <div id="sign-in"></div>
        `

        const signInDiv = document.getElementById('sign-in')

        clerk.mountSignIn(signInDiv)
      }
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

---
title: Build a custom flow for handling email links
description: Learn how to build a custom flow using Clerk's API to handle email links for sign-up, sign-in, and email address verification.
---

<Include src="_partials/custom-flows-callout" />

<If sdk="expo">
  > [!WARNING]
  > Expo does not support email links. You can request this feature on [Clerk's roadmap](https://feedback.clerk.com/).
</If>

[Email links](/docs/authentication/configuration/sign-up-sign-in-options#email-link) can be used to sign up new users, sign in existing users, or allow existing users to verify newly added email addresses to their user profiles.

The email link flow works as follows:

1. The user enters their email address and asks for an email link.
1. Clerk sends an email to the user, containing a link to the verification URL.
1. The user visits the email link, either on the same device where they entered their email address or on a different device, depending on the settings in the Clerk Dashboard.
1. Clerk verifies the user's identity and advances any sign-up or sign-in attempt that might be in progress.
1. If the verification is successful, the user is authenticated or their email address is verified, depending on the reason for the email link.

This guide demonstrates how to use Clerk's API to build a custom flow for handling email links. It covers the following scenarios:

- [Sign up](#sign-up-flow)
- [Sign in](#sign-in-flow)
- [Verify a new email address](#add-new-email-flow)

<Steps>
  ## Enable email link authentication

  To allow your users to sign up or sign in using email links, you must first configure the appropriate settings in the Clerk Dashboard.

  1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
  1. For this guide, ensure that _only_ **Email address** is required. If **Phone number**, **Username**, or **Name** are enabled, ensure they are not required. Use the settings icon next to each option to verify if it's required or optional. If you would like to require any of these, you'll need to combine their custom flows with the email link custom flow.
  1. In the **Authentication strategies** section, ensure **only** **Email verification link** is enabled. By default, **Require the same device and browser** is enabled, which means that email links are required to be verified from the same device and browser on which the sign-up or sign-in was initiated. For this guide, leave this setting enabled.
  1. Keep this page open to enable email link verification in the next step.

  ## Enable email link verification

  [**Verification methods**](/docs/authentication/configuration/sign-up-sign-in-options#verification-methods) are different from [**authentication strategies**](/docs/authentication/configuration/sign-up-sign-in-options#authentication-strategies). **Authentication strategies** are used for authenticating a user, such as when they are signing in to your application. **Verification methods** are used for verifying a user's identifier, such as an email address upon initial sign-up or when adding a new email to their account.

  To allow your users to verify their email addresses using email links, configure the following settings:

  1. On the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page of the Clerk Dashboard, next to **Email address**, select the settings icon. A modal will open.
  1. Under **Verification methods**, enable the **Email verification link** option. By default, **Require the same device and browser** is enabled, which means that email links are required to be verified from the same device and browser on which the sign-up or sign-in was initiated. For this guide, leave this setting enabled.
  1. Because this guide focuses on email links, uncheck the box for **Email verification code**.
  1. Select **Continue** to save your changes.

  ## Sign-up flow

  1. The [`useSignUp()`](/docs/hooks/use-sign-up) hook is used to get the [`SignUp`](/docs/references/javascript/sign-up) object.
  1. The `SignUp` object is used to access the [`createEmailLinkFlow()`](/docs/references/javascript/types/email-address#create-email-link-flow) method.
  1. The `createEmailLinkFlow()` method is used to access the `startEmailLinkFlow()` method.
  1. The `startEmailLinkFlow()` method is called with the `redirectUrl` parameter set to `/sign-up/verify`. It sends an email with a verification link to the user. When the user visits the link, they are redirected to the URL that was provided.
  1. On the `/sign-up/verify` page, the [`useClerk()`](/docs/hooks/use-clerk) hook is used to get the [`handleEmailLinkVerification()`](/docs/references/javascript/clerk#handle-email-link-verification) method.
  1. The `handleEmailLinkVerification()` method is called to verify the email address. Error handling is included to handle any errors that occur during the verification process.

  <Tabs items={["Next.js"]}>
    <Tab>
      <CodeBlockTabs options={["Sign up page", "Verify page"]}>
        ```tsx {{ filename: 'app/sign-up/page.tsx', collapsible: true }}
        'use client'

        import * as React from 'react'
        import { useSignUp } from '@clerk/nextjs'

        export default function SignInPage() {
          const [emailAddress, setEmailAddress] = React.useState('')
          const [verified, setVerified] = React.useState(false)
          const [verifying, setVerifying] = React.useState(false)
          const [error, setError] = React.useState('')
          const { signUp, isLoaded } = useSignUp()

          if (!isLoaded) return null

          const { startEmailLinkFlow } = signUp.createEmailLinkFlow()

          async function submit(e: React.FormEvent) {
            e.preventDefault()
            // Reset states in case user resubmits form mid sign-up
            setVerified(false)
            setError('')

            setVerifying(true)

            if (!isLoaded && !signUp) return null

            // Start the sign-up process using the email provided
            try {
              await signUp.create({
                emailAddress,
              })

              // Dynamically set the host domain for dev and prod
              // You could instead use an environment variable or other source for the host domain
              const protocol = window.location.protocol
              const host = window.location.host

              // Send the user an email with the email link
              const signUpAttempt = await startEmailLinkFlow({
                // URL to navigate to after the user visits the link in their email
                redirectUrl: `${protocol}//${host}/sign-up/verify`,
              })

              // Check the verification result
              const verification = signUpAttempt.verifications.emailAddress

              // Handle if user visited the link and completed sign-up from /sign-up/verify
              if (verification.verifiedFromTheSameClient()) {
                setVerifying(false)
                setVerified(true)
              }
            } catch (err: any) {
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.error(JSON.stringify(err, null, 2))

              if (err.errors?.[0]?.longMessage) {
                console.log('Clerk error:', err.errors[0].longMessage)
                setError(err.errors[0].longMessage)
              } else {
                setError('An error occurred.')
              }
            }
          }

          async function reset(e: React.FormEvent) {
            e.preventDefault()
            setVerifying(false)
          }

          if (error) {
            return (
              <div>
                <p>Error: {error}</p>
                <button onClick={() => setError('')}>Try again</button>
              </div>
            )
          }

          if (verifying) {
            return (
              <div>
                <p>Check your email and visit the link that was sent to you.</p>
                <form onSubmit={reset}>
                  <button type="submit">Restart</button>
                </form>
              </div>
            )
          }

          if (verified) {
            return <div>Signed up successfully!</div>
          }

          return (
            <div>
              <h1>Sign up</h1>
              <form onSubmit={submit}>
                <input
                  type="email"
                  placeholder="Enter email address"
                  value={emailAddress}
                  onChange={(e) => setEmailAddress(e.target.value)}
                />
                <button type="submit">Continue</button>
              </form>
            </div>
          )
        }
        ```

        ```tsx {{ filename: 'app/sign-up/verify/page.tsx', collapsible: true }}
        'use client'

        import * as React from 'react'
        import { useClerk } from '@clerk/nextjs'
        import { EmailLinkErrorCodeStatus, isEmailLinkError } from '@clerk/nextjs/errors'
        import Link from 'next/link'

        export default function VerifyEmailLink() {
          const [verificationStatus, setVerificationStatus] = React.useState('loading')

          const { handleEmailLinkVerification, loaded } = useClerk()

          async function verify() {
            try {
              // Dynamically set the host domain for dev and prod
              // You could instead use an environment variable or other source for the host domain
              const protocol = window.location.protocol
              const host = window.location.host

              await handleEmailLinkVerification({
                // URL to navigate to if sign-up flow needs more requirements, such as MFA
                redirectUrl: `${protocol}//${host}/sign-up`,
              })

              // If not redirected at this point,
              // the flow has completed
              setVerificationStatus('verified')
            } catch (err: any) {
              let status = 'failed'

              if (isEmailLinkError(err)) {
                // If link expired, set status to expired
                if (err.code === EmailLinkErrorCodeStatus.Expired) {
                  status = 'expired'
                } else if (err.code === EmailLinkErrorCodeStatus.ClientMismatch) {
                  // OPTIONAL: This check is only required if you have
                  // the 'Require the same device and browser' setting
                  // enabled in the Clerk Dashboard
                  status = 'client_mismatch'
                }
              }

              setVerificationStatus(status)
            }
          }

          React.useEffect(() => {
            if (!loaded) return

            verify()
          }, [handleEmailLinkVerification, loaded])

          if (verificationStatus === 'loading') {
            return <div>Loading...</div>
          }

          if (verificationStatus === 'failed') {
            return (
              <div>
                <h1>Verify your email</h1>
                <p>The email link verification failed.</p>
                <Link href="/sign-up">Sign up</Link>
              </div>
            )
          }

          if (verificationStatus === 'expired') {
            return (
              <div>
                <h1>Verify your email</h1>
                <p>The email link has expired.</p>
                <Link href="/sign-up">Sign up</Link>
              </div>
            )
          }

          // OPTIONAL: This check is only required if you have
          // the 'Require the same device and browser' setting
          // enabled in the Clerk Dashboard
          if (verificationStatus === 'client_mismatch') {
            return (
              <div>
                <h1>Verify your email</h1>
                <p>
                  You must complete the email link sign-up on the same device and browser that you started
                  it on.
                </p>
                <Link href="/sign-up">Sign up</Link>
              </div>
            )
          }

          return (
            <div>
              <h1>Verify your email</h1>
              <p>Successfully signed up. Return to the original tab to continue.</p>
            </div>
          )
        }
        ```
      </CodeBlockTabs>
    </Tab>
  </Tabs>

  ## Sign-in flow

  1. The [`useSignIn()`](/docs/hooks/use-sign-in) hook is used to get the [`SignIn`](/docs/references/javascript/sign-in) object.
  1. The `SignIn` object is used to access the [`createEmailLinkFlow()`](/docs/references/javascript/types/email-address#create-email-link-flow) method.
  1. The `createEmailLinkFlow()` method is used to access the `startEmailLinkFlow()` method.
  1. The `startEmailLinkFlow()` method is called with the `redirectUrl` parameter set to `/sign-in/verify`. It sends an email with a verification link to the user. When the user visits the link, they are redirected to the URL that was provided.
  1. On the `/sign-in/verify` page, the [`useClerk()`](/docs/hooks/use-clerk) hook is used to get the [`handleEmailLinkVerification()`](/docs/references/javascript/clerk#handle-email-link-verification) method.
  1. The `handleEmailLinkVerification()` method is called to verify the email address. Error handling is included to handle any errors that occur during the verification process.

  <Tabs items={["Next.js"]}>
    <Tab>
      <CodeBlockTabs options={["Sign in page", "Verify page"]}>
        ```tsx {{ filename: 'app/sign-in/page.tsx', collapsible: true }}
        'use client'

        import * as React from 'react'
        import { useSignIn } from '@clerk/nextjs'
        import { EmailLinkFactor, SignInFirstFactor } from '@clerk/types'

        export default function SignInPage() {
          const [emailAddress, setEmailAddress] = React.useState('')
          const [verified, setVerified] = React.useState(false)
          const [verifying, setVerifying] = React.useState(false)
          const [error, setError] = React.useState('')
          const { signIn, isLoaded } = useSignIn()

          if (!isLoaded) return null

          const { startEmailLinkFlow } = signIn.createEmailLinkFlow()

          async function submit(e: React.FormEvent) {
            e.preventDefault()
            // Reset states in case user resubmits form mid sign-in
            setVerified(false)
            setError('')

            if (!isLoaded && !signIn) return null

            // Start the sign-in process using the email provided
            try {
              const { supportedFirstFactors } = await signIn.create({
                identifier: emailAddress,
              })

              setVerifying(true)

              // Filter the returned array to find the 'email_link' entry
              const isEmailLinkFactor = (factor: SignInFirstFactor): factor is EmailLinkFactor => {
                return factor.strategy === 'email_link'
              }
              const emailLinkFactor = supportedFirstFactors?.find(isEmailLinkFactor)

              if (!emailLinkFactor) {
                setError('Email link factor not found')
                return
              }

              const { emailAddressId } = emailLinkFactor

              // Dynamically set the host domain for dev and prod
              // You could instead use an environment variable or other source for the host domain
              const protocol = window.location.protocol
              const host = window.location.host

              // Send the user an email with the email link
              const signInAttempt = await startEmailLinkFlow({
                emailAddressId,
                redirectUrl: `${protocol}//${host}/sign-in/verify`,
              })

              // Check the verification result
              const verification = signInAttempt.firstFactorVerification

              // Handle if verification expired
              if (verification.status === 'expired') {
                setError('The email link has expired.')
              }

              // Handle if user visited the link and completed sign-in from /sign-in/verify
              if (verification.verifiedFromTheSameClient()) {
                setVerifying(false)
                setVerified(true)
              }
            } catch (err: any) {
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.error(JSON.stringify(err, null, 2))
              setError('An error occurred.')
            }
          }

          async function reset(e: React.FormEvent) {
            e.preventDefault()
            setVerifying(false)
          }

          if (error) {
            return (
              <div>
                <p>Error: {error}</p>
                <button onClick={() => setError('')}>Try again</button>
              </div>
            )
          }

          if (verifying) {
            return (
              <div>
                <p>Check your email and visit the link that was sent to you.</p>
                <form onSubmit={reset}>
                  <button type="submit">Restart</button>
                </form>
              </div>
            )
          }

          if (verified) {
            return <div>Signed in successfully!</div>
          }

          return (
            <div>
              <h1>Sign in</h1>
              <form onSubmit={submit}>
                <input
                  type="email"
                  placeholder="Enter email address"
                  value={emailAddress}
                  onChange={(e) => setEmailAddress(e.target.value)}
                />
                <button type="submit">Continue</button>
              </form>
            </div>
          )
        }
        ```

        ```tsx {{ filename: 'app/sign-in/verify/page.tsx', collapsible: true }}
        'use client'

        import * as React from 'react'
        import { useClerk } from '@clerk/nextjs'
        import { EmailLinkErrorCodeStatus, isEmailLinkError } from '@clerk/nextjs/errors'
        import Link from 'next/link'

        export default function VerifyEmailLink() {
          const [verificationStatus, setVerificationStatus] = React.useState('loading')

          const { handleEmailLinkVerification, loaded } = useClerk()

          async function verify() {
            try {
              // Dynamically set the host domain for dev and prod
              // You could instead use an environment variable or other source for the host domain
              const protocol = window.location.protocol
              const host = window.location.host

              await handleEmailLinkVerification({
                // URL to navigate to if sign-in flow needs more requirements, such as MFA
                redirectUrl: `${protocol}//${host}/sign-in`,
              })

              // If not redirected at this point,
              // the flow has completed
              setVerificationStatus('verified')
            } catch (err: any) {
              let status = 'failed'

              if (isEmailLinkError(err)) {
                // If link expired, set status to expired
                if (err.code === EmailLinkErrorCodeStatus.Expired) {
                  status = 'expired'
                } else if (err.code === EmailLinkErrorCodeStatus.ClientMismatch) {
                  // OPTIONAL: This check is only required if you have
                  // the 'Require the same device and browser' setting
                  // enabled in the Clerk Dashboard
                  status = 'client_mismatch'
                }
              }

              setVerificationStatus(status)
              return
            }
          }

          React.useEffect(() => {
            if (!loaded) return

            verify()
          }, [handleEmailLinkVerification, loaded])

          if (verificationStatus === 'loading') {
            return <div>Loading...</div>
          }

          if (verificationStatus === 'failed') {
            return (
              <div>
                <h1>Verify your email</h1>
                <p>The email link verification failed.</p>
                <Link href="/sign-in">Sign in</Link>
              </div>
            )
          }

          if (verificationStatus === 'expired') {
            return (
              <div>
                <h1>Verify your email</h1>
                <p>The email link has expired.</p>
                <Link href="/sign-in">Sign in</Link>
              </div>
            )
          }

          // OPTIONAL: This check is only required if you have
          // the 'Require the same device and browser' setting
          // enabled in the Clerk Dashboard
          if (verificationStatus === 'client_mismatch') {
            return (
              <div>
                <h1>Verify your email</h1>
                <p>
                  You must complete the email link sign-in on the same device and browser as you started it
                  on.
                </p>
                <Link href="/sign-in">Sign in</Link>
              </div>
            )
          }

          return (
            <div>
              <h1>Verify your email</h1>
              <p>Successfully signed in. Return to the original tab to continue.</p>
            </div>
          )
        }
        ```
      </CodeBlockTabs>
    </Tab>
  </Tabs>

  ## Add new email flow

  When a user adds an email address to their account, you can use email links to verify the email address.

  <Include src="_partials/custom-flows/email-link-verification" />
</Steps>

---
title: Build a custom flow for handling user impersonation
description: Learn how to build a custom flow using the Clerk API that handles user impersonation.
---

<Include src="_partials/custom-flows-callout" />

[Clerk's user impersonation feature](/docs/users/user-impersonation) allows you to sign in to your application as one of your users, enabling you to directly reproduce and remedy any issues they're experiencing. It's a helpful feature for customer support and debugging.

This guide will walk you through how to build a custom flow that handles user impersonation.

<Tabs items={["Next.js", "Expo"]}>
  <Tab>
    The following example builds a dashboard that is only accessible to users with the `org:admin:impersonate` permission. To use this example, you must first [create the custom `org:admin:impersonate` permission](/docs/organizations/roles-permissions#custom-permissions). Or you can modify the [authorization checks](/docs/organizations/verify-user-permissions) to fit your use case.

    In the dashboard, the user will see a list of the application's users. When the user chooses to impersonate a user, they will be signed in as that user and redirected to the homepage.

    Use the following tabs to view the code for:

    - The main page that gets the list of the application's users using the [JavaScript Backend SDK](/docs/references/backend/user/get-user-list)
    - The Client Component that has the UI for displaying the users and the ability to impersonate them
    - The Server Action that generates the actor token using the [Backend API](/docs/reference/backend-api/tag/Actor-Tokens#operation/CreateActorToken){{ target: '_blank' }}

    <CodeBlockTabs options={["Main page", "Client Component", "Server Action"]}>
      ```tsx {{ filename: 'app/dashboard/page.tsx' }}
      import { auth, clerkClient } from '@clerk/nextjs/server'
      import ImpersonateUsers from './_components'

      export default async function AccountPage() {
        const { has } = await auth()

        // Protect the page
        if (!has({ permission: 'org:admin:impersonate' })) {
          return <p>You do not have permission to access this page.</p>
        }

        const client = await clerkClient()

        // Fetch list of application's users using Clerk's Backend SDK
        const users = await client.users.getUserList()

        // This page needs to be a server component to use clerkClient.users.getUserList()
        // You must pass the list of users to the client for the rest of the logic
        // But you cannot pass the entire User object to the client,
        // because its too complex. So grab the data you need, like so:
        const parsedUsers = []
        for (const user of users.data) {
          parsedUsers.push({
            id: user.id,
            email: user.primaryEmailAddress?.emailAddress,
          })
        }

        // Pass the parsed users to the Client Component
        return <ImpersonateUsers users={parsedUsers} />
      }
      ```

      ```tsx {{ filename: 'app/dashboard/_components.tsx' }}
      'use client'

      import React from 'react'
      import { useUser, useSignIn } from '@clerk/nextjs'
      import { generateActorToken } from './_actions'
      import { useRouter } from 'next/navigation'

      type ParsedUser = {
        id: string
        email: string | undefined
      }

      export type Actor = {
        object: string
        id: string
        status: 'pending' | 'accepted' | 'revoked'
        user_id: string
        actor: object
        token: string | null
        url: string | null
        created_at: Number
        updated_at: Number
      }

      // Create an actor token for the impersonation
      async function createActorToken(actorId: string, userId: string) {
        const res = await generateActorToken(actorId, userId) // The Server Action to generate the actor token

        if (!res.ok) console.log('Error', res.message)

        return res.token
      }

      export default function ImpersonateUsers({ users }: { users: ParsedUser[] }) {
        const { isLoaded, signIn, setActive } = useSignIn()
        const router = useRouter()
        const { user } = useUser()

        if (!user?.id) return null

        // Handle "Impersonate" button click
        async function impersonateUser(actorId: string, userId: string) {
          if (!isLoaded) return

          const actorToken = await createActorToken(actorId, userId)

          // Sign in as the impersonated user
          if (actorToken) {
            try {
              const { createdSessionId } = await signIn.create({
                strategy: 'ticket',
                ticket: actorToken,
              })

              await setActive({ session: createdSessionId })

              router.push('/')
            } catch (err) {
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.error(JSON.stringify(err, null, 2))
            }
          }
        }

        return (
          <>
            <p>Hello {user?.primaryEmailAddress?.emailAddress}</p>

            <h1>Users</h1>
            <ul>
              {users?.map((userFromUserList) => {
                return (
                  <li key={userFromUserList.id} style={{ display: 'flex', gap: '4px' }}>
                    <p>{userFromUserList?.email ? userFromUserList.email : userFromUserList.id}</p>
                    <button onClick={async () => await impersonateUser(user.id, userFromUserList.id)}>
                      Impersonate
                    </button>
                  </li>
                )
              })}
            </ul>
          </>
        )
      }
      ```

      ```tsx {{ filename: 'app/dashboard/_actions.ts' }}
      'use server'

      import { auth } from '@clerk/nextjs/server'

      export async function generateActorToken(actorId: string, userId: string) {
        // Check if the user has the permission to impersonate
        if (!auth().has({ permission: 'org:admin:impersonate' })) {
          return {
            ok: false,
            message: 'You do not have permission to access this page.',
          }
        }

        const params = JSON.stringify({
          user_id: userId,
          actor: {
            sub: actorId,
          },
        })

        // Create an actor token using Clerk's Backend API
        const res = await fetch('https://api.clerk.com/v1/actor_tokens', {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${process.env.CLERK_SECRET_KEY}`,
            'Content-type': 'application/json',
          },
          body: params,
        })

        if (!res.ok) {
          return { ok: false, message: 'Failed to generate actor token' }
        }
        const data = await res.json()

        return { ok: true, token: data.token }
      }
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    The following example creates a basic dashboard for impersonating users.

    <Steps>
      ### Protect the dashboard route

      > [!WARNING]
      > It is **recommended** that you build impersonation into a dashboard that **only authorized users** can access.

      1. Create the `dashboard/` directory.
      1. In the `dashboard/` directory, create a `_layout.tsx` file with the following code. The [`useAuth()`](/docs/hooks/use-auth) hook is used to access the user's authentication state. If the user is already signed in, they'll be redirected to the home page. The [`<Protect>`](/docs/components/protect) component is used to ensure that only users with the `org:dashboard:access` permission can access it. You can modify the `permission` attribute to fit your use case.

      ```tsx {{ filename: 'app/dashboard/_layout.tsx' }}
      import { Redirect, Stack } from 'expo-router'
      import { Protect, useAuth } from '@clerk/clerk-expo'
      import { Text } from 'react-native'

      export default function GuestLayout() {
        const { isSignedIn } = useAuth()

        if (!isSignedIn) {
          return <Redirect href={'/'} />
        }

        return (
          <Protect
            permission="org:dashboard:access"
            fallback={<Text>You don't have the permissions to access the dashboard.</Text>}
          >
            <Stack />
          </Protect>
        )
      }
      ```

      ### Create an API route to generate actor tokens

      To sign in as a different user, you must supply an actor token when creating a session.

      Create the `generateActorToken+api.tsx` file with the following code. This creates an API route that will call Clerk's Backend API [`/actor_tokens`](/docs/reference/backend-api/tag/Actor-Tokens#operation/CreateActorToken) endpoint to create an actor token.

      ```tsx {{ filename: 'app/generateActorToken+api.tsx', collapsible: true }}
      export async function POST(req: Request) {
        const { actorId, userId } = await req.json()

        try {
          // Create an actor token using Clerk's Backend API
          const res = await fetch('https://api.clerk.com/v1/actor_tokens', {
            method: 'POST',
            headers: {
              Authorization: `Bearer ${process.env.CLERK_SECRET_KEY}`,
              'Content-type': 'application/json',
            },
            body: JSON.stringify({
              user_id: userId,
              actor: {
                sub: actorId,
              },
            }),
          })

          const data = await res.json()

          return Response.json(data)
        } catch (err) {
          return Response.json({ error: 'Failed to generate actor token' }, { status: 500 })
        }
      }
      ```

      ### Create a hook to get users

      To impersonate a user, you need a list of your application's users to be able to select one for impersonation.

      1. Create the `hooks/` directory.
      1. In the `hooks/` directory, create the `useUsers.tsx` file with the following code. This creates a hook that will fetch the list of your application's users.

      ```tsx {{ filename: 'app/hooks/useUsers.tsx', collapsible: true }}
      import { UserJSON } from '@clerk/types'
      import { useEffect, useState } from 'react'

      type UseUsersReturn = {
        users: UserJSON[] | null
        isLoading: boolean
        error: Error | null
      }

      /**
       * Returns a list of users for the application.
       *
       * Until the users are fetched, `isLoading` will be set to `true`.
       *
       * @example
       *
       * import { useUsers } from '@/app/hooks/useUsers';
       *
       * function Hello() {
       *   const { users, isLoading, error } = useUsers();
       *   if(isLoading) {
       *     return <div>Loading...</div>;
       *   }
       *   return <div>Users: {users?.map((user) => user.firstName).join(', ')}</div>
       * }
       */
      export default function useUsers(): UseUsersReturn {
        const [users, setUsers] = useState<UserJSON[] | null>(null)
        const [isLoading, setIsLoading] = useState(true)
        const [error, setError] = useState<Error | null>(null)

        useEffect(() => {
          const getUsers = async () => {
            try {
              const res = await fetch('/getUsers')
              if (!res.ok) {
                throw new Error('Failed to fetch users')
              }
              const data = await res.json()
              setUsers(data)
            } catch (err) {
              setError(err instanceof Error ? err : new Error('Unknown error'))
            } finally {
              setIsLoading(false)
            }
          }

          getUsers()
        }, []) // Remove users from dependency array to prevent infinite loop

        return { users, isLoading, error }
      }
      ```

      ### Create the dashboard UI

      1. In the `dashboard/` directory, create the `index.tsx` file with the following code. This creates the UI for the dashboard, which displays a list of users and allows you to impersonate one.

      ```tsx {{ filename: 'app/dashboard/index.tsx', collapsible: true }}
      import React, { useState } from 'react'
      import { Button, Text, View } from 'react-native'
      import { useRouter } from 'expo-router'
      import { useUser, useSignIn } from '@clerk/clerk-expo'
      import useUsers from '../hooks/useUsers'

      export default function Dashboard() {
        const [error, setError] = useState<string | null>(null)

        const { isLoaded, signIn, setActive } = useSignIn()
        const { user } = useUser()
        const router = useRouter()
        const { users, isLoading } = useUsers()

        if (!user?.id) return null

        // Create an actor token for the impersonation
        async function createActorToken(actorId: string, userId: string) {
          setError(null)

          try {
            const res = await fetch('/generateActorToken', {
              method: 'POST',
              body: JSON.stringify({
                actorId,
                userId,
              }),
            })

            const data = await res.json()

            if (data.errors) {
              setError(data.errors[0].long_message)
              return null
            }

            return data.token
          } catch (err) {
            setError('Failed to generate actor token')
            return null
          }
        }

        // Handle "Impersonate" button click
        async function impersonateUser(actorId: string, userId: string) {
          setError(null)
          if (!isLoaded) return

          // Calls your /generateActorToken API route
          const actorToken = await createActorToken(actorId, userId)

          // Sign in as the impersonated user
          if (actorToken) {
            try {
              const { createdSessionId } = await signIn.create({
                strategy: 'ticket',
                ticket: actorToken,
              })

              await setActive({ session: createdSessionId })

              router.push('/')
            } catch (err) {
              setError('Failed to impersonate user')
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.error(JSON.stringify(err, null, 2))
            }
          }
        }

        return (
          <View>
            <Text style={{ fontSize: 24, fontWeight: 'bold', padding: 10 }}>
              Welcome to the dashboard, {user?.firstName}!
            </Text>
            <Text style={{ fontSize: 16, padding: 10 }}>Your user ID is {user?.id}</Text>

            {isLoading && <Text>Loading your users...</Text>}

            {!isLoading && users && (
              <View style={{ padding: 10 }}>
                <View style={{ flexDirection: 'row', padding: 5, borderBottomWidth: 1 }}>
                  <Text style={{ flex: 1, fontWeight: 'bold' }}>User ID</Text>
                  <Text style={{ flex: 1, fontWeight: 'bold' }}>Email ID</Text>
                  <Text style={{ flex: 1, fontWeight: 'bold' }}>First Name</Text>
                  <Text style={{ flex: 1, fontWeight: 'bold' }}>Actions</Text>
                </View>
                {users.map((userFromList) => {
                  const primaryEmail = userFromList.email_addresses?.find(
                    (email) => email.id === userFromList.primary_email_address_id,
                  )
                  return (
                    <View key={userFromList.id} style={{ flexDirection: 'row', padding: 5 }}>
                      <Text style={{ flex: 1 }}>{userFromList.id}</Text>
                      <Text style={{ flex: 1 }}>{primaryEmail?.id || 'N/A'}</Text>
                      <Text style={{ flex: 1 }}>{userFromList.first_name || 'N/A'}</Text>
                      <View style={{ flex: 1 }}>
                        {/* Don't allow impersonation of yourself */}
                        {userFromList.id !== user.id ? (
                          <Button
                            title="Impersonate"
                            onPress={async () => await impersonateUser(user.id, userFromList.id)}
                          />
                        ) : (
                          <Text>You cannot impersonate yourself</Text>
                        )}
                      </View>
                    </View>
                  )
                })}
              </View>
            )}

            {error && (
              <View style={{ padding: 10, backgroundColor: '#ffebee' }}>
                <Text style={{ color: '#c62828' }}>{error}</Text>
              </View>
            )}
          </View>
        )
      }
      ```
    </Steps>
  </Tab>
</Tabs>

---
title: Build a custom flow for managing a user's organization invitations
description: Learn how to use the Clerk API to build a custom flow for managing a user's organization invitations.
---

<Include src="_partials/custom-flows-callout" />

This guide will demonstrate how to use the Clerk API to build a custom flow for managing a user's [organization invitations](/docs/organizations/overview#organization-invitations).

<Tabs items={["Next.js", "JavaScript"]}>
  <Tab>
    The following example:

    1. Uses the [`useOrganizationList()`](/docs/hooks/use-organization) hook to get `userInvitations`, which is a list of the user's organization invitations.
       - `userInvitations` is an object with `data` that contains an array of [`UserOrganizationInvitation`](/docs/references/javascript/types/user-organization-invitation) objects.
       - Each `UserOrganizationInvitation` object has an [`accept()`](/docs/references/javascript/types/organization-membership-request#accept) method that accepts the invitation to the organization.
    1. Maps over the `data` array to display the invitations in a table, providing an "Accept" button for each invitation that calls the `accept()` method.

    This example is written for Next.js App Router but can be adapted for any React-based framework.

    ```jsx {{ filename: 'app/components/UserInvitationsList.tsx', collapsible: true }}
    'use client'

    import { useOrganizationList } from '@clerk/clerk-react'
    import React from 'react'

    export default function UserInvitationsList() {
      const { isLoaded, userInvitations } = useOrganizationList({
        userInvitations: {
          infinite: true,
          keepPreviousData: true,
        },
      })

      if (!isLoaded || userInvitations.isLoading) {
        return <>Loading</>
      }

      return (
        <>
          <h1>Organization invitations</h1>
          <table>
            <thead>
              <tr>
                <th>Email</th>
                <th>Organization name</th>
                <th>Role</th>
                <th>Actions</th>
              </tr>
            </thead>

            <tbody>
              {userInvitations.data?.map((invitation) => (
                <tr key={invitation.id}>
                  <td>{invitation.emailAddress}</td>
                  <td>{invitation.publicOrganizationData.name}</td>
                  <td>{invitation.role}</td>
                  <td>
                    <button onClick={() => invitation.accept()}>Accept</button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>

          <button disabled={!userInvitations.hasNextPage} onClick={userInvitations.fetchNext}>
            Load more
          </button>
        </>
      )
    }
    ```
  </Tab>

  <Tab>
    The following example:

    1. Calls the [`getOrganizationInvitations()`](/docs/references/javascript/user#get-organization-invitations) method to retrieve the list of organization invitations for the active user. This method returns `data`, which is an array of [`UserOrganizationInvitation`](/docs/references/javascript/types/user-organization-invitation) objects.
    1. Maps over the `data` array to display the invitations in a table.
    1. Provides an "Accept" button for each invitation that calls the [`accept()`](/docs/references/javascript/types/user-organization-invitation#accept) method.

    Use the following tabs to view the code necessary for the `index.html` and `main.js` files.

    <CodeBlockTabs options={["index.html", "main.js"]}>
      ```html {{ filename: 'index.html', collapsible: true }}
      <!doctype html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Clerk + JavaScript App</title>
        </head>
        <body>
          <div id="app"></div>

          <h1>Organization invitations</h1>
          <table>
            <thead>
              <tr>
                <th>Email</th>
                <th>Organization name</th>
                <th>Role</th>
                <th>Status</th>
                <th>Actions</th>
              </tr>
            </thead>

            <tbody id="invitations-table-body"></tbody>
          </table>

          <script type="module" src="/src/main.js" async crossorigin="anonymous"></script>
        </body>
      </html>
      ```

      ```js {{ filename: 'main.js', collapsible: true }}
      import { Clerk } from '@clerk/clerk-js'

      const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

      if (!pubKey) {
        throw new Error('Add your VITE_CLERK_PUBLISHABLE_KEY to .env file')
      }

      const clerk = new Clerk('{{pub_key}}')
      await clerk.load()

      if (clerk.user) {
        const { data } = await clerk.user.getOrganizationInvitations()
        const invitations = data

        invitations.map((invitation) => {
          const tableBody = document.getElementById('invitations-table-body')
          const row = tableBody.insertRow()
          row.insertCell().textContent = invitation.emailAddress
          row.insertCell().textContent = invitation.publicOrganizationData.name
          row.insertCell().textContent = invitation.role
          row.insertCell().textContent = invitation.status

          // Show accept button for pending invitations
          if (invitation.status === 'pending') {
            const acceptBtn = document.createElement('button')
            acceptBtn.textContent = 'Accept'
            acceptBtn.addEventListener('click', async function (e) {
              e.preventDefault()
              await invitation.accept()
            })
            row.insertCell().appendChild(acceptBtn)
          }
        })
      } else {
        // If there is no active user, mount Clerk's <SignIn />
        document.getElementById('app').innerHTML = `
          <div id="sign-in"></div>
        `

        const signInDiv = document.getElementById('sign-in')

        clerk.mountSignIn(signInDiv)
      }
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

---
title: Build a custom flow for managing member roles in an organization
description: Learn how to use the Clerk API build a custom flow for managing member roles in an organization.
---

<Include src="_partials/custom-flows-callout" />

Organization members with appropriate [permissions](/docs/organizations/roles-permissions#permissions) can manage a member's [role](/docs/organizations/roles-permissions#roles) and remove members within an organization.

This guide will demonstrate how to use the Clerk API to build a custom flow for managing member roles in an organization.

<Tabs items={["Next.js", "JavaScript"]}>
  <Tab>
    The following example:

    1. Uses the [`useOrganization()`](/docs/hooks/use-organization) hook to get `memberships`, which is a list of the active organization's memberships.
       - `memberships` is an object with `data` that contains an array of [`OrganizationMembership`](/docs/references/javascript/types/organization-membership) objects.
       - Each `OrganizationMembership` object has an [`update()`](/docs/references/javascript/types/organization-membership#update) and [`destroy()`](/docs/references/javascript/types/organization-membership#destroy) method to update the member's role and remove the member from the organization, respectively.
    1. Maps over the `data` array to display the memberships in a table, providing an "Update Role" and "Remove Member" button for each membership that calls the `update()` and `destroy()` methods, respectively.

    This example is written for Next.js App Router but can be adapted for any React-based framework.

    ```tsx {{ filename: 'app/components/ManageRoles.tsx', collapsible: true }}
    'use client'

    import { useState, useEffect, ChangeEventHandler, useRef } from 'react'
    import { useOrganization, useUser } from '@clerk/nextjs'
    import type { OrganizationCustomRoleKey } from '@clerk/types'

    export const OrgMembersParams = {
      memberships: {
        pageSize: 5,
        keepPreviousData: true,
      },
    }

    // List of organization memberships. Administrators can
    // change member roles or remove members from the organization.
    export const ManageRoles = () => {
      const { user } = useUser()
      const { isLoaded, memberships } = useOrganization(OrgMembersParams)

      if (!isLoaded) {
        return <>Loading</>
      }

      return (
        <>
          <h1>Memberships List</h1>
          <table>
            <thead>
              <tr>
                <th>User</th>
                <th>Joined</th>
                <th>Role</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {memberships?.data?.map((mem) => (
                <tr key={mem.id}>
                  <td>
                    {mem.publicUserData.identifier} {mem.publicUserData.userId === user?.id && '(You)'}
                  </td>
                  <td>{mem.createdAt.toLocaleDateString()}</td>
                  <td>
                    <SelectRole
                      defaultRole={mem.role}
                      onChange={async (e) => {
                        await mem.update({
                          role: e.target.value as OrganizationCustomRoleKey,
                        })
                        await memberships?.revalidate()
                      }}
                    />
                  </td>
                  <td>
                    <button
                      onClick={async () => {
                        await mem.destroy()
                        await memberships?.revalidate()
                      }}
                    >
                      Remove
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>

          <div>
            <button
              disabled={!memberships?.hasPreviousPage || memberships?.isFetching}
              onClick={() => memberships?.fetchPrevious?.()}
            >
              Previous
            </button>

            <button
              disabled={!memberships?.hasNextPage || memberships?.isFetching}
              onClick={() => memberships?.fetchNext?.()}
            >
              Next
            </button>
          </div>
        </>
      )
    }

    type SelectRoleProps = {
      fieldName?: string
      isDisabled?: boolean
      onChange?: ChangeEventHandler<HTMLSelectElement>
      defaultRole?: string
    }

    const SelectRole = (props: SelectRoleProps) => {
      const { fieldName, isDisabled = false, onChange, defaultRole } = props
      const { organization } = useOrganization()
      const [fetchedRoles, setRoles] = useState<OrganizationCustomRoleKey[]>([])
      const isPopulated = useRef(false)

      useEffect(() => {
        if (isPopulated.current) return
        organization
          ?.getRoles({
            pageSize: 20,
            initialPage: 1,
          })
          .then((res) => {
            isPopulated.current = true
            setRoles(res.data.map((roles) => roles.key as OrganizationCustomRoleKey))
          })
      }, [organization?.id])

      if (fetchedRoles.length === 0) return null

      return (
        <select
          name={fieldName}
          disabled={isDisabled}
          aria-disabled={isDisabled}
          onChange={onChange}
          defaultValue={defaultRole}
        >
          {fetchedRoles?.map((roleKey) => (
            <option key={roleKey} value={roleKey}>
              {roleKey}
            </option>
          ))}
        </select>
      )
    }
    ```
  </Tab>

  <Tab>
    The following example includes a `checkAdminAndRenderMemberships()` function that checks if the user is an admin of the currently active organization and calls `renderMemberships()`. The `renderMemberships()` function lists the organization's memberships and allows administrators to update a member's role and remove a member from the organization.

    Use the tabs to view the code necessary for the `index.html` and `main.js` files.

    <CodeBlockTabs options={["index.html", "main.js"]}>
      ```html {{ filename: 'index.html', collapsible: true }}
      <!doctype html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Clerk + JavaScript App</title>
        </head>
        <body>
          <div id="app"></div>

          <h1>Memberships List</h1>
          <table>
            <thead>
              <tr>
                <th>User ID</th>
                <th>User identifier</th>
                <th>Joined</th>
                <th>Role</th>
                <th id="update-role-head" hidden>Update role</th>
                <th id="remove-member-head" hidden>Remove member</th>
              </tr>
            </thead>
            <tbody id="memberships-table-body"></tbody>
          </table>

          <script type="module" src="/src/main.js" async crossorigin="anonymous"></script>
        </body>
      </html>
      ```

      ```js {{ filename: 'main.js', collapsible: true }}
      import { Clerk } from '@clerk/clerk-js'

      const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

      if (!pubKey) {
        throw new Error('Add your VITE_CLERK_PUBLISHABLE_KEY to .env file')
      }

      const clerk = new Clerk('{{pub_key}}')
      await clerk.load()

      if (clerk.user) {
        // Check for an active organization
        if (clerk.organization) {
          // Render list of organization memberships
          async function renderMemberships(organization, isAdmin) {
            try {
              const { data } = await organization.getMemberships()
              const memberships = data
              console.log(`getMemberships:`, memberships)

              memberships.map((membership) => {
                const membershipTable = document.getElementById('memberships-table-body')
                const row = membershipTable.insertRow()
                row.insertCell().textContent = membership.publicUserData.userId
                row.insertCell().textContent = membership.publicUserData.identifier
                row.insertCell().textContent = membership.createdAt.toLocaleDateString()
                row.insertCell().textContent = membership.role

                // Add administrative actions:
                // Add and remove a member, and update a member's role.
                if (isAdmin) {
                  // Show update and remove member buttons
                  document.getElementById('update-role-head').removeAttribute('hidden')
                  document.getElementById('remove-member-head').removeAttribute('hidden')

                  // Get the user ID of the member
                  const userId = membership.publicUserData.userId

                  // Update a member's role
                  const updateBtn = document.createElement('button')
                  updateBtn.textContent = 'Change role'
                  updateBtn.addEventListener('click', async function (e) {
                    e.preventDefault()

                    const role = membership.role === 'org:admin' ? 'org:member' : 'org:admin'

                    await organization
                      .updateMember({ userId, role })
                      .then((res) => console.log(`updateMember response:`, res))
                      .catch((error) => console.log('An error occurred:', error))
                  })
                  row.insertCell().appendChild(updateBtn)

                  // Remove a member
                  const removeBtn = document.createElement('button')
                  removeBtn.textContent = 'Remove'
                  removeBtn.addEventListener('click', async function (e) {
                    e.preventDefault()

                    await organization
                      .removeMember(userId)
                      .then((res) => console.log(`removeMember response:`, res))
                      .catch((error) => console.log('An error occurred:', error))
                  })
                  row.insertCell().appendChild(removeBtn)
                }
              })
            } catch (error) {
              console.log('An error occurred:', error)
            }
          }

          /**
           * Checks if a user is an admin of the
           * currently active organization and
           * renders the organization's memberships.
           */
          async function checkAdminAndRenderMemberships() {
            const organizationId = clerk.organization.id

            const { data } = await clerk.user.getOrganizationMemberships()

            const organizationMemberships = data

            const currentMembership = organizationMemberships.find(
              (membership) => membership.organization.id === organizationId,
            )
            const currentOrganization = currentMembership.organization

            if (!currentOrganization) return

            const isAdmin = currentMembership.role === 'org:admin'

            console.log(`Current organization:`, currentOrganization)

            renderMemberships(currentOrganization, isAdmin)
          }

          checkAdminAndRenderMemberships()
        } else {
          // If there is no active organization,
          // mount Clerk's <OrganizationSwitcher />
          // to allow the user to set an organization as active
          document.getElementById('app').innerHTML = `
            <h2>Select an organization to set it as active</h2>
            <div id="org-switcher"></div>
          `

          const orgSwitcherDiv = document.getElementById('org-switcher')

          clerk.mountOrganizationSwitcher(orgSwitcherDiv)
        }
      } else {
        // If there is no active user, mount Clerk's <SignIn />
        document.getElementById('app').innerHTML = `
          <div id="sign-in"></div>
        `

        const signInDiv = document.getElementById('sign-in')

        clerk.mountSignIn(signInDiv)
      }
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

---
title: Build a custom flow for managing organization membership requests
description: Learn how to use the Clerk API to build a custom flow for managing organization membership requests.
---

<Include src="_partials/custom-flows-callout" />

This guide will demonstrate how to use the Clerk API to build a custom flow for managing [organization membership requests](/docs/organizations/verified-domains#membership-requests).

<Tabs items={["Next.js", "JavaScript"]}>
  <Tab>
    The following example:

    1. Uses the [`useOrganization()`](/docs/hooks/use-organization) hook to get `membershipRequests`, which is a list of the active organization's membership requests.
       - `membershipRequests` is an object with `data` that contains an array of [`OrganizationMembershipRequest`](/docs/references/javascript/types/organization-membership-request) objects.
       - Each `OrganizationMembershipRequest` object has an [`accept()`](/docs/references/javascript/types/organization-membership-request#accept) and [`reject()`](/docs/references/javascript/types/organization-membership-request#reject) method to accept or reject the membership request, respectively.
    1. Maps over the `data` array to display the membership requests in a table, providing an "Accept" and "Reject" button for each request that calls the `accept()` and `reject()` methods, respectively.

    This example is written for Next.js App Router but can be adapted for any React-based framework.

    ```jsx {{ filename: 'app/components/MembershipRequests.tsx', collapsible: true }}
    'use client'

    import { useOrganization } from '@clerk/nextjs'

    export const MembershipRequestsParams = {
      membershipRequests: {
        pageSize: 5,
        keepPreviousData: true,
      },
    }

    // List of organization membership requests.
    export const MembershipRequests = () => {
      const { isLoaded, membershipRequests } = useOrganization(MembershipRequestsParams)

      if (!isLoaded) {
        return <>Loading</>
      }

      return (
        <>
          <h1>Membership requests</h1>
          <table>
            <thead>
              <tr>
                <th>User</th>
                <th>Date requested</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {membershipRequests?.data?.map((mem) => (
                <tr key={mem.id}>
                  <td>{mem.publicUserData.identifier}</td>
                  <td>{mem.createdAt.toLocaleDateString()}</td>
                  <td>
                    <button
                      onClick={async () => {
                        await mem.accept()
                      }}
                    >
                      Accept
                    </button>
                    <button
                      onClick={async () => {
                        await mem.reject()
                      }}
                    >
                      Reject
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>

          <div>
            <button
              disabled={!membershipRequests?.hasPreviousPage || membershipRequests?.isFetching}
              onClick={() => membershipRequests?.fetchPrevious?.()}
            >
              Previous
            </button>

            <button
              disabled={!membershipRequests?.hasNextPage || membershipRequests?.isFetching}
              onClick={() => membershipRequests?.fetchNext?.()}
            >
              Next
            </button>
          </div>
        </>
      )
    }
    ```
  </Tab>

  <Tab>
    The following example:

    1. Calls the [`getMembershipRequests()`](/docs/references/javascript/organization#get-membership-requests) method to retrieve the list of membership requests for the active organization. This method returns `data`, which is an array of [`OrganizationMembershipRequest`](/docs/references/javascript/types/organization-membership-request) objects.
    1. Maps over the `data` array to display the membership requests in a table.
    1. Provides an "Accept" and "Reject" button for each request that calls the [`accept()`](/docs/references/javascript/types/organization-membership-request#accept) and [`reject()`](/docs/references/javascript/types/organization-membership-request#reject) methods, respectively.

    Use the tabs to view the code necessary for the `index.html` and `main.js` files.

    <CodeBlockTabs options={["index.html", "main.js"]}>
      ```html {{ filename: 'index.html', collapsible: true }}
      <!doctype html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Clerk + JavaScript App</title>
        </head>
        <body>
          <div id="app"></div>

          <h1>Membership Requests</h1>
          <table>
            <thead>
              <tr>
                <th>User</th>
                <th>Date requested</th>
                <th>Accept</th>
                <th>Reject</th>
              </tr>
            </thead>
            <tbody id="requests-table-body"></tbody>
          </table>

          <script type="module" src="/src/main.js" async crossorigin="anonymous"></script>
        </body>
      </html>
      ```

      ```js {{ filename: 'main.js', collapsible: true }}
      import { Clerk } from '@clerk/clerk-js'

      const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

      if (!pubKey) {
        throw new Error('Add your VITE_CLERK_PUBLISHABLE_KEY to .env file')
      }

      const clerk = new Clerk('{{pub_key}}')
      await clerk.load()

      if (clerk.user) {
        // Check for an active organization
        if (clerk.organization) {
          const requestsTable = document.getElementById('requests-table-body')
          const { data } = await clerk.organization
            .getMembershipRequests()
            .then((res) => console.log(`Membership requests:`, data).catch((err) => console.error(err)))
          const requests = data

          requests.map((request) => {
            const row = requestsTable.insertRow()
            row.insertCell().textContent = request.publicUserData.identifier
            row.insertCell().textContent = request.createdAt.toLocaleDateString()

            // Accept request
            const acceptBtn = document.createElement('button')
            acceptBtn.textContent = 'Accept'
            acceptBtn.addEventListener('click', async function (e) {
              e.preventDefault()
              await request.accept()
            })
            row.insertCell().appendChild(acceptBtn)

            // Reject request
            const rejectBtn = document.createElement('button')
            rejectBtn.textContent = 'Reject'
            rejectBtn.addEventListener('click', async function (e) {
              e.preventDefault()
              await request.reject()
            })
            row.insertCell().appendChild(rejectBtn)
          })
        } else {
          // If there is no active organization,
          // mount Clerk's <OrganizationSwitcher />
          // to allow the user to set an organization as active
          document.getElementById('app').innerHTML = `
            <h2>Select an organization to set it as active</h2>
            <div id="org-switcher"></div>
          `

          const orgSwitcherDiv = document.getElementById('org-switcher')

          clerk.mountOrganizationSwitcher(orgSwitcherDiv)
        }
      } else {
        // If there is no active user, mount Clerk's <SignIn />
        document.getElementById('app').innerHTML = `
          <div id="sign-in"></div>
        `

        const signInDiv = document.getElementById('sign-in')

        clerk.mountSignIn(signInDiv)
      }
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

---
title: Build a custom flow for managing SMS-based multi-factor authentication
description: Learn how to use the Clerk API to build a custom flow for managing SMS-based multi-factor authentication.
---

<Include src="_partials/custom-flows-callout" />

[Multi-factor verification (MFA)](/docs/authentication/configuration/sign-up-sign-in-options) is an added layer of security that requires users to provide a second verification factor to access an account.

One of the options that Clerk supports for MFA is **SMS verification codes**. This guide will walk you through how to build a custom flow that allows users to manage their TOTP settings.

> [!TIP]
> To learn how to build a custom flow for managing authenticator app (TOTP) MFA, see the [dedicated guide](/docs/custom-flows/manage-totp-based-mfa).

<Steps>
  ## Enable multi-factor authentication

  For your users to be able to enable MFA for their account, you need to enable MFA as an MFA authentication strategy in your Clerk application.

  1. In the Clerk Dashboard, navigate to the [**Multi-factor**](https://dashboard.clerk.com/last-active?path=user-authentication/multi-factor) page.
  1. Enable **SMS verification code** and **Backup codes** and select **Save**.

  ## Create the multi-factor management flow

  This example is written for Next.js App Router but it can be adapted for any React-based framework.

  This example consists of two pages:

  - The main page where users can manage their SMS MFA settings.
  - The page where users can add a phone number to their account.

  Use the following tabs to view the code necessary for each page.

  <Include src="_partials/custom-flows/phone-number" />

  <Tabs items={["Manage MFA page", "Add phone number page"]}>
    <Tab>
      ```tsx {{ filename: 'app/account/manage-mfa/page.tsx', collapsible: true }}
      'use client'

      import * as React from 'react'
      import { useUser, useReverification } from '@clerk/nextjs'
      import { BackupCodeResource, PhoneNumberResource } from '@clerk/types'
      import Link from 'next/link'

      // Display phone numbers reserved for MFA
      const ManageMfaPhoneNumbers = () => {
        const { user } = useUser()

        if (!user) return null

        // Check if any phone numbers are reserved for MFA
        const mfaPhones = user.phoneNumbers
          .filter((ph) => ph.verification.status === 'verified')
          .filter((ph) => ph.reservedForSecondFactor)
          .sort((ph: PhoneNumberResource) => (ph.defaultSecondFactor ? -1 : 1))

        if (mfaPhones.length === 0) {
          return <p>There are currently no phone numbers reserved for MFA.</p>
        }

        return (
          <>
            <h2>Phone numbers reserved for MFA</h2>
            <ul>
              {mfaPhones.map((phone) => {
                return (
                  <li key={phone.id} style={{ display: 'flex', gap: '10px' }}>
                    <p>
                      {phone.phoneNumber} {phone.defaultSecondFactor && '(Default)'}
                    </p>
                    <div>
                      <button onClick={() => phone.setReservedForSecondFactor({ reserved: false })}>
                        Disable for MFA
                      </button>
                    </div>

                    {!phone.defaultSecondFactor && (
                      <div>
                        <button onClick={() => phone.makeDefaultSecondFactor()}>Make default</button>
                      </div>
                    )}

                    <div>
                      <button onClick={() => phone.destroy()}>Remove from account</button>
                    </div>
                  </li>
                )
              })}
            </ul>
          </>
        )
      }

      // Display phone numbers that are not reserved for MFA
      const ManageAvailablePhoneNumbers = () => {
        const { user } = useUser()
        const setReservedForSecondFactor = useReverification((phone: PhoneNumberResource) =>
          phone.setReservedForSecondFactor({ reserved: true }),
        )
        const destroyPhone = useReverification((phone: PhoneNumberResource) => phone.destroy())

        if (!user) return null

        // Check if any phone numbers aren't reserved for MFA
        const availableForMfaPhones = user.phoneNumbers
          .filter((ph) => ph.verification.status === 'verified')
          .filter((ph) => !ph.reservedForSecondFactor)

        // Reserve a phone number for MFA
        const reservePhoneForMfa = async (phone: PhoneNumberResource) => {
          // Set the phone number as reserved for MFA
          await setReservedForSecondFactor(phone)
          // Refresh the user information to reflect changes
          await user.reload()
        }

        if (availableForMfaPhones.length === 0) {
          return <p>There are currently no verified phone numbers available to be reserved for MFA.</p>
        }

        return (
          <>
            <h2>Phone numbers that are not reserved for MFA</h2>

            <ul>
              {availableForMfaPhones.map((phone) => {
                return (
                  <li key={phone.id} style={{ display: 'flex', gap: '10px' }}>
                    <p>{phone.phoneNumber}</p>
                    <div>
                      <button onClick={() => reservePhoneForMfa(phone)}>Use for MFA</button>
                    </div>
                    <div>
                      <button onClick={() => destroyPhone()}>Remove from account</button>
                    </div>
                  </li>
                )
              })}
            </ul>
          </>
        )
      }

      // Generate and display backup codes
      function GenerateBackupCodes() {
        const { user } = useUser()
        const [backupCodes, setBackupCodes] = React.useState<BackupCodeResource | undefined>(undefined)
        const createBackupCode = useReverification(() => user?.createBackupCode())

        const [loading, setLoading] = React.useState(false)

        React.useEffect(() => {
          if (backupCodes) {
            return
          }

          setLoading(true)
          void createBackupCode()
            .then((backupCode: BackupCodeResource) => {
              setBackupCodes(backupCode)
              setLoading(false)
            })
            .catch((err) => {
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.error(JSON.stringify(err, null, 2))
              setLoading(false)
            })
        }, [])

        if (loading) {
          return <p>Loading...</p>
        }

        if (!backupCodes) {
          return <p>There was a problem generating backup codes</p>
        }

        return (
          <ol>
            {backupCodes.codes.map((code, index) => (
              <li key={index}>{code}</li>
            ))}
          </ol>
        )
      }

      export default function ManageSMSMFA() {
        const [showBackupCodes, setShowBackupCodes] = React.useState(false)

        const { isLoaded, user } = useUser()

        if (!isLoaded) return null

        if (!user) {
          return <p>You must be logged in to access this page</p>
        }

        return (
          <>
            <h1>User MFA Settings</h1>

            {/* Manage SMS MFA */}
            <ManageMfaPhoneNumbers />
            <ManageAvailablePhoneNumbers />
            <Link href="/account/add-phone">Add a new phone number</Link>

            {/* Manage backup codes */}
            {user.twoFactorEnabled && (
              <div>
                <p>
                  Generate new backup codes? -{' '}
                  <button onClick={() => setShowBackupCodes(true)}>Generate</button>
                </p>
              </div>
            )}
            {showBackupCodes && (
              <>
                <GenerateBackupCodes />
                <button onClick={() => setShowBackupCodes(false)}>Done</button>
              </>
            )}
          </>
        )
      }
      ```
    </Tab>

    <Tab>
      ```tsx {{ filename: 'app/account/add-phone/page.tsx', collapsible: true }}
      'use client'

      import * as React from 'react'
      import { useUser, useReverification } from '@clerk/nextjs'
      import { PhoneNumberResource } from '@clerk/types'

      export default function Page() {
        const { isLoaded, user } = useUser()
        const [phone, setPhone] = React.useState('')
        const [code, setCode] = React.useState('')
        const [isVerifying, setIsVerifying] = React.useState(false)
        const [successful, setSuccessful] = React.useState(false)
        const [phoneObj, setPhoneObj] = React.useState<PhoneNumberResource | undefined>()
        const createPhoneNumber = useReverification((phone: string) =>
          user?.createPhoneNumber({ phoneNumber: phone }),
        )

        if (!isLoaded) return null

        if (!user) {
          return <p>You must be logged in to access this page</p>
        }

        // Handle addition of the phone number
        const handleSubmit = async (e: React.FormEvent) => {
          e.preventDefault()

          try {
            // Add unverified phone number to user
            const res = await createPhoneNumber(phone)
            // Reload user to get updated User object
            await user.reload()

            // Create a reference to the new phone number to use related methods
            const phoneNumber = user.phoneNumbers.find((a) => a.id === res.id)
            setPhoneObj(phoneNumber)

            // Send the user an SMS with the verification code
            phoneNumber?.prepareVerification()

            // Set to true to display second form
            // and capture the OTP code
            setIsVerifying(true)
          } catch (err) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error(JSON.stringify(err, null, 2))
          }
        }

        // Handle the submission of the verification form
        const verifyCode = async (e: React.FormEvent) => {
          e.preventDefault()
          try {
            // Verify that the provided code matches the code sent to the user
            const phoneVerifyAttempt = await phoneObj?.attemptVerification({ code })

            if (phoneVerifyAttempt?.verification.status === 'verified') {
              setSuccessful(true)
            } else {
              // If the status is not complete, check why. User may need to
              // complete further steps.
              console.error(JSON.stringify(phoneVerifyAttempt, null, 2))
            }
          } catch (err) {
            console.error(JSON.stringify(err, null, 2))
          }
        }

        // Display a success message if the phone number was added successfully
        if (successful) {
          return (
            <>
              <h1>Phone added</h1>
            </>
          )
        }

        // Display the verification form to capture the OTP code
        if (isVerifying) {
          return (
            <>
              <h1>Verify phone</h1>
              <div>
                <form onSubmit={(e) => verifyCode(e)}>
                  <div>
                    <label htmlFor="code">Enter code</label>
                    <input
                      onChange={(e) => setCode(e.target.value)}
                      id="code"
                      name="code"
                      type="text"
                      value={code}
                    />
                  </div>
                  <div>
                    <button type="submit">Verify</button>
                  </div>
                </form>
              </div>
            </>
          )
        }

        // Display the initial form to capture the phone number
        return (
          <>
            <h1>Add phone</h1>
            <div>
              <form onSubmit={(e) => handleSubmit(e)}>
                <div>
                  <label htmlFor="phone">Enter phone number</label>
                  <input
                    onChange={(e) => setPhone(e.target.value)}
                    id="phone"
                    name="phone"
                    type="phone"
                    value={phone}
                  />
                </div>
                <div>
                  <button type="submit">Continue</button>
                </div>
              </form>
            </div>
          </>
        )
      }
      ```
    </Tab>
  </Tabs>
</Steps>

---
title: Build a custom flow for managing SSO connections
description: Learn how to use the Clerk API to build a custom flow for adding and managing SSO connections
---

<Include src="_partials/custom-flows-callout" />

## Before you start

You must configure your application instance through the Clerk Dashboard for the SSO connections that you want to use.

- For social (OAuth) connection(s), see [the appropriate guide for your platform](/docs/authentication/social-connections/overview).
- For enterprise connection(s), see [the appropriate guide for your platform](/docs/authentication/enterprise-connections/overview).

This guide uses Discord, Google, and GitHub as examples.

## Build the custom flow

1. The [`useUser()`](/docs/hooks/use-user) hook is used to get the current user's [`User`](/docs/references/javascript/user) object. The `isLoaded` boolean is used to ensure that Clerk is loaded.
1. The `options` array is used to create a list of supported SSO connections. This example uses [OAuth strategies](/docs/authentication/social-connections/oauth). You can edit this array to include all of the SSO connections that you've enabled for your app in the Clerk Dashboard. You can also add [custom SSO connections](/docs/authentication/social-connections/custom-provider) by using the `oauth_custom_<name>` strategy.
1. The `addSSO()` function is used to add a new external account using the `strategy` that is passed in.
   - It uses the `user` object to access the [`createExternalAccount()`](/docs/references/javascript/user#create-external-account) method.
   - The `createExternalAccount()` method is used to create a new external account using the `strategy` that is passed in. It's passed to the [`useReverification()`](/docs/hooks/use-reverification) hook to require the user to reverify their credentials before being able to add an external account to their account.
1. The `unconnectedOptions` array is used to filter out any existing external accounts from the `options` array.
1. In the UI, the `unconnectedOptions` array is used to create a list of buttons for the user to add new external accounts.
1. In the UI, the `User` object is used to access the `externalAccounts` property, which is mapped through to create a list of the user's existing external accounts. If there is an error, it is displayed to the user in the 'Status' column. If the account didn't verify when the user added it, a 'Reverify' button is displayed, which will redirect the user to the provider in order to verify their account.

```tsx {{ filename: 'app/account/manage-external-accounts/page.tsx', collapsible: true }}
'use client'

import { useUser, useReverification } from '@clerk/nextjs'
import { CreateExternalAccountParams, ExternalAccountResource, OAuthStrategy } from '@clerk/types'
import { useRouter } from 'next/navigation'

// Capitalize the first letter of the provider name
// E.g. 'discord' -> 'Discord'
const capitalize = (provider: string) => {
  return `${provider.slice(0, 1).toUpperCase()}${provider.slice(1)}`
}

// Remove the prefix from the provider name
// E.g. 'oauth_discord' -> 'discord'
const normalizeProvider = (provider: string) => {
  return provider.split('_')[1]
}

export default function AddAccount() {
  const router = useRouter()
  // Use Clerk's `useUser()` hook to get the current user's `User` object
  const { isLoaded, user } = useUser()
  const createExternalAccount = useReverification((params: CreateExternalAccountParams) =>
    user?.createExternalAccount(params),
  )
  const accountDestroy = useReverification((account: ExternalAccountResource) => account.destroy())

  // List the options the user can select when adding a new external account
  // Edit this array to include all of your enabled SSO connections
  const options: OAuthStrategy[] = ['oauth_discord', 'oauth_google', 'oauth_github']

  // Handle adding the new external account
  const addSSO = async (strategy: OAuthStrategy) => {
    await createExternalAccount({
      strategy,
      redirectUrl: '/account/manage-external-accounts',
    })
      .then((res) => {
        if (res?.verification?.externalVerificationRedirectURL) {
          router.push(res.verification.externalVerificationRedirectURL.href)
        }
      })
      .catch((err) => {
        console.log('ERROR', err)
      })
      .finally(() => {
        console.log('Redirected user to oauth provider')
      })
  }

  // Show a loading message until Clerk loads
  if (!isLoaded) return <p>Loading...</p>

  // Find the external accounts from the options array that the user has not yet added to their account
  // This prevents showing an 'add' button for existing external account types
  const unconnectedOptions = options.filter(
    (option) =>
      !user?.externalAccounts.some((account) => account.provider === normalizeProvider(option)),
  )

  return (
    <>
      <div>
        <p>Connected accounts</p>
        {user?.externalAccounts.map((account) => {
          return (
            <ul key={account.id}>
              <li>Provider: {capitalize(account.provider)}</li>
              <li>Scopes: {account.approvedScopes}</li>
              <li>
                Status:{' '}
                {/* This example uses the `longMessage` returned by the API. You can use account.verification.error.code to determine the error and then provide your own message to the user. */}
                {account.verification?.status === 'verified'
                  ? capitalize(account.verification?.status)
                  : account.verification?.error?.longMessage}
              </li>
              {account.verification?.status !== 'verified' &&
                account.verification?.externalVerificationRedirectURL && (
                  <li>
                    <a href={account.verification?.externalVerificationRedirectURL?.href}>
                      Reverify {capitalize(account.provider)}
                    </a>
                  </li>
                )}
              <li>
                <button onClick={() => accountDestroy(account)}>
                  Remove {capitalize(account.provider)}
                </button>
              </li>
            </ul>
          )
        })}
      </div>
      {unconnectedOptions.length > 0 && (
        <div>
          <p>Add a new external account</p>
          <ul>
            {unconnectedOptions.map((strategy) => {
              return (
                <li key={strategy}>
                  <button onClick={() => addSSO(strategy)}>
                    Add {capitalize(normalizeProvider(strategy))}
                  </button>
                </li>
              )
            })}
          </ul>
        </div>
      )}
    </>
  )
}
```

---
title: Build a custom flow for managing TOTP-based multi-factor authentication
description: Learn how to use the Clerk API to build a custom flow for managing TOTP-based multi-factor authentication.
---

<Include src="_partials/custom-flows-callout" />

[Multi-factor verification (MFA)](/docs/authentication/configuration/sign-up-sign-in-options) is an added layer of security that requires users to provide a second verification factor to access an account.

One of the options that Clerk supports for MFA is **Authenticator applications (also known as TOTP - Time-based One-time Password)**. This guide will walk you through how to build a custom flow that allows users to manage their TOTP settings.

> [!TIP]
> To learn how to build a custom flow for managing SMS MFA, see the [dedicated guide](/docs/custom-flows/manage-sms-based-mfa).

<Steps>
  ## Enable multi-factor authentication

  For your users to be able to enable MFA for their account, you need to enable MFA as an MFA authentication strategy in your Clerk application.

  1. In the Clerk Dashboard, navigate to the [**Multi-factor**](https://dashboard.clerk.com/last-active?path=user-authentication/multi-factor) page.
  1. Enable **Authenticator application** and **Backup codes**.
  1. Select **Save**.

  ## Create the multi-factor management flow

  <Tabs items={["Next.js", "Expo"]}>
    <Tab>
      This example is written for Next.js App Router but it can be adapted for any React-based framework.

      This example consists of two pages:

      - The main page where users can manage their MFA settings
      - The page where users can add TOTP MFA.

      Use the following tabs to view the code necessary for each page.

      <Tabs items={["Manage MFA page", "Add TOTP page"]}>
        <Tab>
          ```tsx {{ filename: 'app/account/manage-mfa/page.tsx', collapsible: true }}
          'use client'

          import * as React from 'react'
          import { useUser, useReverification } from '@clerk/nextjs'
          import Link from 'next/link'
          import { BackupCodeResource } from '@clerk/types'

          // If TOTP is enabled, provide the option to disable it
          const TotpEnabled = () => {
            const { user } = useUser()
            const disableTOTP = useReverification(() => user?.disableTOTP())

            return (
              <div>
                <p>
                  TOTP via authentication app enabled - <button onClick={() => disableTOTP()}>Remove</button>
                </p>
              </div>
            )
          }

          // If TOTP is disabled, provide the option to enable it
          const TotpDisabled = () => {
            return (
              <div>
                <p>
                  Add TOTP via authentication app -{' '}
                  <Link href="/account/manage-mfa/add">
                    <button>Add</button>
                  </Link>
                </p>
              </div>
            )
          }

          // Generate and display backup codes
          export function GenerateBackupCodes() {
            const { user } = useUser()
            const [backupCodes, setBackupCodes] = React.useState<BackupCodeResource | undefined>(undefined)
            const createBackupCode = useReverification(() => user?.createBackupCode())

            const [loading, setLoading] = React.useState(false)

            React.useEffect(() => {
              if (backupCodes) {
                return
              }

              setLoading(true)
              void createBackupCode()
                .then((backupCode: BackupCodeResource | undefined) => {
                  setBackupCodes(backupCode)
                  setLoading(false)
                })
                .catch((err) => {
                  // See https://clerk.com/docs/custom-flows/error-handling
                  // for more info on error handling
                  console.error(JSON.stringify(err, null, 2))
                  setLoading(false)
                })
            }, [])

            if (loading) {
              return <p>Loading...</p>
            }

            if (!backupCodes) {
              return <p>There was a problem generating backup codes</p>
            }

            return (
              <ol>
                {backupCodes.codes.map((code, index) => (
                  <li key={index}>{code}</li>
                ))}
              </ol>
            )
          }

          export default function ManageMFA() {
            const { isLoaded, user } = useUser()
            const [showNewCodes, setShowNewCodes] = React.useState(false)

            if (!isLoaded) return null

            if (!user) {
              return <p>You must be logged in to access this page</p>
            }

            return (
              <>
                <h1>User MFA Settings</h1>

                {/* Manage TOTP MFA */}
                {user.totpEnabled ? <TotpEnabled /> : <TotpDisabled />}

                {/* Manage backup codes */}
                {user.backupCodeEnabled && user.twoFactorEnabled && (
                  <div>
                    <p>
                      Generate new backup codes? -{' '}
                      <button onClick={() => setShowNewCodes(true)}>Generate</button>
                    </p>
                  </div>
                )}
                {showNewCodes && (
                  <>
                    <GenerateBackupCodes />
                    <button onClick={() => setShowNewCodes(false)}>Done</button>
                  </>
                )}
              </>
            )
          }
          ```
        </Tab>

        <Tab>
          ```tsx {{ filename: 'app/account/manage-mfa/add/page.tsx', collapsible: true }}
          'use client'

          import { useUser, useReverification } from '@clerk/nextjs'
          import { TOTPResource } from '@clerk/types'
          import Link from 'next/link'
          import * as React from 'react'
          import { QRCodeSVG } from 'qrcode.react'
          import { GenerateBackupCodes } from '../page'

          type AddTotpSteps = 'add' | 'verify' | 'backupcodes' | 'success'

          type DisplayFormat = 'qr' | 'uri'

          function AddTotpScreen({
            setStep,
          }: {
            setStep: React.Dispatch<React.SetStateAction<AddTotpSteps>>
          }) {
            const { user } = useUser()
            const [totp, setTOTP] = React.useState<TOTPResource | undefined>(undefined)
            const [displayFormat, setDisplayFormat] = React.useState<DisplayFormat>('qr')
            const createTOTP = useReverification(() => user?.createTOTP())

            React.useEffect(() => {
              void createTOTP()
                .then((totp: TOTPResource) => {
                  setTOTP(totp)
                })
                .catch((err) =>
                  // See https://clerk.com/docs/custom-flows/error-handling
                  // for more info on error handling
                  console.error(JSON.stringify(err, null, 2)),
                )
            }, [])

            return (
              <>
                <h1>Add TOTP MFA</h1>

                {totp && displayFormat === 'qr' && (
                  <>
                    <div>
                      <QRCodeSVG value={totp?.uri || ''} size={200} />
                    </div>
                    <button onClick={() => setDisplayFormat('uri')}>Use URI instead</button>
                  </>
                )}
                {totp && displayFormat === 'uri' && (
                  <>
                    <div>
                      <p>{totp.uri}</p>
                    </div>
                    <button onClick={() => setDisplayFormat('qr')}>Use QR Code instead</button>
                  </>
                )}
                <button onClick={() => setStep('add')}>Reset</button>

                <p>Once you have set up your authentication app, verify your code</p>
                <button onClick={() => setStep('verify')}>Verify</button>
              </>
            )
          }

          function VerifyTotpScreen({
            setStep,
          }: {
            setStep: React.Dispatch<React.SetStateAction<AddTotpSteps>>
          }) {
            const { user } = useUser()
            const [code, setCode] = React.useState('')

            const verifyTotp = async (e: React.FormEvent) => {
              e.preventDefault()
              try {
                await user?.verifyTOTP({ code })
                setStep('backupcodes')
              } catch (err) {
                console.error(JSON.stringify(err, null, 2))
              }
            }

            return (
              <>
                <h1>Verify TOTP</h1>
                <form onSubmit={(e) => verifyTotp(e)}>
                  <label htmlFor="totp-code">Enter the code from your authentication app</label>
                  <input type="text" id="totp-code" onChange={(e) => setCode(e.currentTarget.value)} />
                  <button type="submit">Verify code</button>
                  <button onClick={() => setStep('add')}>Reset</button>
                </form>
              </>
            )
          }

          function BackupCodeScreen({
            setStep,
          }: {
            setStep: React.Dispatch<React.SetStateAction<AddTotpSteps>>
          }) {
            return (
              <>
                <h1>Verification was a success!</h1>
                <div>
                  <p>
                    Save this list of backup codes somewhere safe in case you need to access your account in
                    an emergency
                  </p>
                  <GenerateBackupCodes />
                  <button onClick={() => setStep('success')}>Finish</button>
                </div>
              </>
            )
          }

          function SuccessScreen() {
            return (
              <>
                <h1>Success!</h1>
                <p>You have successfully added TOTP MFA via an authentication application.</p>
              </>
            )
          }

          export default function AddMFaScreen() {
            const [step, setStep] = React.useState<AddTotpSteps>('add')
            const { isLoaded, user } = useUser()

            if (!isLoaded) return null

            if (!user) {
              return <p>You must be logged in to access this page</p>
            }

            return (
              <>
                {step === 'add' && <AddTotpScreen setStep={setStep} />}
                {step === 'verify' && <VerifyTotpScreen setStep={setStep} />}
                {step === 'backupcodes' && <BackupCodeScreen setStep={setStep} />}
                {step === 'success' && <SuccessScreen />}
                <Link href="/account/manage-mfa">Manage MFA</Link>
              </>
            )
          }
          ```
        </Tab>
      </Tabs>
    </Tab>

    <Tab>
      ### Before you start

      Install `expo-checkbox` for the UI and `react-native-qr-svg` for the QR code.

      <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
        ```bash {{ filename: 'terminal' }}
        npm install expo-checkbox react-native-qr-svg
        ```

        ```bash {{ filename: 'terminal' }}
        yarn add expo-checkbox react-native-qr-svg
        ```

        ```bash {{ filename: 'terminal' }}
        pnpm add expo-checkbox react-native-qr-svg
        ```

        ```bash {{ filename: 'terminal' }}
        bun add expo-checkbox react-native-qr-svg
        ```
      </CodeBlockTabs>

      ### Build the flow

      To allow users to configure their MFA settings, you'll create a basic dashboard.

      The following example consists of three pages:

      - The layout page that checks if the user is signed in
      - The page where users can manage their account, including their MFA settings
      - The page where users can add TOTP MFA

      Use the following tabs to view the code necessary for each page.

      <Tabs items={["Layout", "Account page", "Add TOTP page"]}>
        <Tab>
          1. Create the `(dashboard)` route group. This groups your account page and the "Add TOTP MFA" page.
          1. Create a `_layout.tsx` file with the following code. The [`useAuth()`](/docs/hooks/use-auth) hook is used to check if the user is signed in. If the user isn't signed in, they'll be redirected to the sign-in page.

          ```tsx {{ filename: 'app/(dashboard)/_layout.tsx' }}
          import { Redirect, Stack } from 'expo-router'
          import { useAuth } from '@clerk/clerk-expo'

          export default function AuthenticatedLayout() {
            const { isSignedIn } = useAuth()

            if (!isSignedIn) {
              return <Redirect href={'/sign-in'} />
            }

            return <Stack />
          }
          ```
        </Tab>

        <Tab>
          In the `(dashboard)` group, create an `account.tsx` file with the following code. This page shows users whether or not MFA is enabled, and allows them to add MFA with an authenticator app.

          ```tsx {{ filename: 'app/(dashboard)/account.tsx', collapsible: true }}
          import React from 'react'
          import { useUser } from '@clerk/clerk-expo'
          import { useRouter } from 'expo-router'
          import { View, Text, Button, FlatList } from 'react-native'
          import { BackupCodeResource } from '@clerk/types'

          export default function ManageTOTPMfa() {
            const router = useRouter()
            const [backupCodes, setBackupCodes] = React.useState<BackupCodeResource | undefined>(undefined)
            const [loading, setLoading] = React.useState(false)

            const { isLoaded, user } = useUser()

            if (!isLoaded || !user) return null

            const generateBackupCodes = () => {
              setLoading(true)
              void user
                ?.createBackupCode()
                .then((backupCodes: BackupCodeResource) => {
                  setBackupCodes(backupCodes)
                  setLoading(false)
                })
                .catch((error) => {
                  console.log('Error:', error)
                  setLoading(false)
                })
            }

            const disableTOTP = async () => {
              await user.disableTOTP()
            }

            const MFAEnabled = () => {
              return (
                <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                  <Text>TOTP via authentication app enabled - </Text>
                  <Button onPress={() => disableTOTP()} title="Remove" />
                </View>
              )
            }

            const MFADisabled = () => {
              return (
                <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                  <Text>Add TOTP via authentication app - </Text>
                  <Button onPress={() => router.push('/add-mfa')} title="Add" />
                </View>
              )
            }

            return (
              <>
                <Text>Current MFA Settings</Text>

                <Text>Authenticator App</Text>

                {user.totpEnabled ? <MFAEnabled /> : <MFADisabled />}

                {user.backupCodeEnabled && (
                  <View>
                    <Text>Backup Codes</Text>
                    {loading && <Text>Loading...</Text>}
                    {backupCodes && !loading && (
                      <FlatList
                        data={backupCodes.codes}
                        renderItem={(code) => <Text>{code.item}</Text>}
                        keyExtractor={(item) => item}
                      />
                    )}
                    <Button onPress={() => generateBackupCodes()} title="Regenerate Codes" />
                  </View>
                )}
              </>
            )
          }
          ```
        </Tab>

        <Tab>
          In the `(dashboard)` group, create an `add-mfa.tsx` file with the following code. This page adds the functionality for generating the QR code and backup codes.

          ```tsx {{ filename: 'app/(dashboard)/add-mfa.tsx', collapsible: true }}
          import React from 'react'
          import { useUser } from '@clerk/clerk-expo'
          import { Link } from 'expo-router'
          import { QrCodeSvg } from 'react-native-qr-svg'
          import { FlatList, Button, Text, TextInput, View } from 'react-native'

          import { BackupCodeResource, TOTPResource } from '@clerk/types'

          type AddTotpSteps = 'add' | 'verify' | 'backupcodes' | 'success'
          type DisplayFormat = 'qr' | 'uri'

          function AddTOTPMfa({ setStep }: { setStep: React.Dispatch<React.SetStateAction<AddTotpSteps>> }) {
            const [totp, setTotp] = React.useState<TOTPResource | undefined>(undefined)
            const [displayFormat, setDisplayFormat] = React.useState<DisplayFormat>('qr')
            const { user } = useUser()

            React.useEffect(() => {
              void user
                ?.createTOTP()
                .then((totp: TOTPResource) => setTotp(totp))
                .catch((err) => console.error(JSON.stringify(err, null, 2)))
            }, [])

            return (
              <View>
                <Text>Add TOTP MFA</Text>

                {totp && displayFormat === 'qr' && (
                  <>
                    <View>
                      <QrCodeSvg value={totp?.uri || ''} frameSize={200} />
                    </View>
                    <Button title="Use URI" onPress={() => setDisplayFormat('uri')} />
                  </>
                )}

                {totp && displayFormat === 'uri' && (
                  <>
                    <View>
                      <Text>{totp.uri}</Text>
                    </View>
                    <Button title="Use QR Code" onPress={() => setDisplayFormat('qr')} />
                  </>
                )}

                <Button title="Verify" onPress={() => setStep('verify')} />
                <Button title="Reset" onPress={() => setStep('add')} />
              </View>
            )
          }

          function VerifyMFA({ setStep }: { setStep: React.Dispatch<React.SetStateAction<AddTotpSteps>> }) {
            const [code, setCode] = React.useState('')

            const { user } = useUser()

            const verifyTotp = async (e: any) => {
              await user
                ?.verifyTOTP({ code })
                .then(() => setStep('backupcodes'))
                .catch((err) => console.error(JSON.stringify(err, null, 2)))
            }

            return (
              <>
                <Text>Verify MFA</Text>
                <TextInput
                  value={code}
                  placeholder="Enter code"
                  placeholderTextColor="#666666"
                  onChangeText={(c) => setCode(c)}
                />
                <Button onPress={verifyTotp} title="Verify Code" />
                <Button onPress={() => setStep('add')} title="Reset" />
              </>
            )
          }

          function BackupCodes({ setStep }: { setStep: React.Dispatch<React.SetStateAction<AddTotpSteps>> }) {
            const { user } = useUser()
            const [backupCode, setBackupCode] = React.useState<BackupCodeResource | undefined>(undefined)

            React.useEffect(() => {
              if (backupCode) {
                return
              }

              void user
                ?.createBackupCode()
                .then((backupCode: BackupCodeResource) => setBackupCode(backupCode))
                .catch((err) => console.error(JSON.stringify(err, null, 2)))
            }, [])

            return (
              <>
                <Text>Verification was a success!</Text>
                {backupCode && (
                  <View>
                    <Text>
                      Save this list of backup codes somewhere safe in case you need to access your account in
                      an emergency
                    </Text>

                    <FlatList
                      data={backupCode.codes.map((code) => ({
                        key: code,
                      }))}
                      renderItem={({ item }) => <Text>{item.key}</Text>}
                    />

                    <Button title="Finish" onPress={() => setStep('success')} />
                  </View>
                )}
              </>
            )
          }

          function Success() {
            return (
              <>
                <Text>Success</Text>
                <Text>You successfully added TOTP MFA via an authentication application</Text>
              </>
            )
          }

          export default function AddMfaScreen() {
            const [step, setStep] = React.useState<AddTotpSteps>('add')

            return (
              <>
                {step === 'add' && <AddTOTPMfa setStep={setStep} />}
                {step === 'verify' && <VerifyMFA setStep={setStep} />}
                {step === 'backupcodes' && <BackupCodes setStep={setStep} />}
                {step === 'success' && <Success />}

                <Link href="/account">
                  <Text>Manage MFA</Text>
                </Link>
              </>
            )
          }
          ```
        </Tab>
      </Tabs>
    </Tab>
  </Tabs>
</Steps>

---
title: Build a custom flow for resetting a user's password
description: Learn how to build a custom flow using Clerk's API to reset a user's password.
---

<Include src="_partials/custom-flows-callout" />

The password reset flow works as follows:

1. Users can have an email address or phone number, or both, as an [identifier](/docs/authentication/configuration/sign-up-sign-in-options#identifiers). The user enters their email address or phone number and asks for a password reset code.
1. Clerk sends an email or SMS to the user, containing a code.
1. The user enters the code and a new password.
1. Clerk verifies the code, and if successful, updates the user's password and signs them in.

This guide demonstrates how to use Clerk's API to build a custom flow for resetting a user's password. It covers the following scenarios:

- [The user has an email address as an identifier](#email-address)
- [The user has a phone number as an identifier](#phone-number)

## Email address

{/* TODO: Add vanilla JS example. */}

<Tabs items={["Next.js", "iOS"]}>
  <Tab>
    ```tsx {{ filename: 'app/forgot-password.tsx', collapsible: true }}
    'use client'
    import React, { useEffect, useState } from 'react'
    import { useAuth, useSignIn } from '@clerk/nextjs'
    import type { NextPage } from 'next'
    import { useRouter } from 'next/navigation'

    const ForgotPasswordPage: NextPage = () => {
      const [email, setEmail] = useState('')
      const [password, setPassword] = useState('')
      const [code, setCode] = useState('')
      const [successfulCreation, setSuccessfulCreation] = useState(false)
      const [secondFactor, setSecondFactor] = useState(false)
      const [error, setError] = useState('')

      const router = useRouter()
      const { isSignedIn } = useAuth()
      const { isLoaded, signIn, setActive } = useSignIn()

      useEffect(() => {
        if (isSignedIn) {
          router.push('/')
        }
      }, [isSignedIn, router])

      if (!isLoaded) {
        return null
      }

      // Send the password reset code to the user's email
      async function create(e: React.FormEvent) {
        e.preventDefault()
        await signIn
          ?.create({
            strategy: 'reset_password_email_code',
            identifier: email,
          })
          .then((_) => {
            setSuccessfulCreation(true)
            setError('')
          })
          .catch((err) => {
            console.error('error', err.errors[0].longMessage)
            setError(err.errors[0].longMessage)
          })
      }

      // Reset the user's password.
      // Upon successful reset, the user will be
      // signed in and redirected to the home page
      async function reset(e: React.FormEvent) {
        e.preventDefault()
        await signIn
          ?.attemptFirstFactor({
            strategy: 'reset_password_email_code',
            code,
            password,
          })
          .then((result) => {
            // Check if 2FA is required
            if (result.status === 'needs_second_factor') {
              setSecondFactor(true)
              setError('')
            } else if (result.status === 'complete') {
              // Set the active session to
              // the newly created session (user is now signed in)
              setActive({ session: result.createdSessionId })
              setError('')
            } else {
              console.log(result)
            }
          })
          .catch((err) => {
            console.error('error', err.errors[0].longMessage)
            setError(err.errors[0].longMessage)
          })
      }

      return (
        <div>
          <h1>Forgot Password?</h1>
          <form onSubmit={!successfulCreation ? create : reset}>
            {!successfulCreation && (
              <>
                <label htmlFor="email">Provide your email address</label>
                <input
                  type="email"
                  placeholder="e.g john@doe.com"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                />

                <button>Send password reset code</button>
                {error && <p>{error}</p>}
              </>
            )}

            {successfulCreation && (
              <>
                <label htmlFor="password">Enter your new password</label>
                <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} />

                <label htmlFor="password">
                  Enter the password reset code that was sent to your email
                </label>
                <input type="code" value={code} onChange={(e) => setCode(e.target.value)} />

                <button>Reset</button>
                {error && <p>{error}</p>}
              </>
            )}

            {secondFactor && <p>2FA is required, but this UI does not handle that</p>}
          </form>
        </div>
      )
    }

    export default ForgotPasswordPage
    ```
  </Tab>

  <Tab>
    ```swift {{ filename: 'ForgotPasswordView.swift', collapsible: true }}
    import SwiftUI
    import Clerk

    struct ForgotPasswordView: View {
      @Environment(Clerk.self) private var clerk
      @State private var email = ""
      @State private var code = ""
      @State private var newPassword = ""
      @State private var isVerifying = false

      var body: some View {
        switch clerk.client?.signIn?.status {
        case .needsFirstFactor:
          TextField("Enter your code", text: $code)
          Button("Verify") {
            Task { await verify(code: code) }
          }

        case .needsSecondFactor:
          Text("2FA is required, but this UI does not handle that")

        case .needsNewPassword:
          SecureField("New password", text: $newPassword)
          Button("Set new password") {
            Task { await setNewPassword(password: newPassword) }
          }

        default:
          if let session = clerk.session {
            Text("Active Session: \(session.id)")
          } else {
            TextField("Email", text: $email)
            Button("Forgot password?") {
              Task { await createSignIn(email: email) }
            }
          }
        }
      }
    }

    extension ForgotPasswordView {

      func createSignIn(email: String) async {
        do {
          // Start the sign in reset password process
          try await SignIn.create(strategy: .identifier(email, strategy: .resetPasswordEmailCode()))
        } catch {
          // See https://clerk.com/docs/custom-flows/error-handling
          // for more info on error handling
          dump(error)
        }
      }

      func verify(code: String) async {
        do {
          // Access the in progress sign in stored on the client object.
          guard let inProgressSignIn = clerk.client?.signIn else { return }

          // Verify the code sent to the user's email
          try await inProgressSignIn.attemptFirstFactor(strategy: .resetPasswordEmailCode(code: code))
        } catch {
          // See https://clerk.com/docs/custom-flows/error-handling
          // for more info on error handling
          dump(error)
        }
      }

      func setNewPassword(password: String) async {
        do {
          // Access the in progress sign in stored on the client object.
          guard let inProgressSignIn = clerk.client?.signIn else { return }

          // Reset the user's password.
          // Upon successful reset, the user will be signed in
          try await inProgressSignIn.resetPassword(.init(password: password, signOutOfOtherSessions: true))
        } catch {
          // See https://clerk.com/docs/custom-flows/error-handling
          // for more info on error handling
          dump(error)
        }
      }
    }
    ```
  </Tab>
</Tabs>

## Prompting users to reset compromised passwords during sign-in

If you have enabled [rejection of compromised passwords also on sign-in](/docs/security/password-protection#reject-compromised-passwords-on-sign-in), then it is possible for the sign-in attempt to be rejected with the `form_password_pwned` error code.

In this case, you can prompt the user to reset their password using the exact same logic detailed in the previous section.

## Phone number

{/* TODO: Add iOS and vanilla JS example. */}

<Tabs items={["Next.js"]}>
  <Tab>
    ```tsx {{ filename: 'app/forgot-password.tsx', collapsible: true }}
    'use client'
    import React, { useState, useEffect } from 'react'
    import { useAuth, useSignIn } from '@clerk/nextjs'
    import type { NextPage } from 'next'
    import { useRouter } from 'next/navigation'

    const ForgotPasswordPage: NextPage = () => {
      const [phoneNumber, setPhoneNumber] = useState('')
      const [password, setPassword] = useState('')
      const [code, setCode] = useState('')
      const [successfulCreation, setSuccessfulCreation] = useState(false)
      const [secondFactor, setSecondFactor] = useState(false)
      const [error, setError] = useState('')

      const router = useRouter()
      const { isSignedIn } = useAuth()
      const { isLoaded, signIn, setActive } = useSignIn()

      useEffect(() => {
        if (isSignedIn) {
          router.push('/')
        }
      }, [isSignedIn, router])

      if (!isLoaded) {
        return null
      }

      // Send the password reset code to the user's email
      async function create(e: React.FormEvent) {
        e.preventDefault()
        await signIn
          ?.create({
            strategy: 'reset_password_phone_code',
            identifier: phoneNumber,
          })
          .then((_) => {
            setSuccessfulCreation(true)
            setError('')
          })
          .catch((err) => {
            console.error('error', err.errors[0].longMessage)
            setError(err.errors[0].longMessage)
          })
      }

      // Reset the user's password.
      // Upon successful reset, the user will be
      // signed in and redirected to the home page
      async function reset(e: React.FormEvent) {
        e.preventDefault()
        await signIn
          ?.attemptFirstFactor({
            strategy: 'reset_password_phone_code',
            code,
            password,
          })
          .then((result) => {
            // Check if 2FA is required
            if (result.status === 'needs_second_factor') {
              setSecondFactor(true)
              setError('')
            } else if (result.status === 'complete') {
              // Set the active session to
              // the newly created session (user is now signed in)
              setActive({ session: result.createdSessionId })
              setError('')
            } else {
              console.log(result)
            }
          })
          .catch((err) => {
            console.error('error', err.errors[0].longMessage)
            setError(err.errors[0].longMessage)
          })
      }

      return (
        <div>
          <h1>Forgot Password?</h1>
          <form onSubmit={!successfulCreation ? create : reset}>
            {!successfulCreation && (
              <>
                <label htmlFor="phoneNumber">Provide your phone number</label>
                <input
                  type="tel"
                  placeholder="e.g +1234567890"
                  value={phoneNumber}
                  onChange={(e) => setPhoneNumber(e.target.value)}
                />

                <button>Send password reset code</button>
                {error && <p>{error}</p>}
              </>
            )}

            {successfulCreation && (
              <>
                <label htmlFor="password">Enter your new password</label>
                <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} />

                <label htmlFor="code">
                  Enter the password reset code that was sent to your phone number
                </label>
                <input type="text" value={code} onChange={(e) => setCode(e.target.value)} />

                <button>Reset</button>
                {error && <p>{error}</p>}
              </>
            )}

            {secondFactor && <p>2FA is required, but this UI does not handle that</p>}
          </form>
        </div>
      )
    }

    export default ForgotPasswordPage
    ```
  </Tab>
</Tabs>

---
title: Build a custom flow for switching organizations
description: Learn how to use the Clerk API to build a custom flow for switching between organizations.
---

<Include src="_partials/custom-flows-callout" />

This guide will demonstrate how to use the Clerk API to build a custom flow for switching between organizations.

<Tabs items={["Next.js", "JavaScript"]}>
  <Tab>
    Two examples are provided: one for a paginated list and one for an infinite list.

    The following examples:

    1. Use the [`useOrganizationList()`](/docs/hooks/use-organization-list) hook to get `memberships`, which is a list of the current user's organization memberships. `memberships` returns `data`, which is an array of [`OrganizationMembership`](/docs/references/javascript/types/organization-membership) objects.
    1. Map over the `data` array to display the user's organization memberships in a table, providing a button that calls `setActive()` to set the selected organization as the active organization.
       - If there are no organizations, the [`<CreateOrganization />` component (custom-flow version, not the Clerk component)](/docs/custom-flows/create-organizations) is rendered to allow the user to create an organization.

    The difference between the two examples is the parameters passed to the `useOrganizationList()` hook in order to determine how the list is paginated.

    - The "Paginated list" example provides a button to load more organizations if there are more available. The `data` array is paginated and will only return the first 5 results, so the `fetchNext()` method is used to load more organizations if they are available.
    - The "Infinite list" example sets the `infinite` option to `true` to enable infinite results.

    This example is written for Next.js App Router but can be adapted for any React-based framework.

    <CodeBlockTabs options={["Paginated list", "Infinite list"]}>
      ```jsx {{ filename: 'app/components/CustomOrganizationSwitcher.tsx', collapsible: true }}
      'use client'

      import { useAuth, useOrganizationList } from '@clerk/nextjs'
      import CreateOrganization from '../components/create-organization' // See /docs/custom-flows/create-organizations for this component

      // List user's organization memberships
      export default function JoinedOrganizations() {
        const { isLoaded, setActive, userMemberships } = useOrganizationList({
          userMemberships: {
            // Set pagination parameters
            pageSize: 5,
            keepPreviousData: true,
          },
        })
        const { orgId } = useAuth()

        if (!isLoaded) {
          return <p>Loading...</p>
        }

        return (
          <>
            <h1>Joined organizations</h1>
            {userMemberships?.data?.length > 0 && (
              <>
                <table>
                  <thead>
                    <tr>
                      <th>Identifier</th>
                      <th>Organization</th>
                      <th>Joined</th>
                      <th>Role</th>
                      <th>Set as active org</th>
                    </tr>
                  </thead>
                  <tbody>
                    {userMemberships?.data?.map((mem) => (
                      <tr key={mem.id}>
                        <td>{mem.publicUserData.identifier}</td>
                        <td>{mem.organization.name}</td>
                        <td>{mem.createdAt.toLocaleDateString()}</td>
                        <td>{mem.role}</td>
                        <td>
                          {orgId === mem.organization.id ? (
                            <button onClick={() => setActive({ organization: mem.organization.id })}>
                              Set as active
                            </button>
                          ) : (
                            <p>Currently active</p>
                          )}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>

                <div>
                  <button
                    disabled={!userMemberships?.hasPreviousPage || userMemberships?.isFetching}
                    onClick={() => userMemberships?.fetchPrevious?.()}
                  >
                    Previous
                  </button>

                  <button
                    disabled={!userMemberships?.hasNextPage || userMemberships?.isFetching}
                    onClick={() => userMemberships?.fetchNext?.()}
                  >
                    Next
                  </button>
                </div>
              </>
            )}
            {userMemberships?.data?.length === 0 && (
              <div>
                <p>No organizations found</p>
                <CreateOrganization />
              </div>
            )}
          </>
        )
      }
      ```

      ```jsx {{ filename: 'app/components/CustomOrganizationSwitcher.tsx', collapsible: true }}
      'use client'

      import { useAuth, useOrganizationList } from '@clerk/nextjs'
      import CreateOrganization from '../components/create-organization' // See /docs/custom-flows/create-organizations for this component

      // List user's organization memberships
      export default function JoinedOrganizations() {
        const { isLoaded, setActive, userMemberships } = useOrganizationList({
          userMemberships: {
            // Set pagination parameters
            infinite: true,
          },
        })
        const { orgId } = useAuth()

        if (!isLoaded) {
          return <p>Loading...</p>
        }

        return (
          <>
            <h1>Joined organizations</h1>
            {userMemberships?.data?.length > 0 && (
              <table>
                <thead>
                  <tr>
                    <th>Identifier</th>
                    <th>Organization</th>
                    <th>Joined</th>
                    <th>Role</th>
                    <th>Set as active org</th>
                  </tr>
                </thead>
                <tbody>
                  {userMemberships?.data?.map((mem) => (
                    <tr key={mem.id}>
                      <td>{mem.publicUserData.identifier}</td>
                      <td>{mem.organization.name}</td>
                      <td>{mem.createdAt.toLocaleDateString()}</td>
                      <td>{mem.role}</td>
                      <td>
                        {orgId === mem.organization.id ? (
                          <button onClick={() => setActive({ organization: mem.organization.id })}>
                            Set as active
                          </button>
                        ) : (
                          <p>Currently active</p>
                        )}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            )}
            {userMemberships?.data?.length === 0 && (
              <div>
                <p>No organizations found</p>
                <CreateOrganization />
              </div>
            )}
          </>
        )
      }
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    The following example:

    1. Calls the [`getOrganizationMemberships()`](/docs/references/javascript/user#get-organization-memberships) method to retrieve the list of organizations the current user is a part of. This method returns `data`, which is an array of [`OrganizationMembership`](/docs/references/javascript/types/organization-membership) objects.
    1. Maps over the `data` array to display the user's organization memberships in a list, providing a button that calls [`setActive()`](/docs/references/javascript/clerk#set-active) to set the selected organization as the active organization.

    Use the tabs to view the code necessary for the `index.html` and `main.js` files.

    <CodeBlockTabs options={["index.html", "main.js"]}>
      ```html {{ filename: 'index.html', collapsible: true }}
      <!doctype html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Clerk + JavaScript App</title>
        </head>
        <body>
          <div id="app"></div>

          <h2>Joined organizations</h2>
          <table>
            <thead>
              <tr>
                <th>Identifier</th>
                <th>Organization</th>
                <th>Joined</th>
                <th>Role</th>
                <th>Set as active org</th>
              </tr>
            </thead>
            <tbody id="memberships-table-body"></tbody>
          </table>

          <div id="create-organization-container" hidden>
            <h1>Create an organization</h1>
            <form id="create-organization">
              <label for="name">Name</label>
              <input id="name" name="name" />
              <button>Create organization</button>
            </form>
          </div>

          <script type="module" src="/src/main.js" async crossorigin="anonymous"></script>
        </body>
      </html>
      ```

      ```js {{ filename: 'main.js', collapsible: true }}
      import { Clerk } from '@clerk/clerk-js'

      const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

      if (!pubKey) {
        throw new Error('Add your VITE_CLERK_PUBLISHABLE_KEY to .env file')
      }

      const clerk = new Clerk('{{pub_key}}')
      await clerk.load()

      if (clerk.user) {
        // Check for an active organization
        if (clerk.organization) {
          const { data } = await clerk.user.getOrganizationMemberships()
          const memberships = data

          memberships.map((membership) => {
            const membershipTable = document.getElementById('memberships-table-body')
            const row = membershipTable.insertRow()
            row.insertCell().textContent = membership.publicUserData.identifier
            row.insertCell().textContent = membership.organization.name
            row.insertCell().textContent = membership.createdAt.toLocaleDateString()
            row.insertCell().textContent = membership.role

            // Set as active organization
            const addBtn = document.createElement('button')
            addBtn.textContent = 'Set as active'
            addBtn.addEventListener('click', async function (e) {
              e.preventDefault()

              await clerk
                .setActive({ organization: membership.organization.id })
                .then((res) => {
                  console.log('Set as active:', res)
                })
                .catch((err) => {
                  // See https://clerk.com/docs/custom-flows/error-handling
                  // for more info on error handling
                  console.error(JSON.stringify(err, null, 2))
                })
            })
            row.insertCell().appendChild(addBtn)
          })
        } else {
          // If there is no active organization,
          // render a form to create an organization
          document.getElementById('create-organization-container').removeAttribute('hidden')
          const form = document.getElementById('create-organization')

          form.addEventListener('submit', function (e) {
            e.preventDefault()

            const inputEl = document.getElementById('name')

            if (!inputEl) {
              // ... handle empty input
              return
            }

            clerk
              .createOrganization({ name: inputEl.value })
              .then((res) => console.log(res))
              .catch((error) => console.log('An error occurred:', error))
          })
        }
      } else {
        // If there is no active user, mount Clerk's <SignIn />
        // or add your sign-in custom flow
        document.getElementById('app').innerHTML = `
          <div id="sign-in"></div>
        `

        const signInDiv = document.getElementById('sign-in')

        clerk.mountSignIn(signInDiv)
      }
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

---
title: Build a custom flow for updating an organization
description: Learn how to use the Clerk API to build a custom flow for updating an organization in your application.
---

<Include src="_partials/custom-flows-callout" />

Organization members with appropriate [permissions](/docs/organizations/roles-permissions) can update an organization.

This guide will demonstrate how to use Clerk's API to build a custom flow for updating an organization.

<Tabs items={["Next.js", "JavaScript"]}>
  <Tab>
    The following example:

    1. Uses the [`useOrganization()`](/docs/hooks/use-organization) hook to fetch the active `organization`.
    1. Uses `organization` to call the `update()` method with the desired name to update the organization. To see what other attributes can be updated, see the [`update()` reference doc](/docs/references/javascript/organization#update).

    This example is written for Next.js App Router but can be adapted for any React-based framework.

    ```tsx {{ filename: 'app/components/UpdateOrganization.tsx', collapsible: true }}
    'use client'

    import { useState, useEffect } from 'react'
    import { useRouter } from 'next/navigation'
    import { useOrganization } from '@clerk/nextjs'

    export default function UpdateOrganization() {
      const [name, setName] = useState('')
      const router = useRouter()
      const { organization } = useOrganization()

      useEffect(() => {
        if (!organization) {
          return
        }
        setName(organization.name)
      }, [organization])

      if (!organization) {
        return null
      }

      async function submit(e: React.FormEvent<HTMLFormElement>) {
        e.preventDefault()
        try {
          await organization?.update({ name })
          router.push(`/organizations/${organization?.id}`)
        } catch (err) {
          console.error(err)
        }
      }

      return (
        <div>
          <h1>Update the current organization</h1>
          <form onSubmit={submit}>
            <div>
              <label htmlFor="name">Name</label>
              <input id="name" name="name" value={name} onChange={(e) => setName(e.target.value)} />
            </div>
            <button>Update</button>
          </form>
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    The following example uses the `organization.update()` method to update the active organization's name. To see what other attributes can be updated, see the [`update()` reference doc](/docs/references/javascript/organization#update).

    Use the tabs to view the code necessary for the `index.html` and `main.js` files.

    <CodeBlockTabs options={["index.html", "main.js"]}>
      ```html {{ filename: 'index.html', collapsible: true }}
      <!doctype html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Clerk + JavaScript App</title>
        </head>
        <body>
          <div id="app"></div>

          <h1>Update the current organization</h1>
          <form id="update-organization">
            <label for="name">Name</label>
            <input id="name" name="name" />
            <button>Update</button>
          </form>

          <script type="module" src="/src/main.js" async crossorigin="anonymous"></script>
        </body>
      </html>
      ```

      ```js {{ filename: 'main.js', collapsible: true }}
      import { Clerk } from '@clerk/clerk-js'

      const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

      if (!pubKey) {
        throw new Error('Add your VITE_CLERK_PUBLISHABLE_KEY to .env file')
      }

      const clerk = new Clerk('{{pub_key}}')
      await clerk.load()

      if (clerk.user) {
        // Check for an active organization
        if (clerk.organization) {
          const form = document.getElementById('update-organization')

          form.addEventListener('submit', function (e) {
            e.preventDefault()

            const inputEl = document.getElementById('name')

            if (!inputEl) {
              // ... handle empty input
              return
            }

            clerk.organization
              .update({ name: inputEl.value })
              .then((res) => console.log(`Updated org:`, res))
              .catch((error) => console.log('An error occurred:', error))
          })
        } else {
          // If there is no active organization,
          // mount Clerk's <OrganizationSwitcher />
          // to allow the user to set an organization as active
          document.getElementById('app').innerHTML = `
            <h2>Select an organization to set it as active</h2>
            <div id="org-switcher"></div>
          `

          const orgSwitcherDiv = document.getElementById('org-switcher')

          clerk.mountOrganizationSwitcher(orgSwitcherDiv)
        }
      } else {
        // If there is no active user, mount Clerk's <SignIn />
        document.getElementById('app').innerHTML = `
          <div id="sign-in"></div>
        `

        const signInDiv = document.getElementById('sign-in')

        clerk.mountSignIn(signInDiv)
      }
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

---
title: Build a custom Google One Tap authentication flow
description: Learn how to build a custom Google One Tap authentication flow using the Clerk API.
---

<Include src="_partials/custom-flows-callout" />

[Google One Tap](https://developers.google.com/identity/gsi/web/guides/features) enables users to press a single button to authentication in your Clerk application with a Google account.

This guide will walk you through how to build a custom Google One Tap authentication flow.

<Steps>
  ## Enable Google as a social connection

  To use Google One Tap with Clerk, follow the steps in the [dedicated guide](/docs/authentication/social-connections/google#configure-for-your-production-instance) to configure Google as a social connection in the Clerk Dashboard using custom credentials.

  ## Create the Google One Tap authentication flow

  To authenticate users with Google One Tap, you must:

  1. Initialize a ["Sign In With Google"](https://developers.google.com/identity/gsi/web/reference/js-reference) client UI, passing in your Client ID.
  1. Use the response to authenticate the user in your Clerk app if the request was successful.
  1. Redirect the user back to the page they started the authentication flow from by default, or to another URL if necessary.

  The following example creates a component that implements a custom Google One Tap authentication flow, which can be used in a sign-in or sign-up page.

  <Tabs items={["Next.js"]}>
    <Tab>
      ```tsx {{ filename: 'app/components/CustomGoogleOneTap.tsx', collapsible: true }}
      'use client'
      import { useClerk } from '@clerk/nextjs'
      import { useRouter } from 'next/navigation'
      import Script from 'next/script'
      import { useEffect } from 'react'

      // Add clerk to Window to avoid type errors
      declare global {
        interface Window {
          google: any
        }
      }

      export function CustomGoogleOneTap({ children }: { children: React.ReactNode }) {
        const clerk = useClerk()
        const router = useRouter()

        useEffect(() => {
          // Will show the One Tap UI after two seconds
          const timeout = setTimeout(() => oneTap(), 2000)
          return () => {
            clearTimeout(timeout)
          }
        }, [])

        const oneTap = () => {
          const { google } = window
          if (google) {
            google.accounts.id.initialize({
              // Add your Google Client ID here.
              client_id: 'xxx-xxx-xxx',
              callback: async (response: any) => {
                // Here we call our provider with the token provided by Google
                call(response.credential)
              },
            })

            // Uncomment below to show the One Tap UI without
            // logging any notifications.
            // return google.accounts.id.prompt() // without listening to notification

            // Display the One Tap UI, and log any errors that occur.
            return google.accounts.id.prompt((notification: any) => {
              console.log('Notification ::', notification)
              if (notification.isNotDisplayed()) {
                console.log('getNotDisplayedReason ::', notification.getNotDisplayedReason())
              } else if (notification.isSkippedMoment()) {
                console.log('getSkippedReason  ::', notification.getSkippedReason())
              } else if (notification.isDismissedMoment()) {
                console.log('getDismissedReason ::', notification.getDismissedReason())
              }
            })
          }
        }

        const call = async (token: any) => {
          try {
            const res = await clerk.authenticateWithGoogleOneTap({
              token,
            })

            await clerk.handleGoogleOneTapCallback(res, {
              signInFallbackRedirectUrl: '/example-fallback-path',
            })
          } catch (error) {
            router.push('/sign-in')
          }
        }

        return (
          <>
            <Script src="https://accounts.google.com/gsi/client" strategy="beforeInteractive">
              {children}
            </Script>
          </>
        )
      }
      ```
    </Tab>
  </Tabs>

  You can then display this component on any page. The following example demonstrates a page that displays this component:

  <Tabs items={["Next.js"]}>
    <Tab>
      ```tsx {{ filename: 'app/google-sign-in-example/page.tsx' }}
      import { CustomGoogleOneTap } from '@/app/components/CustomGoogleOneTap'

      export default function CustomOneTapPage({ children }: { children: React.ReactNode }) {
        return (
          <CustomGoogleOneTap>
            <h1>Google One Tap Example</h1>
          </CustomGoogleOneTap>
        )
      }
      ```
    </Tab>
  </Tabs>
</Steps>

---
title: Build a custom multi-session flow
description: Learn how to use the Clerk API to add multi-session handling to your application.
---

<Include src="_partials/custom-flows-callout" />

A multi-session application is an application that allows multiple accounts to be signed in from the same browser at the same time. The user can switch from one account to another seamlessly. Each account is independent from the rest and has access to different resources.

This guide provides you with the necessary information to build a custom multi-session flow using the Clerk API.

To implement the multi-session feature to your application, you need to handle the following scenarios:

- [Switching between different accounts](#switch-between-sessions)
- [Adding new accounts](#add-a-new-session)
- [Signing out from one account, while remaining signed in to the rest](#sign-out-active-session)
- [Signing out from all accounts](#sign-out-all-sessions)

## Enable multi-session in your application

To enable multi-session in your application, you need to configure it in the Clerk Dashboard.

1. In the Clerk Dashboard, navigate to the [**Sessions**](https://dashboard.clerk.com/last-active?path=sessions) page.
1. Toggle on **Multi-session handling**.
1. Select **Save changes**.

## Get the active session and user

<CodeBlockTabs options={["React", "JavaScript", "iOS"]}>
  ```jsx
  import { useClerk } from '@clerk/clerk-react'

  // Get the active session and user
  const { session, user } = useClerk()
  ```

  ```js
  // Get the active session
  const activeSession = window.Clerk.session

  // Get the active user
  const activeUser = window.Clerk.user
  ```

  ```swift
  // Get the active session
  var activeSession: Session? { Clerk.shared.session }

  // Get the active user
  var user: User? { Clerk.shared.user }
  ```
</CodeBlockTabs>

## Switch between sessions

<CodeBlockTabs options={["React", "JavaScript", "iOS"]}>
  ```jsx
  import { useClerk } from '@clerk/clerk-react'

  const { client, setActive } = useClerk()

  // You can get all the available sessions through the client
  const availableSessions = client.sessions

  // Use setActive to set the active session.
  setActive({ session: availableSessions[0].id })
  ```

  ```js
  // You can get all the available sessions through the client
  const availableSessions = window.Clerk.client.sessions

  // Use setActive to set the active session.
  window.Clerk.setActive({ session: availableSessions[0].id })
  ```

  ```swift
  // You can get all the available sessions through the client
  var availableSessions: [Session] { Clerk.shared.client?.sessions ?? [] }

  // Use setActive to set the active session.
  try await Clerk.shared.setActive(sessionId: session.id)
  ```
</CodeBlockTabs>

## Add a new session

To add a new session, simply link to your existing sign-in flow. New sign-ins will automatically add to the list of available sessions on the client. To create a sign-in flow, see one of the following popular guides:

- [Email and password](/docs/custom-flows/email-password)
- [Passwordless authentication](/docs/custom-flows/email-sms-otp)
- [Social sign-in (OAuth)](/docs/authentication/social-connections/overview)

For more information on how Clerk's sign-in flow works, see the [detailed sign-in guide](/docs/custom-flows/overview#sign-in-flow).

## Sign out all sessions

Use [`signOut()`](/docs/references/javascript/clerk#sign-out) to deactivate all sessions on the current client.

<CodeBlockTabs options={["React", "JavaScript", "iOS"]}>
  ```jsx
  import { useClerk } from '@clerk/clerk-react'

  const { signOut, session } = useClerk()

  // Use signOut to sign-out all active sessions.
  await signOut()
  ```

  ```js
  // Use signOut to sign-out all active sessions.
  await window.Clerk.signOut()
  ```

  ```swift
  // Use signOut to sign-out all active sessions.
  try await Clerk.shared.signOut()
  ```
</CodeBlockTabs>

## Sign out active session

Use [`signOut()`](/docs/references/javascript/clerk#sign-out) to deactivate a specific session by passing the session ID.

<CodeBlockTabs options={["React", "JavaScript", "iOS"]}>
  ```jsx
  import { useClerk } from '@clerk/clerk-react'

  // Get the signOut method and the active session
  const { signOut, session } = useClerk()

  // Use signOut to sign-out the active session
  await signOut(session.id)
  ```

  ```js
  // Get the active session
  const activeSession = window.Clerk.session

  // Use signOut to sign-out the active session
  await window.Clerk.signOut(activeSession.id)
  ```

  ```swift
  // Use signOut to sign-out a specific session
  try await Clerk.shared.signOut(sessionId: session.id)
  ```
</CodeBlockTabs>

---
title: Build a custom sign-in flow with multi-factor authentication
description: Learn how to build a custom email/password sign-in flow that requires multi-factor authentication (MFA).
---

<Include src="_partials/custom-flows-callout" />

[Multi-factor verification (MFA)](/docs/authentication/configuration/sign-up-sign-in-options) is an added layer of security that requires users to provide a second verification factor to access an account.

Clerk supports second factor verification through **SMS verification code**, **Authenticator application**, and **Backup codes**.

This guide will walk you through how to build a custom email/password sign-in flow that supports **Authenticator application** and **Backup codes** as the second factor.

<Steps>
  ## Enable email and password authentication

  This example uses email and password authentication, however, you can modify this approach according to the needs of your application. To use email and password authentication, you first need to enable these authentication strategies in the Clerk Dashboard.

  1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
  1. Ensure that _only_ **Email address** is required. If **Phone number** and **Username** are enabled, ensure they are not required. Use the settings icon next to each user attribute to check if a setting is required or optional. If you want to require **Username**, you must collect the username and pass the data to the `create()` method in your custom flow.
  1. In the **Authentication strategies** section of this page, ensure **Password** is enabled.

  ## Enable multi-factor authentication

  For your users to be able to enable MFA for their account, you need to enable MFA as an authentication strategy in your Clerk application.

  1. In the Clerk Dashboard, navigate to the [**Multi-factor**](https://dashboard.clerk.com/last-active?path=user-authentication/multi-factor) page.
  1. For the purpose of this guide, toggle on both the **Authenticator application** and **Backup codes** strategies.
  1. Select **Save**.

  ## Sign-in flow

  Signing in to an MFA-enabled account is identical to the regular sign-in process. However, in the case of an MFA-enabled account, a sign-in won't convert until both first factor and second factor verifications are completed.

  To authenticate a user using their email and password, you need to:

  1. Initiate the sign-in process by collecting the user's email address and password.
  1. Prepare the first factor verification.
  1. Attempt to complete the first factor verification.
  1. Prepare the second factor verification. (This is where MFA comes into play.)
  1. Attempt to complete the second factor verification.
  1. If the verification is successful, set the newly created session as the active session.

  > [!TIP]
  > For this example to work, the user must have MFA enabled on their account. You need to add the ability for your users to manage their MFA settings. See the [manage SMS-based MFA](/docs/custom-flows/manage-sms-based-mfa) or the [manage TOTP-based MFA](/docs/custom-flows/manage-totp-based-mfa) guide, depending on your needs.

  <Tabs items={["Next.js", "JavaScript", "Expo", "iOS"]}>
    <Tab>
      ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx', collapsible: true }}
      'use client'

      import * as React from 'react'
      import { useSignIn } from '@clerk/nextjs'
      import { useRouter } from 'next/navigation'

      export default function SignInForm() {
        const { isLoaded, signIn, setActive } = useSignIn()
        const [email, setEmail] = React.useState('')
        const [password, setPassword] = React.useState('')
        const [code, setCode] = React.useState('')
        const [useBackupCode, setUseBackupCode] = React.useState(false)
        const [displayTOTP, setDisplayTOTP] = React.useState(false)
        const router = useRouter()

        // Handle user submitting email and pass and swapping to TOTP form
        const handleFirstStage = (e: React.FormEvent) => {
          e.preventDefault()
          setDisplayTOTP(true)
        }

        // Handle the submission of the TOTP of Backup Code submission
        const handleSubmit = async (e: React.FormEvent) => {
          e.preventDefault()

          if (!isLoaded) return

          // Start the sign-in process using the email and password provided
          try {
            await signIn.create({
              identifier: email,
              password,
            })

            // Attempt the TOTP or backup code verification
            const signInAttempt = await signIn.attemptSecondFactor({
              strategy: useBackupCode ? 'backup_code' : 'totp',
              code: code,
            })

            // If verification was completed, set the session to active
            // and redirect the user
            if (signInAttempt.status === 'complete') {
              await setActive({ session: signInAttempt.createdSessionId })
              router.push('/')
            } else {
              // If the status is not complete, check why. User may need to
              // complete further steps.
              console.log(signInAttempt)
            }
          } catch (err) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error('Error:', JSON.stringify(err, null, 2))
          }
        }

        if (displayTOTP) {
          return (
            <div>
              <h1>Verify your account</h1>
              <form onSubmit={(e) => handleSubmit(e)}>
                <div>
                  <label htmlFor="code">Code</label>
                  <input
                    onChange={(e) => setCode(e.target.value)}
                    id="code"
                    name="code"
                    type="text"
                    value={code}
                  />
                </div>
                <div>
                  <label htmlFor="backupcode">This code is a backup code</label>
                  <input
                    onChange={() => setUseBackupCode((prev) => !prev)}
                    id="backupcode"
                    name="backupcode"
                    type="checkbox"
                    checked={useBackupCode}
                  />
                </div>
                <button type="submit">Verify</button>
              </form>
            </div>
          )
        }

        return (
          <>
            <h1>Sign in</h1>
            <form onSubmit={(e) => handleFirstStage(e)}>
              <div>
                <label htmlFor="email">Email</label>
                <input
                  onChange={(e) => setEmail(e.target.value)}
                  id="email"
                  name="email"
                  type="email"
                  value={email}
                />
              </div>
              <div>
                <label htmlFor="password">Password</label>
                <input
                  onChange={(e) => setPassword(e.target.value)}
                  id="password"
                  name="password"
                  type="password"
                  value={password}
                />
              </div>
              <button type="submit">Continue</button>
            </form>
          </>
        )
      }
      ```
    </Tab>

    <Tab>
      <CodeBlockTabs options={["index.html", "main.js"]}>
        ```html {{ filename: 'index.html', collapsible: true }}
        <!doctype html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <title>Clerk + JavaScript App</title>
          </head>
          <body>
            <div id="signed-in"></div>

            <div id="sign-in">
              <h2>Sign in</h2>
              <form id="sign-in-form">
                <label for="email">Enter email address</label>
                <input name="email" id="sign-in-email" />
                <label for="password">Enter password</label>
                <input name="password" id="sign-in-password" />
                <button type="submit">Continue</button>
              </form>
            </div>

            <form id="verifying" hidden>
              <h2>Verify your account</h2>
              <label for="totp">Enter your code</label>
              <input id="totp" name="code" />
              <label for="backupCode">This code is a backup code</label>
              <input type="checkbox" id="backupCode" name="backupCode" />
              <button type="submit" id="verify-button">Verify</button>
            </form>

            <script type="module" src="/src/main.js" async crossorigin="anonymous"></script>
          </body>
        </html>
        ```

        ```js {{ filename: 'main.js', collapsible: true }}
        import { Clerk } from '@clerk/clerk-js'

        const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

        const clerk = new Clerk(pubKey)
        await clerk.load()

        if (clerk.user) {
          // Mount user button component
          document.getElementById('signed-in').innerHTML = `
            <div id="user-button"></div>
          `

          const userbuttonDiv = document.getElementById('user-button')

          clerk.mountUserButton(userbuttonDiv)
        } else {
          // Handle the sign-in form
          document.getElementById('sign-in-form').addEventListener('submit', async (e) => {
            e.preventDefault()

            const formData = new FormData(e.target)
            const emailAddress = formData.get('email')
            const password = formData.get('password')

            try {
              // Start the sign-in process
              await clerk.client.signIn.create({
                identifier: emailAddress,
                password,
              })

              // Hide sign-in form
              document.getElementById('sign-in').setAttribute('hidden', '')
              // Show verification form
              document.getElementById('verifying').removeAttribute('hidden')
            } catch (error) {
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.error(error)
            }
          })

          // Handle the verification form
          document.getElementById('verifying').addEventListener('submit', async (e) => {
            const formData = new FormData(e.target)
            const totp = formData.get('totp')
            const backupCode = formData.get('backupCode')

            try {
              const useBackupCode = backupCode ? true : false
              const code = backupCode ? backupCode : totp

              // Attempt the TOTP or backup code verification
              const signInAttempt = await clerk.client.signIn.attemptSecondFactor({
                strategy: useBackupCode ? 'backup_code' : 'totp',
                code: code,
              })

              // If verification was completed, set the session to active
              // and redirect the user
              if (signInAttempt.status === 'complete') {
                await clerk.setActive({ session: signInAttempt.createdSessionId })

                location.reload()
              } else {
                // If the status is not complete, check why. User may need to
                // complete further steps.
                console.error(signInAttempt)
              }
            } catch (error) {
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.error(error)
            }
          })
        }
        ```
      </CodeBlockTabs>
    </Tab>

    <Tab>
      ### Before you start

      Install `expo-checkbox` for the UI.

      <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
        ```bash {{ filename: 'terminal' }}
        npm install expo-checkbox
        ```

        ```bash {{ filename: 'terminal' }}
        yarn add expo-checkbox
        ```

        ```bash {{ filename: 'terminal' }}
        pnpm add expo-checkbox
        ```

        ```bash {{ filename: 'terminal' }}
        bun add expo-checkbox
        ```
      </CodeBlockTabs>

      ### Build the flow

      1. Create the `(auth)` route group. This groups your sign-up and sign-in pages.
      1. In the `(auth)` group, create a `_layout.tsx` file with the following code. The [`useAuth()`](/docs/hooks/use-auth) hook is used to access the user's authentication state. If the user's already signed in, they'll be redirected to the home page.

      ```tsx {{ filename: 'app/(auth)/_layout.tsx' }}
      import { Redirect, Stack } from 'expo-router'
      import { useAuth } from '@clerk/clerk-expo'

      export default function AuthenticatedLayout() {
        const { isSignedIn } = useAuth()

        if (isSignedIn) {
          return <Redirect href={'/'} />
        }

        return <Stack />
      }
      ```

      In the `(auth)` group, create a `sign-in.tsx` file with the following code. The [`useSignIn()`](/docs/hooks/use-sign-in) hook is used to create a sign-in flow. The user can sign in using their email and password and will be prompted to verify their account with a code from their authenticator app or with a backup code.

      ```tsx {{ filename: 'app/(auth)/sign-in.tsx', collapsible: true }}
      import React from 'react'
      import { useSignIn } from '@clerk/clerk-expo'
      import { useRouter } from 'expo-router'
      import { Text, TextInput, Button, View } from 'react-native'
      import Checkbox from 'expo-checkbox'

      export default function Page() {
        const { signIn, setActive, isLoaded } = useSignIn()

        const [email, setEmail] = React.useState('')
        const [password, setPassword] = React.useState('')
        const [code, setCode] = React.useState('')
        const [useBackupCode, setUseBackupCode] = React.useState(false)
        const [displayTOTP, setDisplayTOTP] = React.useState(false)
        const router = useRouter()

        // Handle user submitting email and pass and swapping to TOTP form
        const handleFirstStage = async () => {
          if (!isLoaded) return

          // Attempt to sign in using the email and password provided
          try {
            const attemptFirstFactor = await signIn.create({
              identifier: email,
              password,
            })

            // If the sign-in was successful, set the session to active
            // and redirect the user
            if (attemptFirstFactor.status === 'complete') {
              await setActive({ session: attemptFirstFactor.createdSessionId })
              router.replace('/')
            } else if (attemptFirstFactor.status === 'needs_second_factor') {
              // If the sign-in requires a second factor, display the TOTP form
              setDisplayTOTP(true)
            } else {
              // If the sign-in failed, check why. User might need to
              // complete further steps.
              console.error(JSON.stringify(attemptFirstFactor, null, 2))
            }
          } catch (err) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error(JSON.stringify(err, null, 2))
          }
        }

        // Handle the submission of the TOTP or backup code
        const onPressTOTP = React.useCallback(async () => {
          if (!isLoaded) return

          try {
            // Attempt the TOTP or backup code verification
            const attemptSecondFactor = await signIn.attemptSecondFactor({
              strategy: useBackupCode ? 'backup_code' : 'totp',
              code: code,
            })

            // If verification was completed, set the session to active
            // and redirect the user
            if (attemptSecondFactor.status === 'complete') {
              await setActive({ session: attemptSecondFactor.createdSessionId })

              router.replace('/')
            } else {
              // If the status is not complete, check why. User may need to
              // complete further steps.
              console.error(JSON.stringify(attemptSecondFactor, null, 2))
            }
          } catch (err) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error(JSON.stringify(err, null, 2))
          }
        }, [isLoaded, email, password, code, useBackupCode])

        if (displayTOTP) {
          return (
            <View>
              <Text>Verify your account</Text>

              <View>
                <TextInput
                  value={code}
                  placeholder="Enter the code"
                  placeholderTextColor="#666666"
                  onChangeText={(c) => setCode(c)}
                />
              </View>
              <View style={{ flexDirection: 'row', alignItems: 'center', gap: 5 }}>
                <Text>Check if this code is a backup code</Text>
                <Checkbox value={useBackupCode} onValueChange={() => setUseBackupCode((prev) => !prev)} />
              </View>
              <Button title="Verify" onPress={onPressTOTP} />
            </View>
          )
        }

        return (
          <View>
            <Text>Sign in</Text>
            <View>
              <TextInput
                value={email}
                placeholder="Enter email"
                placeholderTextColor="#666666"
                onChangeText={(email) => setEmail(email)}
              />
            </View>

            <View>
              <TextInput
                value={password}
                placeholder="Enter password"
                placeholderTextColor="#666666"
                secureTextEntry={true}
                onChangeText={(password) => setPassword(password)}
              />
            </View>

            <Button title="Continue" onPress={handleFirstStage} />
          </View>
        )
      }
      ```
    </Tab>

    <Tab>
      ```swift {{ filename: 'MFASignInView.swift', collapsible: true }}
      import SwiftUI
      import Clerk

      struct MFASignInView: View {
        @State private var email = ""
        @State private var password = ""
        @State private var code = ""
        @State private var displayTOTP = false

        var body: some View {
          if displayTOTP {
            TextField("Code", text: $code)
            Button("Verify") {
              Task { await verify(code: code) }
            }
          } else {
            TextField("Email", text: $email)
            SecureField("Password", text: $password)
            Button("Next") {
              Task { await submit(email: email, password: password) }
            }
          }
        }
      }

      extension MFASignInView {

        func submit(email: String, password: String) async {
          do {
            // Start the sign-in process.
            let signIn = try await SignIn.create(strategy: .identifier(email, password: password))

            switch signIn.status {
            case .needsSecondFactor:
              // Handle user submitting email and password and swapping to TOTP form.
              displayTOTP = true
            default:
              // If the status is not needsSecondFactor, check why. User may need to
              // complete different steps.
              dump(signIn.status)
            }
          } catch {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            dump(error)
          }
        }

        func verify(code: String) async {
          do {
            // Access the in progress sign in stored on the client object.
            guard let inProgressSignIn = Clerk.shared.client?.signIn else { return }

            // Attempt the TOTP or backup code verification.
            let signIn = try await inProgressSignIn.attemptSecondFactor(strategy: .totp(code: code))

            switch signIn.status {
            case .complete:
              // If sign-in process is complete, navigate the user as needed.
              dump(Clerk.shared.session)
            default:
              // If the status is not complete, check why. User may need to
              // complete further steps.
              dump(signIn.status)
            }
          } catch {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            dump(error)
          }
        }
      }
      ```
    </Tab>
  </Tabs>
</Steps>

{/* TODO: Add logic for MFA for phone code */}

## Next steps

Now that users can sign in with MFA, you need to add the ability for your users to manage their MFA settings. Learn how to build a custom flow for [managing TOTP MFA](/docs/custom-flows/manage-totp-based-mfa) or for [managing SMS MFA](/docs/custom-flows/manage-sms-based-mfa).

---
title: Build a custom sign-out flow
description: Learn how to use the Clerk API to build a custom sign-out flow using Clerk's signOut() function.
---

<Include src="_partials/custom-flows-callout" />

Clerk's [`<UserButton />`](/docs/components/user/user-button) and [`<SignOutButton />`](/docs/components/unstyled/sign-out-button) components provide an out-of-the-box solution for signing out users. However, if you're building a custom solution, you can use the [`signOut()`](/docs/references/javascript/clerk#sign-out) function to handle the sign-out process.

The `signOut()` function signs a user out of all sessions in a [multi-session application](/docs/authentication/configuration/session-options#multi-session-applications), or only the current session in a single-session context. You can also specify a specific session to sign out by passing the `sessionId` parameter.

> [!NOTE]
> The sign-out flow deactivates only the current session. Other valid sessions associated with the same user (e.g., if the user is signed in on another device) will remain active.

<Tabs items={["Next.js", "JavaScript", "Expo", "iOS"]}>
  <Tab>
    The [`useClerk()`](/docs/hooks/use-clerk) hook is used to access the `signOut()` function, which is called when the user clicks the sign-out button.

    This example is written for Next.js App Router but can be adapted for any React-based framework.

    ```jsx {{ filename: 'app/components/SignOutButton.tsx' }}
    'use client'

    import { useClerk } from '@clerk/nextjs'

    export const SignOutButton = () => {
      const { signOut } = useClerk()

      return (
        // Clicking this button signs out a user
        // and redirects them to the home page "/".
        <button onClick={() => signOut({ redirectUrl: '/' })}>Sign out</button>
      )
    }
    ```
  </Tab>

  <Tab>
    <CodeBlockTabs options={["index.html", "main.js"]}>
      ```html {{ filename: 'index.html', collapsible: true }}
      <!doctype html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <link rel="icon" type="image/svg+xml" href="/clerk.svg" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Clerk + JavaScript App</title>
        </head>

        <body>
          <div id="app"></div>
          <button id="sign-out">Sign out</button>
          <script type="module" src="main.js" async crossorigin="anonymous"></script>
        </body>
      </html>
      ```

      ```js {{ filename: 'main.js', collapsible: true }}
      import { Clerk } from '@clerk/clerk-js'

      const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

      const clerk = new Clerk(pubKey)
      await clerk.load()

      if (clerk.user) {
        // Attach signOut function to the sign-out button
        document.getElementById('sign-out').addEventListener('click', async () => {
          await clerk.signOut()
          // Optional: refresh page after sign-out
          window.location.reload()
        })
      }
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    The [`useClerk()`](/docs/hooks/use-clerk) hook is used to access the `signOut()` function, which is called when the user clicks the "Sign out" button.

    <Include src="_partials/expo/sign-out-custom-flow" />
  </Tab>

  <Tab>
    ```swift {{ filename: 'SignOutView.swift', collapsible: true }}
    import SwiftUI
    import Clerk

    struct SignOutView: View {
      @Environment(Clerk.self) private var clerk

      var body: some View {
        if let session = clerk.session {
          Text("Active Session: \(session.id)")
          Button("Sign out") {
            Task { await signOut() }
          }
        } else {
          Text("You are signed out")
        }
      }
    }

    extension SignOutView {

      func signOut() async {
        do {
          try await clerk.signOut()
        } catch {
          // See https://clerk.com/docs/custom-flows/error-handling
          // for more info on error handling.
          dump(error)
        }
      }
    }
    ```
  </Tab>
</Tabs>

---
title: Build a sign-in flow with Clerk Elements
description: Learn how to build a complete sign-in form with Clerk Elements.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Follow the Next.js quickstart",
      link: "/docs/quickstarts/nextjs",
      icon: "nextjs",
    },
    {
      title: "Upgrade to Core 2 (if necessary)",
      link: "/docs/upgrade-guides/core-2/nextjs",
      icon: "arrow-up-circle",
    },
    {
      title: "Install Clerk Elements",
      link: "/docs/customization/elements/overview#getting-started",
      icon: "application-2",
    },
  ]}
/>

> [!NOTE]
>
> - Clerk Elements is for [advanced use-cases](/docs/customization/elements/overview#why-use-clerk-elements) that require a high-level of customization. The easiest way to implement Clerk is with our [all-in-one UI components](/docs/components/overview).
> - Clerk Elements currently only works with Next.js App Router and [Clerk Core 2](/changelog/2024-04-19){{ target: '_blank' }}. As it gets closer to a stable release, support for additional frameworks will be added.

<Steps>
  ## Add a sign-in route

  Create a new route in your Next.js application. The route needs to be an [optional catch-all route](https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#optional-catch-all-segments) so the sign-in flow can handled nested paths, as shown in the following example:

  ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx' }}
  'use client'

  import * as Clerk from '@clerk/elements/common'
  import * as SignIn from '@clerk/elements/sign-in'

  export default function SignInPage() {
    return <SignIn.Root>[Sign In Root]</SignIn.Root>
  }
  ```

  You will use these two imports to build out the rest of the flow. `<SignIn.Root>` manages the sign-in state and handles connecting the components to Clerk's APIs.

  > [!TIP]
  > If you're getting TypeScript errors on the `@clerk/elements` imports you probably have forgotten to set your [`moduleResolution`](https://www.typescriptlang.org/tsconfig/#moduleResolution) in `tsconfig.json` to `bundler`.

  ## Add the start step

  The Clerk authentication flows are made up of **steps**. Steps handle rendering the UI for each part of the flow. To allow users to create a sign-in attempt, the `start` step needs to be rendered. The following example does so with the `<SignIn.Step>` component:

  ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx', mark: [[9, 11]] }}
  'use client'

  import * as Clerk from '@clerk/elements/common'
  import * as SignIn from '@clerk/elements/sign-in'

  export default function SignInPage() {
    return (
      <SignIn.Root>
        <SignIn.Step name="start">
          <h1>Sign in to your account</h1>
        </SignIn.Step>
      </SignIn.Root>
    )
  }
  ```

  ## Add form fields

  Make it functional by adding input fields. The following example uses the `<Clerk.Field>` component to render an `identifier` field, as well as the `<Connection>` component to allow users to sign in with a social connection, like Google:

  ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx', mark: [[12, 20]] }}
  'use client'

  import * as Clerk from '@clerk/elements/common'
  import * as SignIn from '@clerk/elements/sign-in'

  export default function SignInPage() {
    return (
      <SignIn.Root>
        <SignIn.Step name="start">
          <h1>Sign in to your account</h1>

          <Clerk.Connection name="google">Sign in with Google</Clerk.Connection>

          <Clerk.Field name="identifier">
            <Clerk.Label>Email</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignIn.Action submit>Continue</SignIn.Action>
        </SignIn.Step>
      </SignIn.Root>
    )
  }
  ```

  `<Clerk.Field>` takes care of wiring up the input with the label element, and `<Clerk.FieldError>` will render any field-specific errors that get returned from Clerk's API. The `<SignIn.Action>` component provides common actions that are used throughout the flows. In this case, using the `submit` action to render a submit button for the start form.

  > [!NOTE]
  > If your Clerk instance supports signing in with Google and doesn't require multi-factor authentication (MFA), you should be able to complete a sign-in with the components rendered so far.

  ## Add verification

  As users progress through a sign-in attempt, they may be asked to **verify** a number of authentication factors in the `verifications` step. You can render a form for the user to complete verification, but each [verification strategy](/docs/customization/elements/reference/sign-in#strategy) requires different fields. You must render the form fields conditionally for each authentication strategy your instance supports using the `<SignIn.Strategy>` component.

  The following example demonstrates how to conditionally render a form for the `email_code` strategy:

  ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx', mark: [[23, 38]] }}
  'use client'

  import * as Clerk from '@clerk/elements/common'
  import * as SignIn from '@clerk/elements/sign-in'

  export default function SignInPage() {
    return (
      <SignIn.Root>
        <SignIn.Step name="start">
          <h1>Sign in to your account</h1>

          <Clerk.Connection name="google">Sign in with Google</Clerk.Connection>

          <Clerk.Field name="identifier">
            <Clerk.Label>Email</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignIn.Action submit>Continue</SignIn.Action>
        </SignIn.Step>

        <SignIn.Step name="verifications">
          <SignIn.Strategy name="email_code">
            <h1>Check your email</h1>
            <p>
              We sent a code to <SignIn.SafeIdentifier />.
            </p>

            <Clerk.Field name="code">
              <Clerk.Label>Email code</Clerk.Label>
              <Clerk.Input />
              <Clerk.FieldError />
            </Clerk.Field>

            <SignIn.Action submit>Continue</SignIn.Action>
          </SignIn.Strategy>
        </SignIn.Step>
      </SignIn.Root>
    )
  }
  ```

  Verification is the final step in the sign-in flow. When a user has verified all required factors, the sign-in attempt will be complete and they will be signed in.

  ## Add password support

  If your instance is configured to support authenticating with passwords, you must add a few additional steps and verification strategies. You can choose if you want to support providing a password in the `start` step with an additional field, or as an additional verification strategy. For this guide, add it as a standalone verification strategy.

  ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx', mark: [[39, 65], [68, 94]] }}
  'use client'

  import * as Clerk from '@clerk/elements/common'
  import * as SignIn from '@clerk/elements/sign-in'

  export default function SignInPage() {
    return (
      <SignIn.Root>
        <SignIn.Step name="start">
          <h1>Sign in to your account</h1>

          <Clerk.Connection name="google">Sign in with Google</Clerk.Connection>

          <Clerk.Field name="identifier">
            <Clerk.Label>Email</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignIn.Action submit>Continue</SignIn.Action>
        </SignIn.Step>

        <SignIn.Step name="verifications">
          <SignIn.Strategy name="email_code">
            <h1>Check your email</h1>
            <p>
              We sent a code to <SignIn.SafeIdentifier />.
            </p>

            <Clerk.Field name="code">
              <Clerk.Label>Email code</Clerk.Label>
              <Clerk.Input />
              <Clerk.FieldError />
            </Clerk.Field>

            <SignIn.Action submit>Continue</SignIn.Action>
          </SignIn.Strategy>

          <SignIn.Strategy name="password">
            <h1>Enter your password</h1>

            <Clerk.Field name="password">
              <Clerk.Label>Password</Clerk.Label>
              <Clerk.Input />
              <Clerk.FieldError />
            </Clerk.Field>

            <SignIn.Action submit>Continue</SignIn.Action>
            <SignIn.Action navigate="forgot-password">Forgot password?</SignIn.Action>
          </SignIn.Strategy>

          <SignIn.Strategy name="reset_password_email_code">
            <h1>Check your email</h1>
            <p>
              We sent a code to <SignIn.SafeIdentifier />.
            </p>

            <Clerk.Field name="code">
              <Clerk.Label>Email code</Clerk.Label>
              <Clerk.Input />
              <Clerk.FieldError />
            </Clerk.Field>

            <SignIn.Action submit>Continue</SignIn.Action>
          </SignIn.Strategy>
        </SignIn.Step>

        <SignIn.Step name="forgot-password">
          <h1>Forgot your password?</h1>

          <SignIn.SupportedStrategy name="reset_password_email_code">
            Reset password
          </SignIn.SupportedStrategy>

          <SignIn.Action navigate="previous">Go back</SignIn.Action>
        </SignIn.Step>

        <SignIn.Step name="reset-password">
          <h1>Reset your password</h1>

          <Clerk.Field name="password">
            <Clerk.Label>New password</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <Clerk.Field name="confirmPassword">
            <Clerk.Label>Confirm password</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignIn.Action submit>Reset password</SignIn.Action>
        </SignIn.Step>
      </SignIn.Root>
    )
  }
  ```

  To enable users to reset their passwords, you can add the following additional steps:

  1. `forgot-password`   Renders [`<SignIn.SupportedStrategy>`](/docs/customization/elements/reference/sign-in#supported-strategy), which initiates the reset process, whereby an email code is sent to the user for verification.
     - `<SignIn.SupportedStrategy>` is also used in the `forgot-password` and `choose-strategy` steps to trigger verification of a supported strategy.
  1. `reset-password`  Allows a verified user to input a new password. If your instance has been set up to accept SMS codes, you can also use `reset_password_phone_code`.

  > [!NOTE]
  > If your instance isn't configured to use passwords, or any of the strategies outlined here, Clerk Elements will log a warning to the console during development.

  ## Customize and add styling

  Learn how to style your Clerk Elements components with the [styling guide](/docs/customization/elements/guides/styling).

  For more extensive customization of the UI, see the additional Clerk Elements components such as [`<Loading>`](/docs/customization/elements/reference/common#loading) and [`<FieldState>`](/docs/customization/elements/reference/common#field-state).
</Steps>

---
title: Build a sign-up flow with Clerk Elements
description: Learn how to build a complete sign-up form with Clerk Elements.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Follow the Next.js quickstart",
      link: "/docs/quickstarts/nextjs",
      icon: "nextjs",
    },
    {
      title: "Upgrade to Core 2 (if necessary)",
      link: "/docs/upgrade-guides/core-2/nextjs",
      icon: "arrow-up-circle",
    },
    {
      title: "Install Clerk Elements",
      link: "/docs/customization/elements/overview#getting-started",
      icon: "application-2",
    },
  ]}
/>

> [!NOTE]
>
> - Clerk Elements is for [advanced use-cases](/docs/customization/elements/overview#why-use-clerk-elements) that require a high-level of customization. The easiest way to implement Clerk is with our [all-in-one UI components](/docs/components/overview).
> - Clerk Elements currently only works with Next.js App Router and [Clerk Core 2](/changelog/2024-04-19){{ target: '_blank' }}. As it gets closer to a stable release, support for additional frameworks will be added.

<Steps>
  ## Add a sign-up route

  Create a new route in your Next.js application. The route needs to be an [optional catch-all route](https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#optional-catch-all-segments) so the sign-up flow can handled nested paths, as shown in the following example:

  ```tsx {{ filename: 'app/sign-up/[[...sign-up]]/page.tsx' }}
  'use client'

  import * as Clerk from '@clerk/elements/common'
  import * as SignUp from '@clerk/elements/sign-up'

  export default function SignUpPage() {
    return <SignUp.Root>[Sign Up Root]</SignUp.Root>
  }
  ```

  You will use these two imports to build out the rest of the flow. `<SignUp.Root>` manages the sign-up state and handles connecting the components to Clerk's APIs.

  > [!TIP]
  > If you're getting TypeScript errors on the `@clerk/elements` imports you probably have forgotten to set your [`moduleResolution`](https://www.typescriptlang.org/tsconfig/#moduleResolution) in `tsconfig.json` to `bundler`.

  ## Add the start step

  The Clerk authentication flows are made up of **steps**. Steps handle rendering the UI for each part of the flow. To allow users to create a sign-up attempt, the `start` step needs to be rendered. The following example does so with the `<SignUp.Step>` component:

  ```tsx {{ filename: 'app/sign-up/[[...sign-up]]/page.tsx', mark: [[9, 11]] }}
  'use client'

  import * as Clerk from '@clerk/elements/common'
  import * as SignUp from '@clerk/elements/sign-up'

  export default function SignUpPage() {
    return (
      <SignUp.Root>
        <SignUp.Step name="start">
          <h1>Create an account</h1>
        </SignUp.Step>
      </SignUp.Root>
    )
  }
  ```

  ## Add form fields

  Make it functional by adding input fields. The following example uses the `<Clerk.Field>` component to render the `emailAddress` and `username` fields, as well as the `<Connection>` component to allow users to sign up with a social connection, like Google:

  ```tsx {{ filename: 'app/sign-up/[[...sign-up]]/page.tsx', mark: [[12, 34]] }}
  'use client'

  import * as Clerk from '@clerk/elements/common'
  import * as SignUp from '@clerk/elements/sign-up'

  export default function SignUpPage() {
    return (
      <SignUp.Root>
        <SignUp.Step name="start">
          <h1>Create an account</h1>

          <Clerk.Connection name="google">Sign up with Google</Clerk.Connection>

          <Clerk.Field name="username">
            <Clerk.Label>Username</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <Clerk.Field name="emailAddress">
            <Clerk.Label>Email</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <Clerk.Field name="password">
            <Clerk.Label>Password</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignUp.Captcha />

          <SignUp.Action submit>Sign up</SignUp.Action>
        </SignUp.Step>
      </SignUp.Root>
    )
  }
  ```

  `<Clerk.Field>` takes care of wiring up the input with the label element, and `<Clerk.FieldError>` will render any field-specific errors that get returned from Clerk's API. The `<SignUp.Action>` component provides common actions that are used throughout the flows. In this case, using the `submit` action to render a submit button for the start form.

  ## Add verification

  As users progress through a sign-up attempt, they may be asked to **verify** a number of authentication factors in the `verifications` step. You can render a form for the user to complete verification, but each [verification strategy](/docs/customization/elements/reference/sign-in#strategy) requires different fields. You must render the form fields conditionally for each authentication strategy your instance supports using the `<SignIn.Strategy>` component.

  The following example demonstrates how to conditionally render a form for the `phone_code` and `email_code` strategies:

  ```tsx {{ filename: 'app/sign-up/[[...sign-up]]/page.tsx', mark: [[35, 59]] }}
  'use client'

  import * as Clerk from '@clerk/elements/common'
  import * as SignUp from '@clerk/elements/sign-up'

  export default function SignUpPage() {
    return (
      <SignUp.Root>
        <SignUp.Step name="start">
          <h1>Create an account</h1>

          <Clerk.Connection name="google">Sign up with Google</Clerk.Connection>

          <Clerk.Field name="username">
            <Clerk.Label>Username</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <Clerk.Field name="emailAddress">
            <Clerk.Label>Email</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <Clerk.Field name="password">
            <Clerk.Label>Password</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignUp.Action submit>Sign up</SignUp.Action>
        </SignUp.Step>

        <SignUp.Step name="verifications">
          <SignUp.Strategy name="phone_code">
            <h1>Check your phone for an SMS</h1>

            <Clerk.Field name="code">
              <Clerk.Label>Phone Code</Clerk.Label>
              <Clerk.Input />
              <Clerk.FieldError />
            </Clerk.Field>

            <SignUp.Action submit>Verify</SignUp.Action>
          </SignUp.Strategy>

          <SignUp.Strategy name="email_code">
            <h1>Check your email</h1>

            <Clerk.Field name="code">
              <Clerk.Label>Email Code</Clerk.Label>
              <Clerk.Input />
              <Clerk.FieldError />
            </Clerk.Field>

            <SignUp.Action submit>Verify</SignUp.Action>
          </SignUp.Strategy>
        </SignUp.Step>
      </SignUp.Root>
    )
  }
  ```

  Verification is the final step in the sign-up flow. When a user has verified all required factors, the sign-up attempt will be complete, their account will be created, and they will be signed in.

  ## Accept additional fields

  Should a user attempt to sign up via Google while a username is a required field, the `continue` step will be necessary to accept the username. The `<SignUp.Step>` component will display any additional required fields.

  ```tsx {{ filename: 'app/sign-up/[[...sign-up]]/page.tsx', mark: [[35, 45]] }}
  'use client'

  import * as Clerk from '@clerk/elements/common'
  import * as SignUp from '@clerk/elements/sign-up'

  export default function SignUpPage() {
    return (
      <SignUp.Root>
        <SignUp.Step name="start">
          <h1>Create an account</h1>

          <Clerk.Connection name="google">Sign up with Google</Clerk.Connection>

          <Clerk.Field name="username">
            <Clerk.Label>Username</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <Clerk.Field name="emailAddress">
            <Clerk.Label>Email</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <Clerk.Field name="password">
            <Clerk.Label>Password</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignUp.Action submit>Sign up</SignUp.Action>
        </SignUp.Step>

        <SignUp.Step name="continue">
          <h1>Fill in missing fields</h1>

          <Clerk.Field name="username">
            <Clerk.Label>Username</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignUp.Action submit>Continue</SignUp.Action>
        </SignUp.Step>

        <SignUp.Step name="verifications">
          <SignUp.Strategy name="phone_code">
            <h1>Check your phone for an SMS</h1>

            <Clerk.Field name="code">
              <Clerk.Label>Phone Code</Clerk.Label>
              <Clerk.Input />
              <Clerk.FieldError />
            </Clerk.Field>

            <SignUp.Action submit>Verify</SignUp.Action>
          </SignUp.Strategy>

          <SignUp.Strategy name="email_code">
            <h1>Check your email</h1>

            <Clerk.Field name="code">
              <Clerk.Label>Email Code</Clerk.Label>
              <Clerk.Input />
              <Clerk.FieldError />
            </Clerk.Field>

            <SignUp.Action submit>Verify</SignUp.Action>
          </SignUp.Strategy>
        </SignUp.Step>
      </SignUp.Root>
    )
  }
  ```

  If your instance has additional required fields, you can add them the same way you added the `username` field to the continue step.

  > [!NOTE]
  > Under the hood, Clerk Elements will conditionally render the fields that are necessary to complete the sign up attempt, so there's no need to check the state of the sign up attempt yourself.

  ## Customize and add styling

  Learn how to style your Clerk Elements components with the [styling guide](/docs/customization/elements/guides/styling).

  For more extensive customization of the UI, see the additional Clerk Elements components such as [`<Loading>`](/docs/customization/elements/reference/common#loading) and [`<FieldState>`](/docs/customization/elements/reference/common#field-state).
</Steps>

---
title: Build your own sign-in-or-up page for your Expo web app
description: Learn how to add custom sign-in-or-up page to your Expo web app with Clerk's prebuilt components.
---

This guide shows you how to use the [`<SignIn />`](/docs/components/authentication/sign-in) prebuilt component in order to build custom page that **allows users to sign in or sign up within a single flow**.

To set up separate sign-in and sign-up pages, follow this guide, and then follow the [custom sign-up page guide](/docs/references/expo/web-support/custom-sign-up-page).

This guide uses [Expo Router](https://docs.expo.dev/router/introduction/) and the [platform-specific extensions](https://docs.expo.dev/router/create-pages/#platform-specific-extensions) to build the sign-in-or-up page specifically for the **web** platform.

<Steps>
  ## Build a sign-in-or-up page

  The following example demonstrates how to render the [`<SignIn />`](/docs/components/authentication/sign-in) component to allow users to both sign-in or sign-up from a single flow.

  ```tsx {{ filename: '/app/sign-in.web.tsx' }}
  import { SignIn } from '@clerk/clerk-expo/web'

  export default function Page() {
    return <SignIn />
  }
  ```

  ## Visit your new page

  To run your project, use the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run web
    ```

    ```bash {{ filename: 'terminal' }}
    yarn web
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm web
    ```

    ```bash {{ filename: 'terminal' }}
    bun web
    ```
  </CodeBlockTabs>

  Visit your new custom pages locally at [localhost:8081/sign-in](http://localhost:8081/sign-in).
</Steps>

## More resources

Use the following guides to learn more about Clerk components, how to build custom flows for your native apps, and how to use Clerk's client-side helpers.

<Cards>
  - [Custom sign-up page](/docs/references/expo/web-support/custom-sign-up-page)
  - Learn how to add a custom sign-up page to your Next.js app with Clerk's prebuilt components.

  ---

  - [Prebuilt components](/docs/components/overview)
  - Learn more about Clerk's suite of components that let you quickly add authentication to your app.

  ---

  - [Customization & localization](/docs/customization/overview)
  - Learn how to customize and localize Clerk components.

  ---

  - [Custom flows](/docs/custom-flows/overview)
  - Expo native apps require custom flows in place of prebuilt components. Learn more about custom flows.

  ---

  - [Client-side helpers](/docs/hooks/use-user)
  - Learn more about our client-side helpers and how to use them.
</Cards>

---
title: Build your own sign-in-or-up page for your Next.js app with Clerk
description: Learn how to add a custom sign-in-or-up page to your Next.js app with Clerk's prebuilt components.
---

This guide shows you how to use the [`<SignIn />`](/docs/components/authentication/sign-in) component to build a custom page that **allows users to sign in or sign up within a single flow**.

To set up separate sign-in and sign-up pages, follow this guide, and then follow the [custom sign-up page guide](/docs/references/nextjs/custom-sign-up-page).

> [!NOTE]
> Just getting started with Clerk and Next.js? See the [quickstart tutorial](/docs/quickstarts/nextjs)!

<Steps>
  ## Build a sign-in-or-up page

  The following example demonstrates how to render the [`<SignIn />`](/docs/components/authentication/sign-in) component on a dedicated page using the [Next.js optional catch-all route](https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#catch-all-segments).

  ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx' }}
  import { SignIn } from '@clerk/nextjs'

  export default function Page() {
    return <SignIn />
  }
  ```

  ## Make the sign-in-or-up route public

  By default, `clerkMiddleware()` makes all routes public. **This step is specifically for applications that have configured `clerkMiddleware()` to make [all routes protected](/docs/references/nextjs/clerk-middleware#protect-all-routes).** If you have not configured `clerkMiddleware()` to protect all routes, you can skip this step.

  To make the sign-in route public:

  - Navigate to your `middleware.ts` file.
  - Create a new [route matcher](/docs/references/nextjs/clerk-middleware#create-route-matcher) that matches the sign-in route, or you can add it to your existing route matcher that is making routes public.
  - Create a check to see if the user's current route is a public route. If it is not a public route, use [`auth.protect()`](/docs/references/nextjs/auth#auth-protect) to protect the route.

  ```tsx {{ filename: 'middleware.ts' }}
  import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

  const isPublicRoute = createRouteMatcher(['/sign-in(.*)'])

  export default clerkMiddleware(async (auth, req) => {
    if (!isPublicRoute(req)) {
      await auth.protect()
    }
  })

  export const config = {
    matcher: [
      // Skip Next.js internals and all static files, unless found in search params
      '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
      // Always run for API routes
      '/(api|trpc)(.*)',
    ],
  }
  ```

  ## Update your environment variables

  - Set the `CLERK_SIGN_IN_URL` environment variable to tell Clerk where the `<SignIn />` component is being hosted.
  - Set `CLERK_SIGN_IN_FALLBACK_REDIRECT_URL` as a fallback URL incase users visit the `/sign-in` route directly.
  - Set `CLERK_SIGN_UP_FALLBACK_REDIRECT_URL` as a fallback URL incase users select the 'Don't have an account? Sign up' link at the bottom of the component.

  Learn more about these environment variables and how to customize Clerk's redirect behavior in the [dedicated guide](/docs/guides/custom-redirects).

  ```env {{ filename: '.env' }}
  NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
  NEXT_PUBLIC_CLERK_SIGN_IN_FALLBACK_REDIRECT_URL=/
  NEXT_PUBLIC_CLERK_SIGN_UP_FALLBACK_REDIRECT_URL=/
  ```

  ## Visit your new page

  Run your project with the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun dev
    ```
  </CodeBlockTabs>

  Visit your new custom page locally at [localhost:3000/sign-in](http://localhost:3000/sign-in).
</Steps>

## Next steps

<Cards>
  - [Custom sign-up page](/docs/references/nextjs/custom-sign-up-page)
  - Learn how to add a custom sign-up page to your Next.js app with Clerk's prebuilt components.

  ---

  - [Read user and session data](/docs/references/nextjs/read-session-data)
  - Learn how to use Clerk's hooks and helpers to access the active session and user data in your Next.js application.

  ---

  - [Client-side helpers](/docs/references/nextjs/overview#client-side-helpers)
  - Learn more about Next.js client-side helpers and how to use them.

  ---

  - [Next.js SDK Reference](/docs/references/nextjs/overview)
  - Learn more about additional Next.js methods.

  ---

  - [Clerk components](/docs/components/overview)
  - Learn more about Clerk's prebuilt components that make authentication and user management easy.
</Cards>

---
title: Build your own sign-in-or-up page for your React Router app with Clerk
description: Learn how to add a custom sign-in-or-up page to your React Router app with Clerk's prebuilt components.
---

This guide shows you how to use the [`<SignIn />`](/docs/components/authentication/sign-in) component to build a custom page **that allows users to sign in or sign up within a single flow**.

To set up separate sign-in and sign-up pages, follow this guide, and then follow the [custom sign-up page guide](/docs/references/react-router/custom-sign-up-page).

<Steps>
  ## Build a sign-in-or-up page

  The following example demonstrates how to render the [`<SignIn />`](/docs/components/authentication/sign-in) component on a dedicated page using the [React Router Splat route](https://reactrouter.com/start/framework/routing#splats).

  ```tsx {{ filename: 'app/routes/sign-in.tsx' }}
  import { SignIn } from '@clerk/react-router'

  export default function SignInPage() {
    return (
      <div>
        <h1>Sign in or up route</h1>
        <SignIn />
      </div>
    )
  }
  ```

  ## Configure routes

  React Router expects you to define routes in [`app/routes.ts`](https://reactrouter.com/start/framework/routing). Add the previously created sign-in-or-up page to your route configuration.

  ```tsx {{ filename: 'app/routes.ts', mark: [5] }}
  import { type RouteConfig, index, route } from '@react-router/dev/routes'

  export default [
    index('routes/home.tsx'),
    route('sign-in/*', 'routes/sign-in.tsx'),
  ] satisfies RouteConfig
  ```

  ## Configure redirect behavior

  - Set the `CLERK_SIGN_IN_URL` environment variable to tell Clerk where the `<SignIn />` component is being hosted.
  - Set `CLERK_SIGN_IN_FALLBACK_REDIRECT_URL` as a fallback URL incase users visit the `/sign-in` route directly.
  - Set `CLERK_SIGN_UP_FALLBACK_REDIRECT_URL` as a fallback URL incase users select the 'Don't have an account? Sign up' link at the bottom of the component.

  Learn more about these environment variables and how to customize Clerk's redirect behavior in the [dedicated guide](/docs/guides/custom-redirects).

  ```env {{ filename: '.env' }}
  CLERK_SIGN_IN_URL=/sign-in
  CLERK_SIGN_IN_FALLBACK_REDIRECT_URL=/
  CLERK_SIGN_UP_FALLBACK_REDIRECT_URL=/
  ```

  ## Visit your new page

  Run your project with the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun dev
    ```
  </CodeBlockTabs>

  Visit your new custom page locally at [localhost:5173/sign-in](http://localhost:5173/sign-in).
</Steps>

## Next steps

<Cards>
  - [Custom sign-up page](/docs/references/react-router/custom-sign-up-page)
  - Learn how to add a custom sign-up page to your React Router app with Clerk's prebuilt components.
</Cards>

---
title: Build your own sign-in-or-up page for your Remix app with Clerk
description: Learn how to add a custom sign-in-or-up page to your Remix app with Clerk's prebuilt components.
---

This guide shows you how to use the [`<SignIn />`](/docs/components/authentication/sign-in) component to build a custom page **that allows users to sign in or sign up within a single flow**.

To set up separate sign-in and sign-up pages, follow this guide, and then follow the [custom sign-up page guide](/docs/references/remix/custom-sign-up-page).

> [!NOTE]
> Just getting started with Clerk and Remix? See the [quickstart tutorial](/docs/quickstarts/remix)!

<Steps>
  ## Build a sign-in-or-up page

  The following example demonstrates how to render the [`<SignIn />`](/docs/components/authentication/sign-in) component on a dedicated page using the [Remix optional route](https://reactrouter.com/en/main/route/route#optional-segments).

  ```tsx {{ filename: 'app/routes/sign-in.$.tsx' }}
  import { SignIn } from '@clerk/remix'

  export default function Page() {
    return <SignIn />
  }
  ```

  ## Configure your sign-in-or-up page

  <Tabs items={["SSR Mode", "SPA Mode"]}>
    <Tab>
      - Set the `CLERK_SIGN_IN_URL` environment variable to tell Clerk where the `<SignIn />` component is being hosted.
      - Set `CLERK_SIGN_IN_FALLBACK_REDIRECT_URL` as a fallback URL incase users visit the `/sign-in` route directly.
      - Set `CLERK_SIGN_UP_FALLBACK_REDIRECT_URL` as a fallback URL incase users select the 'Don't have an account? Sign up' link at the bottom of the component.

      Learn more about these environment variables and how to customize Clerk's redirect behavior in the [dedicated guide](/docs/guides/custom-redirects).

      ```env {{ filename: '.env' }}
      CLERK_SIGN_IN_URL=/sign-in
      CLERK_SIGN_IN_FALLBACK_REDIRECT_URL=/
      CLERK_SIGN_UP_FALLBACK_REDIRECT_URL=/
      ```
    </Tab>

    <Tab>
      - Set the `signInUrl` property to your `ClerkApp` options to tell Clerk where the `<SignIn />` component is being hosted.
      - Set the `signInFallbackRedirectUrl` property to a fallback URL incase users visit the `/sign-in` route directly.
      - Set the `signUpFallbackRedirectUrl` property to a fallback URL incase users select the 'Don't have an account? Sign up' link at the bottom of the component.

      Learn more about these environment variables and how to customize Clerk's redirect behavior in the [dedicated guide](/docs/guides/custom-redirects).

      ```ts {{ filename: 'app/root.tsx', mark: [[3, 4]] }}
      export default ClerkApp(App, {
        publishableKey: PUBLISHABLE_KEY,
        signInUrl: '/sign-in',
        signInFallbackRedirectUrl: '/',
        signUpFallbackRedirectUrl: '/',
      })
      ```
    </Tab>
  </Tabs>

  ## Visit your new page

  Run your project with the following terminal command from the root directory of your project:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun dev
    ```
  </CodeBlockTabs>

  Visit your new custom page locally at [localhost:3000/sign-in](http://localhost:3000/sign-in).
</Steps>

## Next steps

<Cards>
  - [Custom sign-up page](/docs/references/remix/custom-sign-up-page)
  - Learn how to add a custom sign-up page to your Remix app with Clerk's prebuilt components.

  ---

  - [Read user and session data](/docs/references/remix/read-session-data)
  - Learn how to use Clerk's hooks and helpers to access the active session and user data in your Remix application.
</Cards>

---
title: Build your own sign-in-or-up page for your TanStack React Start app with Clerk
description: Learn how to add a custom sign-in-or-up page to your TanStack React Start app with Clerk's prebuilt components.
---

This guide shows you how to use the [`<SignIn />`](/docs/components/authentication/sign-in) component to build a custom page **that allows users to sign in or sign up within a single flow**.

To set up separate sign-in and sign-up pages, follow this guide, and then follow the [custom sign-up page guide](/docs/references/tanstack-react-start/custom-sign-up-page).

> [!NOTE]
> Just getting started with Clerk and TanStack React Start? See the [quickstart tutorial](/docs/quickstarts/tanstack-react-start)!

<Steps>
  ## Build a sign-in-or-up page

  The following example demonstrates how to render the [`<SignIn />`](/docs/components/authentication/sign-in) component on a dedicated page using the [TanStack Router catch-all route](https://tanstack.com/router/latest/docs/framework/react/routing/routing-concepts#splat--catch-all-routes).

  ```tsx {{ filename: 'app/routes/sign-in.$.tsx' }}
  import { SignIn } from '@clerk/tanstack-react-start'
  import { createFileRoute } from '@tanstack/react-router'

  export const Route = createFileRoute('/sign-in/$')({
    component: Page,
  })

  function Page() {
    return <SignIn />
  }
  ```

  ## Configure your sign-in-or-up page

  - Set the `CLERK_SIGN_IN_URL` environment variable to tell Clerk where the `<SignIn />` component is being hosted.
  - Set `CLERK_SIGN_IN_FALLBACK_REDIRECT_URL` as a fallback URL incase users visit the `/sign-in` route directly.
  - Set `CLERK_SIGN_UP_FALLBACK_REDIRECT_URL` as a fallback URL incase users select the 'Don't have an account? Sign up' link at the bottom of the component.

  Learn more about these environment variables and how to customize Clerk's redirect behavior in the [dedicated guide](/docs/guides/custom-redirects).

  ```env {{ filename: '.env' }}
  CLERK_SIGN_IN_URL=/sign-in
  CLERK_SIGN_IN_FALLBACK_REDIRECT_URL=/
  CLERK_SIGN_UP_FALLBACK_REDIRECT_URL=/
  ```

  ## Visit your new page

  Run your project with the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun dev
    ```
  </CodeBlockTabs>

  Visit your new custom page locally at [localhost:3000/sign-in](http://localhost:3000/sign-in).
</Steps>

## Next steps

<Cards>
  - [Create custom sign-up page](/docs/references/tanstack-react-start/custom-sign-up-page)
  - Learn how to add a custom sign-up page to your TanStack React Start app with Clerk's prebuilt components.

  ---

  - [Read user and session data](/docs/references/tanstack-react-start/read-session-data)
  - Learn how to use Clerk's hooks and helpers to access the active session and user data in your TanStack React Start application.
</Cards>

---
title: Build your own sign-up page for your Next.js app with Clerk
description: Learn how to add a custom sign-up page to your Next.js app with Clerk's prebuilt components.
---

By default, the [`<SignIn />`](/docs/references/nextjs/custom-sign-in-or-up-page) component handles signing in and signing up, but if you'd like to have a dedicated sign-up page, this guide shows you how to use the [`<SignUp />`](/docs/components/authentication/sign-up) component to build a custom sign-up page.

To set up a single sign-in-or-up page, follow the [custom sign-in-or-up page guide](/docs/references/nextjs/custom-sign-in-or-up-page).

> [!NOTE]
> Just getting started with Clerk and Next.js? See the [quickstart tutorial](/docs/quickstarts/nextjs)!

<Steps>
  ## Build a sign-up page

  The following example demonstrates how to render the [`<SignUp />`](/docs/components/authentication/sign-up) component on a dedicated sign-up page using the [Next.js optional catch-all route](https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#catch-all-segments).

  ```tsx {{ filename: 'app/sign-up/[[...sign-up]]/page.tsx' }}
  import { SignUp } from '@clerk/nextjs'

  export default function Page() {
    return <SignUp />
  }
  ```

  ## Make the sign-up route public

  By default, `clerkMiddleware()` makes all routes public. **This step is specifically for applications that have configured `clerkMiddleware()` to make [all routes protected](/docs/references/nextjs/clerk-middleware#protect-all-routes).** If you have not configured `clerkMiddleware()` to protect all routes, you can skip this step.

  To make the sign-up route public:

  - Navigate to your `middleware.ts` file.
  - Add the sign-up route to your existing route matcher that is making routes public.

  ```tsx {{ filename: 'middleware.ts', ins: [5] }}
  import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

  // prettier-ignore
  const isPublicRoute = createRouteMatcher([
    '/sign-in(.*)',
    '/sign-up(.*)'
  ])

  export default clerkMiddleware(async (auth, req) => {
    if (!isPublicRoute(req)) {
      await auth.protect()
    }
  })

  export const config = {
    matcher: [
      // Skip Next.js internals and all static files, unless found in search params
      '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
      // Always run for API routes
      '/(api|trpc)(.*)',
    ],
  }
  ```

  ## Update your environment variables

  - Set the `CLERK_SIGN_UP_URL` environment variable to tell Clerk where the `<SignUp />` component is being hosted.
  - Set `CLERK_SIGN_UP_FALLBACK_REDIRECT_URL` as a fallback URL incase users visit the `/sign-up` route directly.
  - Set `CLERK_SIGN_IN_FALLBACK_REDIRECT_URL` as a fallback URL incase users select the 'Already have an account? Sign in' link at the bottom of the component.

  Learn more about these environment variables and how to customize Clerk's redirect behavior in the [dedicated guide](/docs/guides/custom-redirects).

  ```env {{ filename: '.env' }}
  NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
  NEXT_PUBLIC_CLERK_SIGN_UP_FALLBACK_REDIRECT_URL=/
  NEXT_PUBLIC_CLERK_SIGN_IN_FALLBACK_REDIRECT_URL=/
  ```

  ## Visit your new page

  Run your project with the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun dev
    ```
  </CodeBlockTabs>

  Visit your new custom page locally at [localhost:3000/sign-up](http://localhost:3000/sign-up).
</Steps>

## Next steps

<Cards>
  - [Read user and session data](/docs/references/nextjs/read-session-data)
  - Learn how to use Clerk's hooks and helpers to access the active session and user data in your Next.js application.

  ---

  - [Client-side helpers](/docs/references/nextjs/overview#client-side-helpers)
  - Learn more about Next.js client-side helpers and how to use them.

  ---

  - [Next.js SDK Reference](/docs/references/nextjs/overview)
  - Learn more about additional Next.js methods.

  ---

  - [Clerk components](/docs/components/overview)
  - Learn more about Clerk's prebuilt components that make authentication and user management easy.
</Cards>

---
title: Build your own sign-up page for your React Router app with Clerk
description: Learn how to add a custom sign-up page to your React Router app with Clerk's prebuilt components.
---

By default, the [`<SignIn />`](/docs/references/react-router/custom-sign-in-or-up-page) component handles signing in and signing up, but if you'd like to have a dedicated sign-up page, this guide shows you how to use the [`<SignUp />`](/docs/components/authentication/sign-up) component to build a custom sign-up page.

To set up a single sign-in-or-up page, follow the [custom sign-in-or-up page guide](/docs/references/react-router/custom-sign-in-or-up-page).

> [!NOTE]
> Just getting started with Clerk and React Router? See the [quickstart tutorial](/docs/quickstarts/react-router)!

<Steps>
  ## Build a sign-up page

  The following example demonstrates how to render the [`<SignUp />`](/docs/components/authentication/sign-up) component on a dedicated sign-up page using the [React Router Splat route](https://reactrouter.com/start/framework/routing#splats).

  ```tsx {{ filename: 'app/routes/sign-up.tsx' }}
  import { SignUp } from '@clerk/react-router'

  export default function SignUpPage() {
    return (
      <div>
        <h1>Sign up route</h1>
        <SignUp />
      </div>
    )
  }
  ```

  ## Configure routes

  React Router expects you to define routes in [`app/routes.ts`](https://reactrouter.com/start/framework/routing). Add the previously created sign-up page to your route configuration.

  ```tsx {{ filename: 'app/routes.ts', mark: [6] }}
  import { type RouteConfig, index, route } from '@react-router/dev/routes'

  export default [
    index('routes/home.tsx'),
    route('sign-in/*', 'routes/sign-in.tsx'),
    route('sign-up/*', 'routes/sign-up.tsx'),
  ] satisfies RouteConfig
  ```

  ## Configure redirect behavior

  - Set the `CLERK_SIGN_UP_URL` environment variable to tell Clerk where the `<SignUp />` component is being hosted.
  - Set `CLERK_SIGN_UP_FALLBACK_REDIRECT_URL` as a fallback URL incase users visit the `/sign-up` route directly.
  - Set `CLERK_SIGN_IN_FALLBACK_REDIRECT_URL` as a fallback URL incase users select the 'Already have an account? Sign in' link at the bottom of the component.

  Learn more about these environment variables and how to customize Clerk's redirect behavior in the [dedicated guide](/docs/guides/custom-redirects).

  ```env {{ filename: '.env' }}
  CLERK_SIGN_UP_URL=/sign-up
  CLERK_SIGN_UP_FALLBACK_REDIRECT_URL=/
  CLERK_SIGN_IN_FALLBACK_REDIRECT_URL=/
  ```

  These values control the behavior of the `<SignUp />` and `<SignIn />` components and when you visit the respective links at the bottom of each component.

  ## Visit your new page

  Run your project with the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun dev
    ```
  </CodeBlockTabs>

  Visit your new custom page locally at [localhost:5173/sign-up](http://localhost:5173/sign-up).
</Steps>

---
title: Build your own sign-up page for your Remix app with Clerk
description: Learn how to add a custom sign-up page to your Remix app with Clerk's prebuilt components.
---

By default, the [`<SignIn />`](/docs/references/remix/custom-sign-in-or-up-page) component handles signing in and signing up, but if you'd like to have a dedicated sign-up page, this guide shows you how to use the [`<SignUp />`](/docs/components/authentication/sign-up) component to build a custom sign-up page.

To set up a single sign-in-or-up page, follow the [custom sign-in-or-up page guide](/docs/references/remix/custom-sign-in-or-up-page).

> [!NOTE]
> Just getting started with Clerk and Remix? See the [quickstart tutorial](/docs/quickstarts/remix)!

<Steps>
  ## Build a sign-up page

  The following example demonstrates how to render the [`<SignUp />`](/docs/components/authentication/sign-up) component on a dedicated sign-up page using the [Remix optional route](https://reactrouter.com/en/main/route/route#optional-segments).

  ```tsx {{ filename: 'app/routes/sign-up.$.tsx' }}
  import { SignUp } from '@clerk/remix'

  export default function Page() {
    return <SignUp />
  }
  ```

  ## Configure your sign-up page

  <Tabs items={["SSR Mode", "SPA Mode"]}>
    <Tab>
      - Set the `CLERK_SIGN_UP_URL` environment variable to tell Clerk where the `<SignUp />` component is being hosted.
      - Set `CLERK_SIGN_UP_FALLBACK_REDIRECT_URL` as a fallback URL incase users visit the `/sign-up` route directly.
      - Set `CLERK_SIGN_IN_FALLBACK_REDIRECT_URL` as a fallback URL incase users select the 'Already have an account? Sign in' link at the bottom of the component.

      Learn more about these environment variables and how to customize Clerk's redirect behavior in the [dedicated guide](/docs/guides/custom-redirects).

      ```env {{ filename: '.env' }}
      CLERK_SIGN_UP_URL=/sign-up
      CLERK_SIGN_UP_FALLBACK_REDIRECT_URL=/
      CLERK_SIGN_IN_FALLBACK_REDIRECT_URL=/
      ```
    </Tab>

    <Tab>
      - Set the `signUpUrl` property to your `ClerkApp` options to tell Clerk where the `<SignUp />` component is being hosted.
      - Set the `signUpFallbackRedirectUrl` property to a fallback URL incase users visit the `/sign-up` route directly.
      - Set the `signInFallbackRedirectUrl` property to a fallback URL incase users select the 'Already have an account? Sign in' link at the bottom of the component.

      Learn more about these environment variables and how to customize Clerk's redirect behavior in the [dedicated guide](/docs/guides/custom-redirects).

      ```ts {{ filename: 'app/root.tsx' }}
      export default ClerkApp(App, {
        publishableKey: PUBLISHABLE_KEY,
        signUpUrl: '/sign-up',
        signUpFallbackRedirectUrl: '/',
        signInFallbackRedirectUrl: '/',
      })
      ```
    </Tab>
  </Tabs>

  ## Visit your new page

  Run your project with the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun dev
    ```
  </CodeBlockTabs>

  Visit your new custom page locally at [localhost:3000/sign-up](http://localhost:3000/sign-up).
</Steps>

## Next steps

<Cards>
  - [Read user and session data](/docs/references/remix/read-session-data)
  - Learn how to use Clerk's hooks and helpers to access the active session and user data in your Remix application.
</Cards>

---
title: Build your own sign-up page for your TanStack React Start app with Clerk
description: Learn how to add a custom sign-up page to your TanStack React Start app with Clerk's prebuilt components.
---

By default, the [`<SignIn />`](/docs/references/tanstack-react-start/custom-sign-in-or-up-page) component handles signing in and signing up, but if you'd like to have a dedicated sign-up page, this guide shows you how to use the [`<SignUp />`](/docs/components/authentication/sign-up) component to build a custom sign-up page.

To set up a single sign-in-or-up page, follow the [custom sign-in-or-up page guide](/docs/references/tanstack-react-start/custom-sign-in-or-up-page).

> [!NOTE]
> Just getting started with Clerk and TanStack React Start? See the [quickstart tutorial](/docs/quickstarts/tanstack-react-start)!

<Steps>
  ## Build a sign-up page

  The following example demonstrates how to render the [`<SignUp />`](/docs/components/authentication/sign-up) component on a dedicated sign-up page using the [TanStack Router catch-all route](https://tanstack.com/router/latest/docs/framework/react/routing/routing-concepts#splat--catch-all-routes).

  ```tsx {{ filename: 'app/routes/sign-up.$.tsx' }}
  import { SignUp } from '@clerk/tanstack-react-start'
  import { createFileRoute } from '@tanstack/react-router'

  export const Route = createFileRoute('/sign-up/$')({
    component: Page,
  })

  function Page() {
    return <SignUp />
  }
  ```

  ## Configure your sign-up page

  - Set the `CLERK_SIGN_UP_URL` environment variable to tell Clerk where the `<SignUp />` component is being hosted.
  - Set `CLERK_SIGN_UP_FALLBACK_REDIRECT_URL` as a fallback URL incase users visit the `/sign-up` route directly.
  - Set `CLERK_SIGN_IN_FALLBACK_REDIRECT_URL` as a fallback URL incase users select the 'Already have an account? Sign in' link at the bottom of the component.

  Learn more about these environment variables and how to customize Clerk's redirect behavior in the [dedicated guide](/docs/guides/custom-redirects).

  ```env {{ filename: '.env' }}
  CLERK_SIGN_UP_URL=/sign-up
  CLERK_SIGN_UP_FALLBACK_REDIRECT_URL=/
  CLERK_SIGN_IN_FALLBACK_REDIRECT_URL=/
  ```

  ## Visit your new pages

  Run your project with the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun dev
    ```
  </CodeBlockTabs>

  Visit your new custom page locally at [localhost:3000/sign-up](http://localhost:3000/sign-up).
</Steps>

## Next steps

<Cards>
  - [Read user and session data](/docs/references/tanstack-react-start/read-session-data)
  - Learn how to use Clerk's hooks and helpers to access the active session and user data in your TanStack React Start application.
</Cards>

---
title: Build your own sign-up page with prebuilt components on web
description: Learn how to add custom sign-up page to your Expo app with Clerk's prebuilt components.
---

By default, the [`<SignIn />`](/docs/references/expo/web-support/custom-sign-in-or-up-page) component handles signing in and signing up, but if you'd like to have a dedicated sign-up page, this guide shows you how to use the [`<SignUp />`](/docs/components/authentication/sign-up) component to build a custom sign-up page.

To set up a single sign-in-or-up page, follow the [custom sign-in-or-up page guide](/docs/references/expo/web-support/custom-sign-in-or-up-page).

This guide uses [Expo Router](https://docs.expo.dev/router/introduction/) and the [platform-specific extensions](https://docs.expo.dev/router/create-pages/#platform-specific-extensions) to build the sign-up page specifically for the **web** platform.

<Steps>
  ## Build a sign-up page

  The following example demonstrates how to render the [`<SignUp />`](/docs/components/authentication/sign-up) component.

  ```tsx {{ filename: '/app/sign-up.web.tsx' }}
  import { SignUp } from '@clerk/clerk-expo/web'

  export default function Page() {
    return <SignUp />
  }
  ```

  ## Visit your new page

  To run your project, use the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run web
    ```

    ```bash {{ filename: 'terminal' }}
    yarn web
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm web
    ```

    ```bash {{ filename: 'terminal' }}
    bun web
    ```
  </CodeBlockTabs>

  Visit your new custom pages locally at [localhost:8081/sign-up](http://localhost:8081/sign-up).
</Steps>

## More resources

Use the following guides to learn more about Clerk components, how to build custom flows for your native apps, and how to use Clerk's client-side helpers.

<Cards>
  - [Prebuilt components](/docs/components/overview)
  - Learn more about Clerk's suite of components that let you quickly add authentication to your app.

  ---

  - [Customization & localization](/docs/customization/overview)
  - Learn how to customize and localize Clerk components.

  ---

  - [Custom flows](/docs/custom-flows/overview)
  - Expo native apps require custom flows in place of prebuilt components. Learn more about custom flows.

  ---

  - [Client-side helpers](/docs/hooks/use-user)
  - Learn more about our client-side helpers and how to use them.
</Cards>

---
title: Change domain or subdomain
description: Learn how to change your Clerk production instance's domain or subdomain.
---

Learn how to change your Clerk production instance's domain or subdomain.

> [!WARNING]
> You cannot change the domain of the [development instance](/docs/deployments/environments#development-instance) of your Clerk application.

## Change domain

1. Update your production domain in two ways:
   - the [Clerk Dashboard](#update-your-domain-via-clerk-dashboard)
   - the [Backend API](#update-your-domain-via-backend-api)
1. Once you make the change to your domain, you will need to update the following:
   - Update DNS records
   - Generate new SSL certificates
   - [Update your Publishable Key](#update-your-publishable-key)
   - If using social connections, update the settings with your social connections so that the redirect URL they are using is correct.
   - If using JWT templates, update JWT issuer and JWKS Endpoint in external JWT SSO services.

### Update your domain via Clerk Dashboard

To update your **production** domain in the Clerk Dashboard:

1. In the navigation sidenav, select **[Domains](https://dashboard.clerk.com/last-active?path=domains)**.
1. Select the **Danger** tab.
1. Select **Change domain**.

### Update your domain via Backend API

To update your production domain using the [Backend API](/docs/reference/backend-api){{ target: '_blank' }}, you will need to make a POST request to the `change_domain` endpoint. You will need to provide your new domain in the request body.

1. Copy the following cURL command.

<SignedIn>
  2) Your Secret Key is required to authenticate the request. It is injected into the cURL command after `Authorization`. However, you can also find it on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
</SignedIn>

<SignedOut>
  2. Your Secret Key is required to authenticate the request.
     - Navigate to the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=api-keys) and sign in.
     - In the navigation sidenav, select **API keys** to copy your Secret Key.
     - Paste your Secret Key into the cURL command after `Authorization`, replacing `sk_...`.
</SignedOut>

3. Replace `YOUR_PROD_URL` with your new production domain.

```bash {{ filename: 'terminal' }}
curl -XPOST -H 'Authorization: {{secret}}' -H "Content-type: application/json" -d '{
"home_url": "YOUR_PROD_URL"
}' 'https://api.clerk.com/v1/instance/change_domain'
```

For more information on how to update your instance settings using the Backend API, see the [Backend API reference](/docs/reference/backend-api/tag/Beta-Features#operation/UpdateInstanceAuthConfig){{ target: '_blank' }}.

### Update your Publishable Key

After changing your domain, a new **Publishable Key** will be automatically generated for your application. You need to update your environment variables with this new key and redeploy your application. You can find your **Publishable Key** on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.

> [!NOTE]
> Failing to update your **Publishable Key** will result in Clerk failing to load.

## Set, change, or remove subdomain

To set, change, or remove a subdomain for your production instance:

1. Navigate to the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=domains).
1. In the navigation sidenav, select **Domains**.
1. Select the **Danger** tab.
1. You will see the **Change subdomain** section where you can set, change, or remove your subdomain.

---
title: Chrome Extension Quickstart
description: Add authentication and user management to your Chrome Extension with Clerk.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    }
  ]}
  exampleRepo={[
    {
      title: "Chrome Extension Quickstart Repo",
      link: "https://github.com/clerk/clerk-chrome-extension-quickstart"
    }
  ]}
/>

> [!NOTE]
> Ensure that the Native API is enabled to integrate Clerk in your native application. In the Clerk Dashboard, navigate to the [**Native Applications**](https://dashboard.clerk.com/last-active?path=/native-applications) page.

<Steps>
  ## Configure your authentication options

  When creating your Clerk application in the Clerk Dashboard, your authentication options will depend on how you configure your Chrome Extension. Chrome Extensions can be used as a popup, a side panel, or in conjunction with a web app. Popups and side panels have limited authentication options. [Learn more about what options are available.](/docs/references/chrome-extension/overview#authentication-options)

  This guide will use a popup.

  ## Create a new app using the Plasmo framework

  [Plasmo](https://docs.plasmo.com/framework) is a browser extension framework that includes hot reloading and creating development and production extension builds easily from the same code.

  Plasmo strongly recommends using `pnpm`, so this guide will only use `pnpm`-based examples.

  The following command creates an app with Tailwind CSS preconfigured and with a `src/` directory. You can choose to remove one or both of those options.

  ```bash {{ filename: 'terminal' }}
  pnpm create plasmo --with-tailwindcss --with-src clerk-chrome-extension
  cd clerk-chrome-extension
  ```

  ## Install `@clerk/chrome-extension`

  The [Clerk Chrome Extension SDK](/docs/references/chrome-extension/overview) gives you access to prebuilt components, React hooks, and helpers to make user authentication easier.

  Add the SDK to your project:

  ```bash {{ filename: 'terminal' }}
  pnpm add @clerk/chrome-extension
  ```

  ## Set your Clerk API keys

  Plasmo offers [several options](https://docs.plasmo.com/framework/env) for environment variable files, as the same codebase can be used for development and production builds, as well as for targeting different browsers. This guide uses `.env.development` and `.env.chrome` files.

  <SignedIn>
    Add the following keys to your `.env.development` file. These keys can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
  </SignedIn>

  <SignedOut>
    1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
    1. In the **Quick Copy** section, select **Chrome Extension** and copy your Clerk Publishable Key and Frontend API URL.
    1. Paste your keys into your `.env.development` file.

    The final result should resemble the following:
  </SignedOut>

  ```env {{ filename: '.env.development' }}
  PLASMO_PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
  CLERK_FRONTEND_API=https://{{fapi_url}}
  ```

  ## Add `<ClerkProvider>` to your app

  <Include src="_partials/clerk-provider/explanation" />

  ```tsx {{ filename: 'src/popup.tsx', mark: [1, [7, 11], 15, 19] }}
  import { ClerkProvider } from '@clerk/chrome-extension'

  import { CountButton } from '~features/count-button'

  import '~style.css'

  const PUBLISHABLE_KEY = process.env.PLASMO_PUBLIC_CLERK_PUBLISHABLE_KEY

  if (!PUBLISHABLE_KEY) {
    throw new Error('Please add the PLASMO_PUBLIC_CLERK_PUBLISHABLE_KEY to the .env.development file')
  }

  function IndexPopup() {
    return (
      <ClerkProvider publishableKey={PUBLISHABLE_KEY}>
        <div className="plasmo-flex plasmo-items-center plasmo-justify-center plasmo-h-16 plasmo-w-40">
          <CountButton />
        </div>
      </ClerkProvider>
    )
  }

  export default IndexPopup
  ```

  ## Create a header with Clerk components

  You can control what content signed in and signed out users can see with Clerk's [prebuilt components](/docs/components/overview). Create a header with the following Clerk components. (With Chrome Extensions, you can also add this logic to a footer).

  - [`<SignedIn>`](/docs/components/control/signed-in): Children of this component can only be seen while **signed in**.
  - [`<SignedOut>`](/docs/components/control/signed-out): Children of this component can only be seen while **signed out**.
  - [`<UserButton />`](/docs/components/user/user-button): A prebuilt component that comes styled out-of-the-box to show the avatar from the account the user is signed in with.
  - [`<SignInButton />`](/docs/components/unstyled/sign-in-button): An unstyled component that links to the sign-in page. For this example, because you have not specified any props or [environment variables](/docs/deployments/clerk-environment-variables) for the sign-in URL, the component will link to the [Account Portal sign-in page.](/docs/account-portal/overview)

  ```tsx {{ filename: 'src/popup.tsx', mark: [[1, 7], [22, 29]] }}
  import {
    ClerkProvider,
    SignInButton,
    SignedIn,
    SignedOut,
    UserButton,
  } from '@clerk/chrome-extension'
  import { CountButton } from '~features/count-button'

  import '~style.css'

  const PUBLISHABLE_KEY = process.env.PLASMO_PUBLIC_CLERK_PUBLISHABLE_KEY

  if (!PUBLISHABLE_KEY) {
    throw new Error('Please add the PLASMO_PUBLIC_CLERK_PUBLISHABLE_KEY to the .env.development file')
  }

  function IndexPopup() {
    return (
      <ClerkProvider publishableKey={PUBLISHABLE_KEY}>
        <div className="plasmo-flex plasmo-items-center plasmo-justify-center plasmo-h-[600px] plasmo-w-[800px] plasmo-flex plasmo-flex-col">
          <header className="plasmo-w-full">
            <SignedOut>
              <SignInButton mode="modal" />
            </SignedOut>
            <SignedIn>
              <UserButton />
            </SignedIn>
          </header>
          <main className="plasmo-grow">
            <CountButton />
          </main>
        </div>
      </ClerkProvider>
    )
  }

  export default IndexPopup
  ```

  ## Update `<ClerkProvider>` props for Chrome Extension navigation

  To avoid navigation errors, set the `afterSignOutUrl`, `signInFallbackRedirectUrl` and `signUpFallbackRedirectUrl` props for `<ClerkProvider>`. Chrome Extensions don't use an `http` URL, such as `http://localhost:3000`. Instead, they use a `chrome-extension://` URL appended with an unique extension ID called a CRX ID. This URL is what you will pass to these props.

  ```tsx {{ filename: 'src/popup.tsx', mark: [14, [24, 26]] }}
  import {
    ClerkProvider,
    SignInButton,
    SignedIn,
    SignedOut,
    UserButton,
  } from '@clerk/chrome-extension'

  import { CountButton } from '~features/count-button'

  import '~style.css'

  const PUBLISHABLE_KEY = process.env.PLASMO_PUBLIC_CLERK_PUBLISHABLE_KEY
  const EXTENSION_URL = chrome.runtime.getURL('.')

  if (!PUBLISHABLE_KEY) {
    throw new Error('Please add the PLASMO_PUBLIC_CLERK_PUBLISHABLE_KEY to the .env.development file')
  }

  function IndexPopup() {
    return (
      <ClerkProvider
        publishableKey={PUBLISHABLE_KEY}
        afterSignOutUrl={`${EXTENSION_URL}/popup.html`}
        signInFallbackRedirectUrl={`${EXTENSION_URL}/popup.html`}
        signUpFallbackRedirectUrl={`${EXTENSION_URL}/popup.html`}
      >
        <div className="plasmo-flex plasmo-items-center plasmo-justify-center plasmo-h-[600px] plasmo-w-[800px] plasmo-flex-col">
          <header className="plasmo-w-full">
            <SignedOut>
              <SignInButton mode="modal" />
            </SignedOut>
            <SignedIn>
              <UserButton />
            </SignedIn>
          </header>
          <main className="plasmo-grow">
            <CountButton />
          </main>
        </div>
      </ClerkProvider>
    )
  }

  export default IndexPopup
  ```

  ## Create a consistent CRX ID for your extension

  Chrome Extensions have a unique CRX ID that rotates by default, which can cause errors with the Clerk integration. To avoid these problems, ensure that you have a **consistent** CRX ID in both development and production for your extension by following these steps:

  1. Visit Plasmo Itero's [Generate Keypairs](https://itero.plasmo.com/tools/generate-keypairs) tool.
  1. Select **Generate KeyPairs**.
  1. Save the **Private Key** somewhere secure in case you need it in the future. Save the **Public Key** and the **CRX ID** for the next steps.

  ## Create an `.env.chrome` file to store your public key

  Create an `.env.chrome` file and add your public key to it, as shown in the following example:

  ```env {{ filename: '.env.chrome' }}
  CRX_PUBLIC_KEY=<YOUR_PUBLIC_KEY>
  ```

  ## Edit your `package.json` to use the new public key

  Plasmo [uses the `package.json` to generate a `manifest.json` on build](https://docs.plasmo.com/framework#where-is-the-manifestjson-file), and allows for the use of environment variables in `package.json`.

  In your `package.json`, in the `manifest` object:

  - Set the `key` value to `"$CRX_PUBLIC_KEY"`. This helps configure the consistent CRX ID for your extension.
  - Set the `permissions` array to include `"cookies"` and `"storage"`. `permissions` specifies which permissions your extension requires.
  - Set or update the `host_permissions` array to include `"http://localhost/*"` and `"$CLERK_FRONTEND_API/*"`. `host_permissions` specifies which hosts, or websites, have permission to sync auth state with your app.

  ```json {{ filename: 'package.json' }}
  {
    // The rest of your package.json file
    "manifest": {
      "key": "$CRX_PUBLIC_KEY",
      "permissions": ["cookies", "storage"],
      "host_permissions": ["http://localhost/*", "$CLERK_FRONTEND_API/*"]
    }
  }
  ```

  ## Use `pnpm dev` to start your development server and create a build

  Plasmo facilitates Chrome Extension development by automatically "hot loading" the app whenever you save a changed file in the project. This ensures the `build/chrome-mv3-dev` folder remains up to date. Without the plugin, you would need to manually execute the build command and reload your Chrome Extension after each change. Plasmo automates this process, streamlining development.

  Run the following command to start your development environment. This also creates the build in `build/chrome-mv3-dev`, and rebuilds when you make changes to the extension.

  ```bash {{ filename: 'terminal' }}
  pnpm dev
  ```

  ## Load your Chrome Extension into your Chromium-based browser

  To load your Chrome Extension, follow these steps:

  1. Open Chrome or a Chromium-based browser and navigate to `chrome://extensions`.
  1. In the top-right, enable **Developer mode**.
  1. In the top-left, select **Load unpacked**.
  1. Navigate to where your project is located and select the `build/chrome-mv3-dev` folder. Then select **Select**. Your extension will now be loaded and shown in the list of extensions.
  1. Confirm that the ID shown in your extension matches the CRX ID you saved [earlier](#create-a-consistent-crx-id-for-your-extension).

  ## Test your Chrome Extension

  In your Chrome browser, open the extension popup. Ensure that the `<SignInButton>` appears, and that selecting it opens the `<SignIn />` modal. Sign in and ensure that the `<UserButton />` appears in the header.

  > [!WARNING]
  > After signing up or signing in, your popup may appear to crash. Closing and reopening the popup should restart the extension and you should be signed in.
  >
  > Your extension does not yet have anything to handle routing, and by default, the Clerk components attempt to redirect the user. See [the guide on adding React Router to your Chrome Extension](/docs/references/chrome-extension/add-react-router) to add routing to your extension.
</Steps>

## Next steps

<Cards>
  - [Add React Router](/docs/references/chrome-extension/add-react-router)
  - Learn how to add React Router to your Chrome Extension.

  ---

  - [Sync your Chrome Extension with your web app](/docs/references/chrome-extension/sync-host)
  - Learn how to configure your Chrome Extension to sync user authentication with your web application.

  ---

  - [createClerkClient()](/docs/references/chrome-extension/create-clerk-client)
  - For Chrome Extension's configured as popups, learn how to use Clerk's `createClerkClient()` function in a background service worker to ensure that the user's session is always fresh.
</Cards>

---
title: 'Clerk as an Identity Provider: OAuth 2.0 & OpenID Connect'
description: Learn how to use Clerk as an Identity Provider to facilitate Single Sign-On (SSO) with other clients that support the OAuth 2.0 and OpenID Connect protocol.
---

> [!WARNING]
> **This feature is not designed for handling authentication directly in your application.** To handle authentication _in your_ application, you can [configure one of the many social providers that Clerk offers](/docs/authentication/social-connections/overview#enable-a-social-connection), such as Google.

Clerk can be configured as an OAuth 2.0 and OpenID Connect (OIDC) Identity Provider (IdP) to facilitate Single Sign-On (SSO) with other clients that support the protocols. This feature allows users to authenticate to other applications using their Clerk credentials, enabling user information sharing between your Clerk application and OAuth clients.

For example, if your user wants to sign in to a third party application, they can select Clerk as the IdP and use their Clerk credentials to sign in. It's similar to signing in to a website and using your Google account to sign in.

## When should you use Clerk as an Identity Provider?

You can use Clerk as an IdP if you want your users to authenticate to a third party site or a tool using their credentials from your application. **This is not the same as supporting an OAuth provider, such as Google, in your application. If you want your users to be able to sign in to your application with an OAuth provider, see the [dedicated guide](/docs/authentication/social-connections/overview).**

This feature only currently supports the initial authentication flow from your application to the third party site or tool. The OAuth token returned at the end of the flow is not a [Clerk session JWT](/docs/how-clerk-works/overview#session-token) and cannot be used to make authenticated requests from third-party applications to Clerk-protected API endpoints in your app. If you are interested in Clerk adding support for resource access via OAuth tokens, please [add your feedback to this feature request](https://feedback.clerk.com/roadmap/c05eb8be-ae4e-4b7c-ab1e-e0eaf6b4b38a).

## Configure Clerk as an IdP

Clerk is the OAuth 2.0 and OIDC IdP for your application. The "client" is the third party site or tool that you want your users to authenticate to.

In order to make your Clerk instance operate as a provider, create an OAuth application in the Clerk Dashboard. Then, configure the client to work with your Clerk instance, using the necessary data from your Clerk OAuth application.

### Create a Clerk OAuth application

To create an OAuth application,

1. In the Clerk Dashboard, navigate to the [**OAuth Applications**](https://dashboard.clerk.com/last-active?path=user-authentication/oauth-applications) page.
1. Select the **Add OAuth application** button. A modal will open.
1. Complete the following fields:
   - `Name` - Helps you identify your application.
   - `Scopes` - The scopes that you would like to leverage.
1. Select **Create**. You'll be redirected to your app's settings page.
1. In the **Redirect URI** field, add the redirect URI that the client provides. This is the URL that Clerk will redirect to after the user has authenticated.

> [!WARNING]
> For security reasons, Clerk does not store your Client Secret and cannot show it to you again, so we recommend you download the secret and store it someplace secure.

### Configure your client

Now that you have set up a Clerk OAuth application, you will need to configure any of the following settings needed in your client.

- **Client ID**: Public identifier of your Clerk OAuth application.
- **Client Secret**: Confidential secret used to authenticate your Clerk OAuth application.
- **Discovery URL**: Used by the client to retrieve the configuration data of the Clerk OAuth application.
- **Authorize URL**: Used by the client to request authorization from your user.
- **Token URL**: Used by the client to exchange an authorization code for an access token and a refresh token.
- **User Info URL**: Used by the client to retrieve additional user data upon authentication.

### Scopes

Scopes define the level of access and specific user data that will be shared with the client application during authentication. The following scopes are currently supported:

| Scope | Access |
| - | - |
| `profile` | Grant access to the user's personal information, such as first and last name, avatar, and username |
| `email` | Grant access to the user's email address |
| `public_metadata` | Grant access to the user's public and unsafe metadata |
| `private_metadata` | Grant access to the user's private metadata |
| `openid` | Enables the OpenID Connect flow |

## OAuth 2.0

### Get additional user information

After a user has successfully completed an OAuth 2.0 flow, you can retrieve additional user information from Clerk's [`/oauth/userinfo`](/docs/reference/frontend-api/tag/OAuth2-Identify-Provider#operation/getOAuthUserInfo){{ target: '_blank' }} endpoint. When making the request to this endpoint, you must include the Clerk access token in the `Authorization` header.

The `/oauth/userinfo` endpoint provides the following user properties, depending on the granted scopes:

| Property | Description |
| - | - |
| `user_id` | The ID of the user |
| `sub` | The ID of the user |
| `given_name` | The user's first name |
| `family_name` | The user's last name |
| `name` | The user's full name |
| `picture` | The user's avatar URL |
| `preferred_username` | The user's username |
| `email` | The user's primary email address |
| `email_verified` | Whether the user's primary email address is verified |
| `public_metadata` | The user's public metadata |
| `private_metadata` | The user's private metadata |
| `unsafe_metadata` | The user's unsafe metadata |

### Get token information

For validating access tokens or refresh tokens and retrieving additional token metadata, Clerk provides a standard OAuth 2.0 [Token Introspection Endpoint](https://www.oauth.com/oauth2-servers/token-introspection-endpoint/) at [`/oauth/token_info`](/docs/reference/frontend-api/tag/OAuth2-Identify-Provider#operation/getOAuthTokenInfo){{ target: '_blank' }}.

The endpoint returns detailed token information such as if the token is still active, the client ID, and the granted scopes.

> [!WARNING]
> This endpoint is protected. You must provide your Clerk Client ID and Client Secret credentials to authenticate.

### Grant types

Clerk's OAuth 2.0 IdP implementation supports the following authorization flows and grant types:

- [Authorization Code](https://oauth.net/2/grant-types/authorization-code/)
- [PKCE](https://oauth.net/2/pkce/)
- [Refresh token](https://oauth.net/2/grant-types/refresh-token/)

## OpenID Connect (OIDC)

After a user successfully authenticates using the OIDC flow, they receive an ID token along with other tokens.

The ID token is a JWT (JSON Web Token) that contains standard JWT claims as defined in RFC 7519, as well as additional custom claims that represent the authenticated user's profile information. The token is signed using your instance's private key.

You must validate the ID token before using any of the user information it contains. Validation requires verifying the token signature using your instance's public key. You can find your instance's public key at `https://clerk.<INSERT_YOUR_APP_DOMAIN>.com/.well-known/jwks.json`.

The ID token includes the following standard claims:

| Standard claim | Description |
| - | - |
| `iss` | The issuer of the token, which matches your Clerk Frontend API URL |
| `sub` | The subject of the token, which matches the authenticated user ID |
| `aud` | The intended audience of the token, which matches the used Client ID |
| `exp` | The expiration time of the token |
| `iat` | The time at which the token was issued |
| `jti` | A unique identifier for the token |

Depending on the granted scopes, the ID token can include the following additional claims:

| Additional claim | Description |
| - | - |
| `nonce` | The nonce provided and used during the request |
| `family_name` | The user's last name |
| `given_name` | The user's first name |
| `name` | The user's full name |
| `picture` | The user's avatar URL |
| `preferred_username` | The user's username |
| `email` | The user's primary email address |
| `email_verified` | Whether the user's primary email address is verified |
| `public_metadata` | The user's public metadata |
| `private_metadata` | The user's private metadata |
| `unsafe_metadata` | The user's unsafe metadata |

### OIDC prompt

As part of an OIDC request, you can indicate the desired sign-in experience for the user by using the `prompt` parameter. The following values are supported:

- `none`: The user doesn't interact with the provider, thus they need to have an active session already. If not, the provider responds with an error.
- `login`: The user is forced to re-authenticate, even if they already have an active session. If there was already an active session, the provider ends it.

## Frequently asked questions (FAQ)

### When do the tokens expire?

Authorization codes expire after 10 minutes. Access tokens expire after 2 hours. Refresh tokens expire after 3 days. ID tokens expire after 1 hour.

---
title: Clerk Astro SDK
description: The Clerk Astro SDK gives you access to prebuilt components, React hooks, and helpers to make user authentication easier.
---

The Clerk Astro SDK gives you access to prebuilt components, React hooks, and helpers to make user authentication easier. Refer to the [quickstart guide](/docs/quickstarts/astro) to get started.

## Client-side helpers

The Astro SDK provides [stores](https://github.com/nanostores/nanostores) that give you access to the [`Clerk`](/docs/references/javascript/clerk) object and helper methods for authentication flows.

- [`$authStore`](/docs/references/astro/auth-store)
- [`$clerkStore`](/docs/references/astro/clerk-store)
- [`$userStore`](/docs/references/astro/user-store)
- [`$signInStore`](/docs/references/astro/sign-in-store)
- [`$signUpStore`](/docs/references/astro/sign-up-store)
- [`$sessionStore`](/docs/references/astro/session-store)
- [`$sessionListStore`](/docs/references/astro/session-list-store)
- [`$organizationStore`](/docs/references/astro/organization-store)

## Server-side helpers

The following references show how to integrate Clerk features into your Astro app on the server-side.

### Locals

The Astro SDK provides access to Clerk's authentication data through Astro's [`locals`](https://docs.astro.build/en/guides/middleware/#storing-data-in-contextlocals) object. The following references show how to access authentication data in server-side code:

- [`Auth`](/docs/references/astro/locals#locals-auth)
- [`CurrentUser`](/docs/references/astro/locals#locals-current-user)

### `clerkMiddleware()`

The `clerkMiddleware()` helper integrates Clerk authentication and authorization into your Astro application through middleware. You can learn more [here](/docs/references/astro/clerk-middleware).

---
title: Clerk Chrome Extension SDK
description: The Clerk Chrome Extension SDK gives you access to prebuilt components, React hooks, and helpers to make user authentication easier.
---

The Clerk Chrome Extension SDK gives you access to prebuilt components, React hooks, and helpers to make user authentication easier. Refer to the [quickstart guide](/docs/quickstarts/chrome-extension) to get started.

## Authentication options

When creating your Clerk application in the Clerk Dashboard, your authentication options will depend on how you configure your Chrome Extension. You can configure your Chrome Extension to behave as one of the following:

- **Popup** - Opens as a popup. This is the default behavior.
- **Side Panel** - Opens in a side panel
- **Sync Host** - Deployed alongside a web app that uses [Sync Host](/docs/references/chrome-extension/sync-host).

See the following table to determine the authentication options available for each configuration.

| | Popup | Side Panel | Sync Host |
| - | - | - | - |
| Email + OTP |  |  |  |
| Email + Link | | |  |
| Email + Password |  |  |  |
| Username + Password |  |  |  |
| SMS + OTP |  |  |  |
| OAuth | | |  |
| Google One Tap | | |  |
| SAML | | |  |
| Passkeys |  |  |  |
| Web3 | | |  |

> [!WARNING]
> Our Chrome Extension SDK currently does not fully support Sync Host on side panels. Currently, if a user authenticates in your web app, they need to close and reopen the side panel to update their auth status.

## Sync auth status between your Chrome Extension and web app

Clerk allows you to sync the authentication state from your web app to your Chrome Extension using the Sync Host feature. When a user authenticates in your web app, they will also be authenticated in your Chrome Extension. See [the dedicated guide](/docs/references/chrome-extension/sync-host) for more information.

## `createClerkClient()`

It's recommended to use `createClerkClient()` for Chrome Extension's that need to interact with Clerk in a content script.

The `createClerkClient()` helper initializes a new Clerk instance on demand and refreshes the session token if there is a valid, signed-in user. It can be used in a [content script](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts) or a [background service worker](https://developer.chrome.com/docs/extensions/develop/concepts/service-workers/basics) to access a user's information or session token. [Learn more about `createClerkClient()`](/docs/references/chrome-extension/create-clerk-client).

## Add React Router

[Learn how to add React Router to your Chrome Extension](/docs/references/chrome-extension/add-react-router) to enable routing in your application.

## Deploy your extension to production

See [the Chrome Extension deployment guide](/docs/deployments/deploy-chrome-extension) for information about deploying your extension to production.

## Configure a consistent CRX ID

A Chrome Extension can be identified by its unique CRX ID, similar to how a website can be identified by its domain. The CRX ID rotates by default, which can cause errors with the Clerk integration. [Learn how to configure a consistent CRX ID](/docs/references/chrome-extension/configure-consistent-crx-id) so that your extension will have a stable, unchanging key.

## Frequently asked questions (FAQ)

### Can I use Clerk in a content script?

Unfortunately, no. Clerk has strict security restrictions on the allowed origins for requests from the application or extension to Clerk's API. Since a content script could run on any domain, there is no way to enforce origin restrictions.

### Why can't I use OAuth, SAML, or email links with the extension popup or side panel?

OAuth and SAML require a redirect back from the Identity Provider (IdP), which is not currently supported by Google Chrome.

Email links require the popup to remain open while the user checks their email, copies the link, and returns to paste it. Since popups close as soon as a user clicks outside of them, this flow is not possible. The sign-in status resets when the popup closes.

### Why aren't options like Google One Tap or Web3 available in a popup or side panel?

Chrome Extensions can't load code from remote sources. Features like Google One Tap, Web3, and some other authentication options require loading remote code to function. This functionality is removed from the Chrome Extension SDK to ensure extensions using Clerk are not rejected by the Chrome Web Store.

---
title: Clerk Cookies
description: Learn about Clerk's strictly necessary application cookies.
---

Cookies play a vital role in authentication, state management, and browser-server communication. By understanding their attributes, developers can ensure secure and efficient use in their applications. Clerk leverages cookies in a secure, privacy-compliant manner to facilitate seamless user authentication across domains and subdomains. To learn more about cookies, like what they are and how they work, see the [resource guide on cookies](/docs/backend-requests/resources/cookies).

## Strictly necessary application cookies

Clerk sets cookies when your users interact with your application in ways that trigger requests for services, such as signing in or signing up. This cannot be disabled.

These cookies:

- Are required for Clerk to function, and should not be blocked by you or your users.
- Do not store any personally identifiable information by default.
- Can be configured by modifying the [session token](/docs/backend-requests/resources/session-tokens) in the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=jwt-templates).

| Cookie Subgroup | Cookies | More Information |
| - | - | - |
| .clerk.com | `__session`, `__client_uat` | First party |
| .clerk.com, .dashboard.clerk.com (cloudflare) | `_cfuvid` | Third party [Cloudflare Cookies](https://developers.cloudflare.com/fundamentals/reference/policies-compliances/cloudflare-cookies/) |

> [!WARNING]
> You should seek legal advice before using this information to craft your privacy policy.

---
title: Clerk Elements (beta)
description: Learn how to use Clerk Elements to build custom UIs on top of the Clerk APIs without having to manage the underlying logic.
---

> [!WARNING]
> Clerk Elements is currently in beta with support for Next.js App Router. It is **not yet recommended for production use**.
>
> If you have any feedback, contact [beta-elements@clerk.dev](mailto:beta-elements@clerk.dev) or head over to the [GitHub Discussion](https://github.com/orgs/clerk/discussions/3315).

Clerk Elements is a library of unstyled, composable components that can be used to build custom UIs on top of the Clerk APIs without having to manage the underlying logic.

![Clerk Elements](/images/elements/elements-hero-light.webp){{ dark: '/images/elements/elements-hero-dark.webp' }}

## Why use Clerk Elements?

You should use Clerk Elements if you want a deeper level of control and customization of the styles and layout of your UI while using the Clerk APIs. For example, if [the appearance prop](/docs/customization/overview) does not meet your needs, Clerk Elements might be for you. That said, you can also use Clerk Elements alongside the prebuilt components.

- **Component-first** - Make it as easy to build custom UIs with Clerk as it is with Clerk's drop-in prebuilt components. Clerk Elements handles the underlying business logic for you and provides a curated library of components without sacrificing on best practices or features.
- **Unstyled, with a little bit of magic** - Use the web platform and best-in-class components for building great authentication flows. Baked-in to the components are little bits of magic, like the fully accessible segmented one-time-passcode (OTP) input, and instant password validation during sign up.

### Integrate Clerk Elements into your workflow

Clerk Elements can be integrated into your existing application and workflows. For example, you may want to use Clerk Elements with:

- **Tailwind CSS**  If you use Tailwind CSS, you can pass a `className` prop to most elements that Clerk Elements renders. See [the styling guide](/docs/customization/elements/guides/styling#tailwind-css) to learn more.
- **Existing styles or component library**  If you have an existing component library that you want to use to build your authentication UIs, Clerk Elements supports composition via an `asChild` prop. Read [the styling guide](/docs/customization/elements/guides/styling#with-existing-components-via-as-child) to learn more.
- **With prebuilt components** - Continue using prebuilt components while customizing the flows you care most about.

## Getting started

Clerk Elements currently only works with Next.js App Router and [Clerk Core 2](/changelog/2024-04-19){{ target: '_blank' }}. As it gets closer to a stable release, support for additional frameworks will be added. If your Next.js application is already using Clerk, make sure to [upgrade to Core 2](/docs/upgrade-guides/core-2/nextjs). If you're starting from scratch, follow the [Next.js quickstart](/docs/quickstarts/nextjs) before proceeding.

To get started, install the Clerk Elements package:

<CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
  ```sh {{ filename: 'terminal' }}
  npm install @clerk/elements
  ```

  ```sh {{ filename: 'terminal' }}
  yarn add @clerk/elements
  ```

  ```sh {{ filename: 'terminal' }}
  pnpm add @clerk/elements
  ```

  ```sh {{ filename: 'terminal' }}
  bun add @clerk/elements
  ```
</CodeBlockTabs>

> [!IMPORTANT]
> If your project uses TypeScript, make sure that your [`moduleResolution`](https://www.typescriptlang.org/tsconfig/#moduleResolution) in `tsconfig.json` is set to `bundler`. Otherwise, you might run into issues with resolving TypeScript types from Clerk Elements.

Once you have your project set up, you can start building custom UIs with Clerk Elements using Clerk's guides and examples. For example, to use Clerk Elements to build a custom sign-in flow, you can explore:

- [Build a sign-in flow](/docs/customization/elements/guides/sign-in)
- [Sign-in examples](/docs/customization/elements/examples/sign-in)
- [Sign-in components](/docs/customization/elements/reference/sign-in)

> [!NOTE]
> With the beta release, only sign-up and sign-in flows are supported. Support for building the rest of the prebuilt components with Elements is actively being worked on.

---
title: Clerk environment variables
description: Learn which Clerk environment variables are necessary to configure your projects.
---

You can use environment variables to configure how your Clerk app behaves, such as where users are redirected after signing out of their account, or whether or not Clerk's telemetry should be enabled.

This page is a reference for all available Clerk environment variables.

## Compatibility

In the frontend, Clerk's environment variables work for most popular meta-frameworks, such as Next.js or Remix.

If you're building a pure React app, you should use the props on the components you're using. For example, to force users to redirect to a specific URL after signing in, you would use the `signInForceRedirectUrl` prop on [`<ClerkProvider>`](/docs/components/clerk-provider) rather than the `CLERK_SIGN_IN_FORCE_REDIRECT_URL` environment variable.

## Sign-in and sign-up redirects

Components, such as [`<ClerkProvider>`](/docs/components/clerk-provider), [`<SignIn>`](/docs/components/authentication/sign-in), and more, provide props for you to specify where users will be redirected. For example, `<ClerkProvider>` has the `signInFallbackRedirectUrl` and `signUpFallbackRedirectUrl` props.

However, **it's recommended to use environment variables instead of these props whenever possible.**

<Include src="_partials/environment-variables" />

## Clerk Publishable and Secret Keys

To access your Clerk app in your local project, you must specify your app's Publishable Keys for use in the frontend, and Secret Keys for use in the backend.

You can find these keys on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.

<Tabs items={["General", "Next.js"]}>
  <Tab>
    | Variable | Description |
    | - | - |
    | `CLERK_PUBLISHABLE_KEY` | Your Clerk app's Publishable Key. It will be prefixed with `pk_test_` in development instances and `pk_live_` in production instances. |
    | `CLERK_SECRET_KEY` | Your Clerk app's Secret Key, which you can find in the Clerk Dashboard. It will be prefixed with `sk_test_` in development instances and `sk_live_` in production instances. **Do not expose this on the frontend with a public environment variable**. |
  </Tab>

  <Tab>
    | Variable | Description |
    | - | - |
    | `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY` | Your Clerk app's Publishable Key, which you can find in the Clerk Dashboard. It will be prefixed with `pk_test_` in development instances and `pk_live_` in production instances. |
    | `CLERK_SECRET_KEY` | Your Clerk app's Secret Key, which you can find in the Clerk Dashboard. It will be prefixed with `sk_test_` in development instances and `sk_live_` in production instances. **Do not expose this on the frontend with a public environment variable**. |
  </Tab>
</Tabs>

## API and SDK configuration

The following environment variables enable you to configure API and SDK behavior, such as what version of the SDK your project uses, what proxy URL you use to connect to Clerk's Frontend API, and more.

<Tabs items={["General", "Next.js"]}>
  <Tab>
    | Variable | Description |
    | - | - |
    | `CLERK_JS_URL` | Sets the URL that `@clerk/clerk-react` should hot-load `@clerk/clerk-js` from. `CLERK_JS` does the same but is deprecated. |
    | `CLERK_JS_VERSION` | Sets the npm version for `@clerk/clerk-js`. |
    | `CLERK_API_URL` | Sets the Clerk API URL for debugging. Defaults to `"https://api.clerk.com"` |
    | `CLERK_API_VERSION` | Sets the version of the Clerk API to use. Defaults to `"v1"` |
    | `CLERK_JWT_KEY` | Sets the JWT verification key that Clerk will use to provide networkless JWT session token verification. Refer to [Manual JWT verification](/docs/backend-requests/manual-jwt). |
    | `CLERK_FAPI` | Sets the URL to your Clerk apps' Frontend API. |
    | `CLERK_PROXY_URL` | Sets the URL for your proxy. |
  </Tab>

  <Tab>
    | Variable | Description |
    | - | - |
    | `NEXT_PUBLIC_CLERK_JS_URL` | Sets the URL that `@clerk/clerk-react` should hot-load `@clerk/clerk-js` from. `NEXT_PUBLIC_CLERK_JS` does the same but is deprecated. |
    | `NEXT_PUBLIC_CLERK_JS_VERSION` | Sets the npm version for `@clerk/clerk-js`. |
    | `NEXT_PUBLIC_CLERK_API_URL` | Sets the Clerk API URL for debugging. Defaults to `"https://api.clerk.com"` |
    | `NEXT_PUBLIC_CLERK_API_VERSION` | Sets the version of the Clerk API to use. Defaults to `"v1"` |
    | `NEXT_PUBLIC_CLERK_FAPI` | Sets the URL to your Clerk app's Frontend API. |
    | `NEXT_PUBLIC_CLERK_PROXY_URL` | Sets the URL for your proxy. |
    | `CLERK_ENCRYPTION_KEY` | Sets the encryption key to securely propagate `clerkMiddleware` dynamic keys during request time. A 128-bit, pseudorandom value should be used. See [Dynamic keys](/docs/references/nextjs/clerk-middleware#dynamic-keys) to learn more. |
    | `CLERK_JWT_KEY` | Sets the JWT verification key that Clerk will use to provide networkless JWT session token verification. Refer to [Manual JWT verification](/docs/backend-requests/manual-jwt). |
  </Tab>
</Tabs>

## Satellite domains

Clerk supports sharing sessions across different domains by adding one or many satellite domains to an application. See [the satellite domains guide](/docs/advanced-usage/satellite-domains) for more information.

<Tabs items={["General", "Next.js"]}>
  <Tab>
    | Variable | Description |
    | - | - |
    | `CLERK_DOMAIN` | Sets your satellite application's domain. Required to share sessions across multiple domains. |
    | `CLERK_IS_SATELLITE` | Indicates whether or not the application is a satellite application. |
  </Tab>

  <Tab>
    | Variable | Description |
    | - | - |
    | `NEXT_PUBLIC_CLERK_DOMAIN` | Sets your satellite application's domain. Required to share sessions across multiple domains. |
    | `NEXT_PUBLIC_CLERK_IS_SATELLITE` | Indicates whether or not the application is a satellite application. |
  </Tab>
</Tabs>

## Webhooks

The following environment variable allows you to protect your webhook signing secret. It is read by Clerk's [`verifyWebhook()`](/docs/references/backend/verify-webhook) function.

| Variable | Description |
| - | - |
| `CLERK_WEBHOOK_SIGNING_SECRET` | The signing secret for your webhook. |

## Telemetry

Clerk provides environment variables for opting out of telemetry data collection. See [the telemetry documentation](/docs/telemetry) for more information.

<Tabs items={["General", "Next.js"]}>
  <Tab>
    | Variable | Description |
    | - | - |
    | `CLERK_TELEMETRY_DISABLED` | Set this to `1` to disable Clerk's telemetry data collection. |
    | `CLERK_TELEMETRY_DEBUG` | Set this to `1` to prevent telemetry data from being sent to Clerk. It will be logged to the console instead. |
  </Tab>

  <Tab>
    | Variable | Description |
    | - | - |
    | `NEXT_PUBLIC_CLERK_TELEMETRY_DISABLED` | Set this to `1` to disable Clerk's telemetry data collection. |
    | `NEXT_PUBLIC_CLERK_TELEMETRY_DEBUG` | Set this to `1` to prevent telemetry data from being sent to Clerk. It will be logged to the console instead. |
  </Tab>
</Tabs>

## Deprecated

The following environment variables are deprecated but still supported to avoid breaking changes. Don't use them in new projects. It is recommended to switch to using the recommended alternatives in old projects.

<Tabs items={["General", "Next.js"]}>
  <Tab>
    | Variable | Description |
    | - | - |
    | `CLERK_AFTER_SIGN_UP_URL` | Full URL or path to navigate to after successful sign up. Defaults to `/`. `CLERK_SIGN_UP_FALLBACK_REDIRECT_URL` and `CLERK_SIGN_UP_FORCE_REDIRECT_URL` have priority and should be used instead. |
    | `CLERK_AFTER_SIGN_IN_URL` | Full URL or path to navigate to after successful sign in. Defaults to `/`. `CLERK_SIGN_IN_FALLBACK_REDIRECT_URL` and `CLERK_SIGN_IN_FORCE_REDIRECT_URL` have priority and should be used instead. |
  </Tab>

  <Tab>
    | Variable | Description |
    | - | - |
    | `NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL` | Full URL or path to navigate to after successful sign up. Defaults to `/`. `NEXT_PUBLIC_CLERK_SIGN_UP_FALLBACK_REDIRECT_URL` and `NEXT_PUBLIC_CLERK_SIGN_UP_FORCE_REDIRECT_URL` have priority and should be used instead. |
    | `NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL` | Full URL or path to navigate to after successful sign in. Defaults to `/`. `NEXT_PUBLIC_CLERK_SIGN_IN_FALLBACK_REDIRECT_URL` and `NEXT_PUBLIC_CLERK_SIGN_IN_FORCE_REDIRECT_URL` have priority and should be used instead. |
  </Tab>
</Tabs>

---
title: Clerk Expo SDK
description: The Clerk Expo SDK gives you access to prebuilt components, React hooks, and helpers to make user authentication easier.
---

The Clerk Expo SDK gives you access to prebuilt components, React hooks, and helpers to make user authentication easier. Refer to the [quickstart guide](/docs/quickstarts/expo) to get started.

## Available resources

The Expo SDK gives you access to the following resources:

### Hooks

The Expo SDK provides the following hooks:

- [`useSSO()`](/docs/references/expo/use-sso)
- [`useLocalCredentials()`](/docs/references/expo/use-local-credentials)

Because the Expo SDK is built on top of the Clerk React SDK, you can use the hooks that the React SDK provides. These hooks include access to the [`Clerk`](/docs/references/javascript/clerk) object, [`User` object](/docs/references/javascript/user), [`Organization` object](/docs/references/javascript/organization), and a set of useful helper methods for signing in and signing up.

<Include src="_partials/hooks/hook-list" />

### Components

- **Native** apps:
  - [`<ClerkLoaded>`](/docs/components/control/clerk-loaded)
  - [`<ClerkLoading>`](/docs/components/control/clerk-loading)
  - [`<SignedIn>`](/docs/components/control/signed-in)
  - [`<SignedOut>`](/docs/components/control/signed-out)
  - [`<Protect>`](/docs/components/protect)
  - For other components, see the [custom flows](#custom-flows) section for more information.
- **Web** apps:
  - All Clerk components are available. See [the component docs](/docs/components/overview) for more information.

## Custom flows

<If sdk="expo">
  > [!WARNING]
  > Expo does not support email links. You can request this feature on [Clerk's roadmap](https://feedback.clerk.com/).
</If>

For **native** applications, Clerk's prebuilt components are not supported. You must use the Clerk API to build custom UI's for flows such as signing in and signing up. See the [custom flow](/docs/custom-flows/overview) guides for more information.

For **web** applications, if Clerk's [prebuilt components](/docs/components/overview) don't meet your specific needs or if you require more control over the logic, you can rebuild the existing Clerk flows using the Clerk API. See the [custom flow](/docs/custom-flows/overview) guides for more information.

## Deploy your app

To learn how to deploy your Expo application, see the [dedicated guide](/docs/deployments/deploy-expo).

---
title: Clerk Express SDK
description: The Clerk Express SDK provides a powerful set of tools and utilities to seamlessly integrate authentication, user management, and organization management into your Express application.
---

The Clerk Express SDK provides a powerful set of tools and utilities to seamlessly integrate authentication, user management, and organization management into your Express application. Refer to the [quickstart](/docs/quickstarts/express) to get started.

> [!IMPORTANT]
> If you are upgrading from the Node SDK, see the [upgrade guide](/docs/upgrade-guides/node-to-express) for more information.

## `clerkMiddleware()`

The `clerkMiddleware()` function checks the request's cookies and headers for a session JWT and if found, attaches the [`Auth`](/docs/references/backend/types/auth-object) object to the `request` object under the `auth` key.

```js
import { clerkMiddleware } from '@clerk/express'

const app = express()

// Pass no parameters
app.use(clerkMiddleware())

// Pass options
app.use(clerkMiddleware(options))
```

### `clerkMiddleware()` options

<Include src="_partials/clerk-middleware-options" />

<Properties>
  - `clerkClient`
  - [`ClerkClient`](/docs/references/backend/overview#create-clerk-client-options)

  An instance of the `ClerkClient` class. This is used to interact with the Clerk API.

  ---

  - `debug`
  - `boolean`

  A flag to enable debug mode. When set to `true`, the middleware will log debug information to the console. Defaults to `false`.

  ---

  - `enableHandshake`
  - `boolean`

  A flag to enable Clerk's handshake flow, which helps verify the session state when a session JWT has expired. It issues a `307` redirect to refresh the session JWT if the user is still logged in. Defaults to `true`.
</Properties>

## `requireAuth()`

The `requireAuth()` middleware functions similarly to `clerkMiddleware()`, but also protects your routes by redirecting unauthenticated users to the homepage. It accepts the same [options](/docs/references/express/overview#clerk-middleware-options) as `clerkMiddleware()`.

You can also specify a custom sign-in URL to redirect unauthenticated users to by setting the `CLERK_SIGN_IN_URL` environment variable or by passing a `signInUrl` option to the middleware. It's recommended to set the environment variable.

```js
import { requireAuth } from '@clerk/express'
import express from 'express'

const app = express()
const PORT = 3000

// Apply middleware to all routes
app.use(requireAuth())

// Apply middleware to a specific route
// Redirects to the homepage if the user is not authenticated
app.get('/protected', requireAuth(), (req, res) => {
  res.send('This is a protected route.')
})

// Redirects to a custom URL if the user is not authenticated
// Requires `CLERK_SIGN_IN_URL` to be set in env vars
app.get('/protected', requireAuth({ signInUrl: process.env.CLERK_SIGN_IN_URL }), (req, res) => {
  res.send('This is a protected route.')
})

// Redirects to a custom URL if the user is not authenticated
// Uses the `signInUrl` option instead of the environment variable
app.get('/protected', requireAuth({ signInUrl: '/sign-in' }), (req, res) => {
  res.send('This is a protected route.')
})

// Start the server and listen on the specified port
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`)
})
```

## `getAuth()`

The `getAuth()` helper retrieves authentication state from the `request` object. See the [Next.js reference documentation](https://clerk.com/docs/references/nextjs/get-auth) for more examples on how to use the returned `auth` object.

The following example uses `requireAuth()` to protect the route based on _authentication_ status, and then uses `getAuth()` to protect the route based on _authorization_ status.

```js
import { clerkMiddleware, getAuth, requireAuth } from '@clerk/express'
import express from 'express'

const app = express()
const PORT = 3000

// Apply `clerkMiddleware()` to all routes
app.use(clerkMiddleware())

// Use `getAuth()` to protect a route based on authorization status
const hasPermission = (req, res, next) => {
  const auth = getAuth(req)

  // Handle if the user is not authorized
  if (!auth.has({ permission: 'org:admin:example' })) {
    return res.status(403).send('Forbidden')
  }

  return next()
}

// Use `requireAuth()` to protect this route
// If user is not authenticated, requireAuth() will redirect back to the homepage
app.get('/path', requireAuth(), hasPermission, (req, res) => res.json(req.auth))

// Start the server and listen on the specified port
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`)
})
```

## `clerkClient`

[Clerk's JavaScript Backend SDK](/docs/references/backend/overview) provides access to Backend API resources and low-level authentication utilities for JavaScript environments. For example, to retrieve a list of all users in your application, you can use the `users.getUserList()` method from the JavaScript Backend SDK instead of manually making a fetch request to the `https://api.clerk.com/v1/users` endpoint.

All resource operations are mounted as sub-APIs on the `clerkClient` object. See the [reference documentation](/docs/references/backend/overview#usage){{ target: '_blank' }} for more information.

### Example: Use `clerkClient` to get a user's information

The following example uses `clerkClient` to get information about the currently signed-in user. If the user is authenticated, their `userId` is passed to [`clerkClient.users.getUser()`](/docs/references/backend/user/get-user){{ target: '_blank' }} to get the current user's [`User`](/docs/references/javascript/user){{ target: '_blank' }} object. If not authenticated, the request is rejected with a `401` status code.

```js
import { clerkClient, requireAuth } from '@clerk/express'
import express from 'express'

const app = express()
const PORT = 3000

app.get('/user', async (req, res) => {
  // Get the `userId` from the `Auth` object
  const userId = req.auth.userId

  // If user isn't authenticated, return a 401 error
  if (!userId) {
    res.status(401).json({ error: 'User not authenticated' })
  }

  // Use `clerkClient` to access Clerk's Backend SDK methods
  // and get the user's User object
  const user = await clerkClient.users.getUser(userId)

  res.json(user)
})

// Start the server and listen on the specified port
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`)
})
```

---
title: Clerk Fastify SDK
description: The Clerk Fastify SDK provides a powerful set of tools and utilities to seamlessly integrate authentication, user management, and organization management into your Fastify application.
---

The Clerk Fastify SDK provides a powerful set of tools and utilities to seamlessly integrate authentication, user management, and organization management into your Fastify application. Refer to the [quickstart guide](/docs/quickstarts/fastify) to get started.

## `clerkPlugin()`

The `clerkPlugin()` function is a Fastify plugin that integrates Clerk's authentication into your application. The function checks request cookies and headers for a session JWT. If valid, it attaches the [`Auth`](/docs/references/backend/types/auth-object){{ target: '_blank' }} object to the `request` object under the `auth` key.

You can register the plugin for [all routes](#example-register-clerk-plugin-for-all-routes) or [limit it to specific ones](#example-register-clerk-plugin-for-specific-routes).

### Example: Register `clerkPlugin()` for all routes

```ts
// dotenv must be imported before @clerk/fastify
import 'dotenv/config'
import Fastify from 'fastify'
import { clerkPlugin } from '@clerk/fastify'

const fastify = Fastify({ logger: true })

fastify.register(clerkPlugin)

const start = async () => {
  try {
    await fastify.listen({ port: 8080 })
  } catch (error) {
    fastify.log.error(error)
    process.exit(1)
  }
}

start()
```

### Example: Register `clerkPlugin()` for specific routes

To apply Clerk authentication only to specific routes, register the plugin in the scope of those routes.

In the following example, the application is split into protected and public routes:

```ts {{ filename: 'index.ts', collapsible: true }}
import 'dotenv/config'
import Fastify, { FastifyPluginCallback } from 'fastify'
import { clerkClient, clerkPlugin, getAuth } from '@clerk/fastify'

const fastify = Fastify({ logger: true })

const protectedRoutes: FastifyPluginCallback = (instance, options, done) => {
  instance.register(clerkPlugin)

  instance.get('/protected', async (req, reply) => {
    const { userId } = getAuth(req)

    // Protect the route from unauthenticated users
    if (!userId) {
      return reply.code(403).send({ message: 'Access denied. Authentication required.' })
    }

    const user = await clerkClient.users.getUser(userId)

    // Only authenticated users will see the following message
    reply.send({ message: 'This is a protected route.', user })
  })

  done()
}

const publicRoutes: FastifyPluginCallback = (instance, options, done) => {
  instance.get('/', async (req, reply) => {
    reply.send({ message: 'This is a public route.' })
  })

  done()
}

fastify.register(protectedRoutes)
fastify.register(publicRoutes)

const start = async () => {
  try {
    await fastify.listen({ port: 8080 })
  } catch (error) {
    fastify.log.error(error)
    process.exit(1)
  }
}

start()
```

### `clerkPlugin()` options

The `clerkPlugin()` function accepts the following options:

<Include src="_partials/clerk-options" />

<Properties>
  - `hookName`
  - `'onRequest' | 'preHandler'`

  Determines which of Fastify's [Request/Reply hooks](https://fastify.dev/docs/latest/Reference/Hooks/#requestreply-hooks) Clerk should run. Default: `'preHandler'`
</Properties>

#### Example: Pass `hookName` in `clerkPlugin()` options

```ts
fastify.register(clerkPlugin, {
  hookName: 'preHandler',
})
```

## `getAuth()`

The `getAuth()` helper retrieves the current user's authentication state from the `request` object. It returns the [`Auth` object](/docs/references/backend/types/auth-object){{ target: '_blank' }}. See the [Next.js reference documentation](/docs/references/nextjs/get-auth){{ target: '_blank' }} for more examples on how to use the returned `Auth` object.

### Example: Use `getAuth()` to retrieve the `userId`

<Include src="_partials/fastify/get-auth" />

---
title: Clerk Go SDK
description: Learn how to integrate Clerk into your Go application using the Clerk Go SDK.
---

The Clerk Go SDK is built on top of the [Clerk Backend API](/docs/reference/backend-api){{ target: '_blank' }}.

## Installation

If you're using Go Modules and have a `go.mod` file in your project's root, you can import `clerk-sdk-go` directly:

```go
import (
  "github.com/clerk/clerk-sdk-go/v2"
)
```

Alternatively, you can `go get` the package explicitly:

```sh {{ filename: 'terminal' }}
go get -u github.com/clerk/clerk-sdk-go/v2
```

## Usage

For details on how to use this module, see the [Go Documentation](https://pkg.go.dev/github.com/clerk/clerk-sdk-go/v2).

The Clerk Go SDK is organized using a resource-based structure similar to the [Clerk Backend API](/docs/reference/backend-api){{ target: '_blank' }}.
Each API supports specific operations, like Create or List. While operations for each resource vary, a similar pattern is applied throughout Clerk Go.

To execute API operations, you must configure Clerk Go with your Clerk Secret Key. To find your Clerk Secret Key:

1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
1. In the **Secret Keys** section, copy your Secret Key.

Depending on your use case,
there are two ways to use the Clerk Go SDK: With or without a client.

For most use cases, the API without a client is a better choice. It requires a minimal setup and provides a more concise API for invoking operations.

However, if you need to operate on multiple Clerk instances from one application, or need more flexibility for tests and mocking,
you can instantiate multiple API clients with different API keys.

The following examples demonstrate both approaches.

### Usage without a client

If you only use one API key, you can import the packages required for the APIs you need. Then you can execute your desired request methods as functions, such as `$resource$.Get()` or `$resource$.Delete()`. The following example demonstrates this process:

```go
import (
  "github.com/clerk/clerk-sdk-go/v2"
  "github.com/clerk/clerk-sdk-go/v2/$resource$"
)

// Each operation requires a context.Context as the first argument.
ctx := context.Background()

// Set the API key with your Clerk Secret Key
clerk.SetKey("sk_live_xxx")

// Create
resource, err := $resource$.Create(ctx, &$resource$.CreateParams{})

// Get
resource, err := $resource$.Get(ctx, id)

// Update
resource, err := $resource$.Update(ctx, id, &$resource$.UpdateParams{})

// Delete
resource, err := $resource$.Delete(ctx, id)

// List
list, err := $resource$.List(ctx, &$resource$.ListParams{})
for _, resource := range list.$Resource$s {
    // do something with the resource
}
```

### Usage with a client

If you're working with multiple keys, it's recommended to use Clerk Go with a client. The API packages for each
resource export a `Client`, which supports all the API's operations.
This way, you can create as many clients as needed, each with their own API key, as shown in the following example:

```go
import (
  "github.com/clerk/clerk-sdk-go/v2"
  "github.com/clerk/clerk-sdk-go/v2/$resource$"
)

// Each operation requires a context.Context as the first argument.
ctx := context.Background()

// Initialize a client with an API key
config := &clerk.ClientConfig{}
config.Key = "sk_live_xxx"
client := $resource$.NewClient(config)

// Create
resource, err := client.Create(ctx, &$resource$.CreateParams{})

// Get
resource, err := client.Get(ctx, id)

// Update
resource, err := client.Update(ctx, id, &$resource$.UpdateParams{})

// Delete
resource, err := client.Delete(ctx, id)

// List
list, err := client.List(ctx, &$resource$.ListParams{})
for _, resource := range list.$Resource$s {
    // do something with the resource
}
```

For more usage details, see the [examples](/docs/references/go/other-examples) or the library's [README file](https://github.com/clerk/clerk-sdk-go/tree/v2).

---
title: Clerk guides
description: Guides covering how to build or work with parts of Clerk
---

Clerk offers a variety of guides to help you build and work with Clerk. These guides cover a broad range of topics, from understanding key concepts like [routing](/docs/guides/routing) to practical code examples, such as [adding a custom onboarding flow to your sign-up process](/docs/references/nextjs/add-onboarding-flow).

---
title: Clerk iOS SDK
description: The Clerk iOS SDK provides a set of tools and utilities for handling authentication and user management.
---

The Clerk iOS SDK provides a set of tools and utilities for handling authentication and user management. Refer to the [quickstart guide](/docs/quickstarts/ios) to get started.

## SDK Reference

The full SDK Reference is available on [Swift Package Index](https://swiftpackageindex.com/clerk/clerk-ios/main/documentation/clerk).

## Installation with Swift Package Manager

To install the Clerk iOS SDK using Swift Package Manager, follow the instructions in the [GitHub README](https://github.com/clerk/clerk-ios?tab=readme-ov-file#-installation).

---
title: Clerk JavaScript SDK
description: The Clerk JavaScript SDK is Clerk's foundational library for building user management and authentication.
---

The Clerk JavaScript SDK, or ClerkJS, is our foundational JavaScript library for building user management and authentication. It enables you to register, sign in, verify, and manage users for your application using highly customizable flows. It powers the other JavaScript SDKs, such as the React and Next.js SDKs. The following sections will introduce you to the main objects that power the JavaScript SDK. As you're building your application, you'll likely interact with these objects, either directly or through helpers provided by the other SDKs, like React hooks or Vue composables.

## Installation

Follow the instructions in the [JavaScript quickstart](/docs/quickstarts/javascript) to add the JavaScript SDK to your project.

## Main objects

### `Clerk`

The [`Clerk`](/docs/references/javascript/clerk) class is the main entry point for the Clerk JavaScript SDK. All other objects are accessible from the `Clerk` object.

### `Client`

A client represents the current device or software accessing an application such as your web browser, native application, or Chrome Extension. It is represented by the [`Client`](/docs/references/javascript/client) object.

### `Session`

A session is a secure representation of the authentication state of the current user. Each client can hold multiple sessions on the same device. It is represented by the [`Session`](/docs/references/javascript/session) object.

### `User`

The [`User`](/docs/references/javascript/user) object represents the current user of the session. It holds all the basic user information such as the user's name, email addresses, and phone numbers, and including their public, private, and unsafe metadata.

### `SignIn`

The [`SignIn`](/docs/references/javascript/sign-in) object holds the state of the current sign-in and provides helper methods to navigate and complete the sign-in process. It is used to manage the sign-in lifecycle, including the first and second factor verification, and the creation of a new session.

### `SignUp`

The [`SignUp`](/docs/references/javascript/sign-up) object holds the state of the current sign-up and provides helper methods to navigate and complete the sign-up process. Once a sign-up is complete, a new user is created.

### `Organization`

Organizations are a flexible and scalable way to manage users and their access to resources within your Clerk application. With organizations, you can assign specific roles and permissions to users, making them useful for managing projects, coordinating teams, or facilitating partnerships. Users can belong to many organizations. One of them will be the ["active organization"](/docs/organizations/overview#active-organization) of the session. It is represented by the [`Organization`](/docs/references/javascript/organization) object. To learn about organizations, see the [dedicated guide](/docs/organizations/overview).

---
title: Clerk Next.js SDK
description: The Clerk Next.js SDK gives you access to prebuilt components, React hooks, and helpers to make user authentication easier.
---

The Clerk Next.js SDK gives you access to prebuilt components, React hooks, and helpers to make user authentication easier. Refer to the [quickstart guide](/docs/quickstarts/nextjs) to get started.

## Client-side helpers

Because the Next.js SDK is built on top of the Clerk React SDK, you can use the hooks that the React SDK provides. These hooks include access to the [`Clerk`](/docs/references/javascript/clerk) object, [`User` object](/docs/references/javascript/user), [`Organization` object](/docs/references/javascript/organization), and a set of useful helper methods for signing in and signing up.

<Include src="_partials/hooks/hook-list" />

## Server-side helpers

### App router

Clerk provides first-class support for the [Next.js App Router](https://nextjs.org/docs/app). The following references show how to integrate Clerk features into apps using the latest App Router and React Server Components features.

- [`auth()`](/docs/references/nextjs/auth)
- [`currentUser()`](/docs/references/nextjs/current-user)
- [Route Handlers](/docs/references/nextjs/route-handlers)
- [Server Actions](/docs/references/nextjs/server-actions)

### Pages router

Clerk continues to provide drop-in support for the Next.js Pages Router. In addition to the main Clerk integration, the following references are available for apps using Pages Router.

- [`getAuth()`](/docs/references/nextjs/get-auth)
- [`buildClerkProps()`](/docs/references/nextjs/build-clerk-props)

## `Auth` object

Both `auth()` (App Router) and `getAuth()` (Pages Router) return an `Auth` object. This JavaScript object contains important information like the current user's session ID, user ID, and organization ID. Learn more about the [`Auth` object](/docs/references/backend/types/auth-object){{ target: '_blank' }}.

## `clerkMiddleware()`

The `clerkMiddleware()` helper integrates Clerk authentication into your Next.js application through middleware. It allows you to integrate authorization into both the client and server of your application. You can learn more [here](/docs/references/nextjs/clerk-middleware).

## Demo repositories

For examples of Clerk's features, such as user and organization management, integrated into a single application, see the Next.js demo repositories:

- [Clerk + Next.js App Router Demo](https://github.com/clerk/clerk-nextjs-demo-app-router)
- [Clerk + Next.js Pages Router Demo](https://github.com/clerk/clerk-nextjs-demo-pages-router)

---
title: Clerk Nuxt SDK
description: The Clerk Nuxt SDK gives you access to prebuilt components, composables, and helpers to make user authentication easier.
---

The Clerk Nuxt SDK gives you access to prebuilt components, composables, and helpers to make user authentication easier. Refer to the [quickstart guide](/docs/quickstarts/nuxt) to get started.

## Client-side helpers

Because the Nuxt SDK is built on top of the Clerk Vue SDK, you can use the composables that the Vue SDK provides. These composables include access to the [`Clerk`](/docs/references/javascript/clerk) object, [`User` object](/docs/references/javascript/user), [`Organization` object](/docs/references/javascript/organization), and a set of useful helper methods for signing in and signing up. Learn more in the [Vue SDK reference](/docs/references/vue/overview).

<Include src="_partials/vue-nuxt/composables" />

## `Auth` object

The `Auth` object is available at `event.context.auth()` in your [event handlers](https://h3.unjs.io/guide/event-handler). This JavaScript object contains important information like session data, your user's ID, as well as their organization ID. [Learn more](/docs/references/backend/types/auth-object).

## `clerkMiddleware()`

The `clerkMiddleware()` helper integrates Clerk authentication and authorization into your Nuxt application through middleware. [Learn more](/docs/references/nuxt/clerk-middleware).

## `clerkClient()`

The `clerkClient()` helper returns an instance of the [JavaScript Backend SDK](/docs/references/backend/overview). [Learn more](/docs/references/nuxt/read-session-data).

---
title: Clerk React Router SDK
description: The Clerk React Router SDK gives you access to prebuilt components, React hooks, and helpers to make user authentication easier.
---

The Clerk React Router SDK gives you access to prebuilt components, React hooks, and helpers to make user authentication easier. Refer to the [quickstart guide](/docs/quickstarts/react-router) to get started.

## Client-side helpers

Because the React Router SDK is built on top of the [React SDK](/docs/references/react/overview), you can use the hooks that the React SDK provides. These hooks include access to the [`Clerk`](/docs/references/javascript/clerk) object, [`User` object](/docs/references/javascript/user), [`Organization` object](/docs/references/javascript/organization), and a set of useful helper methods for signing in and signing up. Learn more in the [React SDK reference](/docs/references/react/overview).

<Include src="_partials/hooks/hook-list" />

## Server-side helpers

The following references show how to integrate Clerk features into applications using React Router server functions and API routes.

- [`getAuth()`](/docs/references/react-router/get-auth)
- [`rootAuthLoader()`](/docs/references/react-router/root-auth-loader)

## React Router implementations

React Router can be integrated with Clerk in two ways:

- As a framework (recommended): Configure your app using [Clerk's React Router SDK](/docs/quickstarts/react-router)
- As a library: Manually integrate React Router into your React + Vite app using [library mode](/docs/references/react-router/library-mode)

---
title: Clerk React SDK
description: The Clerk React SDK gives you access to prebuilt components, React hooks, and helpers to make user authentication easier.
---

The Clerk React SDK is built on top of the [JavaScript SDK](/docs/references/javascript/overview) and gives you access to prebuilt components, hooks, and helpers to make user authentication easier. Refer to the [quickstart guide](/docs/quickstarts/react) to get started.

## Custom hooks

The React SDK provides hooks that include access to the [`Clerk`](/docs/references/javascript/clerk) object, [`User` object](/docs/references/javascript/user), [`Organization` object](/docs/references/javascript/organization), and a set of useful helper methods for signing in and signing up.

<Include src="_partials/hooks/hook-list" />

## Framework-specific SDKs

> [!IMPORTANT]
> Clerk provides optimized SDKs for specific React frameworks. If you're using one of the supported frameworks below, you should use its dedicated SDK instead of `@clerk/clerk-react`.

Clerk offers framework-specific SDKs that are customized to provide the better developer experience and integration with each framework's features. Choose the appropriate SDK based on your framework:

| Framework | Package | Docs |
| - | - | - |
| Next.js | `@clerk/nextjs` | [Next.js SDK](/docs/references/nextjs/overview) |
| React Router | `@clerk/react-router` | [React Router SDK](/docs/references/react-router/overview) |
| Remix | `@clerk/remix` | [Remix SDK](/docs/references/remix/clerk-app) |
| Astro | `@clerk/astro` | [Astro SDK](/docs/references/astro/overview) |
| Tanstack React Start | `@clerk/tanstack-react-start` | [Tanstack React Start SDK](/docs/references/tanstack-react-start/overview) |

## Set up Clerk React

Before you can add Clerk to your React application, you must create a Clerk app in the Clerk Dashboard. To get started, follow the [setup guide](/docs/quickstarts/setup-clerk). Then, follow the [quickstart guide](/docs/quickstarts/react) to set up the React SDK in your app.

---
title: Clerk Remix SDK
description: The Clerk Remix SDK gives you access to prebuilt components, React hooks, and helpers to make user authentication easier.
---

The Clerk Remix SDK gives you access to prebuilt components, React hooks, and helpers to make user authentication easier. Refer to the [quickstart guide](/docs/quickstarts/remix) to get started.

## `ClerkApp`

The `ClerkApp` component is a wrapper that provides Clerk's authentication state to your React tree. It is required to configure Clerk in your Remix application. Learn more in the [reference](/docs/references/remix/clerk-app).

## `rootAuthLoader()`

The `rootAuthLoader()` function is a helper function that provides the authentication state to your Remix application. It is required to configure Clerk in your Remix application. Learn more in the [reference](/docs/references/remix/root-auth-loader).

## Client-side helpers

Because the Remix SDK is built on top of the Clerk React SDK, you can use the hooks that the React SDK provides. These hooks include access to the [`Clerk`](/docs/references/javascript/clerk) object, [`User` object](/docs/references/javascript/user), [`Organization` object](/docs/references/javascript/organization), and a set of useful helper methods for signing in and signing up.

<Include src="_partials/hooks/hook-list" />

## Server-side helpers

### `getAuth()`

The `getAuth()` helper retrieves authentication state from the request object. Returns the [`Auth`](/docs/references/backend/types/auth-object){{ target: '_blank' }} object. Accepts the following parameters:

<Properties>
  - `args`

  The arguments object.

  ---

  - `opts?`

  An optional object that can be used to configure the behavior of the `getAuth()` function. It accepts the following properties:

  - `secretKey?`: A string that represents the Secret Key used to sign the session token. If not provided, the Secret Key is retrieved from the environment variable `CLERK_SECRET_KEY`.
</Properties>

See the [dedicated guide](/docs/references/remix/read-session-data#server-side) for example usage.

## SPA mode

Clerk supports [Remix in SPA mode](https://remix.run/docs/en/main/guides/spa-mode) out-of-the-box. Learn more in the [tutorial](/docs/references/remix/spa-mode).

---
title: Clerk Ruby SDK
description: The Clerk Ruby SDK provides a range of backend utilities to simplify user authentication and management in your application.
---

The Clerk Ruby SDK provides a powerful set of tools and utilities to seamlessly integrate authentication, user management, and organization management into your Ruby application.

To get started, refer to the appropriate guide:

- [Vanilla Ruby](/docs/quickstarts/ruby)
- [Rails](/docs/references/ruby/rails)
- [Rack](/docs/references/ruby/rack)
- [Sinatra](/docs/references/ruby/sinatra)

## Available environment variables

The Ruby SDK supports the following environment variables:

| Variable name | Usage |
| - | - |
| `CLERK_SECRET_KEY` | The Secret Key of your instance **(required)** |
| `CLERK_API_BASE` | Overrides the default API base URL: `https://api.clerk.com/v1/` |
| `CLERK_SIGN_IN_URL` | Rails view helper: `clerk_sign_in_url` |
| `CLERK_SIGN_IN_UP` | Rails view helper: `clerk_sign_up_url` |
| `CLERK_USER_PROFILE_URL` | Rails view helper: `clerk_user_profile_url` |

## Available methods

All available methods are listed in the [Ruby HTTP Client documentation](https://github.com/clerk/clerk-http-client-ruby/tree/main/.generated#documentation-for-api-endpoints){{ target: '_blank' }}. The Ruby HTTP Client is a generated wrapper around the [Backend API](/docs/reference/backend-api){{ target: '_blank' }} that provides a more Ruby-friendly interface.

### Reverification

The reverification feature provides an additional layer of security by requiring users to reverify their session before accessing sensitive routes. By default, it is set to `STRICT`, but accepts the following presets:

- `Clerk::StepUp::Preset::LAX`: Authenticated within the past day, requiring the second factor
- `Clerk::StepUp::Preset::MODERATE`: Authenticated within the past hour, requiring the second factor
- `Clerk::StepUp::Preset::STRICT`: Authenticated within the past 10 minutes, requiring the second factor
- `Clerk::StepUp::Preset::STRICT_MFA`: Authenticated within the past 10 minutes, requiring both first and second factors

---
title: Clerk TanStack React Start SDK
description: The Clerk TanStack React Start SDK gives you access to prebuilt components, React hooks, and helpers to make user authentication easier.
---

The Clerk TanStack React Start SDK gives you access to prebuilt components, React hooks, and helpers to make user authentication easier. Refer to the [quickstart guide](/docs/quickstarts/tanstack-react-start) to get started.

## Client-side helpers

Because the Tanstack React Start SDK is built on top of the React SDK, you can use the hooks that the React SDK provides. These hooks include access to the [`Clerk`](/docs/references/javascript/clerk) object, [`User` object](/docs/references/javascript/user), [`Organization` object](/docs/references/javascript/organization), and a set of useful helper methods for signing in and signing up. Learn more in the [React SDK reference](/docs/references/react/overview).

<Include src="_partials/hooks/hook-list" />

## Server-side helpers

The following references show how to integrate Clerk features into applications using TanStack React Start server functions and API routes.

- [`getAuth()`](/docs/references/tanstack-react-start/get-auth)

### `Auth` object

The `getAuth()` returns an `Auth` object. This JavaScript object contains important information like session data, your user's ID, as well as their organization ID. Learn more about the `Auth` object [here](/docs/references/backend/types/auth-object).

---
title: Clerk Telemetry
description: Clerk collects telemetry data from its SDKs about general product and feature usage.
---

Clerk collects telemetry data from its SDKs about general product and feature usage. Participation in telemetry collection is optional and users of the product can opt-out at any time.

## Why is Clerk collecting telemetry data?

While we actively engage with our users and community to gather feedback and inform our product roadmap, the information collected from these efforts only represents a small subset of our users.

Collecting telemetry data gives us a clearer picture into how our SDKs, components, and authentication helpers are used for a diverse set of problems. This data provides valuable insights to help us prioritize features that are useful and impactful for as many of our users as possible.

## What data is being collected?

We track general usage information about our SDKs, components, and authentication helpers from **development instances only**. While we collect identifiers that allows us to associate events with specific Clerk instances, **we do not collect any information from your users**.

Examples of data we are interested in:

- How often are our different components (`<SignIn />`, `<SignUp />`, `<UserProfile />`) rendered?
- What props are being used?
- How are developers utilizing the `appearance` prop on our components?
- What versions of our SDKs are being used?
- What associated framework versions are being used? (e.g. what `next` version is being used along with `@clerk/nextjs`)
- Usage of new features

> [!NOTE]
> We regularly audit this list to ensure it is an accurate representation of the data we are collecting. To audit telemetry data sent from our SDKs yourself, you can set a `CLERK_TELEMETRY_DEBUG=1` environment variable in your application. In this mode, telemetry events are only logged to the console and not sent to Clerk.

An example event looks like this:

```js {{ prettier: false }}
{
  event: 'COMPONENT_MOUNTED',
  cv: '4.62.1',
  sdk: '@clerk/nextjs',
  sdkv: '4.25.6',
  pk: 'pk_test_YmFsYW5jZWQtY293YmlyZC0xNi5jbGVyay5hY2NvdW50cy5kDXyk',
  payload: { component: 'SignIn', appearanceProp: false },
}
```

- `event`  A unique identifier for the event type.
- `cv`  Clerk Version. The version of the core Clerk library in use.
- `sdk`  SDK. The Clerk SDK that is being used.
- `sdkv`  SDK Version. The version of the Clerk SDK.
- `pk`  Publishable Key. The instance's Publishable Key.
- `payload`  Each unique event can provide custom data as part of the payload. As seen above, for the `COMPONENT_MOUNTED` event we track the component name and additional data about prop usage.

## What about sensitive data?

We will not collect sensitive data from your application or development environment that is not directly related to your implementation of Clerk's SDKs. Notably, we will not collect: environment variables unrelated to Clerk, any information about your users, file paths, contents of files, logs, git remote information, or raw JavaScript errors.

## How is my data protected?

Clerk takes data privacy and protection seriously. Telemetry data is most useful in aggregate form to gain product insights, and the raw data is only available to a small subset of Clerk employees.

We will never share with or sell telemetry data to third parties. The data is used strictly to help improve the Clerk product.

## How do I opt-out?

### Environment variables

> [!WARNING]
> Note that the variable name might differ between frameworks. See the [framework specific instructions](#framework-specific-instructions) below.

For meta-framework SDKs, you can opt-out of telemetry collection by setting the environment variable:

```env {{ filename: '.env' }}
CLERK_TELEMETRY_DISABLED=1
```

### `telemetry` prop

If you are using `@clerk/clerk-react` directly, or using an SDK that doesn't have environment variable support, you can opt out by passing the `telemetry` prop to `<ClerkProvider>`:

```tsx
<ClerkProvider telemetry={false} />
```

### Framework specific instructions

<CodeBlockTabs
  options={["Next.js", "React", "Remix", "JavaScript", "Chrome Extension", "Expo", "Astro", "React Router", "Tanstack React Start"]}
>
  ```env {{ filename: '.env' }}
  NEXT_PUBLIC_CLERK_TELEMETRY_DISABLED=1
  ```

  ```tsx
  <ClerkProvider telemetry={false} />
  ```

  ```env {{ filename: '.env' }}
  CLERK_TELEMETRY_DISABLED=1
  ```

  ```js
  const clerk = new Clerk(publishableKey)
  c.load({ telemetry: false })
  ```

  ```tsx
  <ClerkProvider telemetry={false} />
  ```

  ```tsx
  <ClerkProvider telemetry={false} />
  ```

  ```env {{ filename: '.env' }}
  PUBLIC_CLERK_TELEMETRY_DISABLED=1
  ```

  ```env {{ filename: '.env' }}
  VITE_CLERK_TELEMETRY_DISABLED=1
  ```

  ```env {{ filename: '.env' }}
  VITE_CLERK_TELEMETRY_DISABLED=1
  ```
</CodeBlockTabs>

---
title: Clerk types
description: Explore the different types available for typing your application.
---

Types are a powerful tool for adding type-safety to your application. They can help you catch bugs early, make your code easier to understand, and make your code easier to refactor. Clerk provides a number of types to help you add type-safety to your application.

To get access to Clerk types, you need to add the `@clerk/types` package to your project. Run the following command to install it:

<CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
  ```bash {{ filename: 'terminal' }}
  npm install @clerk/types
  ```

  ```bash {{ filename: 'terminal' }}
  yarn add @clerk/types
  ```

  ```bash {{ filename: 'terminal' }}
  pnpm add @clerk/types
  ```

  ```bash {{ filename: 'terminal' }}
  bun add @clerk/types
  ```
</CodeBlockTabs>

---
title: Clerk Vue SDK
description: The Clerk Vue SDK gives you access to prebuilt components, composables, and helpers to make user authentication easier.
---

The Clerk Vue SDK gives you access to prebuilt components, composables, and helpers to make user authentication easier. Refer to the [quickstart guide](/docs/quickstarts/vue) to get started.

## Custom composables

The Vue SDK provides access to custom composables that include access to the [`Clerk`](/docs/references/javascript/clerk) object, [`User` object](/docs/references/javascript/user), [`Organization` object](/docs/references/javascript/organization), and a set of useful helper methods for signing in and signing up.

<Include src="_partials/vue-nuxt/composables" />

## Framework-specific SDKs

> [!IMPORTANT]
> If you're building a standard Vue application (client-side only), use `@clerk/vue`. If you're using Nuxt, use the dedicated `@clerk/nuxt` package which includes backend integration.

Clerk offers framework-specific SDKs that are customized to provide the better developer experience and integration with each framework's features. Choose the appropriate SDK based on your framework:

| Framework | Package | Docs |
| - | - | - |
| Nuxt | `@clerk/nuxt` | [Nuxt SDK](/docs/references/nuxt/overview) |

---
title: clerkMiddleware() | Next.js
description: The clerkMiddleware() function allows you to protect your Next.js application using Middleware.
---

The `clerkMiddleware()` helper integrates Clerk authentication into your Next.js application through Middleware. `clerkMiddleware()` is compatible with both the App and Pages routers.

## Configure `clerkMiddleware()`

Create a `middleware.ts` file at the root of your project, or in your `src/` directory if you have one.

> [!NOTE]
> For more information about Middleware in Next.js, see the [Next.js documentation](https://nextjs.org/docs/pages/building-your-application/routing/middleware).

```tsx {{ filename: 'middleware.ts' }}
import { clerkMiddleware } from '@clerk/nextjs/server'

export default clerkMiddleware()

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

By default, `clerkMiddleware` will not protect any routes. All routes are public and you must opt-in to protection for routes.

## `createRouteMatcher()`

`createRouteMatcher()` is a Clerk helper function that allows you to protect multiple routes. `createRouteMatcher()` accepts an array of routes and checks if the route the user is trying to visit matches one of the routes passed to it. The paths provided to this helper can be in the same format as the paths provided to the Next Middleware matcher.

The `createRouteMatcher()` helper returns a function that, if called with the `req` object from the Middleware, will return `true` if the user is trying to access a route that matches one of the routes passed to `createRouteMatcher()`.

In the following example, `createRouteMatcher()` sets all `/dashboard` and `/forum` routes as protected routes.

```tsx
const isProtectedRoute = createRouteMatcher(['/dashboard(.*)', '/forum(.*)'])
```

## Protect API routes

You can protect routes using either or both of the following:

- [Authentication-based protection](#protect-routes-based-on-authentication-status): Verify if the user is signed in.
- [Authorization-based protection](#protect-routes-based-on-authorization-status): Verify if the user has the required organization roles or custom permissions.

### Protect routes based on authentication status

You can protect routes based on a user's authentication status by checking if the user is signed in.

There are two methods that you can use:

- Use [`auth.protect()`](/docs/references/nextjs/auth#auth-protect) if you want to redirect unauthenticated users to the sign-in route automatically.
- Use [`auth().userId`](/docs/references/nextjs/auth#protect-pages-and-routes) if you want more control over what your app does based on user authentication status.

<CodeBlockTabs options={["auth.protect()", "auth().userId()"]}>
  ```tsx {{ filename: 'middleware.ts' }}
  import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

  const isProtectedRoute = createRouteMatcher(['/dashboard(.*)', '/forum(.*)'])

  export default clerkMiddleware(async (auth, req) => {
    if (isProtectedRoute(req)) await auth.protect()
  })

  export const config = {
    matcher: [
      // Skip Next.js internals and all static files, unless found in search params
      '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
      // Always run for API routes
      '/(api|trpc)(.*)',
    ],
  }
  ```

  ```tsx {{ filename: 'app/middleware.ts' }}
  import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

  const isProtectedRoute = createRouteMatcher(['/dashboard(.*)', '/forum(.*)'])

  export default clerkMiddleware(async (auth, req) => {
    const { userId, redirectToSignIn } = await auth()

    if (!userId && isProtectedRoute(req)) {
      // Add custom logic to run before redirecting

      return redirectToSignIn()
    }
  })

  export const config = {
    matcher: [
      // Skip Next.js internals and all static files, unless found in search params
      '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
      // Always run for API routes
      '/(api|trpc)(.*)',
    ],
  }
  ```
</CodeBlockTabs>

### Protect routes based on authorization status

You can protect routes based on a user's authorization status by checking if the user has the required roles or permissions.

There are two methods that you can use:

- Use [`auth.protect()`](/docs/references/nextjs/auth#auth-protect) if you want Clerk to return a `404` if the user does not have the role or permission.
- Use [`auth().has()`](/docs/references/backend/types/auth-object#has) if you want more control over what your app does based on the authorization status.

<Tabs items={["auth.protect()", "auth().has()"]}>
  <Tab>
    ```tsx {{ filename: 'middleware.ts' }}
    import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

    const isProtectedRoute = createRouteMatcher(['/admin(.*)'])

    export default clerkMiddleware(async (auth, req) => {
      // Restrict admin routes to users with specific permissions
      if (isProtectedRoute(req)) {
        await auth.protect((has) => {
          return has({ permission: 'org:admin:example1' }) || has({ permission: 'org:admin:example2' })
        })
      }
    })

    export const config = {
      matcher: [
        // Skip Next.js internals and all static files, unless found in search params
        '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
        // Always run for API routes
        '/(api|trpc)(.*)',
      ],
    }
    ```
  </Tab>

  <Tab>
    <Include src="_partials/has-warning" />

    ```tsx {{ filename: 'middleware.ts' }}
    import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

    const isProtectedRoute = createRouteMatcher(['/admin(.*)'])

    export default clerkMiddleware(async (auth, req) => {
      const { has, redirectToSignIn } = await auth()
      // Restrict admin routes to users with specific permissions
      if (
        (isProtectedRoute(req) && !has({ permission: 'org:admin:example1' })) ||
        !has({ permission: 'org:admin:example2' })
      ) {
        // Add logic to run if the user does not have the required permissions

        return redirectToSignIn()
      }
    })

    export const config = {
      matcher: [
        // Skip Next.js internals and all static files, unless found in search params
        '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
        // Always run for API routes
        '/(api|trpc)(.*)',
      ],
    }
    ```
  </Tab>
</Tabs>

## Protect multiple groups of routes

You can use more than one `createRouteMatcher()` in your application if you have two or more groups of routes.

The following example uses the [`has()`](/docs/references/backend/types/auth-object#has) method from the `auth()` helper.

```tsx {{ filename: 'middleware.ts' }}
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

const isTenantRoute = createRouteMatcher(['/organization-selector(.*)', '/orgid/(.*)'])

const isTenantAdminRoute = createRouteMatcher(['/orgId/(.*)/memberships', '/orgId/(.*)/domain'])

export default clerkMiddleware(async (auth, req) => {
  // Restrict admin routes to users with specific permissions
  if (isTenantAdminRoute(req)) {
    await auth.protect((has) => {
      return has({ permission: 'org:admin:example1' }) || has({ permission: 'org:admin:example2' })
    })
  }
  // Restrict organization routes to signed in users
  if (isTenantRoute(req)) await auth.protect()
})

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

## Protect all routes

To protect all routes in your application and define specific routes as public, you can use any of the above methods and simply invert the `if` condition.

```jsx {{ filename: 'middleware.ts' }}
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

const isPublicRoute = createRouteMatcher(['/sign-in(.*)', '/sign-up(.*)'])

export default clerkMiddleware(async (auth, req) => {
  if (!isPublicRoute(req)) {
    await auth.protect()
  }
})

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

## Debug your Middleware

If you are having issues getting your Middleware dialed in, or are trying to narrow down auth-related issues, you can use the debugging feature in `clerkMiddleware()`. Add `{ debug: true }` to `clerkMiddleware()` and you will get debug logs in your terminal.

```tsx {{ filename: 'middleware.ts', mark: [[4, 7]] }}
import { clerkMiddleware } from '@clerk/nextjs/server'

export default clerkMiddleware(
  (auth, req) => {
    // Add your middleware checks
  },
  { debug: true },
)

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

If you would like to set up debugging for your development environment only, you can use the `process.env.NODE_ENV` variable to conditionally enable debugging. For example, `{ debug: process.env.NODE_ENV === 'development' }`.

## Combine Middleware

You can combine other Middleware with Clerk's Middleware by returning the second Middleware from `clerkMiddleware()`.

```js {{ filename: 'middleware.ts' }}
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'
import createMiddleware from 'next-intl/middleware'

import { AppConfig } from './utils/AppConfig'

const intlMiddleware = createMiddleware({
  locales: AppConfig.locales,
  localePrefix: AppConfig.localePrefix,
  defaultLocale: AppConfig.defaultLocale,
})

const isProtectedRoute = createRouteMatcher(['dashboard/(.*)'])

export default clerkMiddleware(async (auth, req) => {
  if (isProtectedRoute(req)) await auth.protect()

  return intlMiddleware(req)
})

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

## `clerkMiddleware()` options

<Include src="_partials/clerk-middleware-options" />

It's also possible to dynamically set options based on the incoming request:

```ts {{ filename: 'middleware.ts' }}
import { clerkMiddleware } from '@clerk/nextjs/server'

export default clerkMiddleware(
  (auth, req) => {
    // Add your middleware checks
  },
  (req) => ({
    // Provide `domain` based on the request host
    domain: req.nextUrl.host,
  }),
)
```

### Dynamic keys

> [!NOTE]
> Dynamic keys are not accessible on the client-side.

The following options, known as "Dynamic Keys," are shared to the Next.js application server through `clerkMiddleware`, enabling access by server-side helpers like [`auth()`](/docs/references/nextjs/auth):

- `signUpUrl`
- `signInUrl`
- `secretKey`
- `publishableKey`

Dynamic keys are encrypted and shared during request time using a [AES encryption algorithm](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard). When providing a `secretKey`, the `CLERK_ENCRYPTION_KEY` environment variable is mandatory and used as the encryption key. If no `secretKey` is provided to `clerkMiddleware`, the encryption key defaults to `CLERK_SECRET_KEY`.

When providing `CLERK_ENCRYPTION_KEY`, it is recommended to use a 32-byte (256-bit), pseudorandom value. You can use `openssl` to generate a key:

```sh {{ filename: 'terminal' }}
openssl rand --hex 32
```

For multi-tenant applications, you can dynamically define Clerk keys depending on the incoming request. Here's an example:

```ts {{ filename: 'middleware.ts' }}
import { clerkMiddleware } from '@clerk/nextjs/server'

// You would typically fetch these keys from a external store or environment variables.
const tenantKeys = {
  tenant1: { publishableKey: 'pk_tenant1...', secretKey: 'sk_tenant1...' },
  tenant2: { publishableKey: 'pk_tenant2...', secretKey: 'sk_tenant2...' },
}

export default clerkMiddleware(
  (auth, req) => {
    // Add your middleware checks
  },
  (req) => {
    // Resolve tenant based on the request
    const tenant = getTenant(req)
    return tenantKeys[tenant]
  },
)
```

### `OrganizationSyncOptions`

The `organizationSyncOptions` property on the [`clerkMiddleware()`](#clerk-middleware-options) options
object has the type `OrganizationSyncOptions`, which has the following properties:

<Properties>
  - `organizationPatterns`
  - <code>[Pattern](#pattern)\[]</code>

  Specifies URL patterns that are organization-specific, containing an organization ID or slug as a path parameter. If a request
  matches this path, the organization identifier will be used to set that org as active.

  If the route also matches the `personalAccountPatterns` prop, this prop takes precedence.

  Patterns must have a path parameter named either `:id` (to match a Clerk organization ID) or `:slug` (to match a Clerk organization slug).

  > [!WARNING]
  > If the organization can't be activatedeither because it doesn't exist or the user lacks accessthe previously active organization will remain unchanged. Components must detect this case and provide an appropriate error and/or resolution pathway, such as calling `notFound()` or displaying an [`<OrganizationSwitcher />`](/docs/components/organization/organization-switcher).

  Common examples:

  - `["/orgs/:slug", "/orgs/:slug/(.*)"]`
  - `["/orgs/:id", "/orgs/:id/(.*)"]`
  - `["/app/:any/orgs/:slug", "/app/:any/orgs/:slug/(.*)"]`

  ---

  - `personalAccountPatterns`
  - <code>[Pattern](#pattern)\[]</code>

  URL patterns for resources that exist within the context of a [Clerk Personal Account](/docs/organizations/organization-workspaces) (user-specific, outside any
  organization).

  If the route also matches the `organizationPattern` prop, the `organizationPattern` prop takes precedence.

  Common examples:

  - `["/me", "/me/(.*)"]`
  - `["/user/:any", "/user/:any/(.*)"]`
</Properties>

### Pattern

A `Pattern` is a `string` that represents the structure of a URL path. In addition to any valid URL, it may include:

- Named path parameters prefixed with a colon (e.g., `:id`, `:slug`, `:any`).
- Wildcard token, `(.*)`, which matches the remainder of the path.

#### Examples

- `/orgs/:slug`

| URL | Matches | `:slug` value |
| - | - | - |
| `/orgs/acmecorp` |  | `acmecorp` |
| `/orgs` |  | n/a |
| `/orgs/acmecorp/settings` |  | n/a |

- `/app/:any/orgs/:id`

| URL | Matches | `:id` value |
| - | - | - |
| `/app/petstore/orgs/org_123` |  | `org_123` |
| `/app/dogstore/v2/orgs/org_123` |  | n/a |

- `/personal-account/(.*)`

| URL | Matches |
| - | - |
| `/personal-account/settings` |  |
| `/personal-account` |  |

---
title: clerkMiddleware() | Nuxt
description: The clerkMiddleware() helper allows you to protect your Nuxt application using middleware.
---

The `clerkMiddleware()` helper allows you to protect your Nuxt application **on the server-side**. It can be used to validate a user's authentication status or authorization status.

> [!NOTE]
> To learn how to protect pages, see the [dedicated guide](/docs/references/nuxt/protect-pages).

## Configure `clerkMiddleware()`

By default, the Nuxt SDK **automatically** adds the `clerkMiddleware()` helper to your Nuxt application.

To **manually** configure the middleware:

1. In your `nuxt.config.ts` file, under the `clerk` property, set `skipServerMiddleware: true`.

   ```ts {{ filename: 'nuxt.config.ts', mark: [[3, 5]] }}
   export default defineNuxtConfig({
     modules: ['@clerk/nuxt'],
     clerk: {
       skipServerMiddleware: true,
     },
   })
   ```
1. In your `server/middleware/` directory, create a file named `clerk.ts` with the following code:

   ```ts {{ filename: 'server/middleware/clerk.ts' }}
   import { clerkMiddleware } from '@clerk/nuxt/server'
   export default clerkMiddleware()
   ```

## Protect API routes

You can protect routes using either or both of the following:

- [Authentication-based protection](#authentication-based-protection): Verify if the user is signed in.
- [Authorization-based protection](#authorization-based-protection): Verify if the user has the required organization roles or custom permissions.

### Authentication-based protection

To protect routes based on user authentication status, you can check if the user is signed in by checking the `userId` on the [`auth`](/docs/references/nuxt/overview#auth-object) object.

In the following example, the `clerkMiddleware()` helper checks if the user is signed in and accessing a protected route. If they aren't signed in, an error is thrown using Nuxt's [`createError()`](https://nuxt.com/docs/api/utils/create-error) utility.

```tsx {{ filename: 'server/middleware/clerk.ts' }}
import { clerkMiddleware } from '@clerk/nuxt/server'

export default clerkMiddleware((event) => {
  const { userId } = event.context.auth()
  const isAdminRoute = event.path.startsWith('/api/admin')

  if (!userId && isAdminRoute) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Unauthorized: User not signed in',
    })
  }
})
```

### Authorization-based protection

To protect routes based on user authorization status, you can use the `has()` helper to check if the user has the required [organization roles or custom permissions](/docs/organizations/roles-permissions). It is available on the [`auth`](/docs/references/nuxt/overview#auth-object) object.

#### Protecting routes using custom permissions

In the following example, the `clerkMiddleware()` helper checks if the user is accessing a protected route. If so, it checks if the user has the required custom permission. If they don't, an error is thrown using Nuxt's [`createError()`](https://nuxt.com/docs/api/utils/create-error) utility.

```ts {{ filename: 'server/middleware/clerk.ts' }}
import { clerkMiddleware } from '@clerk/nuxt/server'

export default clerkMiddleware((event) => {
  const { has } = event.context.auth()
  const isInvoicesRoute = event.path.startsWith('/api/invoices')
  const canCreateInvoices = has({
    permission: 'org:invoices:create',
  })

  // Check if user is accessing sensitive customer data
  if (isInvoicesRoute) {
    // Check if user has the required permission
    if (!canCreateInvoices) {
      throw createError({
        statusCode: 403,
        statusMessage: 'Unauthorized: Missing permission to create invoices',
      })
    }
  }
})
```

#### Protecting routes using default roles

> [!WARNING]
> It's best practice to use permission-based authorization over role-based authorization, as it reduces complexity and increases security. Usually, complex role checks can be refactored with a single permission check.

In the following example, the `clerkMiddleware()` helper checks if the user is accessing a protected route. If so, it checks if the user has the required admin role. If they don't, an error is thrown using Nuxt's [`createError()`](https://nuxt.com/docs/api/utils/create-error) utility.

```ts {{ filename: 'server/middleware/clerk.ts' }}
import { clerkMiddleware } from '@clerk/nuxt/server'

export default clerkMiddleware((event) => {
  const { has } = event.context.auth()
  const isAdminRoute = event.path.startsWith('/api/admin')
  const isAdmin = has({
    role: 'org:admin',
  })

  // Check if the user is trying to access a protected route
  if (isAdminRoute) {
    // Check if the user has the required admin role
    if (!isAdmin) {
      throw createError({
        statusCode: 403,
        statusMessage: 'Unauthorized: Admin access required',
      })
    }
  }
})
```

---
title: Client errors
description: An index of Clerk errors related to a client.
type: reference
---

An index of Clerk errors related to a client.

## `ClientNotFound`

Signifies an error when no client is found with `clientID`.

```json
{
  "shortMessage": "Client not found",
  "longMessage": "No client was found with id <clientID>",
  "code": "resource_not_found_code"
}
```

## `ClientNotFoundInRequest`

Signifies an error when no client is found in an incoming request.

```json
{
  "shortMessage": "No client found",
  "longMessage": "This request is expecting a client and did not find one",
  "code": "client_not_found_code"
}
```

---
title: Coinbase Wallet
description: Learn how to set up Web3 authentication with Coinbase Wallet.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk application is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
  ]}
/>

Enabling [Coinbase Wallet](https://www.coinbase.com/wallet) as a Web3 provider allows your users to sign in and up to your Clerk application with their Coinbase Wallet. Both [Smart Wallet](https://www.coinbase.com/wallet/smart-wallet) and the [Coinbase Wallet browser extension](https://www.coinbase.com/wallet/downloads) are supported.

> [!WARNING]
> This guide is for using Coinbase Wallet for authentication. If you're looking to connect users using [Coinbase.com](https://www.coinbase.com/) as a social provider, see the [dedicated guide](/docs/authentication/social-connections/coinbase).

## Enable Coinbase Wallet as a Web3 provider

1. In the Clerk Dashboard, navigate to the [**Web3**](https://dashboard.clerk.com/last-active?path=user-authentication/web3) page.
1. From the list of web3 providers, enable **Coinbase Wallet**.

## Test authentication

The simplest way to test authentication is to visit your Clerk application's [Account Portal](/docs/account-portal/overview), which is available for all Clerk applications out-of-the-box.

1. In the Clerk Dashboard, navigate to the [**Account Portal**](https://dashboard.clerk.com/last-active?path=account-portal) page.
1. Next to the **Sign-in** URL, select **Visit**. The URL should resemble:
   - **For development**  `https://your-domain.accounts.dev/sign-in`
   - **For production**  `https://accounts.your-domain.com/sign-in`
1. On the sign-in page, you should see **Coinbase Wallet** as an option. Use it to sign in.

## Collect additional user information during sign-up (optional)

Web3 applications typically use a hexadecimal wallet address to identify users, which offers a high level of privacy. However, when bridging the gap between Web3 and Web2, it's often necessary to gather human-readable information about the user, such as their email address, phone number, or a username.

To collect additional information about your user during sign-up:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. On this page, enable the attributes you want to collect from your user during sign-up.
1. To set an attribute as required, select the settings icon next to the enabled attribute. Clerk will automatically prompt the user for this information after authenticating with Coinbase Wallet.

## Connect Coinbase Wallet to existing account

Users can connect their Coinbase Wallet to their account at any time through their user profile page. You can configure your application to use the [Account Portal user profile page](/docs/account-portal/overview#user-profile) or the prebuilt [`<UserProfile />`](/docs/components/user/user-profile) component.

---
title: Common components
description: Reference documentation for common Clerk Elements components.
---

Clerk Elements provides a set of common components that are used across all flows. It's recommended to import them all under the `Clerk` namespace to make discovery easier and reduce naming conflicts with other common components throughout your application. The code snippets on this page assume you have imported the components this way.

```tsx {{ filename: 'Anatomy' }}
import * as Clerk from '@clerk/elements/common'
```

Unless otherwise mentioned, all components accept a `className` prop.

## `<Connection>`

Renders a social connection button based on the provided `name`. Throws an error in development if the provided social connection is not enabled in your instance. See [Social connections (OAuth)](/docs/authentication/social-connections/overview) to learn how to enable them in the Clerk Dashboard.

By default, `<Connection>` will be rendered as an unstyled `<button>`.

### Properties {{ toc: false }}

<Properties>
  - `asChild`
  - `boolean` (optional)

  If `true`, `<Connection>` will render as its child element, passing along any necessary props. Default: `false`

  ---

  - `name`
  - `string`

  Name of the social connection to render.
</Properties>

### Usage {{ toc: false }}

```tsx {{ filename: 'page.tsx', mark: [3] }}
<SignIn.Root>
  <SignIn.Step name="start">
    <Clerk.Connection name="google">Sign in with Google</Clerk.Connection>
  </SignIn.Step>
</SignIn.Root>
```

You can enrich this example by providing an [`<Icon>`](#icon) to display the social connection's logo.

## `<Field>`

Associates its child elements with a specific `<Input>`. It automatically generates unique IDs and associates child `<Label>` and `<Input>` elements with each other.

### Properties {{ toc: false }}

<Properties>
  - `name`
  - `'code' | 'confirmPassword' | 'currentPassword' | 'emailAddress' | 'firstName' | 'identifier' | 'lastName' | 'name' | 'newPassword' | 'password' | 'phoneNumber' | 'username'`

  Name for form field, will be used to associate all underlying field elements.

  ---

  - `alwaysShow?`
  - `boolean`

  When `true`, the field will always be rendered, regardless of its state. When `false`, the field is hidden if it's optional or if it's a filled-out required field. Default: `false`

  ---

  - `children?`
  - `(state: 'success' | 'error' | 'warning' | 'info' | 'idle') => React.ReactNode`

  Provide a function as children and access the field's state.
</Properties>

### Usage {{ toc: false }}

Place common components like [`<Input>`](#input), [`<FieldError>`](#field-error), or [`<Label>`](#label) inside `<Field>`.

```tsx
<Clerk.Field name="unique-name">{/* Your content */}</Clerk.Field>
```

#### Function as children

The `state` you can access here is the same as in [`<FieldState>`](#field-state).

```tsx
<Clerk.Field name="unique-name">{(state) => <p>Field's state is: {state}</p>}</Clerk.Field>
```

## `<FieldError>`

Renders error messages associated with a specific `<Field>`. By default, the error's message will be rendered in an unstyled `<span>`. Optionally, the `children` prop accepts a function to customize rendering.

### Properties {{ toc: false }}

<Properties>
  - `name?`
  - `string`

  Used to target a specific field by name when rendering outside of a `<Field>` component. Default: Automatically inferred

  ---

  - `asChild?`
  - `boolean`

  If `true`, `<FieldError>` will render as its child element, passing along any necessary props. Default: `false`

  ---

  - `children?`
  - `({ message: string, code: string }) => React.ReactNode`

  Provide a function as children and access the error's `message` and `code`.
</Properties>

### Usage {{ toc: false }}

If the `<Field>` is in an error state, `<FieldError>` will display its message.

```tsx
<Clerk.Field name="unique-name">
  <Clerk.FieldError />
</Clerk.Field>
```

#### Function as children

By having access to both `message` and `code` you can enrich the incoming `message` or localize it by checking for a specific `code`.

```tsx
<Clerk.Field name="unique-name">
  <Clerk.FieldError>
    {({ message, code }) => (
      <span>
        {message} ({code})
      </span>
    )}
  </Clerk.FieldError>
</Clerk.Field>
```

## `<FieldState>`

Enables you to programmatically access additional information from the parent `<Field>` component. By default, you'll have access to `state`. `state` will also contain the field's [`ValidityState`](https://developer.mozilla.org/en-US/docs/Web/API/ValidityState). `<FieldState>` is useful for implementing animations if you need direct access to the `state` value.

If you use `<Input type="password" validatePassword>`, additional information in the form of `message` and `codes` is provided.

### Properties {{ toc: false }}

<Properties>
  - `children`
  - `(args: { state: 'success' | 'error' | 'warning' | 'info' | 'idle'; message: string | undefined; codes: (string | [string, Record<string, string | number>])[] | undefined }) => React.ReactNode`

  Use this function to access the field's state. Optionally, information regarding password validation is given.
</Properties>

### Usage {{ toc: false }}

`<Input>` will start with a `state` of `idle` until the user interacts with it. Depending on the user's input, the `state` will change to `success` or `error`.

```tsx {{ mark: [4] }}
<Clerk.Field name="emailAddress">
  <Clerk.Label>Email</Clerk.Label>
  <Clerk.Input />
  <Clerk.FieldState>{({ state }) => <p>Field's state is: {state}</p>}</Clerk.FieldState>
</Clerk.Field>
```

#### `<Input type="password" validatePassword>`

If you're using [`<Input type="password" validatePassword>`](#input-type-password), the `<FieldState>`'s children function receives additional arguments:

<Properties>
  - `message`
  - `string`

  The standardized English message generated for the current state of the input. This message is generated based on the codes associated with the `<FieldState>`.

  ---

  - `codes`
  - `(string | [string, Record<string, string | number>])[]`

  The error codes associated with the `<FieldState>`. You can use these codes to return a custom `message` or localize its contents.
</Properties>

Initially, the `<Input>` will have a `state` of `idle` until the user interacts with the input. Depending on the user's input, the `state` will change to `'success' | 'error' | 'warning' | 'info'`.

```tsx {{ mark: [[4, 12]] }}
<Clerk.Field name="password">
  <Clerk.Label>Password</Clerk.Label>
  <Clerk.Input type="password" validatePassword />
  <Clerk.FieldState>
    {({ state, codes, message }) => (
      <div>
        <pre>Field state: {state}</pre>
        <pre>Field msg: {message}</pre>
        <pre>Codes: {JSON.stringify(codes, null, 2)}</pre>
      </div>
    )}
  </Clerk.FieldState>
</Clerk.Field>
```

## `<GlobalError />`

Renders errors that are returned from Clerk's API but are not associated with a specific form field. By default, renders the error's message wrapped in a `<div>`. Optionally, the `children` prop accepts a function to customize rendering. **Must be a child of components like `<SignIn>`/`<SignUp>` to have access to the underlying form state**.

### Properties {{ toc: false }}

<Properties>
  - `asChild?`
  - `boolean`

  If `true`, `<GlobalError>` will render as its child element, passing along any necessary props. Default: `false`

  ---

  - `code?`
  - `string`

  Forces the message with the matching code to be shown. This is useful when using server-side validation. Default: `undefined`

  ---

  - `children?`
  - `({ message: string, code: string }) => React.ReactNode`

  Provide a function as children and access the error's `message` and `code`.
</Properties>

### Usage {{ toc: false }}

```tsx {{ filename: 'page.tsx' }}
<SignIn.Root>
  <Clerk.GlobalError />
</SignIn.Root>
```

#### Function as children

By having access to both `message` and `code` you can enrich the incoming `message` or localize it by checking for specific `code`.

```tsx {{ filename: 'page.tsx' }}
<SignIn.Root>
  <Clerk.GlobalError>
    {({ message, code }) => (
      <span>
        {message} ({code})
      </span>
    )}
  </Clerk.GlobalError>
</SignIn.Root>
```

## `<Icon>`

By default, renders as an `<img>` element with the logo of the parent `<Connection>` as the value of its `src` prop. **Must be a child of [`<Connection>`](#connection)**.

> [!TIP]
> `<Icon>` is designed to give you access to Clerk's social connection logos and has intentionally limited customizability. If you need more customizability, consider options such as [Iconify](https://iconify.design/getting-started/).

### Properties {{ toc: false }}

<Properties>
  - `asChild?`
  - `boolean`

  If `true`, `<Icon>` will render as its child element, passing along any necessary props. Default: `false`
</Properties>

### Usage {{ toc: false }}

The following example demonstrates how to render the Google social connection logo with `<Icon>`:

```tsx {{ filename: 'page.tsx', mark: [4] }}
<SignIn.Root>
  <SignIn.Step name="start">
    <Clerk.Connection name="google">
      <Clerk.Icon />
      Sign in with Google
    </Clerk.Connection>
  </SignIn.Step>
</SignIn.Root>
```

## `<Input>`

Handles rendering of [`<input />` elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input) within Clerk's flows. Supports special `type` prop values to render input types that are unique to authentication and user management flows. Additional props will be passed through to the `<input />`.

> [!NOTE]
> For screen reader accessibility, always associate a [`<Label>`](#label) with your `<Input>` elements.

### Properties {{ toc: false }}

<Properties>
  - `asChild?`
  - `boolean`

  If `true`, `<Input>` will render as its child element, passing along any necessary props. Default: `false`

  ---

  - `name?`
  - `string`

  Name for the form field. Will be used to associate all underlying field elements. Can be automatically inferred from the name on the `<Field>` component.

  ---

  - `type?`
  - `'text' | 'email' | 'tel' | 'otp'* | 'password'`

  Type for the input. Default: `'text'`

  ---

  - `autoComplete?`
  - `string`

  Refers to the [HTML attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete). If `<Input>` is used inside a `<SignIn>` flow and `autoComplete="webauthn"` is set, [passkey autofill](https://developer.chrome.com/docs/identity/webauthn-conditional-ui) will be attempted.
</Properties>

> [!NOTE]
> Values denoted with `*` are unique Clerk input types.

The following data attributes are also added to the underlying element:

- `data-valid` - If the field state is valid
- `data-invalid` - If the field state is invalid (Either the [`ValidityState`](https://developer.mozilla.org/en-US/docs/Web/API/ValidityState) or has an associated error from Clerk's API)
- `date-state` - Refers to the [`<FieldState>`](#field-state) status
- `data-has-value` - If the input has a value

### Usage {{ toc: false }}

```tsx
<Clerk.Field name="identifier">
  <Clerk.Label>Email</Clerk.Label>
  <Clerk.Input type="email" />
</Clerk.Field>
```

### `<Input type="otp">`

A special type used to render an input that accepts a one-time passcode (OTP). If the corresponding `<Field>` has `name="code"`, the child `<Input>` will default to the `otp` type. Only numbers are accepted as inputs, and the default max length is 6.

By default, a single text `<input />` will be rendered. If provided, the `render` prop will be called for each character present in the input. This enables UI patterns where an OTP input is visually represented as N distinct elements.

#### Properties

<Properties>
  - `length?`
  - `number`

  Sets how many digits the input number can be. Default: `6`

  ---

  - `autoSubmit?`
  - `boolean`

  If `true`, the form will be automatically submitted once the input is filled out. Default: `false`

  ---

  - `passwordManagerOffset?`
  - `number`

  Password managers place their icon inside an `<input />`. This default behaviour is not desirable when you use the render prop to display N distinct element. With this prop you can increase the width of the `<input />` so that the icon is rendered outside the OTP inputs. Default: `40`

  ---

  - `render?`
  - `({ value, status }: { value: string; status: 'none' | 'selected' | 'cursor' | 'hovered' }) => React.ReactNode`

  A render prop function that receives the `value` and `status` of each character. `value` is the character to render, `status` is the current status of the input character.
</Properties>

The properties `asChild` and `name` from [`<Input>`](#input) also apply to `<Input type="otp">`.

The following data attributes are also added to the underlying element:

- `data-otp-input`

#### Usage

A single `<input type="text" />` input that only allows 6 numbers to be entered. Once the user filled in all information, the form is automatically submitted.

```tsx
<Clerk.Field name="code">
  <Clerk.Input type="otp" autoSubmit />
</Clerk.Field>
```

#### Segmented

You can render each number into an individual item and animate its appearance depending on the `status`.

```tsx
<Clerk.Field name="code">
  <Clerk.Input
    type="otp"
    passwordManagerOffset={40}
    render={({ value, status }) => <span data-status={status}>{value}</span>}
  />
</Clerk.Field>
```

### `<Input type="password">`

A thin wrapper around the [`<input type="password" />` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/password) to provide password validation logic. You can define [password rules](/docs/security/password-protection) in the Clerk Dashboard. By default, this validation is turned off and you need to set a `validatePassword` prop.

Once activated, you can access the instant validation feedback through [`<FieldState>`](#field-state) and display rich information to your users.

#### Properties

<Properties>
  - `validatePassword?`
  - `boolean`

  If `true`, password validation according to your [password rules](/docs/security/password-protection) is happening while the user types in their password. Default: `false`
</Properties>

The following data attributes are also added to the underlying Element if `validatePassword` is `true`:

- `data-has-passed-validation` - If the password has passed the validation or not

The existing data attributes from [`<Input>`](#input) are also present on this Element.

#### Usage

For more information on how to use `state`, `codes`, and `message` check the [`<FieldState>`](#field-state) docs.

```tsx {{ mark: [3] }}
<Clerk.Field name="password">
  <Clerk.Label>Password</Clerk.Label>
  <Clerk.Input type="password" validatePassword />
  <Clerk.FieldState>
    {({ state, codes, message }) => (
      <div>
        <pre>Field state: {state}</pre>
        <pre>Field msg: {message}</pre>
        <pre>Codes: {codes?.join(', ')}</pre>
      </div>
    )}
  </Clerk.FieldState>
</Clerk.Field>
```

## `<Label>`

Renders a `<label>` element that is automatically associated with its sibling `<Input />` inside of a `<Field>`. Additional props will be passed through to the [`<label>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label).

### Properties {{ toc: false }}

<Properties>
  - `asChild?`
  - `boolean`

  If `true`, `<Label />` will render as its child element, passing along any necessary props. Default: `false`
</Properties>

### Usage {{ toc: false }}

```tsx
<Clerk.Field name="unique-name">
  <Clerk.Label>Label</Clerk.Label>
</Clerk.Field>
```

#### With `asChild`

```tsx
<Clerk.Field name="unique-name">
  <Clerk.Label asChild>
    <label className="my-custom-label">Label</label>
  </Clerk.Label>
</Clerk.Field>
```

## `<Loading>`

Enables you to access the loading state of a chosen scope. Scope can refer to a step, a `<Connection>`, or the global loading state. The global loading state is `true` when any of the other scopes are loading.

### Properties {{ toc: false }}

<Properties>
  - `children`
  - `(isLoading: boolean) => React.ReactNode`

  A function that receives `isLoading` as an argument. `isLoading` is a boolean that indicates if the current scope is loading or not.

  ---

  - `scope?`
  - `string`

  Specify which loading state to access. Can be a step, a connection, or the global loading state. If `<Loading>` is used outside a `<Step>`, the scope will default to `'global'`. If used inside a `<Step>` the scope will default to the current step. For external authentication providers, the scope needs to be manually defined in the format of `provider:<provider name>`. Default: `'global'`
</Properties>

Relying on the auto-inference of the scope can be helpful when using `<Loading>` in shared components, which might be referenced inside different steps. You won't need to manually pass the scope as a prop to your shared component.

### Usage {{ toc: false }}

```tsx {{ filename: 'page.tsx', mark: [[2, 4], [7, 9], 12] }}
<SignIn.Root>
  <Clerk.Loading>
    {(isGlobalLoading) => (isGlobalLoading ? 'Global Loading...' : 'Global')}
  </Clerk.Loading>
  <SignIn.Step name="start">
    <Clerk.Connection name="google">
      <Clerk.Loading scope="provider:google">
        {(isLoading) => (isLoading ? 'Loading...' : 'Continue with Google')}
      </Clerk.Loading>
    </Clerk.Connection>
    <SignIn.Action submit>
      <Clerk.Loading>{(isLoading) => (isLoading ? 'Loading...' : 'Submit')}</Clerk.Loading>
    </SignIn.Action>
  </SignIn.Step>
</SignIn.Root>
```

#### Nested loading states

To target the loading state of a specific `<Connection>`, you need to specify the scope as `provider:<provider name>`.

```tsx {{ filename: 'page.tsx' }}
<SignIn.Root>
  <Clerk.Loading>
    {(isGlobalLoading) => (
      <SignIn.Step name="start">
        <Clerk.Connection name="google" disabled={isGlobalLoading}>
          <Clerk.Loading scope="provider:google">
            {(isLoading) => (isLoading ? 'Loading...' : 'Continue with Google')}
          </Clerk.Loading>
        </Clerk.Connection>
        <SignIn.Action submit disabled={isGlobalLoading}>
          <Clerk.Loading>{(isLoading) => (isLoading ? 'Loading...' : 'Submit')}</Clerk.Loading>
        </SignIn.Action>
      </SignIn.Step>
    )}
  </Clerk.Loading>
</SignIn.Root>
```

## `<Link>`

Render a link tag that can be used to navigate between `<SignIn />` and `<SignUp />` flows.

<Properties>
  - `navigate`
  - `sign-in` | `sign-up`

  The destination flow to navigate to.

  ---

  - `children`
  - `React.ReactNode | ((props: {url: string}) => React.ReactNode)`
</Properties>

### Usage {{ toc: false }}

```tsx {{ filename: 'page.tsx' }}
<SignIn.Root>
  <SignIn.Step name="start">
    <Clerk.Link navigate="sign-up">Sign up</Clerk.Link>
  </SignIn.Step>
</SignIn.Root>
```

### With render function {{ toc: false }}

```tsx {{ filename: 'page.tsx' }}
<SignIn.Root>
  <SignIn.Step name="start">
    <Clerk.Link navigate="sign-up">{({ url }) => <Link href={url}>Sign up</Link>}</Clerk.Link>
  </SignIn.Step>
</SignIn.Root>
```

---
title: Community SDK References
description: Learn about the community SDK's available for integrating Clerk into your application.
---

<Include src="_partials/community-sdks" />

<Include src="_partials/help" />

---
title: Component Reference
description: A list of Clerk's comprehensive suite of components designed to seamlessly integrate authentication and multi-tenancy into your application.
---

Clerk offers a comprehensive suite of components designed to seamlessly integrate authentication and multi-tenancy into your application. With Clerk components, you can easily customize the appearance of authentication components and pages, manage the entire authentication flow to suit your specific needs, and even build robust SaaS applications.

## UI components

- [`<SignIn />`](/docs/components/authentication/sign-in)
- [`<SignUp />`](/docs/components/authentication/sign-up)
- [`<GoogleOneTap />`](/docs/components/authentication/google-one-tap)
- [`<UserButton />`](/docs/components/user/user-button)
- [`<UserProfile />`](/docs/components/user/user-profile)
- [`<CreateOrganization />`](/docs/components/organization/create-organization)
- [`<OrganizationProfile />`](/docs/components/organization/organization-profile)
- [`<OrganizationSwitcher />`](/docs/components/organization/organization-switcher)
- [`<OrganizationList />`](/docs/components/organization/organization-list)
- [`<Waitlist />`](/docs/components/waitlist)

## Control components

Control components manage authentication-related behaviors in your application. They handle tasks such as controlling content visibility based on user authentication status, managing loading states during authentication processes, and redirecting users to appropriate pages. Control components render at `<Loading />` and `<Loaded />` states for assertions on the [`Clerk` object](/docs/references/javascript/clerk). A common example is the [`<SignedIn>`](/docs/components/control/signed-in) component, which allows you to conditionally render content only when a user is authenticated.

- [`<AuthenticateWithRedirectCallback />`](/docs/components/control/authenticate-with-callback)
- [`<ClerkLoaded />`](/docs/components/control/clerk-loaded)
- [`<ClerkLoading />`](/docs/components/control/clerk-loading)
- [`<Protect />`](/docs/components/protect)
- [`<RedirectToSignIn />`](/docs/components/control/redirect-to-signin)
- [`<RedirectToSignUp />`](/docs/components/control/redirect-to-signup)
- [`<RedirectToUserProfile />`](/docs/components/control/redirect-to-userprofile)
- [`<RedirectToOrganizationProfile />`](/docs/components/control/redirect-to-organizationprofile)
- [`<RedirectToCreateOrganization />`](/docs/components/control/redirect-to-createorganization)
- [`<SignedIn />`](/docs/components/control/signed-in)
- [`<SignedOut />`](/docs/components/control/signed-out)

## Unstyled components

- [`<SignInButton />`](/docs/components/unstyled/sign-in-button)
- [`<SignInWithMetamask />`](/docs/components/unstyled/sign-in-with-metamask)
- [`<SignUpButton />`](/docs/components/unstyled/sign-up-button)
- [`<SignOutButton />`](/docs/components/unstyled/sign-out-button)

## Customization Guides

- [Customize components with the `appearance` prop](/docs/customization/overview)
- [Localize components with the `localization` prop (experimental)](/docs/customization/localization)
- [Add pages to the `<UserProfile />` component](/docs/customization/user-profile)
- [Add pages to the `<OrganizationProfile />` component](/docs/customization/organization-profile)

<Include src="_partials/help" />

---
title: Configure a consistent CRX ID for your Chrome Extension
description: Learn how to configure a consistent CRX ID in your Chrome Extension.
---

Chrome Extensions have a unique CRX ID that rotates by default, which can cause errors with the Clerk integration. This guide demonstrates how to configure a consistent CRX ID so that your extension will have a stable, unchanging key. This guide assumes you are using the Plasmo framework. If you need help applying these concepts to another framework, [contact support](https://clerk.com/contact/support).

There are two ways to configure a consistent CRX ID:

1. [For a new extension](#for-a-new-extension).
1. [For an extension uploaded to the Chrome Developer Dashboard](#for-an-extension-uploaded-to-the-chrome-developer-dashboard).

> [!WARNING]
> If you followed the [Chrome Extension Quickstart](/docs/quickstarts/chrome-extension), you have already completed this configuration.

## For a new extension

To configure a consistent CRX ID for a new extension, follow these steps:

<Steps>
  ### Generate your keypairs

  1. Visit Plasmo Itero's [Generate Keypairs](https://itero.plasmo.com/tools/generate-keypairs) tool.
  1. Select **Generate KeyPairs**.
  1. Save the **Private Key** somewhere secure in case you need it in the future. Save the **Public Key** and the **CRX ID** for the next steps.

  ### Create an `.env.chrome` file to store your public key

  Create an `.env.chrome` file and add your public key to it, as shown in the following example:

  ```env {{ filename: '.env.chrome' }}
  CRX_PUBLIC_KEY="<PUBLIC KEY>"
  ```

  ### Edit your `package.json` to use the new public key

  Plasmo uses the `package.json` to generate a `manifest.json` on build, and allows for the use of environment variables in `package.json`.

  In your `package.json`, in the `manifest` object:

  - Add `"key": "$CRX_PUBLIC_KEY"`.
  - Set the `permissions` array to include `"cookies"` and `"storage"`.
  - Set/update the `host_permissions` array to include `"http://localhost/*"` and `"$CLERK_FRONTEND_API/*"`.

  ```json {{ filename: 'package.json' }}
  {
    // The rest of your package.json file
    "manifest": {
      "key": "$CRX_PUBLIC_KEY",
      "permissions": ["cookies", "storage"],
      "host_permissions": ["http://localhost/*", "$CLERK_FRONTEND_API/*"]
    }
  }
  ```

  ### Verify the CRX ID

  1. Ensure that the development build is updated by running `pnpm dev`.
  1. Open Chrome or a Chromium-based browser and navigate to `chrome://extensions`.
  1. Remove and re-install the extension. To re-install, in the top-left, select **Load unpacked**. Navigate to where your project is located and select the `build/chrome-mv3-dev` folder. Then select **Select**. Your extension will now be loaded and shown in the list of extensions.
  1. Confirm that the ID shown in your extension matches the CRX ID you saved [earlier](#generate-your-keypairs).
</Steps>

## For an extension uploaded to the Chrome Developer Dashboard

If you have already uploaded a version of your extension to the Chrome Developer Dashboard, follow these steps to configure your extension.

<Steps>
  ### Copy the public key

  1. In the [Chrome Developer Dashboard](https://chrome.google.com/webstore/developer/dashboard), select your project.
  1. In the navigation sidenav, select **Package**.
  1. Select **View public key**. A modal will open with your public key.
  1. Copy the string between `-----BEGIN PUBLIC KEY-----` and `-----END PUBLIC KEY-----`.

  ### Create an `.env.chrome` file to store your public key

  Create an `.env.chrome` file and add your public key to it, as shown in the following example:

  ```env {{ filename: '.env.chrome' }}
  CRX_PUBLIC_KEY=<YOUR_PUBLIC_KEY>
  ```

  ### Edit your `package.json` to use the new public key

  Plasmo uses the `package.json` to generate a `manifest.json` on build, and allows for the use of environment variables in `package.json`.

  In your `package.json`, in the `manifest` object:

  - Add `"key": "$CRX_PUBLIC_KEY"`.
  - Set the `permissions` array to include `"cookies"` and `"storage"`.
  - Set/update the `host_permissions` array to include `"http://localhost/*"` and `"$CLERK_FRONTEND_API/*"`.

  ```json {{ filename: 'package.json' }}
  {
    // The rest of your package.json file
    "manifest": {
      "key": "$CRX_PUBLIC_KEY",
      "permissions": ["cookies", "storage"],
      "host_permissions": ["http://localhost/*", "$CLERK_FRONTEND_API/*"]
    }
  }
  ```

  ### Validate the Extension ID

  Verify that your extension has a consistent CRX ID by following these steps:

  1. At the top-left of the Chrome Developer Dashboard, your extension ID will be displayed below the name of your extension.
  1. In a separate tab, open Chrome or a Chromium-based browser and navigate to `chrome://extensions`.
  1. Locate your extension in the list of extensions. Confirm that the ID shown in your extension matches the ID displayed in the Chrome Developer Dashboard.
</Steps>

---
title: Configure Clerk Content-Security-Policy headers
description: Learn how to configure your Content Security Policy to work with the Clerk APIs.
---

[Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) (CSP) headers secure your document by preventing resources from being loaded from unexpected sources. This protects your apps from [XSS](/docs/security/xss-leak-protection) attacks and data injections.

For Clerk to work correctly in your application, you'll need to configure the following CSP directives:

1. `script-src` - This value should include the host application's FAPI hostname, such as `https://clerk.your-domain.com`, as well as cloudflare's bot protection host, `https://challenges.cloudflare.com`.
1. `connect-src` - This value should include the host application's FAPI hostname, such as `https://clerk.your-domain.com`.
1. `img-src` - This value should be `https://img.clerk.com`.
1. `worker-src` - Use the `'self'` value to indicate that workers can be loaded from first-party scripts. The `blob:` schema value also needs to be included.
1. `style-src` - This value should include `'unsafe-inline'` due to Clerk's usage of runtime CSS-in-JS for styling.
1. `frame-src` - This value should include cloudflare's bot protection host, `https://challenges.cloudflare.com`.

The following example demonstrates a Next.js config file that sets the necessary directives for your application's assets and Clerk to load and function correctly. The values used in the example are generated from your currently selected instance. Make sure to handle both your development instance and production instance hosts.

> [!WARNING]
> You will need to make sure any third-party domains where scripts or assets are loaded from are also specified.

```js {{ filename: 'next.config.js' }}
const cspHeader = `
  default-src 'self';
  script-src 'self' 'unsafe-inline' 'unsafe-eval' https://{{fapi_url}} https://challenges.cloudflare.com;
  connect-src 'self' https://{{fapi_url}};
  img-src 'self' https://img.clerk.com;
  worker-src 'self' blob:;
  style-src 'self' 'unsafe-inline';
  frame-src 'self' https://challenges.cloudflare.com;
  form-action 'self';
`

/** @type {import('next').NextConfig} */
const nextConfig = {
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'Content-Security-Policy',
            value: cspHeader.replace(/\n/g, ''),
          },
        ],
      },
    ]
  },
}

module.exports = nextConfig
```

## Usage of `unsafe-eval` and `unsafe-inline` directives in Next.js

- Within `script-src`, `unsafe-eval` is a [requirement for Next.js](https://nextjs.org/docs/app/building-your-application/configuring/content-security-policy#without-nonces) to run **in development mode**. **For production environment** CSPs, it should be removed.
- Within `script-src`, `unsafe-inline` is a requirement for Next.js in both dev and prod environments if you're using the App Router and not using `strict-dynamic`. If you are using the Pages Router, it can be removed.
- Within `style-src`, `unsafe-inline` is a requirement for Clerk's components to inject their styles. Removing this requirement is on our roadmap. If you'd like to see this implemented sooner, [contact support](/contact/support){{ target: '_blank' }}.

## Implementing a `strict-dynamic` CSP

If you'd like to implement a [strict-dynamic CSP](https://content-security-policy.com/strict-dynamic/), Clerk supports this, but with a different type of configuration. As strict-dynamic CSPs require a "nonce" value that should be programmatically generated per-request, the best way to make this work is within middleware that runs on every request. The following example demonstrates how to implement a strict-dynamic CSP with Next.js middleware, but the same approach could be used with any other framework.

```ts {{ filename: 'middleware.ts' }}
import { NextResponse } from 'next/server'
import { clerkMiddleware } from '@clerk/nextjs/server'

export default clerkMiddleware((auth, req) => {
  return applyCsp(req)
})

function applyCsp(req) {
  // create a randomly generated nonce value
  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')

  // format the CSP header
  const cspHeader = `
    default-src 'self';
    script-src 'self' 'strict-dynamic' 'nonce-${nonce}' https: http: ${
      process.env.NODE_ENV === 'production' ? '' : `'unsafe-eval'`
    };
    connect-src 'self' https://{{fapi_url}};
    img-src 'self' https://img.clerk.com;
    worker-src 'self' blob:;
    style-src 'self';
    frame-src 'self' https://challenges.cloudflare.com;
    form-action 'self';
  `
  // Replace newline characters and spaces
  const contentSecurityPolicyHeaderValue = cspHeader.replace(/\s{2,}/g, ' ').trim()

  // set the nonce and csp values in the request headers
  const requestHeaders = new Headers(req.headers)
  requestHeaders.set('x-nonce', nonce)
  requestHeaders.set('Content-Security-Policy', contentSecurityPolicyHeaderValue)

  const response = NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  })

  response.headers.set('Content-Security-Policy', contentSecurityPolicyHeaderValue)

  return response
}

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

With this `strict-dynamic` configuration in place, **all script tags must be passed with a `nonce` value** or they will be blocked. This can be done by passing the nonce value as a `nonce` parameter to the script tag. For example, `<script src="https://example.com/script.js" nonce="<nonce_value>"></script>`. If you are using Next.js, any scripts loaded through next will automatically have the nonce value injected.

> [!NOTE]
> You must pass the [`dynamic` prop](/docs/components/clerk-provider#properties) to `<ClerkProvider>` for `strict-dynamic` CSPs to work correctly. This is because the nonce value is generated on the server and passed to the client, which requires dynamic rendering.

With the above middleware, the nonce value is made accessible via the `x-nonce` request header. An example is provided below on how to access this value within a Next.js page.

```tsx {{ filename: 'pages/index.tsx' }}
import { headers } from 'next/headers'

export default function Page() {
  const nonce = headers().get('x-nonce')

  return <p>{nonce}</p>
}
```

If you're using one of Clerk's React-based SDKs, in order for Clerk to load correctly, the nonce value must also be passed to the `<ClerkProvider>` component. This can be done by passing the nonce value as a `nonce` prop to the `<ClerkProvider>` component. For example:

```tsx {{ filename: 'app/layout.tsx' }}
import { ClerkProvider } from '@clerk/nextjs'
import { headers } from 'next/headers'

export default function Layout({ children }) {
  return (
    // Note: since this is server-rendered, you don't _need_ to pass the nonce, see note below
    <ClerkProvider nonce={headers().get('x-nonce')} dynamic>
      <html lang="en">
        <body>{children}</body>
      </html>
    </ClerkProvider>
  )
}
```

If you are using Next.js and your layout file is rendered on the server (as is the case with the example above), Clerk's SDK will automatically read the `nonce` from the request and pass it into `<ClerkProvider>`. If you are rendering the provider on the client, you will need to explicitly pass the `nonce` value to the client and into `<ClerkProvider>`.

---
title: Configure passkeys for Expo
description: Learn how to configure passkeys for your Expo application.
---

[Passkeys](/docs/authentication/configuration/sign-up-sign-in-options#passkeys) are a secure, passwordless authentication method that use biometrics and a physical device to authenticate users. This guide shows you how to configure passkeys for your Expo application.

> [!WARNING]
> This API is available only for [`@clerk/clerk-expo >=2.2.0`](/docs/upgrade-guides/expo/v2).

<Steps>
  ## Enable passkeys

  To use passkeys, first enable the strategy in the Clerk Dashboard.

  1. In the Clerk Dashboard, navigate to the [**Email, Phone, Username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
  1. In the **Authentication strategies** section, enable **Passkeys**.

  ## Configure passkeys

  Use the following tabs to configure your passkeys for `iOS` or `Android`.

  <Tabs items={['iOS', 'Android']}>
    <Tab>
      > [!WARNING]
      > iOS supports passkeys from version iOS 16+
      >
      > This library includes native code and will not work when running Expo Go. Instead, use a development build by running `npx expo run:ios`.

      ## Get your App ID Prefix and Bundle ID from Apple

      To get your **App ID Prefix** and **Bundle ID**, follow these steps:

      1. Navigate to the [Apple Developer dashboard](https://developer.apple.com/account).
      1. Under **Certificates, IDs and Profiles**, select [**Identifiers**](https://developer.apple.com/account/resources/identifiers/list).
      1. In the top-right, select the dropdown and select **App IDs**.
      1. Select the **App ID** you want to configure passkeys for. You'll be redirect to the **Review your App ID Configuration** page.
      1. At the top of the page, you'll see your **App ID Prefix** and **Bundle ID**. Save these values somewhere secure.

      ## Set up your associated domain file in the Clerk Dashboard

      1. In the Clerk Dashboard, navigate to the [**Native Applications**](https://dashboard.clerk.com/last-active?path=user-authentication/native-applications) page.
      1. Select the **iOS** tab.
      1. Select **Add iOS App**.
      1. Paste the **App ID Prefix** and **Bundle ID** that you copied in the previous step.
      1. Select **Add App**.
      1. On the right-side, save your **Frontend API URL** somewhere secure.

      ## Update `app.json` in your Expo app

      1. In your app's `app.json` file, under the `ios` object, add the `associatedDomains` property as shown in the following example. Replace `<YOUR_FRONTEND_API_URL>` with the **Frontend API URL** value that you saved in the previous step.

      ```json {{ filename: 'app.json', mark: [[5, 12], [14, 20]] }}
      {
        "expo": {
          //...existing properties
          "plugins": [
            [
              "expo-build-properties",
              {
                "ios": {
                  "deploymentTarget": "16.0" //  iOS Support passkeys from version iOS 16+
                }
              }
            ]
          ],
          "ios": {
            //...existing properties
            "associatedDomains": [
              "applinks:<YOUR_FRONTEND_API_URL>",
              "webcredentials:<YOUR_FRONTEND_API_URL>"
            ]
          }
        }
      }
      ```
    </Tab>

    <Tab>
      > [!WARNING]
      > Android supports passkeys from version 9+. Passkeys will not work with Android emulators. You must use a physical device.
      >
      > This library includes native code and [will not work when running Expo Go](https://docs.expo.dev/workflow/customizing/#using-libraries-that-include-native-code). Instead, use a development build by running `npx expo run:android`.

      ## Set up your Android app links in the Clerk Dashboard

      1. In the Clerk Dashboard, navigate to the [**Native Applications**](https://dashboard.clerk.com/last-active?path=user-authentication/native-applications) page.
      1. Select the **Android** tab.
      1. Select **Add Android app**.
      1. Fill out the form with the following information:
         - The `namespace` (This guide uses the default value: `android_app`)
         - Your Android app's package name
         - The `SHA256 certificate fingerprints`. If you don't know where to find the `SHA256 certificate fingerprints`, see the [Expo docs](https://docs.expo.dev/linking/android-app-links/#create-assetlinksjson-file).
      1. After submitting the form, you can verify that your `assetlinks.json` file is properly associated with your app by using [Google's **Statement List Generator and Tester**](https://developers.google.com/digital-asset-links/tools/generator).
      1. On the right-side, save your **Frontend API URL** somewhere secure.

      ## Install `expo-build-properties` in your Expo application

      <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
        ```bash {{ filename: 'terminal' }}
        npm install expo-build-properties
        ```

        ```bash {{ filename: 'terminal' }}
        yarn add expo-build-properties
        ```

        ```bash {{ filename: 'terminal' }}
        pnpm add expo-build-properties
        ```

        ```bash {{ filename: 'terminal' }}
        bun add expo-build-properties
        ```
      </CodeBlockTabs>

      ## Update `app.json` in your Expo application

      1. In your app's `app.json` file, under `android`, add the `intentFilters` property as shown in the following example. Replace `<YOUR_FRONTEND_API_URL>` with the **Frontend API URL** value that you saved in the previous step.

      ```json {{ filename: 'app.json', mark: [[3, 6], [10, 22]] }}
      {
        "expo": {
          "plugins": [["expo-build-properties"]],
          "android": {
            //...existing properties
            "intentFilters": [
              {
                "action": "VIEW",
                "autoVerify": true,
                "data": [
                  {
                    "scheme": "https",
                    "host": "<YOUR_FRONTEND_API_URL>"
                  }
                ],
                "category": ["BROWSABLE", "DEFAULT"]
              }
            ]
          }
        }
      }
      ```
    </Tab>
  </Tabs>

  ## Install `@clerk/expo-passkeys`

  Run the following command to install the `@clerk/expo-passkeys` package:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/expo-passkeys
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/expo-passkeys
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/expo-passkeys
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @clerk/expo-passkeys
    ```
  </CodeBlockTabs>

  ## Prebuild Expo project

  Run the following command to prebuild your Expo project:

  ```bash {{ filename: 'terminal' }}
  npx expo prebuild
  ```

  ## Update your `<ClerkProvider>`

  Pass the `passkeys` object to the `__experimental_passkeys` property of your `<ClerkProvider>` component, as shown in the following example:

  ```tsx {{ filename: 'app/_layout.tsx', mark: [4, 11] }}
  import { ClerkProvider } from '@clerk/clerk-expo'
  import { Slot } from 'expo-router'
  import { tokenCache } from '@clerk/clerk-expo/token-cache'
  import { passkeys } from '@clerk/clerk-expo/passkeys'

  export default function RootLayout() {
    return (
      <ClerkProvider
        tokenCache={tokenCache}
        publishableKey={publishableKey}
        __experimental_passkeys={passkeys}
      >
        <Slot />
      </ClerkProvider>
    )
  }
  ```
</Steps>

## Usage

To learn how to use passkeys in your Expo application, such as creating, deleting, and authenticating users with passkeys, see the [custom flow guide](/docs/custom-flows/passkeys).

---
title: Conventions
description: A set of agreed standards for building Clerk SDKs.
---

Ideally, when a user switches from one Clerk SDK to another, the general concepts, feature set, names, and exports should be consistent. By following certain conventions, you can develop an SDK that achieves this ideal state, making it easier for users to quickly start a new project.

## SDK name

> [!NOTE]
> If there are strong conventions for your specific framework/language, default to those. Otherwise, follow the guidance below.

Add **Clerk** as a prefix or postfix into the name as itll make the SDK easier to discover. Here are some real world examples:

- `vue-clerk` (Vue)
- `clerk-rs` (Rust)
- `@hono/clerk-auth` (Hono)
- `Clerk.Net` (C#)

## Environment variables

Any environment variable used in the context of Clerk should be prefixed with `CLERK_`. [Learn more about Clerk environment variables](/docs/deployments/clerk-environment-variables).

> [!NOTE]
> Depending on your framework, youll need to add a prefix to environment variables that should be available on the frontend. For example, `PUBLIC_`, `VITE_` or `NEXT_PUBLIC`. These alterations are fine.

### Required

You should always support these environment variables:

- `CLERK_PUBLISHABLE_KEY` (Frontend-only, fullstack)
- `CLERK_SECRET_KEY` (Backend-only, fullstack)

Additionally, you need to make the environment variables for [API and SDK configuration](/docs/deployments/clerk-environment-variables#api-and-sdk-configuration) available to your users.

> [!WARNING]
> The `CLERK_SECRET_KEY` should never be exposed on the client-side (frontend). Always use a server-side environment variable.

### Optional

Clerk recommends implementing the [sign-in and sign-up redirect](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) environment variables.

## README

The README is most often the first thing a user sees of your SDK, so it's paramount to include all the crucial information.

Use the template below to setup your own README.

````md {{ filename: 'README.md', collapsible: true }}
# clerk-sdk-name

<!-- Give an overview. Explain what the SDK does and what one can use it for. Link out to clerk.com when mentioning Clerk -->

## Getting started

### Prerequisites

- If you haven't already, [sign up for an account](https://dashboard.clerk.com/sign-up) and create a new application. Go to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page to retrieve your Publishable Key and/or Secret Key.

<!-- Mention any other necessary steps a user has to perform before continuing. Mention any hard requirements e.g. like minimum supported Node.js version. -->

### Installation

```shell
# Install command for SDK
```

## Usage

<!-- Explain how to use the Publishable Key and/or Secret Key, e.g. by placing them into an .env file -->

<!-- Explain how to use your SDK! -->

## License

<!-- State which license your library falls under, Clerk recommends MIT -->
````

## Publishing to npm

While this reference can't cover the whole surface area of publishing a package to npm, there are a couple of conventions Clerk uses for their own SDKs to deliver a great developer experience.

> [!TIP]
> Clerk recommends reading [The Modern Guide to Packaging your JavaScript library](https://github.com/frehner/modern-guide-to-packaging-js-library) to get more familiar with common terms and problems.
> It's also recommended to use [publint](https://publint.dev/) and [arethetypeswrong](https://arethetypeswrong.github.io/) to validate your package before publishing. You can use both tools as a CLI, too.

### Provide TypeScript types for your SDK

This is the biggest benefit you can provide to your users, as they'll get IntelliSense autocompletion in their IDE.

You can achieve this by authoring your SDK in TypeScript or providing a hand-written file. Enable the [`declaration`](https://www.typescriptlang.org/tsconfig/#declaration) setting in your `tsconfig.json`.

When only defining a [main entry point](https://nodejs.org/api/packages.html#main-entry-point-export), use the `types` key. Otherwise, for [conditional exports](https://nodejs.org/api/packages.html#conditional-exports), use the `types` key inside the [`exports`](https://nodejs.org/api/packages.html#exports) field.

### Use subpath exports

Use [subpath exports](https://nodejs.org/api/packages.html#subpath-exports) to provide API boundaries, enable more efficient code-splitting, and split code between client & server.

Here's how the [`@clerk/astro`](/docs/references/astro/overview) package is using subpath exports:

- `@clerk/astro/react` - Import Clerk's prebuilt React components
- `@clerk/astro/client` - Access to useful stores like `$authStore`
- `@clerk/astro/server` - Import Clerk's middleware

This setup ensures that functions that only work on the server are not bundled into client-side code. It also makes it easier for the bundler to tree-shake any unused code.

### CommonJS/ES Module

Authoring [dual packages](https://nodejs.org/api/packages.html#dual-commonjses-module-packages) is challenging, but not impossible. Before deciding to publish in both CommonJS (CJS) and ES Module (ESM) formats, consider whether you can publish solely in the ESM format. Most modern frameworks support ESM-only packages.

Build tools that can help you build dual and ESM-only packages:

- [tsup](https://tsup.egoist.dev/) (recommended)
- [unbuild](https://github.com/unjs/unbuild)
- [rollup](https://github.com/rollup/rollup)
- [bunchee](https://github.com/huozhi/bunchee)

### Define `peerDependencies` and `engines`

Your SDK will require your users to have Node.js installed and use the framework the SDK is built for. To ensure compatibility, define [`peerDependencies`](https://docs.npmjs.com/cli/v10/configuring-npm/package-json#peerdependencies) and [`engines`](https://docs.npmjs.com/cli/v10/configuring-npm/package-json#engines) in your `package.json`.

### Generate provenance statements

Security is important at Clerk and thus all Clerk SDKs are published with provenance statements. This allows you to publicly establish where a package was built and who published a package, which can increase supply-chain security for your packages.

Read npm's guide on [generating provenance statements](https://docs.npmjs.com/generating-provenance-statements).

---
title: Cookie errors
description: An index of Clerk errors related to cookies.
type: reference
---

An index of Clerk errors related to cookies.

## `MissingClaims`

Signifies an error when token is missing claim.

```json
{
  "shortMessage": "<invalidCookieMessage>",
  "longMessage": "The token is missing the following claims: <claims>",
  "code": "cookie_invalid_code"
}
```

## `InvalidCookie`

Signifies an error when cookie is invalid.

```json
{
  "shortMessage": "The provided cookie is invalid.",
  "code": "cookie_invalid_code"
}
```

## `InvalidRotatingToken`

Signifies an error when rotating token does not match the client's rotating token.

```json
{
  "shortMessage": "<invalidCookieMessage>",
  "longMessage": "The client's rotating key does not match the given one <token>",
  "code": "cookie_invalid_code"
}
```

---
title: Cookies
description: Learn how cookies enable secure authentication and manage browser-server interactions.
---

Cookies play a vital role in authentication, state management, and browser-server communication. By understanding their attributes, developers can ensure secure and efficient use in their applications.

## What are cookies?

Cookies are small pieces of information stored in the browser and sent automatically alongside some requests coming from that browser.

By default, HTTP requests are "stateless" and lack memory of previous interactions. Cookies change this behavior, as they are stored long term and can be sent alongside each request.

### Setting cookies

Cookies are typically created by the server and communicated to the browser through the [`Set-Cookie` HTTP header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie). When the browser receives this header, it stores the cookie and includes it in future requests to the **same domain**. Here's an example:

```http
HTTP/2 200
Content-Type: text/html
Set-Cookie: session_id=sess123

<html>
  <body>
    <p>Hello, world!</p>
  </body>
</html>
```

This response sets a `session_id` cookie with the value `sess123`. To view cookies in your browser's developer tools, navigate to the **Application** tab. Then in the **Storage** section, select **Cookies**. Here's an example from Clerk's website:

![cookies in browser console](/docs/images/how-clerk-works/devtools-cookies.png)

## Cookie domains and scope

Each cookie has a [`Domain`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#define_where_cookies_are_sent) that indicates **the domain from which the cookie was set**. This determines when the cookie will be included in requests.

For example:

- If a cookie is set by `example.com` without a `Domain` value, it will be sent only with requests _to_ `example.com`.
- If the cookie's `Domain` value is _explicitly_ set to `example.com`, it will also be sent with requests to subdomains like `sub.example.com`.
- However, cookies set by subdomains (e.g., `sub.example.com`) won't be sent with requests to the parent domain (`example.com`).

## Tracking cookies and privacy concerns

Historically, cookies were often used for tracking user behavior across websites.

For example, say you [hotlink](https://developer.mozilla.org/en-US/docs/Glossary/Hotlink) an image from `facebook.com` on to your website, `example.com`, as such:

```
<!doctype html>
<html>
  <body>
    <p>Check out this cool picture of me on vacation that I posted on FB</p>
    <img src='http://facebook.com/images/h0e208whe8r0.jpg alt='Me on vacation' />
  <body>
</html>
```

To display the image, `example.com` requests the image from `facebook.com`. Let's say Facebook's web server:

1. Retrieves the image
1. Creates an entry for you as a user in their database with a unique ID
1. Records that you visited `example.com`
1. Sets a cookie with your unique ID and [the `SameSite` value set to "none"](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#samesitesamesite-value)

The response from Facebook would look something like:

```
HTTP/2 200
Set-Cookie: fb_tracker=user123; SameSite=none

...the content of the image
```

Now let's say you visit another website, `foobar.com`, and that website is using a script from Facebook for tracking the effectiveness of Facebook ads. So now `foobar.com` makes a request to `facebook.com`, and Facebook gets back the cookie that it set from the image on `example.com`. But how could this happen? Let's revisit this statement one more time:

> Cookies are typically created by the server and communicated to the browser through the [`Set-Cookie` HTTP header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie). When the browser receives this header, it stores the cookie and includes it in future requests to the **same domain**.

Despite being set on `example.com`, the cookie's domain value is `facebook.com`, since it was set _by_ Facebook. And remember that the cookie was set with the `SameSite` value set to none, which, according to [the docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#samesitesamesite-value), means that the browser sends the cookie **with both cross-site and same-site requests.**

So in this scenario, even if the cookie was set on a different website, the browser still sends the cookie back to Facebook, because the cookie has `facebook.com` set as its domain. Facebook then gets the cookie, is able to identify you as a user, and can identify that you also visited `foobar.com`. Any other site that you visit that loads anything from Facebook is an opportunity for Facebook to get back the cookie and use it to build a profile of your browsing habits and history.

Clerk doesn't do any of this type of tracking. However, this example is still helpful for building a foundation around the edges of how cookies are stored and transmitted.

## Controlling cross-site cookie behavior with `SameSite`

The `SameSite` attribute of cookies plays a crucial role in controlling cross-site cookie behavior. Clerk uses the `SameSite=Lax` setting to ensure a secure and user-friendly experience. This setting allows cookies to be sent with top-level navigation (e.g., clicking a link) but not with other cross-site requests (e.g., loading images).

See MDN's guide on [`SameSite`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#samesitesamesite-value) for more details.

## Sharing cookies across subdomains

Sharing cookies across subdomains is controlled by the `Domain` attribute.

- A cookie **explicitly** set with `Domain=example.com` will be sent with requests to both `example.com` and `sub.example.com`.
- A cookie set without a domain value will only be sent to the domain that created it (e.g., `example.com`) and not its subdomains.

Cookies **explicitly** set with a domain appear in devtools with a leading period (e.g., `.example.com`). Cookies set without a domain value appear without the leading period (e.g., `example.com`).

## Controlling JavaScript access with `HttpOnly`

By default, cookies can be accessed via `document.cookie` in JavaScript. While this can be useful, it exposes cookies to risks like [Cross-Site Scripting (XSS) attacks](https://owasp.org/www-community/attacks/xss/). Setting the [`HttpOnly`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#httponly) flag prevents JavaScript from accessing the cookie, enhancing security. These cookies are still sent with HTTP requests but are inaccessible to client-side scripts.

## How Clerk uses cookies

Clerk leverages cookies in a secure, privacy-compliant manner to facilitate seamless user authentication across domains and subdomains. See the [guide on Clerk cookies](/docs/how-clerk-works/cookies) for more details.

---
title: Create a minimal reproduction
description: Learn how to create a minimal reproduction in order to help the Clerk Support team debug and resolve issues specific to your application.
---

Software development is hard, and there are an infinite number of different ways that you can configure and code a given application. Additionally, with large and complex applications, the cause of an error can be traced back to a wide variety of different things, making issues even more difficult to debug. The creation of minimal reproductions is an essential tool in any seasoned developers belt for resolving difficult issues, as this process gradually eliminates causes of an issue, narrowing it down to only the root cause.

## What is a minimal reproduction?

A minimal reproduction is a small test case to demonstrate a problem - often this problem is caused by a bug in the library or user code. Your minimal reproduction should contain the bare minimum code needed to clearly demonstrate that bug.

## Templates

The best way to create a minimal reproduction is to start fresh, with a minimal functional template. Clerk provides minimal functional templates for each of the frameworks we have SDKs for, which are great starting points:

- [Next.js App Router](https://github.com/clerk/clerk-nextjs-app-quickstart)
- [Next.js Pages Router](https://github.com/clerk/clerk-nextjs-pages-quickstart)
- [React](https://github.com/clerk/clerk-react-starter)
- [Vanilla JS](https://github.com/clerk/clerk-js-starter)
- [Expo](https://github.com/clerk/clerk-expo-quickstart)
- [Remix](https://github.com/clerk/clerk-remix-v2)
- [React Router](https://github.com/clerk/clerk-react-router-quickstart)
- [Redwood](https://github.com/clerk/clerk-redwood-starter)
- [Rails](https://github.com/clerk/clerk-rails-starter)
- [Chrome Extension](https://github.com/clerk/clerk-chrome-extension-quickstart)
- [Tanstack React Start](https://github.com/clerk/clerk-tanstack-react-start-quickstart)

## Steps to create a minimal reproduction

<Steps>
  ### Clone a template

  Clone down one of the [templates listed above](#templates) in order to have the application locally on your machine.

  In the example below, you can see options for cloning the [Clerk Next.js App Router](https://github.com/clerk/clerk-nextjs-app-quickstart) repository.

  ![The 'clerk-nextjs-app-quickstart' repository page with the 'Code' button clicked on and its drop down menu is opened. There is a red arrow pointing to the 'Code' button](/docs/images/troubleshooting/how-to-clone.webp)

  ### Create a Clerk application

  Create a new Clerk application through the Clerk Dashboard. You can follow the [setup guide](/docs/quickstarts/setup-clerk) to help you get started.

  ### Set the environment variables

  Set the environment variables in your Clerk application. You can find instructions on how to do so in the appropriate [quickstart guide](/docs/quickstarts/overview).

  ### Run the app

  Run the application locally and verify that its functional. For example, if you used `npm` to install the dependencies, you can run the app's development instance with the command `npm run dev`. The app should then be running on `http://localhost:3000` with no errors.

  ### Add code to reproduce the issue

  Adjust your template project by adding code gradually until you get to the point where you are running into the same error.

  ### Add a README file (optional)

  Add a README file to the root of the repository that contains the steps that must be taken in the app in order to produce the error (select the X button, sign in using Y provider, etc).

  > [!WARNING]
  > This step is only required if you are submitting the minimal reproduction to the Clerk support team.
</Steps>

Its important throughout this process to be vigilant about removing code that is not necessary to produce the issue. The ideal result is that the repository gets to the state where the exact same issue is able to be produced, with the fewest lines of code possible to get to that point (beyond the baseline included in the templates).

Often times, the process of creating the minimal reproduction will clarify or resolve the original issue. This is great, if it does happen! That is the magic of minimal reproductions.

## Submitting a minimal reproduction

The Clerk support team **requires** minimal reproductions in order to start looking into reported bugs or issues for any users or customers that are not on an enterprise plan.

### Submission requirements

Before submitting a minimal reproduction to the Clerk support team, ensure that the repository:

- Is based off one of the templates above and contains a minimal reproduction _or_ has been stripped down to the bare minimum code needed to reproduce the issue
- Contains a README file with the steps that must be taken in the app in order to produce the error

### Submission do's

You can submit either of these options to the Clerk support team:

- A link to a github/bitbucket/gitlab/etc repository.
- A zip file containing a repository.

### Submission don'ts

What is not acceptable to submit to the Clerk support team:

- A list of steps that we can take to produce the error
- A pasted error message or error trace
- A link/zip of a full featured app or branch within an app were an error is occurring
- A link to a line in your, or our codebase where an error is presumed to be
- A document containing code blocks that, if combined, describe an app that produces a minimal reproduction
- A link to a repository with a minimal reproduction but no information on how to produce the issue
- A link to a repository with a minimal reproduction that contains a bunch of other third party libraries that are required to produce the issue

---
title: Create organizations on behalf of users
description: Learn how to architect your application to create organizations on users' behalf without running into rate limits and billing issues.
---

In some cases, you may want the onboarding process for your app to include creating an organization on the user's behalf. This could be beneficial for several reasons, such as:

- You'd like your users to be manually onboarded by sales staff who will send invites to join via an organization created for them.
- Your app only makes sense if the user is part of an organization, so you want to create the organization on their behalf as part of onboarding.
- You'd like to have an "admin account" that has access to all organizations across your app and can achieve this by creating an organization for the user with an admin account, rather than allowing the user to create their own organization.

If this aligns with your use case, this guide will walk you through architecting your app to avoid unexpected rate limits or billing issues, which can be a common problem when creating organizations on behalf of users.

## Recommended: require users to create orgs during onboarding

The recommended approach is to implement an [onboarding flow](/docs/references/nextjs/add-onboarding-flow) in which it's required to create an organization before the user is able to access the app. You can use tools like the [`<CreateOrganization>` component](/docs/components/organization/create-organization) to allow the user to create and name their own organization, or you can use the [Backend API](/docs/reference/backend-api/tag/Organizations#operation/CreateOrganization){{ target: '_blank' }} or a backend SDK, such as the [JS Backend SDK](/docs/references/backend/organization/create-organization), to create an organization on the user's behalf.

If you'd like to have the onboarding flow include inviting users via email, use the [invitation feature](/docs/users/invitations). The flow would look like this:

- User receives an invitation via email to join your app.
- User visits the invitation link, registers an account, and enters the onboarding flow.
- User creates an organization as part of the onboarding flow, and can invite other users if needed.
- The user can now access your app and is part of an org.

If you'd like to enable users to join an existing org that matches their email domain (if one exists) as an alternative to creating a new organization, use the [verified domains](/docs/organizations/verified-domains) feature.

## Not recommended: use an admin account to create organizations for users

Although it may seem like a reasonable option, it's strongly recommended not to use a single admin account to create organizations on the behalf of users. Generally, this is because it can create **unexpectedly high costs** due to [the way that organizations are billed](/docs/organizations/overview#monthly-active-organization-mao).

Let's walk through an example to see why.

Imagine you have an admin account configured to create organizations on a user's behalf during onboarding and then sends an invitation to the user to join the organization. When the user accepts the invitation, the organization will have their account plus the admin account in it. At that point, the organization has two monthly active users (MAUs), which makes it a **billable** organization. All [Clerk plans](https://clerk.com/pricing) come with 100 active organizations included for free, but over that limit, organizations are billed at $1 per month. In this case, for every user that is created in your app, they have an active organization automatically, because of the fact that the admin account is also in the organization. This tends to result in much higher costs than if users' organizations are created without an admin account included, since orgs with only one active user are not billable. Additionally, it's generally a nicer experience for users not to have extra admin accounts in their organizations.

If you have an architecture scenario that isn't covered here or feel that it's critical to create organizations using an admin account, contact [support@clerk.com](mailto:support@clerk.com) for help.

## Grant a user access to all orgs

The simplest way to grant someone on your team access to all orgs in your app is to add them as a member to your [organization workspace](/docs/organizations/organization-workspaces) in the Clerk Dashboard. Members of your organization workspace, also known as collaborators, can view all of the orgs for each of your apps and perform administrative actions, such as adding or removing members, renaming an org, or deleting an org.

If this isn't an option, you can use the [Backend API](/docs/reference/backend-api){{ target: '_blank' }} or a backend SDK, such as the [JS Backend SDK](/docs/references/backend/overview), along with [roles and permissions](/docs/organizations/roles-permissions) to create a custom admin dashboard where authorized users can take administrative actions for orgs.

---
title: Create roles and permissions
description: Use the Clerk Dashboard to create and assign roles and permissions to users in your organization.
---

In the Clerk Dashboard, you can create roles, assign permissions to them, and change users' roles.

## Create a new role for your organization

1. In the Clerk Dashboard, navigate to [**Roles**](https://dashboard.clerk.com/last-active?path=organizations-settings/roles)
1. Select **Create new role**.
1. Give the role a name, a key to reference it by in the format `org:<role>`, and a description.
1. Select **Create role**.

## Create a new permission for your organization

1. In the Clerk Dashboard, navigate to [**Permissions**](https://dashboard.clerk.com/last-active?path=organizations-settings/permissions).
1. Select **Create new permission**.
1. Give the permission a name, a key to reference it by in the format `org:<feature>:<action>`, and a description.
1. Select **Create permission**.

## Change a user's role in an organization

1. In the top in the Clerk Dashboard, select [**Organizations**](https://dashboard.clerk.com/last-active?path=organizations) and select an organization.
1. Select the **Members** tab.
1. In the list of members, find the one whose role you want to change.
1. Select another role from their role dropdown.

## Delete a role in your organization

You cannot delete a role that is still assigned to members of an organization. Change the members to a different role before completing the following steps.

1. In the Clerk Dashboard, navigate to [**Roles**](https://dashboard.clerk.com/last-active?path=organizations-settings/roles).
1. Select the "..." menu next to the role.
1. Select **Delete role**.

---
title: Create users
description: Learn how to create users in your Clerk application.
---

There are two ways to create users in Clerk: [in the Clerk Dashboard](#in-the-clerk-dashboard) or [using the Backend API](#using-the-backend-api).

## In the Clerk Dashboard

To create users in the Clerk Dashboard:

1. In the top in the Clerk Dashboard, select [**Users**](https://dashboard.clerk.com/last-active?path=users).
1. Select **Create user**.
1. Enter the required user details and select **Create**.

## Using the Backend API

You can create users in your app using Clerk's Backend API.

Use the following tabs to see examples of how to create users using one of the following:

- Frontend SDKs, such as Next.js, React, or Remix
- Express
- cURL

<Tabs items={["Fullstack SDKs", "Express", "cURL"]}>
  <Tab>
    The following example shows how to create a user using the JavaScript Backend SDK's [`createUser()`](/docs/references/backend/user/create-user) method from the `users` sub-api of the `clerkClient` instance.

    ```ts {{ filename: 'route.ts' }}
    export async function POST() {
      try {
        const user = await clerkClient.users.createUser({
          emailAddress: ['test@example.com'],
          password: 'password',
        })
        return Response.json({ message: 'User created', user })
      } catch (error) {
        console.log(error)
        return Response.json({ error: 'Error creating user' })
      }
    }
    ```

    <If sdk="nextjs">
      If you're using Next.js, you must `await` the instantiation of the `clerkClient` instance, like so:

      ```ts
      const client = await clerkClient()

      const response = await client.users.createUser()
      ```
    </If>
  </Tab>

  <Tab>
    ```ts {{ filename: 'create-user.ts' }}
    import { clerkClient } from '@clerk/express'

    app.post('/createUser', async (req, res) => {
      const userData = req.body

      try {
        const user = await clerkClient.users.createUser(userData)
        res.status(200).json({ message: 'User created', user })
      } catch (error) {
        console.log(error)
        res.status(500).json({ error: 'Error creating user' })
      }
    })
    ```
  </Tab>

  <Tab>
    ```bash {{ filename: 'terminal' }}
    curl 'https://api.clerk.com/v1/users' -X POST -H 'Authorization:Bearer {{secret}}' -H 'Content-Type:application/json' -d '{
      "email_address": ["test@example.com"],
      "password": "my-secure-password"
    }'
    ```
  </Tab>
</Tabs>

---
title: CSRF protection
description: CSRF is an attack that tricks the victim into submitting a malicious request. It inherits the identity and privileges of the victim to perform an undesired function on the victims behalf.
---

Cross Site Request Forgery (CSRF) is an attack that deceives a victim into submitting a malicious request. The attack inherits the victim's identity and privileges to perform an undesired action on the their behalf. For most sites, browser requests automatically include credentials associated with the site, such as the user's session cookie, IP address, Windows domain credentials, and more. Therefore, if the user is currently authenticated, the site cannot distinguish between a forged request initiated by the attacker and a legitimate request from the user.

[The OWASP Foundation, Cross Site Request Forgery (CSRF)](https://owasp.org/www-community/attacks/csrf)

Most CSRF attacks can be protected against by properly configuring the way session tokens are stored. Clerk handles the necessary configuration on your behalf by configuring cookies with the `SameSite` flag.

## What does a CSRF attack look like?

Imagine an attacker made a malicious website at `foo.com` that contained the following code:

```html
<img src="https://www.example.com/?action=delete&id=123" />
```

Notice the query string `?action=delete&id=123`.

If a user logged into `example.com` loads this page, and `example.com` is configured to execute actions from the query string for authorized users, an attacker could potentially delete the user's account on `example.com` without their knowledge. The user would simply see a webpage with a broken image, which could be easily hidden using CSS.

## How does `SameSite` help prevent CSRF attacks?

Fortunately, [the `SameSite` flag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#samesitesamesite-value), which can be added to the `Set-Cookie` header, can prevent CSRF attacks. In the previous example, if the developers of `example.com` set the `SameSite` flag on their session cookies to `Strict` or `Lax`, the browser would not send the cookie with requests to `foo.com`. Therefore, the attack would fail as the user would not be authenticated and the backend would presumably block the delete action.

Let's break down what each of the values of `SameSite` do:

- `Strict`: The cookie will only be sent with HTTP requests initiated from the same site. While this may seem like the most secure option, it results in users being signed out if they navigate to the site from an external link. Since the cookie is omitted in cross-site requests, this leads to a poor user experience and is generally not recommended when using cookies for authentication.
- `Lax`: The cookie will be sent with HTTP requests initiated from the same site, and with direct navigations from a cross-site origin, but not with requests to load resources such as images or frames. This setting still protects against CSRF attacks without the poor user experience issues of `Strict`, where users are signed out when navigating from external links. `Lax` is the default setting in modern browsers and is recommended for most use cases.
- `None`: The browser will send cookies for both same-site and cross-site requests. While this setting allows for more flexibility in certain scenarios, it also increases the risk of CSRF attacks and therefore is not recommended.

Clerk sets the `SameSite` flag for all of its session cookies to `Lax`, which is the default in modern browsers.

## Do I need to take additional steps to prevent CSRF attacks?

You do not, but it is still possible to accidentally make your application vulnerable to XSS attacks.

Because Clerk uses the `Lax` setting, it is critical to remember that navigation alone should never trigger a mutation in your backend. Otherwise, the user can be tricked into clicking a link that takes an action they did not intend.

---
title: Custom commands
description: Use custom commands to sign in and out with Clerk in your Cypress tests.
---

The `@clerk/testing` package provides [Cypress custom commands](https://docs.cypress.io/api/cypress-api/custom-commands) to sign in and out with Clerk in your Cypress tests without having to interact with the UI.
To use these commands, you must import them in your [Cypress E2E support file](https://docs.cypress.io/guides/core-concepts/writing-and-organizing-tests#Support-file), as shown in the following example.

```ts {{ filename: 'cypress/support/e2e.ts' }}
/// <reference types="cypress" />
import { addClerkCommands } from '@clerk/testing/cypress'
addClerkCommands({ Cypress, cy })

export {}
```

### `cy.clerkSignIn`

The `cy.clerkSignIn` command is used to sign in a user using Clerk. This custom command supports only the following first factor strategies:

- Password
- Phone code
- Email code

Multi-factor authentication is not supported.

> [!NOTE]
> This helper internally uses the `setupClerkTestingToken()` helper, so you don't need to call it separately.

#### Prerequisites

- Before calling this command, you must call `cy.visit`.
- Before using this command, navigate to a non-protected page that loads Clerk.

#### Parameters

`cy.clerkSignIn` accepts an object with the following properties:

<Properties>
  - `strategy`
  - `'password' | 'phone_code' | 'email_code'`

  The sign-in strategy. Supported strategies are:

  - `password`: The command will sign in the user using the provided password and identifier.
  - `phone_code`: You must have a user with a test phone number as an identifier (e.g., `+15555550100`).
  - `email_code`: You must have a user with a test email as an identifier (e.g., `your_email+clerk_test@example.com`).

  ---

  - `identifier`
  - `string`

  The user's identifier. This could be a username, a phone number, or an email.

  ---

  - `password`
  - `string`

  The user's password. This is required only if the `strategy` is set to `'password'`.
</Properties>

#### Example

The following example demonstrates how to use the `cy.clerkSignIn()` command in a test to sign in a user.

```ts {{ filename: 'cypress/e2e/my-test.cy.ts' }}
it('sign in', () => {
  cy.visit(`/`)
  cy.clerkSignIn({ strategy: 'phone_code', identifier: '+15555550100' })
  cy.visit('/protected')
  // user is signed in from here on
})
```

### `cy.clerkSignOut`

The `cy.clerkSignOut` command is used to sign out the current user using Clerk.

#### Prerequisites

- Before calling this command, yu must call `cy.visit`.
- Before using this command, navigate to a page that loads Clerk.

#### Parameters

`cy.clerkSignOut` accepts an optional parameter `signOutOptions`, which includes the following properties:

<Properties>
  - `sessionId?`
  - `string`

  The ID of a specific session to sign out of. Useful for multi-session applications.

  ---

  - `redirectUrl?`
  - `string`

  The full URL or path to navigate to after sign-out is complete.
</Properties>

#### Example

The following example demonstrates how to use the `cy.clerkSignOut()` command in a test to sign a user out.

```ts {{ filename: 'cypress/e2e/my-test.cy.ts' }}
it('sign out', () => {
  cy.visit(`/`)
  cy.clerkSignIn({ strategy: 'phone_code', identifier: '+15555550100' })
  cy.visit('/protected')
  cy.clerkSignOut()
  // user is signed out from here on
})
```

### `cy.clerkLoaded`

The `cy.clerkLoaded` command asserts that Clerk has been loaded.

#### Prerequisites

- Before calling this command, you must call `cy.visit`.
- Before using this command, navigate to a page that loads Clerk.

#### Example

The following example demonstrates how to use the `cy.clerkLoaded()` command in a test to assert that Clerk has been loaded.

```ts {{ filename: 'cypress/e2e/my-test.cy.ts' }}
it('check Clerk loaded', () => {
  cy.visit(`/`)
  cy.clerkLoaded()
  // Clerk has been loaded from here on
})
```

---
title: Custom flows
description: Learn the process behind building custom sign-up and sign-in flows with Clerk.
---

A _custom flow_ refers to a user flow created entirely from scratch using the Clerk API. If [prebuilt components](/docs/components/overview) don't meet your specific needs or if you require more control over the logic, you can rebuild the existing Clerk flows using the Clerk API.

> [!TIP]
> The information in this guide will help you get a general understanding of custom flow concepts. To skip to code examples, choose the guide that best fits your needs from the navigation on the left.

## How authentication flows work in Clerk

Before building custom authentication flows, read the following sections to get a general understanding of how authentication flows work in Clerk.

### Sign-up flow

The [`SignUp`](/docs/references/javascript/sign-up) object is the pivotal concept in the sign-up process. It is used to gather the user's information, verify their email address or phone number, add OAuth accounts, and finally, convert them into a [`User`](/docs/references/javascript/user).

Every `SignUp` must meet specific requirements before being converted into a `User`. These requirements are defined by the instance settings you selected in the [Clerk Dashboard](https://dashboard.clerk.com/). For example, on the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page, you can configure passwords, email links, or both as [authentication strategies](/docs/authentication/configuration/sign-up-sign-in-options#authentication-strategies).

Once all requirements are met, the `SignUp` will turn into a new `User`, and an active session for that `User` will be created on the current [`Client`](/docs/references/javascript/client).

Don't worry about collecting all the required fields at once and passing them to a single request. The API is designed to accommodate progressive multi-step sign-up forms.

The following steps outline the sign-up process:

1. Initiate the sign-up process by collecting the user's authentication information and passing the appropriate parameters to the [`create()`](/docs/references/javascript/sign-in#create) method.
1. Prepare the verification.
1. Attempt to complete the verification.
1. If the verification is successful, set the newly created session as the active session by passing the `SignIn.createdSessionId` to the [`setActive()`](/docs/references/javascript/clerk#set-active) method on the `Clerk` object.

#### The state of a `SignUp`

The `SignUp` object will show **the state of the current sign-up** in the `status` property.

If you need further help on where things are and what you need to do next, you can also consult the `required_fields`, `optional_fields`, and `missingFields` properties.

<Properties>
  - `requiredFields`

  All fields that must be collected before the `SignUp` converts into a `User`.

  ---

  - `optionalFields`

  All fields that can be collected, but are not necessary to convert the `SignUp` into a `User`.

  ---

  - `missingFields`

  A subset of `requiredFields`. It contains all fields that still need to be collected before a `SignUp` can be converted into a `User`. Note that this property will be updated dynamically. As you add more fields to the `SignUp`, they will be removed. Once this property is empty, your `SignUp` will automatically convert into a `User`.
</Properties>

#### Verified fields

Some properties of the `SignUp`, such as `emailAddress` and `phoneNumber`, must be **verified** before they are **fully** added to the `SignUp` object.

The `SignUp` object will show **the state of verification** in the following properties:

<Properties>
  - `unverifiedFields`

  A list of all [`User`](/docs/references/javascript/user) attributes that need to be verified and are pending verification. This is a list that gets updated dynamically. When verification for all required fields has been successfully completed, this value will become an empty array.

  ---

  - `verifications`

  An object that describes the current state of verification for the [`SignUp`](/docs/references/javascript/sign-in). There are currently three different keys: `email_address`, `phone_number`, and `external_account`.
</Properties>

### Sign-in flow

The [`SignIn`](/docs/references/javascript/sign-in) object is the pivotal concept in the sign-in process.

Sign-ins are initiated by creating a `SignIn` object on the current `Client`. If the sign-in is successfully authenticated, it will transform into an active session for that [`User`](/docs/references/javascript/user) on the current `Client`.

The following steps outline the sign-in process:

1. Initiate the sign-in process by collecting the user's authentication information and passing the appropriate parameters to the [`create()`](/docs/references/javascript/sign-in#create) method.
1. Prepare the first factor verification. Users must complete a first factor verification to prove their identity. This can be something like providing a password, an email link, a one-time code (OTP), a Web3 wallet address, or providing proof of their identity through an external social account (SSO/OAuth).
1. Attempt to complete the first factor verification.
1. Optionally, if you have enabled [multi-factor](/docs/authentication/configuration/sign-up-sign-in-options) for your application, you will need to prepare the second factor verification for users who have set up 2FA for their account.
1. Attempt to complete the second factor verification.
1. If verification is successful, set the newly created session as the active session by passing the `SignIn.createdSessionId` to the [`setActive()`](/docs/references/javascript/clerk#set-active) method on the `Clerk` object.

## Next steps

Now that you have a general understanding of how authentication flows work in Clerk, you can start building your custom flows. To get started, choose the guide that best fits your needs from the navigation on the left.

---
title: Customize max sign-in attempts and duration of user lockout
description: Use Clerk to limit the number of times a user can attempt to sign in before they are locked out of their account and customize how long such lockouts last.
---

Clerk provides an account lockout feature in order to protect user credentials against brute force attacks. By default, this feature is enabled. To configure this feature, in the Clerk Dashboard, navigate to the [**Attack protection**](https://dashboard.clerk.com/last-active?path=user-authentication/attack-protection) page. Here, you can enable or disable **Account lockout**, or configure the following settings:

- The **Maximum attempt limit** setting controls the number of failed sign-in attempts before a user is locked out. To change this setting, enter a new number of failed attempts allowed. (The default is 100 attempts.)
- **Lockout duration** controls the amount of time a user is locked out from their account after reaching the **Maximum attempt limit**.
  - The **Time limit** setting allows you to set an amount of time until the user account is unlocked. To change this setting, select the unit of time (minutes/hours/days/years) and enter the number of units you want lockouts to last.
  - The **Indefinite Lockout** setting locks a user account until it's manually unlocked in the Clerk Dashboard.

---
title: Customize your redirect URLs
description: Customize where your users are redirected to after they sign in or sign up.
---

To avoid breaking a user's flow through your app, when a user navigates to a Clerk sign up or sign in page via a link or button, Clerk will:

1. Persist the previous page's URL in a `redirect_url` query string
1. Navigate back to that page after the sign-up or sign-in is completed

For example, a user selecting a sign-in button on `example.com/foo` will navigate to `example.com/sign-in?redirect_url=example.com/foo`, then navigate back to `example.com/foo` upon completing the sign-in process.

However, you can customize this behavior to redirect users to a specific page by using the following methods:

- [Environment variables (recommended)](#environment-variables)
- [Props on Clerk components](#redirect-url-props)

## Environment variables

The following environment variables are available for customizing your redirect URLs.

<Include src="_partials/environment-variables" />

## Redirect URL props

This section describes the properties available for customizing your redirect URLs on Clerk components. In general, **it's recommended to use [environment variables](#environment-variables) instead.**

> [!WARNING]
> The `afterSignIn`, `afterSignUp`, and `redirectUrl` props are deprecated. If you're still using them, the props described in this section will override them.

### Fallback redirect URL props

The "fallback redirect URL" props will only be used if there is no `redirect_url` value. This can happen if the user has navigated directly to the sign up or sign in page.

- `fallbackRedirectUrl` - Used by sign-in and sign-up related components.
- `signInFallbackRedirectUrl` - Used for the 'Already have an account? Sign in' link that's rendered on sign-up components, such as `<SignUp />` and `<SignUpButton>`.
- `signUpFallbackRedirectUrl` - Used for the 'Don't have an account? Sign up' link that's rendered on sign-in components, such as `<SignIn />` and `<SignInButton>`.

### Force redirect URL props

The "force redirect URL" props will _always_ redirect to the provided URL after sign up or sign in, regardless of what page the user was on before, and will override the `redirect_url` value if present.

- `forceRedirectUrl` - Used by sign-in and sign-up related components.
- `signInForceRedirectUrl` - Used for the 'Already have an account? Sign in' link that's rendered on sign-up components, such as `<SignUp />` and `<SignUpButton>`.
- `signUpForceRedirectUrl` - Used for the 'Don't have an account? Sign up' link that's rendered on sign-in components, such as `<SignIn />` and `<SignInButton>`.

### Set the props

It is recommended to define both sign-up and sign-in variables, as some users may choose to sign up instead after attempting to sign in, and vice versa. For example, if you define `signInFallbackRedirectUrl`, you should also define `signUpFallbackRedirectUrl`.

The following components accept the redirect URL props:

- [`<RedirectToSignIn />`](/docs/components/control/redirect-to-signin)
- [`<RedirectToSignUp />`](/docs/components/control/redirect-to-signup)
- [`<ClerkProvider>`](/docs/components/clerk-provider)
- [`<SignInButton>`](/docs/components/unstyled/sign-in-button)
- [`<SignUpButton>`](/docs/components/unstyled/sign-up-button)
- [`<SignIn>`](/docs/components/authentication/sign-in)
- [`<SignUp>`](/docs/components/authentication/sign-up)

See the appropriate reference documentation for each component, as linked above, for more information on what specific props are available.

> [!NOTE]
> `<RedirectToSignIn />` or `<RedirectToSignUp />` child components will always take precedence over `<ClerkProvider>`.

---
title: Customize your session token
description: Learn how to customize the session token that is generated for you by Clerk.
---

Session tokens are JWTs generated by Clerk on behalf of your instance, and convey an authenticated user session to your backend.

By default, session tokens contain claims that are required for Clerk to function. You can learn more about these "default claims" in the [session tokens](/docs/backend-requests/resources/session-tokens) documentation.

This guide will show you how to customize a session token to include additional claims that you may need in your application.

<Include src="_partials/token-size-callout" />

<Steps>
  ## Add custom claims to your session token

  1. In the Clerk Dashboard, navigate to the [**Sessions**](https://dashboard.clerk.com/last-active?path=sessions) page.
  1. In the **Customize your session token** section, select **Edit**.
  1. In the modal that opens, you can add any claim to your session token that you need.

  The following example adds the `fullName` and `primaryEmail` claims to the session token.

  ![Clerk Dashboard showing the custom claim modal](/docs/images/advance/session-tokens/custom-session-example.png)

  ## Use the custom claims in your application

  The [`Auth`](/docs/references/backend/types/auth-object) object includes a `sessionClaims` property that contains the custom claims you added to your session token. It's returned by the [`auth()`](/docs/references/nextjs/auth) and `getAuth()` helpers, and the `request` object in server contexts.

  The following example demonstrates how to access the `fullName` and `primaryEmail` claims that were added to the session token in the last step. This examples are written for Next.js, but they can be adapted to other frameworks by using the appropriate method for accessing the `Auth` object.

  <CodeBlockTabs options={["App Router", "Pages Router"]}>
    ```tsx {{ filename: 'app/api/example/route.tsx' }}
    import { auth } from '@clerk/nextjs/server'
    import { NextResponse } from 'next/server'

    export async function GET() {
      const { sessionClaims } = await auth()

      const fullName = sessionClaims?.fullName

      const primaryEmail = sessionClaims?.primaryEmail

      return NextResponse.json({ fullName, primaryEmail })
    }
    ```

    ```tsx {{ filename: 'pages/api/example.ts' }}
    import { getAuth } from '@clerk/nextjs/server'
    import type { NextApiRequest, NextApiResponse } from 'next'

    export default async function handler(req: NextApiRequest, res: NextApiResponse) {
      const { sessionClaims } = getAuth(req)

      const fullName = sessionClaims.fullName

      const primaryEmail = sessionClaims.primaryEmail

      return res.status(200).json({ fullName, primaryEmail })
    }
    ```
  </CodeBlockTabs>

  ## Add global TypeScript type for custom session claims

  To get auto-complete and prevent TypeScript errors when working with custom session claims, you can define a global type.

  1. In your application's root folder, add a `types` directory.
  1. Inside of the `types` directory, add a `globals.d.ts` file.
  1. Create the `CustomJwtSessionClaims` interface and declare it globally.
  1. Add the custom claims to the `CustomJwtSessionClaims` interface.

  The following example demonstrates how to add the `fullName` and `primaryEmail` claims to the `CustomJwtSessionClaims` interface.

  ```tsx {{ filename: 'types/globals.d.ts' }}
  export {}

  declare global {
    interface CustomJwtSessionClaims {
      fullName?: string
      primaryEmail?: string
    }
  }
  ```
</Steps>

---
title: Debug your webhooks
description: Understand how to debug your webhooks while developing your application
---

Developing with webhooks can be a new experience for developers. It can be hard to debug when something goes awry. This guide will cover the basics for debugging and help you to direct your attention to the correct spot.

## Webhooks and local development

When you or a user of your application performs certain actions, a webhook can be triggered. You can see the full list of [webhook events](/docs/webhooks/overview#supported-webhook-events) for a list of the actions that could result in a Webhook. Depending on the events subscribed to in the [**Webhooks**](https://dashboard.clerk.com/last-active?path=webhooks) page in the Clerk Dashboard, a webhook event will be triggered and sent to the specified endpoint in your application.

When you are developing on your localhost, your application is not internet facing and can't receive the webhook request. You will need to use a tool that creates a tunnel from the internet to your localhost. These tools will provide temporary or permanent URLs depending on the tool and the plan you subscribe to. Popular tools include `ngrok`, `localtunnel`, and `Cloudflare Tunnel`.

![Using webhooks in development](/docs/images/integrations/webhooks/webhooks_diagram.png)

Debugging webhook-related issues can be tricky, so the following sections address common issues and how to resolve them.

## Check your Middleware configuration

Incoming webhook events will never be signed in -- they are coming from a source outside of your application. Since they will be in a signed out state, the route should be public.

The following example shows the recommended Middleware configuration for your webhook routes.

```tsx {{ filename: 'middleware.tsx' }}
import { clerkMiddleware } from '@clerk/nextjs/server'

// Make sure that the `/api/webhooks/(.*)` route is not protected here
export default clerkMiddleware()

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

## Test the Route Handler or API Route

If you are having trouble with your webhook, you can create a basic Route Handler to test it locally.

1. Create a test route by adding the following file and code to your application:
   <CodeBlockTabs options={["Next.js"]}>
     ```ts {{ filename: 'app/webhooks/test/route.ts' }}
     export async function POST() {
       return Response.json({ message: 'The route is working' })
     }
     ```
   </CodeBlockTabs>
1. Run your application.
1. Send a request to the test route using the following command:
   ```bash
   curl -H 'Content-Type: application/json' \
       -X POST http://localhost:3000/api/webhooks/test
   ```

If you see the `{"message":"The route is working"}`, then the basic Route Handler is working and ready to build on.

> [!IMPORTANT]
> Your webhook needs to return a success code like `200` or `201` when it has been successfully handled. This will mark the webhook as successful in the Dashboard and prevent [retries](/docs/webhooks/overview#retry).

## Check your configuration in the Clerk Dashboard

Whether you are developing locally or deploying to production, the webhook URL provided in your [webhook endpoint](https://dashboard.clerk.com/last-active?path=webhooks) must be exact and correct. The URL breaks down into three parts:

- the protocol (`http` vs `https`) - Whether in development using a tunnel or in production, the URL will almost always use `https` so ensure that the protocol is correct.
- the domain (`domain.com`) - The domain needs to be exact. A common error in production is not including the `www.`. Unlike entering a domain in your browser, a webhook will not be redirected from `domain.com` to `www.domain.com`. If your application lives on `www.domain.com` then the webhook URL must use that.
- the path (`/api/webhooks/user`) - The path must match the path in your application.

## Debug your tunnel and webhook delivery

If your webhook is still getting errors after testing its route locally and verifying the endpoint's configuration in the Clerk Dashboard, you can further investigate the specific errors returned by the webhook. Depending on the type of error, your approach to fixing the webhook will vary.

1. In the Clerk Dashboard, navigate to the [**Webhooks**](https://dashboard.clerk.com/last-active?path=webhooks) page.
1. Select the endpoint for which you want to test.
1. In the **Message attempts** table, you will likely see that one or more of those attempts have failed. Select the failed attempt to expand it.
1. In the details for the attempt, there will be a `HTTP RESPONSE CODE`. The code will likely be either a `500` or a `4xx` error, which will indicate there is some misconfiguration.

### Common HTTP response codes

The following table has some of the common response codes you might see and what they indicate. This is not an exhaustive list and you may need to research the code or error you are receiving. See [HTTP response status codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status) from MDN for reference.

| Code | Information |
| - | - |
| `400` | Usually indicates the verification failed, but could be caused by other issues. |
| `401` | The request was not authorized. If your test in the [Test the Route Handler or API Route](#test-the-route-handler-or-api-route) section worked, you should not see this error. If you are seeing it, then you will need to configure your Middleware to accept the request. |
| `404` | The URL for the webhook was not found. Check that your application is running and that [the endpoint is correct in the Clerk Dashboard](/docs/webhooks/debug-your-webhooks#check-your-configuration-in-the-clerk-dashboard). |
| `405` | Your route is not accepting a `POST` request. All webhooks are `POST` requests and the route must accept them. Unless you are using the route for something else, you can restrict the route to `POST` requests only. |
| `500` | The request made it to your application, but there is a code-related issue. This is likely a webhook verification issue or something in the webhook logic. See the following sections. |

## Debug webhook verification

To verify the webhook, see the [guide on webhooks](/docs/webhooks/sync-data) for a detailed code example. You can also visit the [Svix guide on verifying payloads](https://docs.svix.com/receiving/verifying-payloads/how).

Diagnosing a problem in this part of the webhook can be challenging. Your best bet would be the liberal use of `console.log`. You could log out the following to check if the values are correct:

- the signing secret
- the headers
- the `body` before verifying
- the result of the `.verify()` attempt

The results of these will appear in the command line where you are running your application.

Checking the values and the progress of the webhook code will allow you to narrow down where the code is failing. They will often return `null` or errors where they should be returning values.

## Check your logic

Once you have verified the webhook, you will now be writing your own code to handle the values from the webhook. This could range from saving data to a database, or integrating with another system, to updating users or sending emails or SMS.

If the webhook is verified and you're seeing a `500` status code or your webhook is not behaving as expected, remember that you can use `console.log` to help diagnose what the problem is. Console logs and errors will be displayed on your command line, allowing you to see what's happening and address the bugs.

---
title: Delete users
description: Learn how to delete users in your Clerk application.
---

There are two ways to delete users in Clerk: [in the Clerk Dashboard](#in-the-clerk-dashboard) or [using the Backend API](#using-the-backend-api).

## In the Clerk Dashboard

To delete users in the Clerk Dashboard:

1. At the top of the Clerk Dashboard, select [**Users**](https://dashboard.clerk.com/last-active?path=users).
1. You can either select the user and then in the side navigation menu, select **Delete user**, or select the menu icon on the right side of the user's row and select **Delete user**.

## Using the Backend API

You can delete users in your app using Clerk's Backend API.

Use the following tabs to see examples of how to delete users using one of the following:

- Frontend SDKs, such as Next.js, React, or Remix
- Express
- cURL

<Tabs items={["Fullstack SDKs", "Express", "cURL"]}>
  <Tab>
    The following example shows how to delete a user using the JavaScript Backend SDK's [`deleteUser()`](/docs/references/backend/user/delete-user) method from the `users` sub-api of the `clerkClient` instance.

    ```ts {{ filename: 'route.ts' }}
    export async function DELETE() {
      const userId = 'user_123'

      try {
        await clerkClient.users.deleteUser(userId)
        return Response.json({ message: 'User deleted' })
      } catch (error) {
        console.log(error)
        return Response.json({ error: 'Error deleting user' })
      }
    }
    ```

    <If sdk="nextjs">
      If you're using Next.js, you must `await` the instantiation of the `clerkClient` instance, like so:

      ```ts
      const client = await clerkClient()

      const response = await client.users.deleteUser(userId)
      ```
    </If>
  </Tab>

  <Tab>
    ```ts {{ filename: 'delete-user.ts' }}
    import { clerkClient } from '@clerk/express'

    app.post('/deleteUser', async (req, res) => {
      const userId = req.body.userId

      try {
        await clerkClient.users.deleteUser(userId)
        res.status(200).json({ message: 'User deleted' })
      } catch (error) {
        console.log(error)
        res.status(500).json({ error: 'Error deleting user' })
      }
    })
    ```
  </Tab>

  <Tab>
    ```bash {{ filename: 'terminal' }}
    curl 'https://api.clerk.com/v1/users/{user_id}' -X DELETE -H 'Authorization:Bearer {{secret}}' -H 'Content-Type:application/json'
    ```
  </Tab>
</Tabs>

---
title: Deploy a Chrome Extension to production
description: Learn how to deploy a Chrome Extension to production with Clerk.
---

> [!WARNING]
> This guide assumes you are using the Plasmo framework. If you need help applying these concepts to another framework, [contact support](https://clerk.com/contact/support).

## Create a production instance

For Clerk production instances, there must be a domain associated with the instance. Even though there may not be a web application associated with your Chrome Extension, a domain is still required. Follow the [guide on deploying your Clerk app to production](/docs/deployments/overview).

## Update your `.env.production` file

<SignedIn>
  Add your Publishable and Frontend API keys for your Clerk production instance to your `.env.production` file. These keys can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard. If you're using [the Sync Host feature](/docs/references/chrome-extension/sync-host), you also need to set the `PLASMO_PUBLIC_CLERK_SYNC_HOST` environment variable. The value is the domain your web app's production server runs on. For example, `https://clerk.com`.
</SignedIn>

<SignedOut>
  1. At the top of the Clerk Dashboard, in the instance selection dropdown, ensure that your production instance is selected.
  1. In the navigation sidenav, select [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys).
  1. In the **Quick Copy** section, select **Chrome Extension** and copy your Clerk Publishable and Frontend API keys.
  1. Paste your keys into your `.env.production` file.
  1. If you are using [the Sync Host feature](/docs/references/chrome-extension/sync-host), you will also need to set the `PLASMO_PUBLIC_CLERK_SYNC_HOST` environment variable. The value should be the domain your web app's production server runs on. For example, `https://clerk.com`.

  The final result should resemble the following:
</SignedOut>

```env {{ filename: '.env.production' }}
PLASMO_PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
CLERK_FRONTEND_API={{fapi_url}}
PLASMO_PUBLIC_CLERK_SYNC_HOST=https://yourdomain.com
```

## Add production domain to `host_permissions`

`host_permissions` specifies which hosts, or websites, will have permission to sync auth state with your app. It accepts an array, allowing you to add more than one host. You must add your production domain to the `host_permissions` array.

> [!WARNING]
> If you are using the Sync Host feature and followed [the configuration guide](/docs/references/chrome-extension/sync-host), then you have already completed this step (the `http://$PLASMO_PUBLIC_CLERK_SYNC_HOST/*` value points to your production domain.)

In the `package.json` file, in the `manifest` object, update the `host_permissions` array. Add your domain and ensure it is preceded with `https://`. For example, `https://clerk.com`. Only add the root domain and not any subdomains. Then, add `/*` to the end of the domain.

The following example shows how to configure `host_permissions` for production:

```json {{ filename: 'package.json', mark: [6] }}
{
  // The rest of your package.json file
  "manifest": {
    "key": "$CRX_PUBLIC_KEY",
    "permissions": ["cookies", "storage"],
    "host_permissions": ["https://<yourdomain>/*", "$CLERK_FRONTEND_API/*"]
  }
}
```

## Add the Extension's ID to your web app's `allowed_origins`

> [!WARNING]
> You may have already added the Extension ID to your web app's `allowed_origins` using your **development** Secret Key. You must repeat this step using your **production** Secret Key.

<SignedIn>
  In your terminal, paste the following command and replace the `<CHROME_EXTENSION_KEY>` with your extension's ID.
</SignedIn>

<SignedOut>
  1. At the top of the Clerk Dashboard, in the instance selection dropdown, ensure that your production instance is selected.
  1. In the navigation sidenav, select [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys).
  1. Copy your Secret Key. It should begin with `sk_live_`.
  1. In your terminal, paste the following command. Replace `YOUR_SECRET_KEY` with your Clerk Secret Key and the `<CHROME_EXTENSION_KEY>` with your extension's ID.

  The final result should resemble the following:
</SignedOut>

```bash {{ filename: 'terminal' }}
curl -X PATCH https://api.clerk.com/v1/instance \
  -H "Authorization: Bearer {{secret}}" \
  -H "Content-type: application/json" \
  -d '{"allowed_origins": ["chrome-extension://<CHROME_EXTENSION_KEY>"]}'
```

## Submit your extension for review

1. In your app, create a new zip of the `build/chrome-mv3-dev` folder.
1. In the top-right of the [Chrome Web Store Developer Dashboard](https://chrome.google.com/webstore/developer/dashboard), select **Upload new package** and upload the zip file.
1. Complete the required information to submit your extension for review. To check the requirements that must be met before submitting, select **Why can't I submit?**.

---
title: Deploy a Clerk app behind a proxy
description: Learn how to deploy a Clerk app to a web server using proxies and reverse proxies like nginx or Caddy, or using Docker.
---

When deploying a Clerk app behind a proxy, you must forward two headers:

- `X-Forwarded-Host` - The host of the request.
- `X-Forwarded-Proto` - The protocol of the request.

Here are some common platforms and servers that require header proxying:

- [nginx](https://nginx.org/en/)
- [Caddy](https://caddyserver.com/)
- [Docker](https://www.docker.com/)
- [AWS Amplify](https://amplify.com/)

## `nginx` configuration example

The following can be added to your `nginx` configuration to forward the headers to your application.

```nginx
proxy_set_header X-Forwarded-Host $host;
proxy_set_header X-Forwarded-Proto https;
```

## Test header forwarding

To test if the headers are forwarded correctly, you can console log them to check what their values are. They are available on the `request` object.

```ts {{ filename: 'middleware.ts' }}
export default clerkMiddleware(
  (auth, req) => {
    console.log('=========================')
    console.log('Request Headers')
    console.log('x-forwarded-host', req.headers.get('x-forwarded-host'))
    console.log('x-forwarded-proto', req.headers.get('x-forwarded-proto'))
    console.log('=========================')
  },
  { debug: debugStatus },
)
```

The `X-Forwarded-Host` header should return the same domain as the one you configured on the [**Domains**](https://dashboard.clerk.com/last-active?path=domains) page in the Clerk Dashboard. The `X-Forwarded-Proto` header should return `https` as Clerk requires this value to be `https` for production instances.

Here is an example result:

```log
=========================
Request Headers
x-forwarded-host example.com
x-forwarded-proto https
=========================
```

---
title: Deploy an Astro app to production
description: Learn how to deploy an Astro app to production with Clerk.
---

> [!WARNING]
> This guide assumes that you have already installed Clerk in your application locally and are ready to deploy. If you haven't installed Clerk yet, see [the quickstart guide](/docs/quickstarts/astro).

This guide will walk you through the steps to deploy your Astro app to production.

## Deploy your Clerk app to production

Follow the [guide on deploying your Clerk app to production](/docs/deployments/overview).

## Deploy to a hosting platform

To deploy to a hosting platform, it's recommended to choose one of the [official adapters](https://docs.astro.build/en/guides/server-side-rendering/#official-adapters) Astro offers. While the Node.js and Cloudflare adapters work out-of-the-box with Clerk, the Netlify and Vercel adapters have caveats. See the following sections for more information.

### Netlify

Due to Netlify's caching strategies, one of Clerk's core mechanisms is unable to work as expected, resulting in infinite redirects that cause an app to fail. This also affects preview environments that use **development** API keys. It's recommended to use [production API keys with a new domain](/docs/deployments/set-up-preview-environment#acquire-an-additional-root-domain).

Additionally, read [this section](#issues-with-edge-middleware) about **Edge middleware**.

### Vercel

Read [this section](#issues-with-edge-middleware) about **Edge middleware**.

## Issues with Edge middleware

The Netlify and Vercel adapters allow developers to convert the Astro middleware to an Edge middleware.

Currently, this is expected to not work for the following reasons:

- Our Astro SDK populates `Astro.locals.auth` with a function that cannot be serialized.
- For developers using Astro and React, SSR would not work as expected, as `clerkMiddleware` uses Async Local Storage, and it's stored value will not persist across the runtimes.

---
title: Deploy an Expo app to production
description: Learn how to deploy an Expo app to production with Clerk.
---

There are a few caveats to deploying production Expo applications with Clerk. This guide will walk you through the steps to deploy your Expo app to production.

## Acquire a domain

Before deploying your Expo app to production, you must acquire a domain. Even though there may not be a web application associated with an Expo app, Clerk still requires a domain for production instances.

## Configure your Expo app

With Clerk, you can [add OAuth flows in your Expo applications](/docs/custom-flows/oauth-connections).

Clerk ensures that security critical nonces will be passed only to allowlisted URLs when the OAuth flow is complete in native browsers or webviews.

So for maximum security in your production instances, you need to allowlist the SSO callback URL:

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Scroll to the **Allowlist for mobile SSO redirect** section and add your redirect URLs.
   - The default is `<INSERT-YOUR-APP-SCHEME>://sso-callback`

> [!TIP]
> You can also add redirect URLs via [the Backend API](/docs/reference/backend-api/tag/Redirect-URLs#operation/CreateRedirectURL){{ target: '_blank' }}.

## Deploy to production

Now that you have acquired a domain and configured your Expo app, you can follow [the Clerk deployment guide](/docs/deployments/overview).

---
title: Deploy your Clerk app to production
description: Learn how to deploy your Clerk app to production.
---

Before you begin:

1. You will need to have a domain you own.
1. You will need to be able to add DNS records on your domain.
1. You will need social sign-in (OAuth) credentials for any providers that you would like to use in production. Each [OAuth provider](/docs/authentication/social-connections/oauth) has a dedicated guide on how to set up OAuth credentials for Clerk production apps.

## Create your production instance

1. Navigate to the [Clerk Dashboard](https://dashboard.clerk.com).
1. At the top of the Dashboard, select the **Development** button to reveal the instance selection dropdown. Select **Create production instance**.
1. You will be prompted with a modal to either clone your development instance settings to your production instance or create your production instance with Clerk's default settings.
1. The homepage of the dashboard will show you what is still required to deploy your production instance.

> [!WARNING]
> For security reasons, [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections), [**Integrations**](https://dashboard.clerk.com/last-active?path=integrations), and [**Paths**](https://dashboard.clerk.com/last-active?path=paths) settings do not copy over. You will need to set these values again.

## API keys and environment variables

A common mistake when deploying to production is **forgetting to change your API keys to your production instances keys.** The best way to set this up is to make use of _environment variables_. All modern hosting providers, such as Vercel, AWS, GCP, Heroku, and Render, make it easy to add these values. Locally, you should use an `.env` file. This way, these values are being set dynamically depending on your environment. Here's a list of Clerk variables you'll need to change:

1. **Publishable Key:** Formatted as `pk_test_` in development and `pk_live_` in production. This is passed to the `<ClerkProvider>` during initialization.

1. **Secret Key:** Formatted as `sk_test_` in development and `sk_live_` in production. These values are used to access Clerk's Backend API.

> [!TIP]
> Be sure to update these values in your hosting provider's environment variables, and also to redeploy your app.

## OAuth credentials

In development, for most social providers, Clerk provides you with a set of shared OAuth credentials.

In production, these are not secure and you will need to provide your own. Each [OAuth provider](/docs/authentication/social-connections/oauth) has a dedicated guide on how to set up OAuth credentials for Clerk production apps.

## Webhooks

Your webhook endpoints will need to be updated to use your production instance's URL and signing secret. See the [guide on syncing data](/docs/webhooks/sync-data#configure-your-production-instance) for more information.

## Content Security Policy (CSP)

If you're using a CSP, follow the instructions in the [CSP guide](/docs/security/clerk-csp).

## DNS records

Clerk uses DNS records to provide session management and emails verified from your domain.

To see what DNS records you need, navigate to the [**Domains**](https://dashboard.clerk.com/last-active?path=domains) page in the Clerk Dashboard.

> [!NOTE]
> It can take up to 24hrs for DNS Records to fully propagate, so be patient.

## Authentication across subdomains

When you set a root domain for your production deployment, Clerk's authentication will work across all subdomains. User sessions will also be shared across the subdomains.

**Examples**

- `example-site.com` and `dashboard.example-site.com`
- `dashboard.example-site.com` and `accounts.example-site.com`

> [!NOTE]
> If you're using [passkeys](/docs/authentication/configuration/sign-up-sign-in-options#passkeys), only the first scenario in the above example will work due to restrictions in the [WebAuthn standard](https://www.w3.org/TR/webauthn-2/#sctn-rp-operations).

To share sessions and authentication across two different domains with the same Clerk application, see the [Authentication across different domains guide](/docs/advanced-usage/satellite-domains).

## Configure `authorizedParties` for secure request authorization

For enhanced security, it's highly recommended to explicitly set the `authorizedParties` option when authorizing requests. This option acts as an allowlist of origins to verify against, protecting your application from subdomain cookie leaking attacks. Without this setting, if an app on another subdomain of the same root domain as your Clerk app is compromised, that app could potentially generate valid sessions for your Clerk app.

The `authorizedParties` value should include a list of domains allowed to make requests to your application. Omitting this setting can expose your application to [CSRF attacks](https://owasp.org/www-community/attacks/csrf).

### Examples

The following examples show how to set `authorizedParties` with different Clerk helpers.

#### Set `authorizedParties` with `clerkMiddleware()`

```typescript
clerkMiddleware({
  authorizedParties: ['https://example.com'],
})
```

#### Set `authorizedParties` with `authenticateRequest()`

```typescript
clerkClient.authenticateRequest(req, {
  authorizedParties: ['https://example.com'],
})
```

## Deploy certificates

The Clerk Dashboard home page will tell you what steps are still required to deploy your production instance. Once you have completed all of the necessary steps, a **Deploy certificates** button will appear. Selecting this button will deploy your production instance.

## Troubleshooting

### DNS records not propagating with Cloudflare

Clerk uses a DNS check to validate this CNAME record. If this subdomain is reverse proxied behind a service that points to generic hostnames, such as Cloudflare, the DNS check will fail. Set the DNS record for this subdomain to a "DNS only" mode on your host to prevent proxying.

### Deployment stuck in certificate issuance

If your instance is stuck during TLS certificate issuance for longer than a few minutes, this might be caused due to certain [CAA DNS records](https://en.wikipedia.org/wiki/DNS_Certification_Authority_Authorization) set on your primary domain.

CAA are DNS records you may set to denote which certificate authorities (CA) are permitted to issue certificates for your domain, as a security measure against certain attacks. When you deploy your application, Clerk attempts to provision certificates using either the [LetsEncrypt](https://letsencrypt.org/) or [Google Trust Services](https://pki.goog/) certificate authorities.

Ensure that your primary domain (e.g., example.com) does not have any CAA records that prevent either LetsEncrypt or Google Trust Services from issuing certificates for your domain. To check this, run the following command in your terminal, replacing `example.com` with your apps domain:

```sh
dig example.com +short CAA
```

If the command returns an empty response, your domain is correctly configured. If it returns any text, you need to remove the CAA records from your primary domain to avoid potential downtime during certificate renewal.

### Incorrect domain

If you accidentally set the wrong domain, you can change it through the Clerk Dashboard or the Backend API. For more information, see the [dedicated guide](/docs/deployments/changing-domains).

---
title: Deploying a Clerk app to Vercel
description: Learn how to deploy a Clerk app to Vercel.
---

> [!WARNING]
> This guide assumes that you have already installed Clerk in your application locally and are ready to deploy. If you haven't installed Clerk yet, see the [setup guide](/docs/quickstarts/setup-clerk).

If you haven't set up your application in Vercel yet, [set up a new Vercel project](#set-up-a-new-vercel-project).

If you already have a Vercel project for your application and need to integrate Clerk, [add Clerk API keys to an existing Vercel project](#add-clerk-api-keys-to-existing-vercel-project).

## Set up a new Vercel project

1. To set up a new Vercel project, start by going to your [Vercel Dashboard](https://vercel.com/dashboard). Here, you'll see a list of your projects or, if you don't have any projects yet, a prompt to create a new project.
1. Create a new project by pressing the **Add New** button in the top right corner of the screen or by [pressing this link](https://vercel.com/new). You'll be redirected to a page where you can import a Git repository.
1. Find the Git repository you want to use and press **Import**. You'll be redirected to the **Configure Project** page.
1. Fill out the necessary information. And most importantly, ensure to add your Clerk API keys to the **[Environment Variables](https://vercel.com/docs/concepts/projects/environment-variables)**. You can find your Clerk API keys by navigating to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.

> [!WARNING]
> If you would like to deploy to production, you will need to add your **production** API keys to your Vercel project. Refer to the [Deploy to production](/docs/deployments/overview) guide for more information.

## Add Clerk API keys to existing Vercel project

1. To add your Clerk API keys to an existing Vercel project, start by selecting your project from your [Vercel dashboard](https://vercel.com/dashboard).
1. Select **Settings** in the navigation bar at the top.
1. In the sidenav, select **Environment Variables** and add your Clerk API keys. You can find your Clerk API keys by navigating to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
1. When adding **Environment Variables**, you can select which keys associate with which Vercel deployment environments. Using this, you can have your production Vercel environment use your production Clerk API keys while having your preview and development Vercel deployments use your development Clerk API keys.

> [!WARNING]
> If you would like to deploy to production, you will need to add your **production** API keys to your Vercel project. Refer to the [Deploy to production](/docs/deployments/overview) guide for more information.

## Vercel preview environment

To configure Clerk within your Vercel preview environment, see the [guide for configuring a preview environment](/docs/deployments/set-up-preview-environment).

## Deploy to production

If you would like to deploy your Vercel project to production, you will need to add your **production** API keys to your Vercel project. You will also need a domain that you own, as you cannot use a `*.vercel.app` domain for production. Refer to the [Deploy to production](/docs/deployments/overview) guide for more information.

---
title: Deprecation errors
description: An index of Clerk errors related to deprecation.
type: reference
---

An index of Clerk errors related to deprecation.

## `BAPIEndpointDeprecated`

```json
{
  "shortMessage": "endpoint is deprecated and pending removal",
  "longMessage": "<DeprecationMessage>",
  "code": "api_operation_deprecated_code"
}
```

---
title: Disabling the Account Portal
description: Learn how to disable the Account Portal.
---

> [!CAUTION]
> We recommend leaving the Account Portal enabled, even if you do choose to set up your own authentication flow. This helps with testing as well as providing an alternative path for users when needed.

To disable the Account Portal:

1. In the Clerk Dashboard, navigate to the [**Account Portal**](https://dashboard.clerk.com/last-active?path=account-portal) page.
1. Select the **Danger** tab.
1. Select **Disable Account Portal**. You will not be able to select this button until you have [set up an authentication flow for your users](#customize-your-sign-up-sign-in-flow), as applying this setting will immediately result in a 404 for all Account Portal pages.

## Customize your sign-up/sign-in flow

If you would like to migrate away from the Account Portal and create your own sign-up/sign-in flow, Clerk provides a set of [prebuilt components](/docs/components/overview) that you can use. If prebuilt components don't meet your specific needs or if you require more control over the logic, you can rebuild the existing Clerk flows using the Clerk API. See the [custom flows](/docs/custom-flows/overview) guides for more information.

---
title: Domain errors
description: An index of Clerk errors related to domains.
type: reference
---

An index of Clerk errors related to domains.

## `DomainNotFound`

Signifies an error when no domain with the given ID was found.

```json
{
  "shortMessage": "Domain not found",
  "longMessage": "No domain was found with <id>",
  "code": "resource_not_found_code"
}
```

## `DomainUpdateForbidden`

Signifies an error when trying to update a domain for any instance that is not a production instance.

```json
{
  "shortMessage": "Domain update was forbidden",
  "longMessage": "Domain can be only updated for production instances",
  "code": "domain_update_forbidden_code"
}
```

## <code>OperationNotAllowed<wbr />OnSatelliteDomain</code>

Signifies an error when trying to perform an operation on a satellite domain that is not allowed.

```json
{
  "shortMessage": "operation not allowed",
  "longMessage": "This operation is not allowed on a satellite domain. Try again using the primary domain of your instance.",
  "code": "operation_not_allowed_on_satellite_domain_code"
}
```

## <code>OperationNotAllowed<wbr />OnPrimaryDomain</code>

Signifies an error when trying to perform an operation on a primary domain that is not allowed.

```json
{
  "shortMessage": "operation not allowed",
  "longMessage": "This operation is not allowed on a primary domain. Try again with a satellite domain of the instance.",
  "code": "operation_not_allowed_on_primary_domain_code"
}
```

## `SyncNonceAlreadyConsumed`

Signifies an error when the nonce that was given during the sync flow is already consumed.

```json
{
  "shortMessage": "sync nonce already consumed",
  "longMessage": "The given sync nonce has already been consumed and cannot be re-used.",
  "code": "sync_nonce_already_consumed_code"
}
```

## `PrimaryDomainAlreadyExists`

Signifies an error when a new domain is added as primary while there is already one in the instance. Currently, we only support a single primary domain per instance.

```json
{
  "shortMessage": "primary domain already exists",
  "longMessage": "Currently, only a single primary domain is supported and the current instance already has one. All new domains need to be set a satellites.",
  "code": "primary_domain_already_exists_code"
}
```

## `InvalidProxyConfiguration`

Signifies an error when the proxy URL is not configured correctly.

```json
{
  "longMessage": "Clerk Frontend API cannot be accessed through the proxy URL. Make sure your proxy is configured correctly.",
  "code": "invalid_proxy_configuration_code"
}
```

---
title: Email and SMS templates
description: Learn how to configure the theming of Clerk-sent emails and SMS messages.
---

Clerk provides a templating system that allows you to customize the default system email and SMS messages sent during authentication flows.

The template editor enables you to change the wording and styling so that it is more consistent with your own branding.

It is also a useful way to translate the content to another target language in the case that English is not the default locale of your application.

## Before you start

### Terminology

It will be useful to take a look at the following terms as they will reappear in the rest of the guide:

| Name | Description |
| - | - |
| variables | Also known as merge tags in the context of email marketing, these are placeholders that are replaced with dynamic data when the actual email or SMS is being sent to the recipient. |
| WYSIWYG | Stands for 'What You See Is What You Get.' This term is used for editors and design tools that allow you to create content or layouts in a visual manner (without requiring you to edit the underlying markup) so that you can instantly see how the result is going to display to your users. |
| blocks | Email WYSIWYG editors enable you to use blocks, rows, and columns in order to control the layout of their content. This is then transpiled to table-based HTML. |

### Revolvapp WYSIWYG email editor plugin

The email editor uses the [Revolvapp](https://imperavi.com/legacy/revolvapp/) email template editor plugin by Imperavi. To acquaint yourself with the template markup syntax, consult [Imperavi's docs](https://imperavi.com/legacy/revolvapp/docs/syntax/quick-start).

As you will see, the template markup is an HTML-like language and each type of node supports its own set of attributes which control its behavior. A lot of the attributes are borrowed from HTML itself.

Revolvapp allows the user to design the template using [blocks](#terminology) and under the hood transpiles its markup to table-based HTML so that the resulting email renders consistently across email clients.

### Handlebars templating language

Both the email and SMS editor use the [Handlebars](https://handlebarsjs.com/) templating language for the interpolation of dynamic values into your content via [variables](#terminology). Variables are wrapped in double curly braces. For example: `{{app.name}}`. When the message is to be sent, the variable will be replaced with the actual value, which in this example would be the name of the application.

When editing a template in the Clerk Dashboard, you can insert variables at the desired position, so there is no need to write them by hand. Though, you can still do so if you like.

> [!NOTE]
> In order to unescape special characters, you may need to wrap variables in triple curly braces. For example: `{{{app.name}}}`. This will allow special characters (e.g. `'`, `&`) to appear as displayed and not as escaped HTML entities (e.g. `&apos;`, `&amp;`).

## Edit email templates

To access the email templates:

1. In the Clerk Dashboard, navigate to the [**Emails**](https://dashboard.clerk.com/last-active?path=customization/email) page.
1. Select a template to edit.
1. Once you have selected a template, you will be presented with [template operations](#template-operations), the [template settings](#email-template-settings), and [the WYSIWYG editor](#email-wysiwyg-editor).

### Template operations

The following operations are available for an email template:

- **Preview**: enables you to get an idea of how the template will render when sent to the recipient. This is useful for sampling your changes without actually having to commit them first. The `app_logo` and `copyright` sections (if present) will be replaced with their actual markup in this view.
- **Copy**: copies the current state of the editor to another instance. This is especially useful for promoting changes from your development or staging environment to production after you have tested them. **The copy icon will not appear if there are no other instances available on your application.**
- **Revert**: reverts to the system default template version. This can be useful if you want to start over from scratch.
- **Reset**: undo all changes since the last save by selecting the **Reset** button at the bottom right of the dashboard.

### Email template settings

The following settings can be changed per email template:

- **Delivered by Clerk**: Clerk will deliver your emails using its own Email Service Provider (ESP), which is currently [SendGrid](https://sendgrid.com/). However, if you wish to handle delivery of emails on your own, then you can toggle this setting off. This means that Clerk will no longer be sending this particular email and in order to deliver it yourself, you will need to listen to the `emails.created` [webhook](/docs/webhooks/overview) and extract the necessary info from the event payload.
- **Name**: a name for the template on the template listing page. It does not affect the outgoing email in any way.
- **From**: the email address that will be used as the **From** address in the email header. The format is `<local part>@<your-domain>`. You can change the local part to a custom value. If no value is provided, it defaults `noreply`.
- **Reply-To**: the email address that will be used as the **Reply-To** address in the email header. This is useful if you want to direct replies to a different email address than the one used in the **From** field. The format is `<local part>@<your-domain>`. You can change the local part to a custom value. If no value is provided, the **Reply-To** header will be omitted.
- **Subject**: the subject line of the email.

### Email WYSIWYG editor

The email WYSIWYG editor is split into two parts:

- [The toolbar](#toolbar-controls)
- [The text area](#text-area-controls)

#### Toolbar controls

The toolbar is located at the top of the editor and contains the following controls, in order from left to right:

- **Shortcut** button
- **Mobile view** toggle
- **HTML mode** toggle - For this tool to appear, you will need to unselect any currently selected block.
- **Background** button
- **Settings** button

For the following controls to appear, you will need to select an existing [block](#terminology) in the text area. These controls will not be visible otherwise.

- **Add block** button
- **Alignment** button
- **Link** button
- **Text color** button
- **Variable** button
- **Border** button

#### Text area controls

The email WYSIWYG editor text area is intended mainly for authoring content. Though, if you select a [block](#terminology), a set of tools will also appear. In order from top to bottom, these are:

- **Move handle**
- **Delete**
- **Clone**

## Edit SMS templates

To access the SMS templates:

1. In the Clerk Dashboard, navigate to the [**SMS**](https://dashboard.clerk.com/last-active?path=customization/sms) page.
1. Select a template to edit. You can also disable certain SMS notifications.
1. A modal will appear that shows you what the template looks like, plus options to toggle the [**Delivered by Clerk**](#delivered-by-clerk) setting or to [request a change to the template](#request-change).

### Delivered by Clerk

Clerk will deliver your SMS messages using its own SMS Gateway. However, if you wish to handle SMS delivery on your own, then you can toggle **Delivered by Clerk** off.

This means that Clerk will no longer be sending this particular SMS and in order to deliver it yourself, you will need to listen to the `sms.created` [webhook](/docs/webhooks/overview) and extract the necessary info from the event payload.

> [!NOTE]
> Remember, this is a per-template setting and will not be applied to other templates.

### Request change

Modifications to an SMS template are subject to approval by Clerk support. Once you submit the desired copywriting for a particular SMS template, a draft will be created for Clerk support to review.

If the change conforms to Clerk content policy, a support agent will approve your draft, and it will become effective from that point on. If the change is rejected, then the draft will be canceled.

You can also cancel a draft yourself if you decide you no longer need the changes or if you wish to submit a new draft.

The following settings can be changed for an SMS template:

- **Name**: a name for the template on the template listing page. It does not affect the outgoing email in any way.
- **Message**: a text area where you can author the content of the SMS message. The SMS content should fit within a limit of 160 simple GSM-7 or 140 unicode characters. To insert a [variable](#terminology) at the current cursor position, select the corresponding variable badge. You can interpolate a particular metadata key by using the following syntax: `{{user.metadata.foo.bar}}`.

---
title: Email deliverability
description: A lot goes into making sure verification emails make it to your customers as quickly as possible. Clerk uses every best practice, and is proactive about monitoring verification email deliverability and speed. Behind the scenes, Clerk uses Sendgrid using a pool of dedicated IP addresses to ensure that our reputation stays perfect.
---

A lot goes into making sure verification emails make it to your customers as quickly as possible. Clerk uses every best practice, and is proactive about monitoring verification email deliverability and speed. Behind the scenes, Clerk uses [Sendgrid](https://sendgrid.com) using a pool of dedicated IP addresses to ensure that our reputation stays perfect.

In development instances, all emails are sent from `@accounts.dev` domain. In production instances, they are sent from your own domain e.g. `@example.com`.

During production instance set up, Clerk will have you set up the required records to configure `SPF`, `DKIM`, and `DMARC` for security and deliverability.

## Best practices

Following the practices below will allow emails to be delivered quickly and reliably:

- Refrain from sending any spam from your domain
- Set up an inbox for your domain's "from" address
- Try sending email verification codes instead of verification links
- Use Clerk's default emails
- Make sure DMARC is set up

## Deliverability factors

Email deliverability is made of a number of factors, each contributing to whether or not it will get classified as spam, quarantined, or delayed.

### IP address reputation and blocklists

Email providers check against a pool of IP addresses and domain blocklists to protect against bad actors. Clerk is constantly monitoring to make sure our IP addresses are not on any of these lists. If you're experiencing issues, it may be helpful to verify that your domain doesn't live on any of these lists.

### Domain name reputation

Every domain name (i.e. `example.com`, `clerk.com`, etc.) has its own reputation score. Newer domains do not have a high score, and this may impact deliverability.

### Setup a real email address

Email providers will check if there's an actual mailbox behind the "from address" of an email. By default, Clerk will send your emails from [notifications@yourdomain.com](mailto:notifications@yourdomain.com). You should make sure that you set up a mailbox at this email address. If you'd like to use a different "from address", you can change its value via our [Backend API](/docs/reference/backend-api/tag/Beta-Features#operation/UpdateInstanceAuthConfig){{ target: '_blank' }}.

### Email content

The email content is scanned by email providers, so this also plays a crucial role in determining if an email clears spam filters. Clerk's default verification email copy is optimized based on trial and error, so, make modifications to the default template at your own risk. However, minor changes are usually ok.

### SPF and DKIM email authentication

These records are set up during production instance initialization and tell email providers which servers and domains are authorized to send emails on behalf of your organization. They also add a digital signature to every outgoing message, which lets providers verify that emails were indeed sent from you. Almost all email providers look for these to be set as a strong signal of legitimacy. Clerk handles these records for you automatically.

### Email traps

Because a lot of bad actors send spam to large, programmatically generated lists, mailbox providers have set up "email traps". If you send to one of these trap email addresses, it will get you flagged, and heavily ding your domain or IP address. Because we only send verification emails, it is very unlikely that Clerk will fall into one of these traps. Out of necessity mailbox providers do not advertise which addresses are "traps".

### Setup DMARC email authentication

DMARC, or "Domain-based Message Authentication, Reporting & Conformance", should also be set up on your domain. If an email ever fails one of the above checks, email providers will act based on the settings you choose here. In order to set up a DMARC policy, you will need to add a TXT record to your domain. The following is an example DMARC policy that Clerk uses for its own emails.

```txt
TXT Record

name:
_dmarc<.example.com>

content:
v=DMARC1; p=reject; pct=100; rua=mailto:you@example.com; ruf=mailto:you@example.com;
```

This policy will reject all emails that weren't sent from you. There are other [policies](https://dmarc.org/overview/) that you can use.

## Known provider-related issues

Despite all precautions, emails still sometimes end up in spam or quarantined. It's worth noting that if you're running into these issues, it's likely not a unique situation. Trying to figure out what is going wrong is a painful process, and some email providers are notoriously opaque and overly aggressive with their spam filters. This is always frustrating, especially when it comes to verification emails. While the following provider-related issues are common, following the steps listed at the top of this document is very likely to get your emails delivered to these inboxes. The two main culprits we've run into are as follows.

### Gmail

The most common issue with Clerk's verification emails is that they are "delayed" for roughly 4 minutes. This only happens with email addresses that are part of Google Workspace due to their ["pre-delivery message scanning."](https://apps.google.com/supportwidget/articlehome?hl=en\&article_url=https%3A%2F%2Fsupport.google.com%2Fa%2Fanswer%2F7380368%3Fhl%3Den\&product_context=7380368\&product_name=UnuFlow\&trigger_context=a) To further debug email issues with Gmail, you should sign up for [Gmail's postmaster tools](https://www.gmail.com/postmaster/).

### Microsoft (Hotmail / Outlook / Office365)

Microsoft Defender's aggressive anti-spam filters are the most common reason that verification emails might not reach certain Outlook inboxes.

In the event that an email does not reach an Outlook recipient at all, this most likely means they are placed in Quarantine and the workspace's administrator has been able to restore it. If you encounter this issue, try switching to OTP codes instead of email links, since they tend to have better deliverability with Outlook.

Another thing you can do is sign up for [Sender Support](https://sendersupport.olc.protection.outlook.com/snds/FAQ.aspx), and make sure you're following all of their best practices.

## Managing your own email delivery

If you would like to handle the delivery of these messages yourself, you can opt out of Clerk's email and SMS delivery on a **per-template basis**. To do this:

1. Navigate to the [Clerk Dashboard]().
1. In the navigation sidenav, select **Customization** and then select which option you would like to manage: **Emails** or **SMS**.
1. Select the template you would like to manage.
1. Disable **Delivered by Clerk**.

> [!NOTE]
> There is currently no way to disable Clerk's email and SMS delivery for all templates at once.

Once Clerk delivery is disabled, in order to handle the delivery of a email or SMS message, you will need to enable [webhooks](/docs/webhooks/overview) and listen for the `email.created` or `sms.created` events, respectively.

The event contains both the original message that Clerk would send, in case you would like to use it as-is, or the necessary metadata for you to create messages with your own copywriting. For instance, for a verification code email, the `email.created` event will contain the `otp_code`, which you can then use in your own messaging.

---
title: Embeddable email links with sign-in tokens
description: Learn how to build custom embeddable email link sign-in flows to increase user engagement and reduce drop off in transactional emails, SMS's, and more.
---

<If sdk="expo">
  > [!WARNING]
  > Expo does not support email links. You can request this feature on [Clerk's roadmap](https://feedback.clerk.com/).
</If>

An "email link" is a link that, when visited, will automatically authenticate your user so that they can perform some action on your site with less friction than if they had to sign in manually. You can create email links with Clerk by generating a sign-in token.

Common use cases include:

- Welcome emails when users are added off a waitlist
- Promotional emails for users
- Recovering abandoned carts
- Surveys or questionnaires

This guide will demonstrate how to generate a sign-in token and use it to sign in a user.

<Steps>
  ## Generate a sign-in token

  [Sign-in tokens](/docs/reference/backend-api/tag/Sign-in-Tokens#operation/CreateSignInToken){{ target: '_blank' }} are JWTs that can be used to sign in to an application without specifying any credentials. A sign-in token can be used **once**, and can be consumed from the Frontend API using the [`ticket`](/docs/references/javascript/sign-in#sign-in-create-params) strategy, which is demonstrated in the following example.

  > [!NOTE]
  > By default, sign-in tokens expire in 30 days. You can optionally specify a different duration in seconds using the `expires_in_seconds` property.

  The following example demonstrates a cURL request that creates a valid sign-in token:

  ```bash
  curl 'https://api.clerk.com/v1/sign_in_tokens' \
    -X POST \
    -H 'Authorization: Bearer {{secret}}' \
    -H 'Content-Type: application/json' \
    -d '{ "user_id": "user_123" }'
  ```

  This will return a `url` property, which can be used as your email link. Keep in mind that this link will use the [Account Portal sign-in page](/docs/account-portal/overview#sign-in) to sign in the user.

  If you would rather use your own sign-in page, you can use the `token` property that is returned. Add the `token` as a query param in any link, such as the following example:

  `https://your-site.com/accept-token?token=<INSERT_TOKEN_HERE>`

  Then, you can embed this link anywhere, such as an email.

  ## Build a custom flow for signing in with a sign-in token

  To handle email links with sign-in tokens, you must set up a page in your frontend that detects the token, signs the user in, and performs any additional actions you need.

  The following example demonstrates basic code that detects a token in the URL query params and uses it to initiate a sign-in with Clerk:

  <Tabs items={["Next.js"]}>
    <Tab>
      <CodeBlockTabs options={["App Router", "Pages Router"]}>
        ```tsx {{ filename: 'app/accept-token/page.tsx' }}
        'use client'
        import { useUser, useSignIn } from '@clerk/nextjs'
        import { useEffect, useState } from 'react'
        import { useSearchParams } from 'next/navigation'

        export default function Page() {
          const [loading, setLoading] = useState<boolean>(false)
          const { signIn, setActive } = useSignIn()
          const { user } = useUser()

          // Get the token from the query params
          const signInToken = useSearchParams().get('token')

          useEffect(() => {
            if (!signIn || !setActive || !signInToken || user || loading) {
              return
            }

            const createSignIn = async () => {
              setLoading(true)
              try {
                // Create the `SignIn` with the token
                const signInAttempt = await signIn.create({
                  strategy: 'ticket',
                  ticket: signInToken as string,
                })

                // If the sign-in was successful, set the session to active
                if (signInAttempt.status === 'complete') {
                  setActive({
                    session: signInAttempt.createdSessionId,
                  })
                } else {
                  // If the sign-in attempt is not complete, check why.
                  // User may need to complete further steps.
                  console.error(JSON.stringify(signInAttempt, null, 2))
                }
              } catch (err) {
                // See https://clerk.com/docs/custom-flows/error-handling
                // for more info on error handling
                console.error('Error:', JSON.stringify(err, null, 2))
              } finally {
                setLoading(false)
              }
            }

            createSignIn()
          }, [signIn, setActive, signInToken, user, loading])

          if (!signInToken) {
            return <div>No token provided.</div>
          }

          if (!user) {
            return null
          }

          if (loading) {
            return <div>Signing you in...</div>
          }

          return <div>Signed in as {user.id}</div>
        }
        ```

        ```tsx {{ filename: 'pages/accept-token.tsx' }}
        import { InferGetServerSidePropsType, GetServerSideProps } from 'next'
        import { useUser, useSignIn } from '@clerk/nextjs'
        import { useEffect, useState } from 'react'

        // Get the token from the query param server-side, and pass through props
        export const getServerSideProps: GetServerSideProps = async (context) => {
          return {
            props: { signInToken: context.query.token ? context.query.token : null },
          }
        }

        export default function AcceptTokenPage({
          signInToken,
        }: InferGetServerSidePropsType<typeof getServerSideProps>) {
          const [loading, setLoading] = useState<boolean>(false)
          const { signIn, setActive } = useSignIn()
          const { user } = useUser()

          useEffect(() => {
            if (!signIn || !setActive || !signInToken || user || loading) {
              return
            }

            const createSignIn = async () => {
              setLoading(true)
              try {
                // Create the `SignIn` with the token
                const signInAttempt = await signIn.create({
                  strategy: 'ticket',
                  ticket: signInToken as string,
                })

                // If the sign-in was successful, set the session to active
                if (signInAttempt.status === 'complete') {
                  setActive({
                    session: signInAttempt.createdSessionId,
                  })
                } else {
                  // If the sign-in attempt is not complete, check why.
                  // User may need to complete further steps.
                  console.error(JSON.stringify(signInAttempt, null, 2))
                }
              } catch (err) {
                // See https://clerk.com/docs/custom-flows/error-handling
                // for more info on error handling
                console.error('Error:', JSON.stringify(err, null, 2))
                setLoading(true)
              } finally {
                setLoading(false)
              }
            }

            createSignIn()
          }, [signIn, setActive, signInToken, user, loading])

          if (!signInToken) {
            return <div>No token provided.</div>
          }

          if (loading) {
            return <div>Loading...</div>
          }

          if (!user) {
            return null
          }

          return <div>Signed in as {user.id}</div>
        }
        ```
      </CodeBlockTabs>
    </Tab>
  </Tabs>
</Steps>

---
title: Enable biometric sign-in for returning users in Expo
description: Learn how to use the useLocalCredentials() hook in your Expo app to enable biometric sign-ins for returning users.
---

> [!WARNING]
> This feature requires `@clerk/clerk-expo >=@2.2.0` and works only for sign-in attempts that use the password strategy.

This guide demonstrates how to use the [`useLocalCredentials()`](/docs/references/expo/use-local-credentials) hook in your Expo app to securely store a user's password credentials on their device, enabling biometric sign-in for returning users.

<Steps>
  ## Install the necessary peer dependencies

  The `useLocalCredentials()` hook requires the following packages to be installed in your project:

  - `expo-local-authentication`: Provides biometric authentication functionality
  - `expo-secure-store`: Enables secure storage of credentials on the device

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install expo-local-authentication expo-secure-store
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add expo-local-authentication expo-secure-store
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add expo-local-authentication expo-secure-store
    ```

    ```bash {{ filename: 'terminal' }}
    bun add expo-local-authentication expo-secure-store
    ```
  </CodeBlockTabs>

  ## Update `app.json`

  See the following Expo docs to update your `app.json` file with the necessary configurations for biometric sign-in. Replace `$(PRODUCT_NAME)` with your app's name as specified in the `"name"` field in your `app.json` file.

  - [`expo-local-authentication`](https://docs.expo.dev/versions/latest/sdk/local-authentication/#configuration-in-appjsonappconfigjs)
  - [`expo-secure-store`](https://docs.expo.dev/versions/latest/sdk/securestore/#configuration-in-appjsonappconfigjs)

  ## Securely store/access the user's credentials during sign in

  The following example demonstrates how to use `useLocalCredentials()` in a custom flow for signing in users.

  ```tsx {{ filename: 'app/sign-in.tsx' }}
  import { useSignIn } from '@clerk/clerk-expo'
  import { Link, useRouter } from 'expo-router'
  import { Text, TextInput, Button, View } from 'react-native'
  import { useState } from 'react'
  import { useLocalCredentials } from '@clerk/clerk-expo/local-credentials'

  export default function Page() {
    const router = useRouter()
    const { signIn, setActive, isLoaded } = useSignIn()
    const { hasCredentials, setCredentials, authenticate, biometricType } = useLocalCredentials()

    const [emailAddress, setEmailAddress] = useState('')
    const [password, setPassword] = useState('')

    const onSignInPress = async (useLocal: boolean) => {
      if (!isLoaded) return

      // Start the sign-in process using the email and password provided
      try {
        const signInAttempt =
          hasCredentials && useLocal
            ? await authenticate()
            : await signIn.create({
                identifier: emailAddress,
                password,
              })

        // If sign-in process is complete,
        // set the created session as active and redirect the user
        if (signInAttempt.status === 'complete') {
          console.log('status is complete?', signInAttempt.status)

          if (!useLocal) {
            await setCredentials({
              identifier: emailAddress,
              password,
            })
          }

          await setActive({ session: signInAttempt.createdSessionId })
          router.replace('/')
        } else {
          // If the status is not complete, check why.
          // User may need to complete further steps.
          console.error(JSON.stringify(signInAttempt, null, 2))
        }
      } catch (err) {
        // For info on error handing,
        // see https://clerk.com/docs/custom-flows/error-handling
        console.error(JSON.stringify(err, null, 2))
      }
    }

    return (
      <View>
        <TextInput
          autoCapitalize="none"
          value={emailAddress}
          placeholder="Enter email"
          onChangeText={(emailAddress: string) => setEmailAddress(emailAddress)}
        />

        <TextInput
          value={password}
          placeholder="Enter password"
          secureTextEntry={true}
          onChangeText={(password: string) => setPassword(password)}
        />

        <Button title="Sign In" onPress={() => onSignInPress(false)} />

        {hasCredentials && biometricType && (
          <Button
            title={
              biometricType === 'face-recognition' ? 'Sign in with Face ID' : 'Sign in with Touch ID'
            }
            onPress={() => onSignInPress(true)}
          />
        )}

        <View>
          <Text>Don't have an account?</Text>

          <Link href="/sign-up">
            <Text>Sign up</Text>
          </Link>
        </View>
      </View>
    )
  }
  ```

  ## Delete credentials while user is logged in

  The following example demonstrates how to use the `userOwnsCredentials` and `clearCredentials` properties of the `useLocalCredentials()` hook in order to remove the stored credentials if those belong to the signed in user.

  ```tsx {{ filename: 'app/user.tsx' }}
  import { useUser, useClerk } from '@clerk/clerk-expo'
  import { useLocalCredentials } from '@clerk/clerk-expo/local-credentials'
  import { View, Text, Button } from 'react-native'

  export default function Page() {
    const { user } = useUser()
    const { signOut } = useClerk()

    const { userOwnsCredentials, clearCredentials } = useLocalCredentials()

    return (
      <View>
        <Text>Settings, {user?.emailAddresses[0].emailAddress}</Text>
        <Button title="Sign out" onPress={() => signOut()} />
        {userOwnsCredentials && (
          <Button title="Remove biometric credentials" onPress={() => clearCredentials()} />
        )}
      </View>
    )
  }
  ```

  ## Update credentials while user is logged in

  The following example demonstrates how to use `userOwnsCredentials` and `setCredentials` properties of the `useLocalCredentials()` hook in order to update the stored credentials if those belong to the signed in user.

  ```tsx {{ filename: 'app/update-user.tsx' }}
  import { useUser, useClerk } from '@clerk/clerk-expo'
  import { useLocalCredentials } from '@clerk/clerk-expo/local-credentials'

  export default function Page() {
    const { user } = useUser()
    const [currentPassword, setCurrentPassword] = React.useState('')
    const [password, setPassword] = React.useState('')

    const { userOwnsCredentials, setCredentials } = useLocalCredentials()

    const changePassword = React.useCallback(async () => {
      try {
        await user?.updatePassword({
          currentPassword: currentPassword,
          newPassword: password,
        })

        if (userOwnsCredentials) {
          await setCredentials({
            password,
          })
        }
      } catch (err: any) {
        console.error(JSON.stringify(err, null, 2))
      }
    }, [currentPassword, password])

    return (
      <View>
        <TextInput
          autoCapitalize="none"
          value={currentPassword}
          placeholder="Current password..."
          secureTextEntry={true}
          onChangeText={(currentPassword) => setCurrentPassword(currentPassword)}
        />
        <TextInput
          value={password}
          placeholder="Password..."
          secureTextEntry={true}
          onChangeText={(password) => setPassword(password)}
        />
        <Button title="Update password" onPress={changePassword} />
      </View>
    )
  }
  ```
</Steps>

---
title: Enable Google Analytics for Clerk
description: Enable Clerk with Google Analytics to authenticate requests to your application.
---

This integration enables Clerk to send user authentication events to the configured Google Analytics property which corresponds to your application.

> [!NOTE]
> The Google Analytics integration can be enabled only for Production Instances.

To enable the integration, you will need to provide Clerk with the required Google Analytics configuration attributes depending on the type of Google Analytics property. **We support both Universal Analytics and Google Analytics 4 properties.**

To get started, navigate to the [**Integrations**](https://dashboard.clerk.com/last-active?path=integrations) page in the Clerk Dashboard. Turn on the Google Analytics integration.

![The Integrations page in the Clerk Dashboard. A red arrow points to the toggle next to 'Google Analytics'.](/docs/images/integrations/google/integrations.webp)

Once enabled, you will be presented with a form to enter the required Google Analytics configuration attributes.

![The Google Analytics configuration form in the Clerk Dashboard.](/docs/images/integrations/google/configuration-settings.webp)

## Configuration

To allow Clerk to report selected events on your Google Analytics property and improve your user analytics quality, you will need to set some configuration attributes on the integration page.

### Integration type

To send events to Google Analytics servers, Clerk uses the [Measurement Protocol](https://developers.google.com/analytics/devguides/collection/protocol) specification. Depending on your property type, you would need to provide the keys as described below:

#### Google Analytics 4

- **API Secret**: An API secret generated in the Google Analytics UI. To create a new secret, navigate to **Admin  Data Streams  choose your stream  Measurement Protocol  Create**.

![A gif showing how to access the API secret in the Google Analytics UI.](/docs/images/integrations/google/api-secret.gif)

- **Measurement ID**: The measurement ID associated with the data stream sending data to your Google Analytics 4 property. The format is **G-XXXXXXX** and can be found in the Google Analytics UI under **Admin  Data Streams  choose your stream  Measurement ID**.

![A gif showing how to access the measurement ID in the Google Analytics UI](/docs/images/integrations/google/measurement-id.gif)

#### Universal Analytics

- **Tracking ID**: The tracking ID is a string composed of your account number and the property index and is used to send data to the correct Google Analytics property. The format is **UA-YYYYYY-Z** and can be found in the Google Analytics UI under **Admin  Tracking Info  Tracking Code**.

![A gif showing how to access the measurement ID in the Google Analytics UI](/docs/images/integrations/google/tracking-id.webp)

### Include Clerk user ID

Since Clerk is used for the user management and authentication in your application, we provide the capability to associate the user identifier (UID) generated from Clerk with the User ID feature in Google Analytics. Enabling this feature will allow enhanced user analysis capabilities on Google Analytics like cross-device user tracking, session unification and more.Read more about the User ID feature:

[Google Analytics 4 User-ID](https://support.google.com/analytics/answer/9213390)

[Universal Analytics User-ID](https://support.google.com/analytics/answer/3123662?hl=en)

### Events to track

Select during which user authentication events, such as user sign-in or user sign-up, a Google Analytics event should be recorded.

#### Sign-up

Sent every time a user signs up for your application through Clerk.

For **Universal Analytics** properties, this is sent as a custom event. The custom event is composed as:

- Category: `Clerk`
- Action: `sign_up`
- Label: `{{signup method}}`

For **Google Analytics 4** properties, this matches the standard [sign\_up event](https://developers.google.com/analytics/devguides/collection/ga4/reference/events#sign_up).

#### Sign-in

Sent every time a user signs in to his account through Clerk.

For **Universal Analytics** properties, this is sent as a custom event.

- Category: `Clerk`
- Action: `login`
- Label: `{{login method}}`

For **Google Analytics 4** properties, this matches the standard [login event](https://developers.google.com/analytics/devguides/collection/ga4/reference/events#login).

## Frequently asked questions (FAQ)

**Will Clerk events disrupt session attribution, user count or other metrics?**

No, Clerk's production architecture allows us to configure the measurement protocol events sent to your property in such a way that session attribution, user count and identification attributes are kept intact.

---
title: Enable offline support in your Expo app
description: Learn how to enable offline support in your Expo app with Clerk.
---

> [!WARNING]
> **This is an experimental API.**
>
> The `__experimental_resourceCache` property introduced in this guide is an experimental feature. It is subject to change in future updates, so use it cautiously in production environments. Ensure thorough testing and stay informed through [the package's changelog](https://github.com/clerk/javascript/blob/main/packages/expo/CHANGELOG.md).

The Clerk Expo SDK provides enhanced offline support to improve reliability and user experience. This update enables your app to bootstrap offline using cached Clerk resources, ensuring quick initialization without requiring an internet connection.

It offers the following benefits:

- Initialization of the Clerk SDK is now more resilient to network failures.
- Faster resolution of the `isLoaded` property and the [`<ClerkLoaded>`](/docs/components/control/clerk-loaded) control component with only a single network fetch attempt. If the fetch fails, it gracefully falls back to cached resources.
- Network errors are no longer muted, allowing developers to catch and handle them effectively in their custom flows.
- The [`getToken()`](/docs/references/javascript/session#get-token) function in the `useAuth()` hook now supports returning cached tokens, minimizing disruptions caused by network failures.

## How to enable offline support

To enable offline support in your Expo app, follow these steps:

<Steps>
  ### Install the necessary peer dependencies

  The `expo-secure-store` package is required to use the offline support feature.

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install expo-secure-store
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add expo-secure-store
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add expo-secure-store
    ```

    ```bash {{ filename: 'terminal' }}
    bun add expo-secure-store
    ```
  </CodeBlockTabs>

  ### Use the `__experimental_resourceCache` property on `ClerkProvider`

  On [`<ClerkProvider>`](/docs/components/clerk-provider), pass the `resourceCache` object to the `__experimental_resourceCache` property, as shown in the following example:

  ```tsx {{ filename: 'app/_layout.tsx', mark: [4, 8] }}
  import { ClerkProvider } from '@clerk/clerk-expo'
  import { Slot } from 'expo-router'
  import { tokenCache } from '@clerk/clerk-expo/token-cache'
  import { resourceCache } from '@clerk/clerk-expo/resource-cache'

  export default function RootLayout() {
    return (
      <ClerkProvider tokenCache={tokenCache} __experimental_resourceCache={resourceCache}>
        <Slot />
      </ClerkProvider>
    )
  }
  ```
</Steps>

## How to handle network errors

When there is no internet connection, Clerk's custom flows (e.g., `signIn.create()`) will throw a network error.

To handle network errors in your Expo app, you can use the `isClerkRuntimeError()` function to check if the error is a Clerk-related error. Clerk-related errors are returned as an array of [`ClerkAPIError`](/docs/references/javascript/types/clerk-api-error) objects. These errors contain a `code` property that you can use to identify the specific error. See the following example.

```tsx {{ mark: [1, [22, 30]] }}
import { useSignIn, isClerkRuntimeError } from '@clerk/clerk-expo'
import { Link, useRouter } from 'expo-router'
import { Text, TextInput, Button, View } from 'react-native'
import React from 'react'

export default function SignInPage() {
  const { signIn, setActive, isLoaded } = useSignIn()
  const router = useRouter()

  const [emailAddress, setEmailAddress] = React.useState('')
  const [password, setPassword] = React.useState('')

  const onSignInPress = React.useCallback(async () => {
    if (!isLoaded) return
    try {
      const signInAttempt = await signIn.create({
        identifier: emailAddress,
        password,
      })

      // The rest of your custom flow logic
    } catch (err) {
      // See https://clerk.com/docs/custom-flows/error-handling
      // for more info on error handling
      if (isClerkRuntimeError(err) && err.code === 'network_error') {
        console.error('Network error occurred!')
      }

      console.error(JSON.stringify(err, null, 2))
    }
  }, [isLoaded, emailAddress, password])

  return (
    <View>
      <Button title="Sign in" onPress={onSignInPress} />
    </View>
  )
}
```

---
title: Endpoints
description: Learn how to use Clerk's Astro SDK in your Astro endpoints.
---

Clerk provides helpers that allow you to protect your [Astro endpoints](https://docs.astro.build/en/guides/endpoints/#server-endpoints-api-routes), fetch the current user, and interact with the Clerk Backend API.

## Protect your endpoints

If you aren't protecting your endpoints using [`clerkMiddleware()`](/docs/references/astro/clerk-middleware), you can use the [`auth()` local](/docs/references/astro/locals) and check for the `userId` value, as shown in the following example:

```ts {{ filename: 'src/pages/api/route.ts' }}
export async function GET({ locals }) {
  const { userId } = locals.auth()

  if (!userId) {
    return new Response('Error: No signed in user', { status: 401 })
  }

  // Add your Endpoint logic here

  return new Response(JSON.stringify({ userId }))
}
```

## Retrieve data from external sources

Clerk provides integrations with a number of popular databases.

To retrieve a token from a JWT template and fetch data from an external source, use the [`getToken()`](/docs/references/backend/types/auth-object#get-token){{ target: '_blank' }} method from the [`auth()` local](/docs/references/astro/locals), as shown in the following example:

```ts {{ filename: 'src/pages/api/route.ts' }}
export async function GET({ locals }) {
  const { userId, getToken } = locals.auth()

  if (!userId) {
    return new Response('Unauthorized', { status: 401 })
  }

  const token = await getToken({ template: 'supabase' })

  // Fetch data from Supabase and return it.
  const data = { supabaseData: 'Hello World' }

  return new Response(JSON.stringify(data))
}
```

## Retrieve the current user

In some cases, you might need the current user in your endpoint. Use the asynchronous [`currentUser()` local](/docs/references/astro/locals#locals-current-user) to retrieve the current [`Backend User`](/docs/references/backend/types/backend-user){{ target: '_blank' }} object, as shown in the following example:

```ts {{ filename: 'src/pages/api/route.ts' }}
export async function GET({ locals }) {
  const user = await locals.currentUser()

  if (!user) {
    return new Response('Unauthorized', { status: 401 })
  }

  return new Response(JSON.stringify({ user }))
}
```

## Interact with Clerk's Backend API

The [JavaScript Backend SDK](/docs/references/backend/overview) exposes the [Backend API](/docs/reference/backend-api){{ target: '_blank' }} resources and low-level authentication utilities for JavaScript environments.

`clerkClient` exposes an instance of the JavaScript Backend SDK for use in server environments. Use this instance to interact with the Clerk Backend API, as shown in the following example:

```ts {{ filename: 'src/pages/api/route.ts' }}
import { clerkClient } from '@clerk/astro/server'

export async function POST(context) {
  const { userId } = context.locals.auth()

  if (!userId) {
    return new Response('Unauthorized', { status: 401 })
  }

  const params = { firstName: 'Clerk', lastName: 'Cookie' }

  const user = await clerkClient(context).users.updateUser(userId, params)

  return new Response(JSON.stringify({ user }))
}
```

---
title: Enterprise Single Sign-On (SSO)
description: Clerk provides Enterprise SSO to authenticate users via federated Identity Providers such such as Azure AD, Okta, Google Workspace and more.
---

Enterprise Single Sign-On (SSO) allows users to sign in seamlessly using their Identity Provider (IdP) credentials (e.g.,Azure AD, Okta, or Google Workspace) and have their user data synchronized with Clerk. Clerk supports multiple protocols for implementing Enterprise SSO, including SAML and OIDC. Learn more about the process in the guides on [authentication flows](/docs/authentication/enterprise-connections/authentication-flows) and [account linking](/docs/authentication/enterprise-connections/account-linking).

## SAML

Clerk supports Enterprise SSO via the SAML protocol, enabling you to create authentication strategies for an IdP. The following IdPs are supported: [Microsoft Azure AD](/docs/authentication/enterprise-connections/saml/azure), [Google Workspace](/docs/authentication/enterprise-connections/saml/google), and [Okta Workforce](/docs/authentication/enterprise-connections/saml/okta). However, you can also [integrate with any other IdP](/docs/authentication/enterprise-connections/saml/custom-provider) that supports the SAML protocol.

### Allow subdomains

Authenticating via SAML SSO requires the user's email address domain to match the exact domain the SAML connection has been configured with. By default, subdomains are not supported. For example, a user with the email address `john@sales.example.com` wouldn't be able to use a SAML connection with the `example.com` domain to authenticate.

To configure subdomains for a SAML connection:

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select the SAML connection you want to allow subdomains for.
1. Select the **Advanced** tab.
1. Enable or disable the **Allow subdomains** option.
1. Select **Save**.

> [!NOTE]
> To enable the **Allow subdomains** option, your SAML connection domain must be an [eTLD+1](https://developer.mozilla.org/en-US/docs/Glossary/eTLD).

### Native applications

Clerk ensures that security critical nonces are passed only to allowlisted URLs when the SSO flow is completed in native browsers or webviews. For maximum security in your **production** instances, you need to allowlist your custom redirect URLs via the [Clerk Dashboard](https://dashboard.clerk.com/) or the [Clerk Backend API](/docs/references/backend/redirect-urls/create-redirect-url).

To allowlist a redirect URL via the Clerk Dashboard:

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Scroll down to the **Allowlist for mobile SSO redirect** section.
1. Under **Redirect URLs**, paste your the URL and select **Add**.

## OIDC

Clerk supports Enterprise SSO via the OpenID Connect (OIDC) protocol, either through [EASIE](#easie) or by [integrating with any OIDC-compatible provider](/docs/authentication/enterprise-connections/oidc/custom-provider).

### EASIE

[EASIE](https://easie.dev) SSO is a way for applications to provide enterprise-grade SSO through a multi-tenant OpenID provider. It is designed to be an easier alternative to SAML SSO.

The following IdPs are supported: Google Workspace and Microsoft Entra ID. For _development instances_, Clerk uses preconfigured shared credentials and redirect URIsno other configuration is needed. For _production instances_, you must provide custom credentials. Follow the steps outlined in the guides to complete the setup:

- [Google](/docs/authentication/social-connections/google)
- [Microsoft](/docs/authentication/social-connections/microsoft)

#### Automatic deprovisioning

Clerk prevents users linked to deprovisioned accounts in the OpenID provider from accessing the app.

Before creating a new session token for an EASIE user, Clerk verifies whether the user has been deprovisioned from their OpenID provider (e.g., [suspended](https://support.google.com/a/answer/33312?hl=en) or [deleted](https://support.google.com/a/answer/33314?hl=en) in Google Workspace, or [deleted](https://learn.microsoft.com/en-us/entra/fundamentals/how-to-create-delete-users#delete-a-user) in Microsoft Entra). This verification process might involve a delay of up to 10 minutes. If deprovisioning is detected, Clerk revokes that user's existing sessions and responds to any requests for a new session token with a `401 Unauthorized` error.

It is ultimately the app's responsibility to handle this unauthenticated state and display something appropriate to the user. For example, Next.js apps using [`auth.protect()`](/docs/references/nextjs/auth#auth-protect) will automatically redirect the user to the sign-in page.

## SAML vs. EASIE

The primary security difference between EASIE SSO and SAML SSO is that EASIE depends on a multi-tenant identity provider, while SAML depends on a single-tenant identity provider. Relying on a multi-tenant provider **increases** the risk that a user from one tenant will mistakenly be granted access to the resources of another tenant. While Clerk implements [measures to address this risk](https://easie.dev/#mitigating-tenant-crossover-vulnerabilities:~:text=4.%20Mitigating%20tenant%20crossover%20vulnerabilities), apps that require single-tenant IdPs should opt for SAML.

For more information, see the [EASIE docs](https://easie.dev#security).

## Frequently asked questions (FAQ)

### I've enabled other strategies but they don't work

A Clerk app can have multiple authentication strategies, but a domain that enables Enterprise SSO can't. Once Enterprise SSO is enabled for a domain, there can be no other authentication methods for that specific domain. This is in line with an organization's intent to manage their users' identity from one place. This allows your Clerk app to enable Enterprise SSO connections for certain domains while others use non-Enterprise SSO methods depending on each organization's needs.

### Will Enterprise SSO work for my existing users?

Yes, Enterprise SSO will work for your existing users as well! If you enable SAML or EASIE, any existing users with an email address that matches the SAML or EASIE connection domain will have to authenticate on the IdP side and an Enterprise account will be linked to their existing account.

### What happens if I have multi-factor enabled at Clerk?

Once the user returns from the IdP, they will need to complete additional authentication factors. This is useful if you want to add extra factors beyond what your IdP supports or if your IdP doesnt support them. This feature is optional and can be disabled if not needed.

### What happens if I delete the Enterprise Connection? Will my users be deleted?

The users will not be deleted, so your app will not break. However, they will need to use another [strategy](/docs/authentication/configuration/sign-up-sign-in-options#authentication-strategies) such as password or email to authenticate themselves moving forward.

### Does Clerk support IdP-initiated SSO?

Yes, for SAML only. Clerk supports both Service Provider-initiated (SP-initiated) and Identity Provider-initiated (IdP-initiated) SSO flows. For more information, see the [authentication flows guide](/docs/authentication/enterprise-connections/authentication-flows).

### How much does it cost?

For development instances, Enterprise connections are always free but limited to a maximum of 25.

Production instances require the Pro plan and the Enhanced Authentication Add-on. Please see [pricing](/pricing){{ target: '_blank' }} for more information.

---
title: Enterprise SSO authentication flows
description: Learn about the Enterprise SSO authentication flows.
---

Clerk offers the following types of Enterprise SSO connections: [SAML](#saml), [OIDC](#oidc), and [EASIE](#easie).

## SAML

The SAML protocol supports two methods to start an SSO flow: [Service Provider-initiated (SP-initiated)](#service-provider-initiated-flow-recommended) and [Identity Provider-initiated (IdP-initiated)](#identity-provider-initiated-flow).

For the best security practices, it's recommended to use the SP-initiated flow wherever possible. If you decide to enable IdP-initiated flows, ensure that proper [security measures](#clerks-security-measures), such as MFA and short validation periods, are in place to mitigate the associated risks.

### Service Provider-initiated flow (recommended)

In an SP-initiated flow:

- The user starts the authentication process from your application (Service Provider, or SP), by providing their email address.
- The user is redirected to the SAML provider (Identity Provider, or IdP) where they must authenticate.
- After successful authentication, the user is redirected back to your app, gaining access to their account.

### Identity Provider-initiated flow

In an IdP-initiated flow:

- The user starts the authentication flow from the SAML provider (IdP) by selecting which app (SP) they want to access.
- The user is redirected to the app of their choice, gaining access to their account.

> [!NOTE]
> IdP-Initiated flow carries a [security risk](#risks-of-id-p-initiated-flow). It is recommended to use an SP-Initiated flow whenever possible.

To allow IdP-initiated flows for your SAML connection:

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select **Add connection** and select **For specific domains or organizations**.
1. Select your **Identity Provider**. Complete the fields and select **Add connection**. You'll be redirected to the SAML connection's configuration page.
1. Select the **Advanced** tab.
1. In **Advanced Settings**, enable **Allow IdP-Initiated flow**. A modal will open. Select **Enable** to confirm.
1. Select **Save**.

#### Risks of IdP-initiated flow

While IdP-initiated flows might offer convenience, they are also susceptible to security risks, such as [meddler-in-the-middle (MITM) attacks](https://en.wikipedia.org/wiki/Man-in-the-middle_attack). A bad actor might hijack the IdP response to gain access to a compromised account.

When enabling an IdP-initiated flow, it's possible for Clerk to receive unsolicited authentication requests, which neither the SP nor IdP can verify were initiated by the specified user. Additionally, a bad actor could intercept the IdP response and replace it, performing a CSRF attack to sign in as the attacker.

#### Clerk's security measures

To mitigate the risks associated with IdP-initiated flows, Clerk implements several security measures:

- **Unsolicited `InResponseTo` attribute**: Clerk ensures that unsolicited responses don't contain an `InResponseTo` attribute, in accordance with the [SAML 2.0 profiles specification](https://docs.oasis-open.org/security/saml/v2.0/saml-profiles-2.0-os.pdf). This prevents bad actors from stealing a response used in an SP-initiated flow and using it in an IdP-initiated flow.
- **Replay detection**: Clerk consumes and remembers each response to prevent re-use. This ensures that bad actors cannot steal and reuse a response to gain access to a user's account.
- **Multi-factor authentication**: Clerk supports [multi-factor authentication (MFA)](/docs/authentication/configuration/sign-up-sign-in-options#multi-factor-authentication) for SAML IdP-initiated flows. MFA requires users to provide two or more forms of verification, which significantly enhances security by reducing the risk of unauthorized access.
- **Use small validation periods**: Each SAML response contains a timestamp indicating when it was issued and when it will expire. Since IdP-initiated flows are expected to be completed within seconds, validation periods must be as small as possible to prevent attacks. Common IdP providers such as Azure, Google, and Okta handle this by default. However, if you're using a custom IdP, you must ensure that the validation periods are set correctly.

## OIDC

Clerk supports Enterprise SSO via the OpenID Connect (OIDC) protocol, either through [EASIE](#easie) or by [integrating with any OIDC-compatible provider](/docs/authentication/enterprise-connections/oidc/custom-provider).

### EASIE

EASIE connections support the authentication flows described at [easie.dev](https://easie.dev).

---
title: Entitlement errors
description: An index of Clerk errors related to entitlements.
type: reference
---

An index of Clerk errors related to entitlements.

## `FormInvalidEntitlementKey`

Signifies an error when no domain with the given ID was found.

```json
{
  "shortMessage": "invalid key format",
  "longMessage": "<value> cannot be used as an entitlement key. An entitlement key should have the following format: <scope>:<feature> Both `scope` and `feature` should only contain alphanumeric characters without any spaces.",
  "code": "form_invalid_entitlement_key_code"
}
```

## <code>EntitlementAlready<wbr />AssociatedWithProduct</code>

Signifies an error when the given entitlement is already associated with the product.

```json
{
  "shortMessage": "already associated",
  "longMessage": "The given entitlement is already associated with the product.",
  "code": "entitlement_already_associated_code"
}
```

---
title: Error handling
description: Provide your users with useful information about the errors being returned from sign-up and sign-in requests.
---

Clerk-related errors are returned as an array of [`ClerkAPIError`](/docs/references/javascript/types/clerk-api-error) objects. These errors contain a `code`, `message`, `longMessage` and `meta` property. These properties can be used to provide your users with useful information about the errors being returned from sign-up and sign-in requests.

> [!TIP]
> To see a list of all possible errors, refer to the [Errors](/docs/errors/overview) documentation.

## Example

The following example uses the [email & password sign-in custom flow](/docs/custom-flows/email-password) to demonstrate how to handle errors returned during the sign-in process.

<Tabs items={["Next.js", "JavaScript"]}>
  <Tab>
    This example is written for Next.js App Router but it can be adapted for any React-based framework.

    ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx', mark: [[6, 7], 13, [21, 22], [45, 48], [79, 85]] }}
    'use client'

    import * as React from 'react'
    import { useSignIn } from '@clerk/nextjs'
    import { useRouter } from 'next/navigation'
    import { ClerkAPIError } from '@clerk/types'
    import { isClerkAPIResponseError } from '@clerk/nextjs/errors'

    export default function SignInForm() {
      const { isLoaded, signIn, setActive } = useSignIn()
      const [email, setEmail] = React.useState('')
      const [password, setPassword] = React.useState('')
      const [errors, setErrors] = React.useState<ClerkAPIError[]>()

      const router = useRouter()

      // Handle the submission of the sign-in form
      const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault()

        // Clear any errors that may have occurred during previous form submission
        setErrors(undefined)

        if (!isLoaded) {
          return
        }

        // Start the sign-in process using the email and password provided
        try {
          const signInAttempt = await signIn.create({
            identifier: email,
            password,
          })

          // If sign-in process is complete, set the created session as active
          // and redirect the user
          if (signInAttempt.status === 'complete') {
            await setActive({ session: signInAttempt.createdSessionId })
            router.push('/')
          } else {
            // If the status is not complete, check why. User may need to
            // complete further steps.
            console.error(JSON.stringify(signInAttempt, null, 2))
          }
        } catch (err) {
          if (isClerkAPIResponseError(err)) setErrors(err.errors)
          console.error(JSON.stringify(err, null, 2))
        }
      }

      // Display a form to capture the user's email and password
      return (
        <>
          <h1>Sign in</h1>
          <form onSubmit={(e) => handleSubmit(e)}>
            <div>
              <label htmlFor="email">Enter email address</label>
              <input
                onChange={(e) => setEmail(e.target.value)}
                id="email"
                name="email"
                type="email"
                value={email}
              />
            </div>
            <div>
              <label htmlFor="password">Enter password</label>
              <input
                onChange={(e) => setPassword(e.target.value)}
                id="password"
                name="password"
                type="password"
                value={password}
              />
            </div>
            <button type="submit">Sign in</button>
          </form>

          {errors && (
            <ul>
              {errors.map((el, index) => (
                <li key={index}>{el.longMessage}</li>
              ))}
            </ul>
          )}
        </>
      )
    }
    ```
  </Tab>

  <Tab>
    <CodeBlockTabs options={["index.html", "main.js"]}>
      ```html {{ filename: 'index.html', mark: [22] }}
      <!doctype html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Clerk + JavaScript App</title>
        </head>
        <body>
          <div id="signed-in"></div>

          <div id="sign-in">
            <h2>Sign in</h2>
            <form id="sign-in-form">
              <label for="email">Enter email address</label>
              <input name="email" id="sign-in-email" />
              <label for="password">Enter password</label>
              <input name="password" id="sign-in-password" />
              <button type="submit">Continue</button>
            </form>
          </div>

          <p id="error"></p>

          <script type="module" src="/src/main.js" async crossorigin="anonymous"></script>
        </body>
      </html>
      ```

      ```js {{ filename: 'main.js', mark: [[43, 49]] }}
      import { Clerk } from '@clerk/clerk-js'

      const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

      const clerk = new Clerk(pubKey)
      await clerk.load()

      if (clerk.user) {
        // Mount user button component
        document.getElementById('signed-in').innerHTML = `
            <div id="user-button"></div>
          `

        const userbuttonDiv = document.getElementById('user-button')

        clerk.mountUserButton(userbuttonDiv)
      } else {
        // Handle the sign-in form
        document.getElementById('sign-in-form').addEventListener('submit', async (e) => {
          e.preventDefault()

          const formData = new FormData(e.target)
          const emailAddress = formData.get('email')
          const password = formData.get('password')

          try {
            // Start the sign-in process
            const signInAttempt = await clerk.client.signIn.create({
              identifier: emailAddress,
              password,
            })

            // If the sign-in is complete, set the user as active
            if (signInAttempt.status === 'complete') {
              await clerk.setActive({ session: signInAttempt.createdSessionId })

              location.reload()
            } else {
              // If the status is not complete, check why. User may need to
              // complete further steps.
              console.error(JSON.stringify(signInAttempt, null, 2))
            }
          } catch (error) {
            if (isClerkAPIResponseError(err)) {
              const errors = err.errors
              document.getElementById('error').textContent = errors[0].longMessage
            }
            console.error(JSON.stringify(err, null, 2))
          }
        })
      }
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

## Special error cases

### User locked

If you have [account lockout](/docs/security/user-lock-guide) enabled on your instance and the user reaches the maximum allowed attempts ([see list of relevant actions here](/docs/security/user-lock-guide#actions)), you will receive an HTTP status of `403 (Forbidden)` and the following error payload:

```json
{
  "errors": [
    {
      "message": "Account locked",
      "long_message": "Your account is locked. You will be able to try again in 30 minutes. For more information, contact support.",
      "code": "user_locked",
      "meta": {
        "lockout_expires_in_seconds": 1800
      }
    }
  ]
}
```

`lockout_expires_in_seconds` represents the time remaining until the user is able to attempt authentication again.
In the above example, 1800 seconds (or 30 minutes) are left until they are able to retry, as of the current moment.

The admin might have [configured](/docs/security/customize-user-lockout) e.g. a 45-minute lockout duration.
Thus, 15 minutes after one has been locked, 30 minutes will still remain until the lockout lapses.

You can opt to render the error message returned as-is or format the supplied `lockout_expires_in_seconds` value as per your liking in your own custom error message.

For instance, if you wish to inform a user at which absolute time they will be able to try again, you could add the remaining seconds to the current time and format the resulting timestamp.

<Tabs items={["Next.js"]}>
  <Tab>
    ```js {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx' }}
    if (errors[0].code === 'user_locked') {
      // Get the current date and time
      let currentDate = new Date()

      // Add the remaining seconds until lockout expires
      currentDate.setSeconds(currentDate.getSeconds() + errors[0].meta.lockout_expires_in_seconds)

      // Format the resulting date and time into a human-readable string
      const lockoutExpiresAt = currentDate.toLocaleString()

      // Do something with lockoutExpiresAt
      console.log('Your account is locked, you will be able to try again at ' + lockoutExpiresAt)
    }
    ```
  </Tab>
</Tabs>

---
title: Errors overview
description: A breakdown of all Clerk's errors.
---

Clerk uses a set of error codes to communicate the status of an operation.

An error's type is not always enough to understand what went wrong. In these cases, Clerk provides a more detailed error message that can help you understand the issue. Select the appropriate category in the sidenav to see the list of errors and their descriptions.

---
title: Expo Quickstart
description: Add authentication and user management to your Expo app with Clerk.
---

<TutorialHero
  exampleRepo={[
    {
      title: "Expo quickstart repo",
      link: "https://github.com/clerk/clerk-expo-quickstart",
    },
  ]}
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Create an Expo app",
      link: "https://docs.expo.dev/get-started/create-a-project/",
      icon: "expo",
    },
  ]}
/>

> [!NOTE]
> Ensure that the Native API is enabled to integrate Clerk in your native application. In the Clerk Dashboard, navigate to the [**Native Applications**](https://dashboard.clerk.com/last-active?path=/native-applications) page.

<Steps>
  ## Install `@clerk/clerk-expo`

  The [Clerk Expo SDK](/docs/references/expo/overview) gives you access to prebuilt components, hooks, and helpers to make user authentication easier.

  Run the following command to install the SDK:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/clerk-expo
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/clerk-expo
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/clerk-expo
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @clerk/clerk-expo
    ```
  </CodeBlockTabs>

  ## Set your Clerk API keys

  <SignedIn>
    Add your Clerk Publishable Key to your `.env` file. It can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
  </SignedIn>

  <SignedOut>
    1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
    1. In the **Quick Copy** section, copy your Clerk Publishable Key.
    1. Paste your key into your `.env` file.

    The final result should resemble the following:
  </SignedOut>

  ```env {{ filename: '.env' }}
  EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
  ```

  ## Add `<ClerkProvider>` to your root layout

  <Include src="_partials/clerk-provider/explanation" />

  Add the component to your root layout as shown in the following example:

  ```tsx {{ filename: 'app/_layout.tsx' }}
  import { ClerkProvider } from '@clerk/clerk-expo'
  import { Slot } from 'expo-router'

  export default function RootLayout() {
    return (
      <ClerkProvider>
        <Slot />
      </ClerkProvider>
    )
  }
  ```

  ## Configure the token cache

  Clerk stores the active user's session token in memory by default. In Expo apps, the recommended way to store sensitive data, such as tokens, is by using `expo-secure-store` which encrypts the data before storing it.

  To use `expo-secure-store` as your token cache:

  1. Run the following command to install the library:

     <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
       ```bash {{ filename: 'terminal' }}
       npm install expo-secure-store
       ```

       ```bash {{ filename: 'terminal' }}
       yarn add expo-secure-store
       ```

       ```bash {{ filename: 'terminal' }}
       pnpm add expo-secure-store
       ```

       ```bash {{ filename: 'terminal' }}
       bun add expo-secure-store
       ```
     </CodeBlockTabs>
  1. Update your root layout to use the secure token cache:
     ```tsx {{ filename: 'app/_layout.tsx', mark: [2, 7] }}
     import { ClerkProvider } from '@clerk/clerk-expo'
     import { tokenCache } from '@clerk/clerk-expo/token-cache'
     import { Slot } from 'expo-router'

     export default function RootLayout() {
       return (
         <ClerkProvider tokenCache={tokenCache}>
           <Slot />
         </ClerkProvider>
       )
     }
     ```

  > [!TIP]
  > When you sign a user out with [`signOut()`](/docs/hooks/use-auth#returns), Clerk will remove the user's session JWT from the token cache.

  ## Add sign-up and sign-in pages

  Clerk currently only supports [control components](/docs/components/overview#control-components) for Expo native. UI components are only available for Expo web. Instead, you must build [custom flows](/docs/custom-flows/overview) using Clerk's API. The following sections demonstrate how to build [custom email/password sign-up and sign-in flows](/docs/custom-flows/email-password). If you want to use different authentication methods, such as passwordless or OAuth, see the dedicated custom flow guides.

  ### Layout page

  First, protect your sign-up and sign-in pages.

  1. Create an `(auth)` [route group](https://docs.expo.dev/router/advanced/shared-routes/). This will group your sign-up and sign-in pages.
  1. In the `(auth)` group, create a `_layout.tsx` file with the following code. The [`useAuth()`](/docs/hooks/use-auth) hook is used to access the user's authentication state. If the user is already signed in, they will be redirected to the home page.

  ```tsx {{ filename: 'app/(auth)/_layout.tsx' }}
  import { Redirect, Stack } from 'expo-router'
  import { useAuth } from '@clerk/clerk-expo'

  export default function AuthRoutesLayout() {
    const { isSignedIn } = useAuth()

    if (isSignedIn) {
      return <Redirect href={'/'} />
    }

    return <Stack />
  }
  ```

  ### Sign-up page

  In the `(auth)` group, create a `sign-up.tsx` file with the following code. The [`useSignUp()`](/docs/hooks/use-sign-up) hook is used to create a sign-up flow. The user can sign up using their email and password and will receive an email verification code to confirm their email.

  ```tsx {{ filename: 'app/(auth)/sign-up.tsx', collapsible: true }}
  import * as React from 'react'
  import { Text, TextInput, TouchableOpacity, View } from 'react-native'
  import { useSignUp } from '@clerk/clerk-expo'
  import { Link, useRouter } from 'expo-router'

  export default function SignUpScreen() {
    const { isLoaded, signUp, setActive } = useSignUp()
    const router = useRouter()

    const [emailAddress, setEmailAddress] = React.useState('')
    const [password, setPassword] = React.useState('')
    const [pendingVerification, setPendingVerification] = React.useState(false)
    const [code, setCode] = React.useState('')

    // Handle submission of sign-up form
    const onSignUpPress = async () => {
      if (!isLoaded) return

      console.log(emailAddress, password)

      // Start sign-up process using email and password provided
      try {
        await signUp.create({
          emailAddress,
          password,
        })

        // Send user an email with verification code
        await signUp.prepareEmailAddressVerification({ strategy: 'email_code' })

        // Set 'pendingVerification' to true to display second form
        // and capture OTP code
        setPendingVerification(true)
      } catch (err) {
        // See https://clerk.com/docs/custom-flows/error-handling
        // for more info on error handling
        console.error(JSON.stringify(err, null, 2))
      }
    }

    // Handle submission of verification form
    const onVerifyPress = async () => {
      if (!isLoaded) return

      try {
        // Use the code the user provided to attempt verification
        const signUpAttempt = await signUp.attemptEmailAddressVerification({
          code,
        })

        // If verification was completed, set the session to active
        // and redirect the user
        if (signUpAttempt.status === 'complete') {
          await setActive({ session: signUpAttempt.createdSessionId })
          router.replace('/')
        } else {
          // If the status is not complete, check why. User may need to
          // complete further steps.
          console.error(JSON.stringify(signUpAttempt, null, 2))
        }
      } catch (err) {
        // See https://clerk.com/docs/custom-flows/error-handling
        // for more info on error handling
        console.error(JSON.stringify(err, null, 2))
      }
    }

    if (pendingVerification) {
      return (
        <>
          <Text>Verify your email</Text>
          <TextInput
            value={code}
            placeholder="Enter your verification code"
            onChangeText={(code) => setCode(code)}
          />
          <TouchableOpacity onPress={onVerifyPress}>
            <Text>Verify</Text>
          </TouchableOpacity>
        </>
      )
    }

    return (
      <View>
        <>
          <Text>Sign up</Text>
          <TextInput
            autoCapitalize="none"
            value={emailAddress}
            placeholder="Enter email"
            onChangeText={(email) => setEmailAddress(email)}
          />
          <TextInput
            value={password}
            placeholder="Enter password"
            secureTextEntry={true}
            onChangeText={(password) => setPassword(password)}
          />
          <TouchableOpacity onPress={onSignUpPress}>
            <Text>Continue</Text>
          </TouchableOpacity>
          <View style={{ display: 'flex', flexDirection: 'row', gap: 3 }}>
            <Text>Already have an account?</Text>
            <Link href="/sign-in">
              <Text>Sign in</Text>
            </Link>
          </View>
        </>
      </View>
    )
  }
  ```

  ### Sign-in page

  In the `(auth)` group, create a `sign-in.tsx` file with the following code. The [`useSignIn()`](/docs/hooks/use-sign-in) hook is used to create a sign-in flow. The user can sign in using email address and password, or navigate to the sign-up page.

  ```tsx {{ filename: 'app/(auth)/sign-in.tsx', collapsible: true }}
  import { useSignIn } from '@clerk/clerk-expo'
  import { Link, useRouter } from 'expo-router'
  import { Text, TextInput, TouchableOpacity, View } from 'react-native'
  import React from 'react'

  export default function Page() {
    const { signIn, setActive, isLoaded } = useSignIn()
    const router = useRouter()

    const [emailAddress, setEmailAddress] = React.useState('')
    const [password, setPassword] = React.useState('')

    // Handle the submission of the sign-in form
    const onSignInPress = async () => {
      if (!isLoaded) return

      // Start the sign-in process using the email and password provided
      try {
        const signInAttempt = await signIn.create({
          identifier: emailAddress,
          password,
        })

        // If sign-in process is complete, set the created session as active
        // and redirect the user
        if (signInAttempt.status === 'complete') {
          await setActive({ session: signInAttempt.createdSessionId })
          router.replace('/')
        } else {
          // If the status isn't complete, check why. User might need to
          // complete further steps.
          console.error(JSON.stringify(signInAttempt, null, 2))
        }
      } catch (err) {
        // See https://clerk.com/docs/custom-flows/error-handling
        // for more info on error handling
        console.error(JSON.stringify(err, null, 2))
      }
    }

    return (
      <View>
        <Text>Sign in</Text>
        <TextInput
          autoCapitalize="none"
          value={emailAddress}
          placeholder="Enter email"
          onChangeText={(emailAddress) => setEmailAddress(emailAddress)}
        />
        <TextInput
          value={password}
          placeholder="Enter password"
          secureTextEntry={true}
          onChangeText={(password) => setPassword(password)}
        />
        <TouchableOpacity onPress={onSignInPress}>
          <Text>Continue</Text>
        </TouchableOpacity>
        <View style={{ display: 'flex', flexDirection: 'row', gap: 3 }}>
          <Text>Don't have an account?</Text>
          <Link href="/sign-up">
            <Text>Sign up</Text>
          </Link>
        </View>
      </View>
    )
  }
  ```

  For more information about building these custom flows, including guided comments in the code examples, see the [Build a custom email/password authentication flow](/docs/custom-flows/email-password) guide.

  ## Add a sign-out button

  At this point, your users can sign up or in, but they need a way to sign out.

  In the `components/` folder, create a `SignOutButton.tsx` file with the following code. The [`useClerk()`](/docs/hooks/use-clerk) hook is used to access the `signOut()` function, which is called when the user clicks the "Sign out" button.

  <Include src="_partials/expo/sign-out-custom-flow" />

  ## Conditionally render content

  You can control which content signed-in and signed-out users can see with Clerk's [prebuilt control components](/docs/components/overview#control-components). For this quickstart, you'll use:

  - [`<SignedIn>`](/docs/components/control/signed-in): Children of this component can only be seen while **signed in**.
  - [`<SignedOut>`](/docs/components/control/signed-out): Children of this component can only be seen while **signed out**.

  To get started:

  1. Create a `(home)` route group.
  1. In the `(home)` group, create a `_layout.tsx` file with the following code.

  ```tsx {{ filename: 'app/(home)/_layout.tsx' }}
  import { Stack } from 'expo-router/stack'

  export default function Layout() {
    return <Stack />
  }
  ```

  Then, in the same folder, create an `index.tsx` file with the following code. If the user is signed in, it displays their email and a sign-out button. If they're not signed in, it displays sign-in and sign-up links.

  ```tsx {{ filename: 'app/(home)/index.tsx' }}
  import { SignedIn, SignedOut, useUser } from '@clerk/clerk-expo'
  import { Link } from 'expo-router'
  import { Text, View } from 'react-native'
  import { SignOutButton } from '@/app/components/SignOutButton'

  export default function Page() {
    const { user } = useUser()

    return (
      <View>
        <SignedIn>
          <Text>Hello {user?.emailAddresses[0].emailAddress}</Text>
          <SignOutButton />
        </SignedIn>
        <SignedOut>
          <Link href="/(auth)/sign-in">
            <Text>Sign in</Text>
          </Link>
          <Link href="/(auth)/sign-up">
            <Text>Sign up</Text>
          </Link>
        </SignedOut>
      </View>
    )
  }
  ```

  ## Create your first user

  Run your project with the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun" ]}>
    ```bash {{ filename: 'terminal' }}
    npm start
    ```

    ```bash {{ filename: 'terminal' }}
    yarn start
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm start
    ```

    ```bash {{ filename: 'terminal' }}
    bun start
    ```
  </CodeBlockTabs>

  Now visit your app's homepage at [`http://localhost:8081`](http://localhost:8081). Sign up to create your first user.
</Steps>

## Enable OTA updates

Though not required, it is recommended to implement over-the-air (OTA) updates in your Expo app. This enables you to easily roll out Clerk's feature updates and security patches as they're released without having to resubmit your app to mobile marketplaces.

See the [`expo-updates`](https://docs.expo.dev/versions/latest/sdk/updates) library to learn how to get started.

## Next steps

<Cards>
  - [OAuth with Expo](/docs/custom-flows/oauth-connections)
  - Learn more how to build a custom OAuth flow with Expo.

  ---

  - [MFA with Expo](/docs/custom-flows/email-password-mfa)
  - Learn more how to build a custom multi-factor authentication flow with Expo.

  ---

  - [Read session and user data](/docs/references/expo/read-session-user-data)
  - Learn how to read session and user data with Expo.

  ---

  - [Sign-up and sign-in flow](/docs/custom-flows/email-password)
  - Learn how to build a custom sign-up and sign-in authentication flow.
</Cards>

---
title: Export your user's data from Clerk
description: Learn how to export user's data from your Clerk application.
---

## Access user data in the backend

By using the [`GetUserList`](/docs/reference/backend-api/tag/Users#operation/GetUserList){{ target: '_blank' }} Backend API endpoint, you can programmatically export your user's data safely.

Additionally, the [`getUserList()`](/docs/references/backend/user/get-user-list) method in the [JavaScript Backend SDK](/docs/references/backend/overview) can also be used to retrieve a list of users.

## Export your users' data from the Clerk Dashboard

Users who are either admins or are in their personal workspace can export and download a CSV file containing a list of their application's users that _includes their hashed passwords_. Users can also view detailed export and download history logs. These logs offer a record of previous export actions, ensuring visibility and traceability of data exports.

To export your users' data:

1. In the Clerk Dashboard, navigate to the application's [**Settings**](https://dashboard.clerk.com/last-active?path=settings).
1. In the **User Exports** section, select **Export all users**.
1. A new entry in the export history will appear. Select the **Download** button to download the CSV file.

---
title: Express Quickstart
description: Learn how to use Clerk to quickly and easily add secure authentication and user management to your Express server.
---

<TutorialHero
  exampleRepo={[
    {
      title: "Express Quickstart Repo",
      link: "https://github.com/clerk/clerk-express-quickstart"
    }
  ]}
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Create a Express application",
      link: "https://expressjs.com/en/starter/installing.html",
      icon: "expressjs",
    }
  ]}
/>

Learn how to integrate Clerk into your Express backend for secure user authentication and management. This guide focuses on backend implementation and requires a Clerk frontend SDK to function correctly.

<Steps>
  ## Install `@clerk/express`

  The [Clerk Express SDK](/docs/references/express/overview) provides a range of backend utilities to simplify user authentication and management in your application.

  Run the following command to install the SDK:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/express
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/express
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/express
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @clerk/express
    ```
  </CodeBlockTabs>

  ## Set your Clerk API keys

  <SignedIn>
    Add the following keys to your `.env` file. These keys can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
  </SignedIn>

  <SignedOut>
    1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
    1. In the **Quick Copy** section, copy your Clerk Publishable and Secret Keys.
    1. Paste your keys into your `.env` file.

    The final result should resemble the following:
  </SignedOut>

  ```sh {{ filename: '.env' }}
  CLERK_PUBLISHABLE_KEY={{pub_key}}
  CLERK_SECRET_KEY={{secret}}
  ```

  This guide uses `dotenv` to load the environment variables. Run the following command to install it:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install dotenv
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add dotenv
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add dotenv
    ```

    ```bash {{ filename: 'terminal' }}
    bun add dotenv
    ```
  </CodeBlockTabs>

  ## Add `clerkMiddleware()` to your app

  The [`clerkMiddleware()`](/docs/references/express/overview#clerk-middleware) function checks the request's cookies and headers for a session JWT and, if found, attaches the [`Auth`](/docs/references/backend/types/auth-object){{ target: '_blank' }} object to the `request` object under the `auth` key.

  ```ts {{ filename: 'index.ts', mark: [3, 8] }}
  import 'dotenv/config'
  import express from 'express'
  import { clerkMiddleware } from '@clerk/express'

  const app = express()
  const PORT = 3000

  app.use(clerkMiddleware())

  // Start the server and listen on the specified port
  app.listen(PORT, () => {
    console.log(`Example app listening at http://localhost:${PORT}`)
  })
  ```

  ## Protect your routes using `requireAuth()`

  To protect your routes, use the [`requireAuth()`](/docs/references/express/overview#require-auth) middleware. This middleware functions similarly to `clerkMiddleware()`, but also protects your routes by redirecting unauthenticated users to the sign-in page.

  In the following example, `requireAuth()` is used to protect the `/protected` route. If the user isn't authenticated, they're redirected to the homepage. If the user is authenticated, the [`getAuth()`](/docs/references/express/overview#get-auth) function is used to get the `userId`, which is passed to [`clerkClient.users.getUser()`](/docs/references/backend/user/get-user){{ target: '_blank' }} to fetch the current user's `User` object.

  ```ts {{ filename: 'index.ts' }}
  import 'dotenv/config'
  import express from 'express'
  import { clerkClient, requireAuth, getAuth } from '@clerk/express'

  const app = express()
  const PORT = 3000

  // Use requireAuth() to protect this route
  // If user isn't authenticated, requireAuth() will redirect back to the homepage
  app.get('/protected', requireAuth(), async (req, res) => {
    // Use `getAuth()` to get the user's `userId`
    const { userId } = getAuth(req)

    // Use Clerk's JavaScript Backend SDK to get the user's User object
    const user = await clerkClient.users.getUser(userId)

    return res.json({ user })
  })

  // Start the server and listen on the specified port
  app.listen(PORT, () => {
    console.log(`Example app listening at http://localhost:${PORT}`)
  })
  ```

  ## Add global TypeScript type (optional)

  If you're using TypeScript, add a global type reference to your project to enable auto-completion and type checking for the `auth` object in Express request handlers.

  1. In your application's root folder, create a `types/` directory.
  1. Inside this directory, create a `globals.d.ts` file with the following code.

  ```ts {{ filename: 'types/globals.d.ts' }}
  /// <reference types="@clerk/express/env" />
  ```
</Steps>

## Next steps

<Cards>
  - [Use middleware to protect routes](/docs/references/express/overview#require-auth)
  - Learn how to protect specific routes from unauthenticated users.

  ---

  - [Protect routes based on authorization status](/docs/references/express/overview#get-auth)
  - Learn how to protect a route based on both authentication and authorization status.

  ---

  - [Express SDK reference](/docs/references/express/overview)
  - Learn more about additional Express SDK methods.

  ---

  - [Deploy to Production](/docs/deployments/overview)
  - Learn how to deploy your Clerk app to production.
</Cards>

---
title: Fastify Quickstart
description: Learn how to integrate Clerk for secure authentication and user management into your application using a Fastify backend.
---

<TutorialHero
  exampleRepo={[
    {
      title: "Fastify Quickstart",
      link: "https://github.com/clerk/clerk-fastify-quickstart"
    }
  ]}
  beforeYouStart={[
    {
    title: "Set up a Clerk application",
    link: "/docs/quickstarts/setup-clerk",
    icon: "clerk",
    },
    {
      title: "Add Fastify as your backend",
      link: "https://fastify.dev/docs/latest/Guides/Getting-Started",
      icon: "fastify",
    },
  ]}
/>

Learn how to integrate Clerk into your Fastify backend for secure user authentication and management. This guide uses TypeScript and allows you to choose your frontend framework.

> [!IMPORTANT]
> [Fastify is only compatible with Next.js versions 13.4 and below](https://github.com/fastify/fastify-nextjs). If you're using a newer version of Next.js, consider using a different backend framework that supports the latest Next.js features.
>
> This guide uses ECMAScript Modules (ESM). To use ESM in your project, you must include `"type": "module"` in your `package.json`.

<Steps>
  ## Install `@clerk/fastify`

  [Clerk's Fastify SDK](https://github.com/clerk/javascript/tree/main/packages/fastify) provides a range of backend utilities to simplify user authentication and management in your application.

  Run the following command to install the SDK:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/fastify
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/fastify
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/fastify
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @clerk/fastify
    ```
  </CodeBlockTabs>

  ## Set your Clerk API keys

  <SignedIn>
    Add the following keys to your `.env` file. These keys can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
  </SignedIn>

  <SignedOut>
    1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
    1. In the **Quick Copy** section, copy your Clerk Publishable and Secret Keys.
    1. Paste your keys into your `.env` file.

    The final result should resemble the following:
  </SignedOut>

  ```env {{ filename: '.env' }}
  CLERK_PUBLISHABLE_KEY={{pub_key}}
  CLERK_SECRET_KEY={{secret}}
  ```

  ## Configure `clerkPlugin()` for all routes

  The `clerkPlugin()` function is a Fastify plugin provided by Clerk to integrate authentication into your Fastify application. To ensure that Clerk's authentication and user management features are applied across your Fastify application, configure the `clerkPlugin()` to handle all routes or limit it to specific ones.

  The following example registers the plugin for all routes. To register the plugin for specific routes, see the [reference docs](/docs/references/fastify/overview).

  > [!IMPORTANT]
  > The `dotenv/config` module must be imported before any Clerk modules. This order is important because Clerk instances are created during the import process and rely on environment variables, such as API keys, to be initialized correctly. For more information, refer to the [Fastify docs](https://fastify.dev/docs/latest/Guides/Getting-Started/#loading-order-of-your-plugins).

  ```ts {{ filename: 'index.ts' }}
  import 'dotenv/config'
  import Fastify from 'fastify'
  import { clerkPlugin } from '@clerk/fastify'

  const fastify = Fastify({ logger: true })

  fastify.register(clerkPlugin)

  const start = async () => {
    try {
      await fastify.listen({ port: 8080 })
    } catch (error) {
      fastify.log.error(error)
      process.exit(1)
    }
  }

  start()
  ```

  ## Protect your routes using `getAuth()`

  The [`getAuth()`](/docs/references/fastify/overview#get-auth) helper retrieves the current user's authentication state from the `request` object. It returns the [`Auth` object](/docs/references/backend/types/auth-object){{ target: '_blank' }}.

  <Include src="_partials/fastify/get-auth" />
</Steps>

---
title: Feature errors
description: An index of Clerk errors related to features.
type: reference
---

An index of Clerk errors related to features.

## `FeatureNotEnabled`

```json
{
  "shortMessage": "not enabled",
  "longMessage": "This feature is not enabled on this instance",
  "code": "feature_not_enabled_code"
}
```

## `NotImplemented`

```json
{
  "shortMessage": "not implemented",
  "longMessage": "Feature `<feature>` is not available yet",
  "code": "feature_not_implemented_code"
}
```

## `FeatureRequiresPSU`

```json
{
  "shortMessage": "not a Progressive Sign Up instance",
  "longMessage": "<feature> can only be used in instances that migrated to Progressive Sign Up (https://clerk.com/docs/upgrade-guides/progressive-sign-up)",
  "code": "feature_requires_psu_code"
}
```

---
title: Fixation protection
description: Session fixation is an attack that permits an attacker to hijack a valid user session. The attack explores a limitation in the way the web application manages the session ID, more specifically the vulnerable web application. When authenticating a user, it doesnt assign a new session ID, making it possible to use an existent session ID.
---

Session fixation is a security vulnerability that allows an attacker to hijack a valid user session. This vulnerability arises when web applications reuse existing session IDs instead of generating new ones during the authentication process. By exploiting this flaw, attackers can potentially gain unauthorized access to a user's account and perform malicious actions on their behalf.

See the [OWASP Session Fixation](https://owasp.org/www-community/attacks/Session_fixation) page for specific examples of how this attack works.

## How does Clerk protect against session fixation?

Clerk resets the session token each time a user signs in or out of a browser. When the session is reset, the old session token is invalidated and can no longer be used for authentication.

---
title: Force multi-factor authentication (MFA) for all users
description: Learn how to force multi-factor authentication (MFA) for all users in your Clerk application.
---

By default, Clerk does not enforce [multi-factor authentication (MFA)](/docs/authentication/configuration/sign-up-sign-in-options#multi-factor-authentication) for all users. This guide demonstrates how to force MFA for all users by using `clerkMiddleware()` to intercept all requests and check whether a user has MFA enabled. If the user does not have MFA enabled, `clerkMiddleware()` redirects them to the `/mfa` page where they can set up MFA.

<Steps>
  ## Enable MFA in the Clerk Dashboard

  If you haven't already, enable MFA for your users.

  1. In the Clerk Dashboard, navigate to the [**Multi-factor**](https://dashboard.clerk.com/last-active?path=user-authentication/multi-factor) page.
  1. Toggle on the MFA strategies you would like to enable.

  ## Customize the session token to include the `two_factor_enabled` property

  Every `User` object has a `two_factor_enabled` property that indicates whether the user has MFA enabled. Store this property in the session token so that you can check it in your `clerkMiddleware()`.

  1. In the Clerk Dashboard, navigate to the [**Sessions**](https://dashboard.clerk.com/last-active?path=sessions) page.
  1. In the **Customize session token** section, select **Edit**.
  1. In the modal that opens, add a key-value pair to the `Claims` object. The key can be any string, but the value must be the `user.two_factor_enabled` property, as shown in the following example.

  ```json
  {
    "isMfa": "{{user.two_factor_enabled}}"
  }
  ```

  ## Update `clerkMiddleware()`

  Update your `clerkMiddleware()` to check if the user has MFA enabled.

  <Tabs items={['Next.js', 'Astro', 'Nuxt']}>
    <Tab>
      ```tsx {{ filename: 'middleware.ts', collapsible: true }}
      import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'
      import { NextResponse } from 'next/server'

      const isMFARoute = createRouteMatcher(['/account/manage-mfa/add(.*)'])
      const isSignInRoute = createRouteMatcher(['/sign-in(.*)'])

      export default clerkMiddleware(async (auth, req) => {
        const { userId, sessionClaims } = await auth()

        // Redirect to homepage if the user is signed in and on the sign-in page
        if (userId !== null && isSignInRoute(req)) {
          return NextResponse.redirect(new URL('/', req.url))
        }

        // Redirect to MFA setup page if MFA is not enabled
        if (userId !== null && !isMFARoute(req)) {
          if (sessionClaims.isMfa === undefined) {
            console.error('You need to add the `isMfa` claim to your session token.')
          }
          if (sessionClaims.isMfa === false) {
            return NextResponse.redirect(new URL('/account/manage-mfa/add', req.url))
          }
        }
      })

      export const config = {
        matcher: [
          // Skip Next.js internals and all static files, unless found in search params
          '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
          // Always run for API routes
          '/(api|trpc)(.*)',
        ],
      }
      ```
    </Tab>

    <Tab>
      ```tsx {{ filename: 'src/middleware.ts', collapsible: true }}
      import { clerkMiddleware, createRouteMatcher } from '@clerk/astro/server'

      const isMFARoute = createRouteMatcher(['/account/manage-mfa/add(.*)'])
      const isSignInRoute = createRouteMatcher(['/sign-in(.*)'])

      export const onRequest = clerkMiddleware((auth, context) => {
        const { userId, sessionClaims } = auth()

        // Redirect to homepage if the user is signed in and on the sign-in page
        if (userId !== null && isSignInRoute(context.request)) {
          return Response.redirect(new URL('/', context.request.url))
        }

        // Redirect to MFA setup page if MFA is not enabled
        if (userId !== null && !isMFARoute(context.request)) {
          if (sessionClaims.isMfa === undefined) {
            console.error('You need to add the `isMfa` claim to your session token.')
          }
          if (sessionClaims.isMfa === false) {
            return Response.redirect(new URL('/account/manage-mfa/add', context.request.url))
          }
        }
      })

      export const config = {
        matcher: [
          // Skip Next.js internals and all static files, unless found in search params
          '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
          // Always run for API routes
          '/(api|trpc)(.*)',
        ],
      }
      ```
    </Tab>

    <Tab>
      By default, the Nuxt SDK automatically adds [the `clerkMiddleware()` helper](/docs/references/nuxt/clerk-middleware) to your Nuxt application. To manually configure the middleware, in your `nuxt.config.ts` file, under the `clerk` property, set `skipServerMiddleware: true`.

      ```tsx {{ filename: 'nuxt.config.ts', mark: [[3, 5]] }}
      export default defineNuxtConfig({
        modules: ['@clerk/nuxt'],
        clerk: {
          skipServerMiddleware: true,
        },
      })
      ```

      Then, in your `server/middleware/clerk.ts` file, add the following code:

      ```tsx {{ filename: 'server/middleware/clerk.ts', collapsible: true }}
      import { clerkMiddleware } from '@clerk/nuxt/server'

      export default clerkMiddleware(async (event) => {
        const isMFARoute = event.path.startsWith('/account/manage-mfa/add')
        const isSignInRoute = event.path.startsWith('/sign-in')

        const { userId, sessionClaims } = event.context.auth()

        // Redirect to homepage if the user is signed in and on the sign-in page
        if (userId !== null && isSignInRoute) {
          throw createError({
            statusMessage: 'You are already signed in.',
          })
        }

        // Redirect to MFA setup page if MFA is not enabled
        if (userId !== null && !isMFARoute) {
          if (sessionClaims.isMfa === undefined) {
            throw createError({
              statusMessage: 'You need to add the `isMfa` claim to your session token.',
            })
          }
          if (sessionClaims.isMfa === false) {
            throw createError({
              statusMessage: 'You need to enable MFA for your account.',
            })
          }
        }
      })

      export const config = {
        matcher: [
          // Skip Next.js internals and all static files, unless found in search params
          '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
          // Always run for API routes
          '/(api|trpc)(.*)',
        ],
      }
      ```
    </Tab>
  </Tabs>

  ## Build your MFA setup page

  Follow the [custom flow guide](/docs/custom-flows/manage-totp-based-mfa) to build the `/account/manage-mfa/add` page.
</Steps>

---
title: Form errors
description: An index of Clerk errors related to forms.
type: reference
---

An index of Clerk errors related to forms.

## `FormPasswordLengthTooShortCode`

Signifies an error when the password is invalid because it is too short.

```json
{
  "shortMessage": "Passwords must be %d characters or more.",
  "code": "form_password_length_too_short"
}
```

## `FormInvalidPasswordLengthTooLong`

Signifies an error when the password is invalid because it is too long.

```json
{
  "shortMessage": "Passwords must be less than %d characters.",
  "code": "form_password_length_too_long"
}
```

## `FormPasswordIncorrectCode`

Signifies an error when the given password is incorrect.

```json
{
  "shortMessage": "Password is incorrect. Try again, or use another method.",
  "code": "form_password_incorrect"
}
```

## `FormIdentifierNotFoundCode`

Signifies an error when a required [identifier](/docs/authentication/configuration/sign-up-sign-in-options#identifiers) is not found.

```json
{
  "shortMessage": "Couldn't find your account.",
  "code": "form_identifier_not_found"
}
```

## `FormIdentifierExistsCode`

Signifies an error when a given [identifier](/docs/authentication/configuration/sign-up-sign-in-options#identifiers) already exists.

```json
{
  "shortMessage": "That %s is taken. Please try another.",
  "code": "form_identifier_exists"
}
```

---
title: Frontend-only SDK
description: A reference for implementing a frontend-only Clerk SDK
---

While [ClerkJS](/docs/references/javascript/overview) can be used in any browser context and framework, realistically users expect to consume its features through the conventions and syntax of their framework of choice. For example, `@clerk/clerk-react` turns ClerkJS into React components, `@clerk/astro` into Astro components, and so on.

In non-browser environments, youll need to re-implement the [Clerk class](/docs/references/javascript/clerk) in the SDKs programming language, interacting with the [FAPI](/docs/references/sdk/terminology).

## Expected features

- User only needs to provide their [Publishable Key](/docs/references/sdk/terminology)
- User only needs to adjust one or two files to add Clerk to their app (e.g. adding Clerk to the configuration file of that framework)
- User can use [Clerks components](/docs/components/overview) in their choice of framework (e.g. in a React-based framework you import these components as React components)
- Give users access to [`Client`](/docs/references/javascript/client){{ target: '_blank' }}, [`Session`](/docs/references/javascript/session){{ target: '_blank' }}, [`User`](/docs/references/javascript/user){{ target: '_blank' }}, and [`Organization`](/docs/references/javascript/organization){{ target: '_blank' }} properties through the frameworks choice of state management
- User should be able to use [ClerkJS options](/docs/references/javascript/clerk#clerk-options){{ target: '_blank' }}

## Implementation

While the implementation details will vary for each SDK, there are certain steps you'll have to go through in any case. Consider the steps below a rough guidance on what needs to be done, and also remember to follow the [conventions](/docs/references/sdk/conventions).

> [!NOTE]
> The code blocks below will be written in pseudo-code. If you're looking for real-world examples, have a look at these repositories: [`@clerk/clerk-react`](https://github.com/clerk/javascript/tree/main/packages/react), [`@clerk/astro`](https://github.com/clerk/javascript/tree/main/packages/astro)

<Steps>
  ### Create a Clerk instance

  Create a Clerk instance that will only be invoked once (e.g. following the [singleton pattern](https://www.patterns.dev/vanilla/singleton-pattern/)). During its initialization you'll execute the following steps.

  ```ts {{ mark: [5], filename: 'create-clerk-instance.ts' }}
  import { runOnce } from './utils'
  // States accessible to other parts of your SDK and/or its users
  import { $clerk, $state } from './stores'

  export const createClerkInstance = runOnce(createClerkInstanceInternal)

  async function createClerkInstanceInternal(options) {
    let clerkJSInstance = window.Clerk
  }
  ```

  ### Hotload ClerkJS

  In order to make `Clerk` available on the `window` object, your SDK needs to load ClerkJS. Call `loadClerkJsScript()` from `@clerk/shared`.

  ```ts {{ mark: [1, [10, 17]], filename: 'create-clerk-instance.ts' }}
  import { loadClerkJSScript } from '@clerk/shared/loadClerkJSScript'
  import { runOnce } from './utils'
  import { $clerk, $state } from './stores'

  export const createClerkInstance = runOnce(createClerkInstanceInternal)

  async function createClerkInstanceInternal(options) {
    let clerkJSInstance = window.Clerk

    if (!clerkJSInstance) {
      await loadClerkJSScript(options)

      if (!window.Clerk) {
        throw new Error('Failed to download latest ClerkJS.')
      }
      clerkJSInstance = window.Clerk
    }

    if (!$clerk.get()) {
      $clerk.set(clerkJSInstance)
    }
  }
  ```

  ### Call `window.Clerk.load()`

  By calling [`window.Clerk.load()`](/docs/references/javascript/clerk#load) the Clerk class is initialized and your SDK now has access to all its functionality.

  ```ts {{ mark: [18], filename: 'create-clerk-instance.ts' }}
  import { loadClerkJSScript } from '@clerk/shared/loadClerkJSScript'
  import { runOnce } from './utils'
  import { $clerk, $state } from './stores'

  export const createClerkInstance = runOnce(createClerkInstanceInternal)

  async function createClerkInstanceInternal(options) {
    let clerkJSInstance = window.Clerk

    if (!clerkJSInstance) {
      // loadClerkJSScript() codepath
    }

    if (!$clerk.get()) {
      $clerk.set(clerkJSInstance)
    }

    await clerkJSInstance.load(options)
  }
  ```

  ### Add event listeners

  Expose properties to the internal state (e.g. a `useState` in React) through adding [event listeners](/docs/references/javascript/clerk#add-listener).

  ```ts {{ mark: [[20, 27]], filename: 'create-clerk-instance.ts' }}
  import { loadClerkJSScript } from '@clerk/shared/loadClerkJSScript'
  import { runOnce } from './utils'
  import { $clerk, $state } from './stores'

  export const createClerkInstance = runOnce(createClerkInstanceInternal)

  async function createClerkInstanceInternal(options) {
    let clerkJSInstance = window.Clerk

    if (!clerkJSInstance) {
      // loadClerkJSScript() codepath
    }

    await clerkJSInstance.load(options)

    if (!$clerk.get()) {
      $clerk.set(clerkJSInstance)
    }

    clerkJSInstance.addListener((resources) => {
      $state.setKey('client', resources.client)
      $state.setKey('session', resources.session)
      $state.setKey('user', resources.user)
      $state.setKey('organization', resources.organization)
    })
  }
  ```

  ### Add UI components

  Build out the components that your users will utilize in their app. Call the `mount()` function when the component is in view/mounts and the `unmount()` function when the component is unmounted. These functions are described in the [`Clerk` class components](/docs/references/javascript/clerk#components).

  Use the idiomatic way of your framework for doing this. If you can abstract these repetitions into a re-usable hook/directive, then do that.

  ```tsx {{ filename: 'SignIn.tsx' }}
  import { $clerk } from './stores'

  const SignInComponent = (props: SignInProps) => {
    const el = ref()

    function onMount() {
      $clerk.mountSignIn(el, props)
    }

    function onUnMount() {
      $clerk.unmountSignIn(el)
    }
  }
  ```
</Steps>

---
title: Fullstack SDK
description: A reference for implementing a fullstack Clerk SDK
---

A fullstack SDK combines the [frontend-only SDK](/docs/references/sdk/frontend-only) and [backend-only SDK](/docs/references/sdk/backend-only) into one. A fullstack SDK is necessary for frameworks that support multiple rendering strategies (SSR, SSG, etc.), middleware, data fetching, and more. Examples of such frameworks would be Next.js or Rails.

## Expected features

- User only needs to provide their [Publishable Key](/docs/references/sdk/terminology) and [Secret Key](/docs/references/sdk/terminology)
- User only needs to adjust one or two files to add Clerk to their app (e.g. adding Clerk to the configuration file of that framework)
- User can use [Clerks components](/docs/components/overview) in their choice of framework (e.g. in a React-based framework you import these components as React components)
- Give users access to [`Client`](/docs/references/javascript/client){{ target: '_blank' }}, [`Session`](/docs/references/javascript/session){{ target: '_blank' }}, [`User`](/docs/references/javascript/user){{ target: '_blank' }}, and [`Organization`](/docs/references/javascript/organization){{ target: '_blank' }} properties through the frameworks choice of state management
- User should be able to use [ClerkJS options](/docs/references/javascript/clerk#clerk-options){{ target: '_blank' }}
- Centralized request authentication (e.g. in a middleware or plugin)
- Give access to the instance of [BAPI](/docs/references/sdk/terminology) client (so that users can use all methods)
- User should be able to limit access to routes by checking for [roles and permissions](/docs/organizations/roles-permissions)

## Optional features

- User should be able to enforce authentication on individual routes (e.g. with a [`requireAuth`](/docs/references/sdk/backend-only#create-a-require-auth-helper) helper)
- Use singleton pattern to only create a pre-configured instance of Clerk backend client

## Implementation

See the respective [frontend-only SDK](/docs/references/sdk/frontend-only) and [backend-only SDK](/docs/references/sdk/backend-only) implementation instructions.

In addition to these instructions, you'll need to go through the following steps to support all required features.

> [!NOTE]
> If you're looking for a real-world example, have a look at [`@clerk/nextjs`](https://github.com/clerk/javascript/tree/main/packages/nextjs).

<Steps>
  ### Add handshake support

  Inside your Clerk middleware, add checks for the `headers` on the `requestState`. Apply these headers to the `Response` and handle any existing `location` headers (e.g. redirects).

  ```ts {{ filename: 'clerk-middleware.ts', mark: [[9, 20]] }}
  import { clerkClient as defaultClerkClient } from './client.ts'

  const clerkMiddleware = (options) => {
    return async (context, next) => {
      const clerkClient = options.clerkClient || defaultClerkClient

      const requestState = await clerkClient.authenticateRequest(context.req, {
        authorizedParties: ['https://example.com'],
      })

      if (requestState.headers) {
        // This adds observability headers to the res
        requestState.headers.forEach((value, key) => context.res.headers.append(key, value))

        const locationHeader = requestState.headers.get('location')

        if (locationHeader) {
          return context.redirect(locationHeader, 307)
        } else if (requestState.status === 'handshake') {
          throw new Error('Clerk: unexpected handshake without redirect')
        }
      }

      context.set('clerkAuth', requestState.toAuth())
      context.set('clerk', clerkClient)

      await next()
    }
  }
  ```
</Steps>

---
title: getOrganizationMembershipList()
description: Use Clerk's Backend SDK to retrieve a list of organization memberships for a given user.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L214 */}

Retrieves a list of organization memberships for a given user. Returns a [`PaginatedResourceResponse`](/docs/references/backend/types/paginated-resource-response) object with a `data` property that contains an array of [`OrganizationMembership`](/docs/references/backend/types/backend-organization-membership) objects, and a `totalCount` property that indicates the total number of organization memberships in the system for the specified organization.

```ts
function getOrganizationMembershipList(
  params: GetOrganizationMembershipListParams,
): Promise<PaginatedResourceResponse<OrganizationMembership[]>>
```

## `GetOrganizationMembershipListParams`

<Properties>
  - `userId`
  - `string`

  The ID of the user to retrieve the list of organization memberships for.

  ---

  - `limit?`
  - `number`

  The number of results to return. Must be an integer greater than zero and less than 501. Can be used for paginating the results together with `offset`. Defaults to `10`.

  ---

  - `offset?`
  - `number`

  Skip the first `offset` results when paginating. Needs to be an integer greater or equal to zero. To be used in conjunction with `limit`. Defaults to `0`.
</Properties>

## Examples

<Include src="_partials/backend/usage" />

```tsx
const userId = 'user_123'

const response = await clerkClient.users.getOrganizationMembershipList({ userId })
```

### Limit the number of results

Retrieves a list of a user's organization memberships that is filtered by the number of results.

```tsx
const userId = 'user_123'

const { data, totalCount } = await clerkClient.users.getOrganizationMembershipList({
  userId,
  // returns the first 10 memberships
  limit: 10,
})
```

### Skip results

Retrieves a list of a user's organization memberships that is filtered by the number of results to skip.

```tsx
const userId = 'user_123'

const { data, totalCount } = await clerkClient.users.getOrganizationMembershipList({
  userId,
  // skips the first 10 memberships
  offset: 10,
})
```

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/users/{user_id}/organization_memberships`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/UsersGetOrganizationMemberships){{ target: '_blank' }} for more information.

---
title: Getting started with the Account Portal
description: The Account Portal offers a comprehensive solution for managing user authentication and profile management in your web application and is the fastest way to add Clerk's authentication to your application with minimal code required.
---

To integrate the Account Portal into your application, simply follow one of the [quickstart guides](/docs/quickstarts/overview). Once your application is set up, all you have to do is run it. Clerk will automatically redirect your users to the Account Portal sign-up/sign-in pages. After successful authentication, users will be redirected back to your application with an active session.

You can also integrate the Account Portal into your application using prebuilt components. For example, the [`<SignUpButton>`](/docs/components/unstyled/sign-up-button) and [`<SignInButton>`](/docs/components/unstyled/sign-in-button) components will redirect users to the Account Portal sign-up and sign-in pages if no props or [environment variables](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) are configured to override this behavior.

> [!NOTE]
> **Dynamic Development Host Detection**
>
> For development environments, the development host (e.g. [http://localhost:3000](http://localhost:3000)) is dynamically detected by Clerk at runtime and tied to your client browser. We store this as the home origin for your application and it is equivalent to your application domain in production environments.

## Accessing your pages

For development environments, Clerk will issue you a randomly generated domain on "accounts.dev". In production, by default, the URLs for your Account Portal are the following:

```sh
https://accounts.<your-domain>.com/sign-in
https://accounts.<your-domain>.com/sign-up
https://accounts.<your-domain>.com/user
https://accounts.<your-domain>.com/unauthorized-sign-in
https://accounts.<your-domain>.com/organization
https://accounts.<your-domain>.com/create-organization
```

To access these links, in the Clerk Dashboard, go to the [**Account Portal**](https://dashboard.clerk.com/last-active?path=account-portal) page and then open the **Pages** tab.

---
title: getUserOauthAccessToken()
description: Use Clerk's Backend SDK to retrieve the corresponding OAuth access token for a user.
---

{/* clerk/javascript file: https://github.com/clerk/javascript/blob/main/packages/backend/src/api/endpoints/UserApi.ts#L197 */}

Retrieve the corresponding OAuth access token for a user that has previously authenticated with a particular OAuth provider.

```ts
function getUserOauthAccessToken(
  userId: string,
  provider: `${OAuthProvider}`,
): Promise<OauthAccessToken[]>
```

## Parameters

<Properties>
  - `userId`
  - `string`

  The ID of the user to retrieve the OAuth access token for.

  ---

  - `provider`
  - <code>$\{[OAuthProvider](/docs/references/javascript/types/sso#o-auth-provider)}</code>

  The OAuth provider to retrieve the access token for. If using a custom OAuth provider, prefix the provider name with `custom_` (e.g., `custom_foo`).
</Properties>

## Example

<Include src="_partials/backend/usage" />

```tsx
const userId = 'user_123'

const provider = 'google'

const response = await clerkClient.users.getUserOauthAccessToken(userId, provider)
```

You can also explore [the example](/docs/authentication/social-connections/overview#get-an-o-auth-access-token-for-a-social-provider) that demonstrates how this method retrieves a social provider's OAuth access token, enabling access to user data from both the provider and Clerk.

## Backend API (BAPI) endpoint

This method in the SDK is a wrapper around the BAPI endpoint `GET/users/{user_id}/oauth_access_tokens/{provider}`. See the [BAPI reference](/docs/reference/backend-api/tag/Users#operation/GetOAuthAccessToken){{ target: '_blank' }} for more information.

---
title: Handle accepting organization invitation links
description: Learn how to use the Clerk API to build a custom flows for accepting organization invitations.
---

<Include src="_partials/custom-flows-callout" />

When a user visits an [organization invitation](/docs/organizations/invitations) link, and no custom redirect URL was specified, then they will be redirected to the [Account Portal sign-in page](/docs/account-portal/overview#sign-in).

However, if you specified [a redirect URL when creating the invitation](/docs/organizations/invitations#redirect-url), you must handle the sign-up and sign-in flows in your code for that page. You can either embed the [`<SignIn />`](/docs/components/authentication/sign-in) component on that page, or if the prebuilt component doesn't meet your specific needs or if you require more control over the logic, you can rebuild the existing Clerk flows using the Clerk API.

This guide demonstrates how to use Clerk's API to build a custom flow for accepting organization invitations from a link.

## Build the custom flow

Once the user visits the invitation link and is redirected to the specified URL, the query parameters `__clerk_ticket` and `__clerk_status` will be appended to the URL.

For example, if the redirect URL was `https://www.example.com/accept-invitation`, the URL that the user would be redirected to would be `https://www.example.com/accept-invitation?__clerk_ticket=.....`.

The `__clerk_ticket` query parameter contains the ticket token, which is essential for completing the organization invitation flow. You'll use this token in your code for the page that you redirected the user to.

The `__clerk_status` query parameter is the outcome of the ticket verification and will contain one of three values:

- `sign_in` indicates the user already exists in your application. You should create a sign-in flow using the invitation token by extracting the token from the URL and passing it to the [`signIn.create()`](/docs/references/javascript/sign-in#create) method.
- `sign_up` indicates the user doesn't already exist in your application. You should create a sign-up flow using the invitation token by extracting the token from the URL and passing it to the [`signUp.create()`](/docs/references/javascript/sign-up#create) method.
- `complete` indicates the user already exists in your application, and was signed in. The flow has been completed and no further actions are required.

The following example demonstrates how to handle both sign-up and sign-in flows using the invitation token:

1. It extracts the token from the URL.
1. It passes the token to either [`signUp.create()`](/docs/references/javascript/sign-up#create) or [`signIn.create()`](/docs/references/javascript/sign-in#create), depending on the `__clerk_status`.
1. It includes optional fields for collecting additional user information during sign-up. You can modify or remove these fields as needed for your application.

<Tabs items={["Next.js"]}>
  <Tab>
    ```tsx {{ filename: 'app/accept-invitation/page.tsx', collapsible: true }}
    'use client'

    import * as React from 'react'
    import { useOrganization, useSignIn, useSignUp } from '@clerk/nextjs'
    import { useSearchParams } from 'next/navigation'

    export default function Page() {
      const { isLoaded, signUp, setActive: setActiveSignUp } = useSignUp()
      const { signIn, setActive: setActiveSignIn } = useSignIn()
      const { organization } = useOrganization()
      const [firstName, setFirstName] = React.useState('')
      const [lastName, setLastName] = React.useState('')
      const [password, setPassword] = React.useState('')

      // Get the token and account status from the query params
      const token = useSearchParams().get('__clerk_ticket')
      const accountStatus = useSearchParams().get('__clerk_status')

      // If there is no invitation token, restrict access to this page
      if (!token) {
        return <p>No invitation token found.</p>
      }

      // Handle sign-in
      React.useEffect(() => {
        if (!signIn || !setActiveSignIn || !token || organization || accountStatus !== 'sign_in') {
          return
        }

        const createSignIn = async () => {
          try {
            // Create a new `SignIn` with the supplied invitation token.
            // Make sure you're also passing the ticket strategy.
            const signInAttempt = await signIn.create({
              strategy: 'ticket',
              ticket: token as string,
            })

            // If the sign-in was successful, set the session to active
            if (signInAttempt.status === 'complete') {
              await setActiveSignIn({
                session: signInAttempt.createdSessionId,
              })
            } else {
              // If the sign-in attempt is not complete, check why.
              // User may need to complete further steps.
              console.error(JSON.stringify(signInAttempt, null, 2))
            }
          } catch (err) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error('Error:', JSON.stringify(err, null, 2))
          }
        }

        createSignIn()
      }, [signIn])

      // Handle submission of the sign-up form
      const handleSignUp = async (e: React.FormEvent) => {
        e.preventDefault()

        if (!isLoaded) return

        try {
          // Create a new sign-up with the supplied invitation token.
          // Make sure you're also passing the ticket strategy.
          // After the below call, the user's email address will be
          // automatically verified because of the invitation token.
          const signUpAttempt = await signUp.create({
            strategy: 'ticket',
            ticket: token,
            firstName,
            lastName,
            password,
          })

          // If the sign-up was successful, set the session to active
          if (signUpAttempt.status === 'complete') {
            await setActiveSignUp({ session: signUpAttempt.createdSessionId })
          } else {
            // If the sign-in attempt is not complete, check why.
            // User may need to complete further steps.
            console.error(JSON.stringify(signUpAttempt, null, 2))
          }
        } catch (err) {
          // See https://clerk.com/docs/custom-flows/error-handling
          // for more info on error handling
          console.error(JSON.stringify(err, null, 2))
        }
      }

      if (accountStatus === 'sign_in' && !organization) {
        return <div>Signing you in...</div>
      }

      if (accountStatus === 'sign_up' && !organization) {
        return (
          <>
            <h1>Sign up</h1>
            <form onSubmit={handleSignUp}>
              <div>
                <label htmlFor="firstName">Enter first name</label>
                <input
                  id="firstName"
                  type="text"
                  name="firstName"
                  value={firstName}
                  onChange={(e) => setFirstName(e.target.value)}
                />
              </div>
              <div>
                <label htmlFor="lastName">Enter last name</label>
                <input
                  id="lastName"
                  type="text"
                  name="lastName"
                  value={lastName}
                  onChange={(e) => setLastName(e.target.value)}
                />
              </div>
              <div>
                <label htmlFor="password">Enter password</label>
                <input
                  id="password"
                  type="password"
                  name="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                />
              </div>
              <div>
                <button type="submit">Next</button>
              </div>
            </form>
          </>
        )
      }

      return <div>Organization invitation accepted!</div>
    }
    ```
  </Tab>
</Tabs>

---
title: Handling webhooks with Inngest
description: Learn how to integrate Clerk with Inngest.
---

Webhooks allow you to [synchronize data](/docs/webhooks/sync-data) from Clerk to your application backend. You can either handle them directly in your backend with an endpoint or use a tool like [Inngest](https://www.inngest.com) which receives the webhook events for you and reliably executes functions in your codebase. When handling webhooks, Inngest receives the [webhook events](/docs/webhooks/overview#supported-webhook-events) for you and uses a built-in queue to reliably execute longer running functions with additional functionality including:

- [Limiting concurrency](https://www.inngest.com/docs/guides/concurrency) to handle spikes in events without overwhelming your API or database.
- Triggering multiple functions from a single event ([fan-out jobs](https://www.inngest.com/docs/guides/fan-out-jobs)).
- [Delaying code](https://www.inngest.com/docs/functions/multi-step) to run after a period of time.
- [Debouncing events](https://www.inngest.com/docs/reference/functions/debounce) to reduce duplicate processing.

In this guide, you'll learn how to set up Inngest to receive Clerk webhook events and how to define Inngest functions in your application using Clerk events including synchronizing data and sending welcome emails.

To follow this guide, you need an Inngest account (free tier is enough) and have Inngest [set up](https://www.inngest.com/docs/quick-start) in your codebase.

## Setting up the Inngest webhook

To create an Inngest webhook endpoint and add it to your Clerk account, navigate to the [**Webhooks**](https://dashboard.clerk.com/last-active?path=webhooks) page in the Clerk Dashboard. Next, select **Add Endpoint**.

![The Webhooks page in the Clerk Dashboard. A red arrow points to the button for Add Endpoint](/docs/images/integrations/inngest/webhook-page.webp)

On the next page, select the **Transformation template** tab and the **Inngest** template, then select the **Connect to Inngest** button.

![The Webhooks page in the Clerk Dashboard showing the Inngest transformation template. Red arrows point to the Transformation Template tab, the Inngest template, and the Connect to Inngest button](/docs/images/integrations/inngest/webhook-transformation-template.webp)

A popup window will appear to complete the setup. Select **Approve** to create the webhook.

![The Inngest permissions popup window showing the Approve button](/docs/images/integrations/inngest/inngest-permissions-dialog.webp)

After the popup window disappears, the Webhooks page will now display **Connected** with the webhook URL underneath. There is one more step to complete setup.

![The Webhooks page in the Clerk Dashboard showing a connected Inngest account. A red arrow points to the Connected button](/docs/images/integrations/inngest/webhook-endpoint-connected.webp)

To complete the setup, scroll down and select **Create**.

![The Webhooks page in the Clerk Dashboard showing the end of the page to create a new endpoint. A red arrow points to the Create button](/docs/images/integrations/inngest/webhook-create.webp)

You'll be redirected to the new endpoint. In your Inngest dashboard, you will see a new webhook created in your account's [production environment](https://app.inngest.com/env/production/manage/webhooks).

## Viewing webhook events within Inngest

After setup, as webhook events are sent from Clerk to Inngest, new `clerk` events will appear in your [Inngest dashboard](https://app.inngest.com/env/production/events). Event names will be the prefixed `clerk/` followed by the event name. See [webhook events](/docs/webhooks/overview#supported-webhook-events) for a full list.

![The Events page in the Inngest Dashboard showing a list of Clerk events](/docs/images/integrations/inngest/inngest-clerk-events.webp)

## Creating a function to sync a new user to a database

With Inngest already set up in your codebase, you can now use these events as triggers for your functions.

Suppose you need to write a function which will insert a new user into the database which will be triggered whenever `clerk/user.created` event occurs. You would use the `inngest.createFunction` method, like in the example below:

```typescript {{ filename: 'src/inngest/sync-user.ts' }}
const syncUser = inngest.createFunction(
  { id: 'sync-user-from-clerk' }, // The 'id' is an arbitrary string used to identify the function in the dashboard
  { event: 'clerk/user.created' }, //  This is the function's triggering event
  async ({ event }) => {
    const user = event.data // The event payload's data will be the Clerk User json object
    const { id, first_name, last_name } = user
    const email = user.email_addresses.find(
      (e) => e.id === user.primary_email_address_id,
    ).email_address
    await database.users.insert({ id, email, first_name, last_name })
  },
)
```

The `event` object contains all of the relevant data for the event. The `event.data` will match the `data` object from the standard Clerk webhook [payload structure](/docs/webhooks/overview#payload-structure). With this `clerk/user.created` event, the `event.data` will be a Clerk User json object.

As you can see, you can choose which events you want to handle with each function. You might write a separate function for `clerk/user.updated` and `clerk/user.deleted` handling the entire lifecycle end to end.

Note that multiple functions can also listen to the same event. This pattern is called [fan-out](https://www.inngest.com/docs/guides/fan-out-jobs).

## Creating a function to send a welcome email

Often, applications need to perform additional tasks when a new user is created, like send a welcome email with tips and useful information.

While it is possible to add this logic at the end of your sync function as seen in the [previous section](/docs/webhooks/inngest#creating-a-function-to-sync-a-new-user-to-a-database), its better to decouple unrelated tasks into different functions so issues with one task do not affect the other ones. For example, if your email fails to send, it should not affect starting a trial for that user in Stripe.

With Inngest, each function has automatic retries, so only the code that has issues is re-run.

The code below creates another function using the same `clerk/user.created` event and adds the logic to send the welcome email:

```typescript {{ filename: 'src/inngest/welcome-emails.ts' }}
const sendWelcomeEmail = inngest.createFunction(
  { id: 'send-welcome-email' },
  { event: 'clerk/user.created' },
  async ({ event }) => {
    const user = event.data
    const { first_name } = user
    const email = user.email_addresses.find(
      (e) => e.id === user.primary_email_address_id,
    ).email_address
    // `emails` is a placeholder for the function in your codebase to send email
    await emails.sendWelcomeEmail({ email, first_name })
  },
)
```

Now, you have a function that utilizes the same Clerk webhook event for another purpose. Clerk webhook events can be used for all sorts of application lifecycle use cases. For example, adding users to a marketing email list, starting a Stripe trial, or provisioning new account resources.

### Sending a delayed follow-up email

Every Inngest function handler has an additional `step` object which provides tools to create more complex functions. Using `step.run` allows you to encapsulate specific code that will be automatically retried ensuring that issues with one part of your function don't force the entire function to re-run. Additionally, [other tools like `step.sleep`](https://www.inngest.com/docs/reference/functions/step-sleep), are available to extend functionality.

The code below sends a welcome email, then uses `step.sleep` to wait for three days before sending another email offering a free trial:

```typescript {{ filename: 'src/inngest/welcome-emails.ts' }}
const sendOnboardingEmails = inngest.createFunction(
  { id: 'onboarding-emails' },
  { event: 'clerk/user.created' },
  async ({ event, step }) => {
    //  step is available in the handler's arguments
    const user = event.data
    const { first_name } = user
    const email = user.email_addresses.find(
      (e) => e.id === user.primary_email_address_id,
    ).email_address

    await step.run('welcome-email', async () => {
      // `emails` is a placeholder for the function in your codebase to send email
      await emails.sendWelcomeEmail({ email, first_name })
    })

    // wait 3 days before second email
    await step.sleep('wait-3-days', '3 days')

    await step.run('trial-offer-email', async () => {
      await emails.sendTrialOfferEmail({ email, first_name })
    })
  },
)
```

Now, you've extended the usefulness of Clerk webhook events even further to build an onboarding drip email campaign in just a few lines of code.

## Testing webhook events using the Inngest Dev Server

During local development with Inngest, you can use the [Inngest Dev Server](https://www.inngest.com/docs/local-development) to run and test your functions on your own machine. Run the following command to start the server:

```sh {{ filename: 'terminal' }}
npx inngest-cli@latest dev
```

In your browser open [http://localhost:8288](http://localhost:8288) to see the Inngest Dev Server.

To quickly get events to test within Dev Server, you can select any individual event from the **Events** tab then select the **Send to Dev Server**.

![The Inngest Dashboard showing an individual event payload. Red arrows point to the Events tab and the Send to Dev Server button](/docs/images/integrations/inngest/inngest-send-to-dev-server.webp)

You'll now see the event in the Inngest Dev Server's **Stream** tab alongside any functions that it triggered.

![The Inngest Dev Server showing the Stream tab. The forwarded event is visible in the stream](/docs/images/integrations/inngest/inngest-dev-server.webp)

From here you can select the event, replay it to re-run any functions or edit and replay to edit the event payload to test different types of events.

![The Inngest Dev Server showing the forwarded event payload. A red arrow points to the Replay button](/docs/images/integrations/inngest/inngest-replay-event.webp)

## Conclusion

Congratulations! You've now learned how to use Inngest to create functions that use Clerk Webhook events.

---
title: Hide personal accounts and force organizations
description: Learn how to hide personal accounts and force organizations in your Clerk application.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Next.js + Clerk application",
      link: "/docs/quickstarts/nextjs",
      icon: "nextjs",
    },
    {
      title: "Enable organizations for your instance",
      link: "/docs/organizations/overview",
      icon: "globe",
    }
  ]}
/>

This guide demonstrates how to hide a user's personal account in order to appear as if they only have access to organizations, and how to limit access to your application to only users with active organizations, further enforcing organization-centric access. This is useful for applications that are built for organizations only, such as B2B applications.

This guide is written for Next.js applications using App Router, but the same concepts can be applied to any application using Clerk.

<Steps>
  ## Hide personal accounts from UI components

  To begin forcing organizations in your application, you need to remove a user's personal account from the UI. A user's personal account cannot be disabled; it can only be hidden.

  If you have an application set up to use organizations, you might have the [`<OrganizationList />`](/docs/components/organization/organization-list) and [`<OrganizationSwitcher />`](/docs/components/organization/organization-switcher) components in your application. These components will show a user's personal account by default, but you can hide it by passing the `hidePersonal` prop.

  <Tabs items={["<OrganizationList />", "<OrganizationSwitcher />"]}>
    <Tab>
      ```tsx {{ mark: [4] }}
      export default function Page() {
        return (
          <OrganizationList
            // prettier-ignore
            hidePersonal={true}
          />
        )
      }
      ```
    </Tab>

    <Tab>
      ```tsx {{ mark: [4] }}
      export default function Page() {
        return (
          <OrganizationSwitcher
            // prettier-ignore
            hidePersonal={true}
          />
        )
      }
      ```
    </Tab>
  </Tabs>

  ## Detect and set an active organization

  A user can have many organization memberships, but only one of them can be active at a time. This is called the "active organization".

  ### Detect an active organization

  The [`Auth` object](/docs/references/backend/types/auth-object#auth-object-example-with-active-organization) includes information about the user's session, including the `orgId`. The `orgId` can be used to detect if a user has an active organization. To see how to access the `Auth` object using your preferred SDK, see the [reference doc](/docs/references/backend/types/auth-object#how-to-access-the-auth-object). The following examples use the Next.js SDK.

  <Tabs items={["Server-side", "Client-side"]}>
    <Tab>
      The [`auth()`](/docs/references/nextjs/auth) helper function can be used to get the `orgId` from the session _server-side_. If the `orgId` is `null`, then the user does not have an active organization.

      ```tsx
      import { auth } from '@clerk/nextjs/server'

      export default async function Layout() {
        const { orgId } = await auth()

        const hasActiveOrg = !!orgId
        // ...
      }
      ```
    </Tab>

    <Tab>
      The [`useAuth()`](/docs/hooks/use-auth) hook can be used to get the `orgId` from the session _client-side_. If the `orgId` is `null`, then the user does not have an active organization.

      ```tsx
      'use client'
      import { useAuth } from '@clerk/nextjs'

      export default function Layout() {
        const { orgId } = useAuth()

        const hasActiveOrg = orgId !== null
        // ...
      }
      ```
    </Tab>
  </Tabs>

  ### Set an active organization

  If you are using [prebuilt components](/docs/components/overview), an organization will _automatically_ be set as active each time the user creates an organization, accepts an invitation, or selects a membership. If prebuilt components don't meet your specific needs or if you require more control over the logic, you can rebuild the existing Clerk flows using the Clerk API. See the [organization switcher custom flow guide](/docs/custom-flows/organization-switcher).

  ### Set an active organization based on the URL

  > [!WARNING]
  > This approach depends on the `setActive()` method, which only runs on the client. Due to this limitation, during SSR, it is possible that `orgId` from `auth()` returns an incorrect value that does not match the organization ID in the URL.

  In some cases, you might want to set an active organization based on the URL. For example, if you have a URL like `/organizations/org_123`, you might want to set `org_123` as the active organization.

  In the following example, a component called `SyncActiveOrganization` is created. The Next.js [`useParams()`](https://nextjs.org/docs/app/api-reference/functions/use-params) hook is used to get the organization ID from the URL, and then the `setActive()` method is used to set the organization as active.

  ```tsx {{ filename: 'app/utils/sync-active-organization.tsx' }}
  'use client'

  import { useEffect } from 'react'
  import { redirect, useParams } from 'next/navigation'
  import { useAuth, useOrganizationList } from '@clerk/nextjs'

  export function SyncActiveOrganization() {
    // Use `useOrganizationList()` to access the `setActive()` method
    const { setActive, isLoaded } = useOrganizationList()

    // Get the organization ID from the session
    const { orgId } = useAuth()

    // Get the organization ID from the URL
    const { orgId: urlOrgId } = useParams() as { orgId: string }

    useEffect(() => {
      if (!isLoaded) return

      // If the org ID in the URL is not valid, redirect to the homepage
      if (!urlOrgId?.startsWith('org_')) {
        redirect('/')
        return
      }

      // If the org ID in the URL is not the same as
      // the org ID in the session (the active organization),
      // set the active organization to be the org ID from the URL
      if (urlOrgId && urlOrgId !== orgId) {
        void setActive({ organization: urlOrgId })
      }
    }, [orgId, isLoaded, setActive, urlOrgId])

    return null
  }
  ```

  Now you can place the `SyncActiveOrganization` helper that you created above in a [layout](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#layouts) and use the layout for all pages that require an active organization. In the following example, the `SyncActiveOrganization` component will run on every page in the `/app/[orgId]` directory.

  ```tsx {{ filename: 'app/[orgId]/layout.tsx' }}
  import { type PropsWithChildren } from 'react'
  import { SyncActiveOrganization } from '../utils/sync-active-organization'

  export default function OrganizationLayout(props: PropsWithChildren) {
    return (
      <>
        <SyncActiveOrganization />
        {props.children}
      </>
    )
  }
  ```

  ## Limit access to only users with active organizations

  Now that you have hidden personal accounts from the UI and can detect and set an active organization, you can limit access to your application to users with active organizations only. This will ensure that users without active organizations cannot access your application.

  It's possible for a user to be signed in, but not have an active organization. This can happen in two cases:

  - The user created an account and hasn't created an organization yet
  - The user joined or created multiple organizations, and left or deleted the active organization

  There are two ways to limit access to only users with active organizations:

  - [Using the `clerkMiddleware()` helper](#limit-access-using-the-clerk-middleware-helper)
  - [Using an App Router layout](#limit-access-using-an-app-router-layout)

  Based on your use case, you can decide to limit users either in the entire app or a specific part of it. For example, a B2B application might need to limit access to only users with an active organization, whereas a B2B2C application might limit only the `/dashboard` path to users with an active organization.

  ### Limit access using the `clerkMiddleware()` helper

  The [`clerkMiddleware()`](/docs/references/nextjs/clerk-middleware) helper can be used to limit access to only users with active organizations.

  <Tabs items={["Entire application", "Specific part of the application"]}>
    <Tab>
      In the following example, the `clerkMiddleware()` helper is used to redirect signed in users to the organization selection page if they are not active in an organization.

      ```tsx {{ filename: 'middleware.ts' }}
      import { clerkMiddleware } from '@clerk/nextjs/server'

      export default clerkMiddleware(async (auth, req) => {
        const { userId, orgId } = await auth()

        // Redirect signed in users to organization selection page if they are not active in an organization
        if (userId && !orgId && req.nextUrl.pathname !== '/org-selection') {
          const searchParams = new URLSearchParams({ redirectUrl: req.url })

          const orgSelection = new URL(`/org-selection?${searchParams.toString()}`, req.url)

          return NextResponse.redirect(orgSelection)
        }
      })

      export const config = {
        matcher: [
          // Skip Next.js internals and all static files, unless found in search params
          '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
          // Always run for API routes
          '/(api|trpc)(.*)',
        ],
      }
      ```
    </Tab>

    <Tab>
      To limit access to a specific part of the application, you can check if the path the user is visiting is the path you want to limit access to. In this example, the `/dashboard` path is limited to users with active organizations only. If the user is not active in an organization, they will be redirected to the `/dashboard/org-selection` page.

      ```tsx {{ filename: 'middleware.ts' }}
      import { clerkMiddleware } from '@clerk/nextjs/server'

      export default clerkMiddleware(async (auth, req) => {
        const { userId, orgId } = await auth()

        // Redirect signed in users to organization selection page if they are not active in an organization
        if (
          userId &&
          !orgId &&
          req.nextUrl.pathname.startsWith('/dashboard') &&
          req.nextUrl.pathname !== '/dashboard/org-selection'
        ) {
          const searchParams = new URLSearchParams({ redirectUrl: req.url })

          const orgSelection = new URL(`/dashboard/org-selection?${searchParams.toString()}`, req.url)

          return NextResponse.redirect(orgSelection)
        }
      })

      export const config = {
        matcher: [
          // Skip Next.js internals and all static files, unless found in search params
          '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
          // Always run for API routes
          '/(api|trpc)(.*)',
        ],
      }
      ```
    </Tab>
  </Tabs>

  Now that you have configured your middleware to redirect users to the `/org-selection` page if they are not active in an organization, you need to create the `/org-selection` page. This page will allow users to select an organization or create their own organization.

  ```tsx {{ filename: 'app/org-selection/page.tsx' }}
  'use client'

  import { OrganizationList } from '@clerk/nextjs'
  import { useSearchParams } from 'next/navigation'

  export default function OrganizationSelection() {
    const searchParams = useSearchParams()
    const redirectUrl = searchParams.get('redirectUrl') ?? '/'

    return (
      <section>
        <h1>Welcome to the Organization Selection page.</h1>
        <p>
          This part of the application requires the user to select an organization in order to
          proceed. If you are not part of an organization, you can accept an invitation or create your
          own organization.
        </p>
        <OrganizationList
          hidePersonal={true}
          afterCreateOrganizationUrl={redirectUrl}
          afterSelectOrganizationUrl={redirectUrl}
        />
      </section>
    )
  }
  ```

  ### Limit access using an App Router layout

  In Next.js App Router applications, instead of using `clerkMiddleware()`, you also have the option to use a layout to limit access to only users with active organizations.

  In the following example, a component called `RequiredActiveOrgLayout` is created. This component will be used as a layout for all pages that require an active organization. If the user has an active organization, the route the user is visiting will be rendered. If the user does not have an active organization, the organization selection page will be rendered.

  ```tsx {{ filename: 'app/(with-active-organization)/layout.tsx' }}
  import { OrganizationList } from '@clerk/nextjs'
  import { auth } from '@clerk/nextjs/server'
  import { PropsWithChildren } from 'react'

  export default async function RequiredActiveOrgLayout(props: PropsWithChildren) {
    // Get the organization ID from the session
    const { orgId } = await auth()

    // If the user has an active organization, render the children
    if (orgId) {
      return props.children
    }

    // If the user does not have an active organization, render the organization selection page
    return (
      <section>
        <h1>Welcome to the Organization Selection page.</h1>
        <p>
          This part of the application requires the user to select an organization in order to
          proceed. If you are not part of an organization, you can accept an invitation or create your
          own organization.
        </p>
        <OrganizationList hidePersonal={true} />
      </section>
    )
  }
  ```
</Steps>

---
title: How Clerk works
description: Learn how Clerk is architected and how it works under the hood.
---

This guide provides a deep dive into Clerk's architecture and internal workings. For developers who are simply looking to add authentication to their app, see the [quickstart guides](/docs/quickstarts/overview).

## The frontend API

When you create a new application through the [Clerk Dashboard](https://dashboard.clerk.com/), Clerk provisions a dedicated frontend API (FAPI) instance for your application. It is hosted at `https://<slug>.clerk.accounts.dev` in development environments, where `<slug>` is a unique identifier generated for your application. You can find your application's FAPI URL in the [**Domains**](https://dashboard.clerk.com/last-active?path=domains) page of the Clerk Dashboard.

When configuring your Clerk app, you must provide a [Publishable Key](/docs/deployments/clerk-environment-variables#clerk-publishable-and-secret-keys). The Publishable Key tells your app what your FAPI URL is, enabling your app to locate and communicate with your dedicated FAPI instance.

The Clerk Publishable Key follows a specific format: it consists of your FAPI instance URL encoded in base64, prefixed with an environment identifier (e.g. `pk_test_` for development environments, `pk_live_` for production environments), and suffixed with a `$` delimiter for future extensibility. The base64-encoded URL enables your application to locate and communicate with your dedicated FAPI instance. You can verify this structure by decoding the key yourself:

```js
const publishableKey = 'pk_test_ZXhhbXBsZS5hY2NvdW50cy5kZXYk'
const keyWithoutPrefix = publishableKey.replace('pk_test_', '')

atob(keyWithoutPrefix) // => example.accounts.dev$
```

> [!NOTE]
> In previous versions of Clerk, the Frontend API URL was exposed directly rather than being encoded within a Publishable Key. This was a source of confusion for users, so we transitioned to encoding it as base64 and making it a key.

FAPI manages authentication flows on a per-user basis. For instance, it handles flows for signing up a user, retrieving a user's active sessions, creating an organization on behalf of a user, or fetching a user's organization invites. You can find the complete FAPI documentation [here](https://clerk.com/docs/reference/frontend-api).

FAPI _does not_ handle administrative actions that impact multiple users, such as listing all users, banning users, or impersonating a user. These types of tasks are handled by [the backend API](#the-backend-api).

Some tasks, such as [signing up a user](https://clerk.com/docs/reference/frontend-api/tag/Sign-Ups#operation/createSignUps), don't require authentication, as that would defeat the purpose of the endpoint. However, endpoints designed for authenticated users, like [updating a user's details](https://clerk.com/docs/reference/frontend-api/tag/User#operation/patchUser), require FAPI to first identify the user making the request and then verify their authorization. This ensures that users cannot modify another user's details. Typically, this is achieved by sending a signed token with the request, either as a cookie or a header. You can [learn more about Clerk's authentication tokens later in this guide](#stateful-authentication).

While it's possible to build complete authentication flows directly on top of the frontend API, it involves significantly more work. Most users prefer our frontend SDKs, which provide higher-level abstractions like the [`mountSignIn()`](/docs/components/authentication/sign-in#mount-sign-in) method or the [`<SignIn />`](/docs/components/authentication/sign-in) component (for React-based SDKs). These abstractions offer a well-tested, thoughtfully designed, a11y-optimized, and customizable UI for authentication flows, handling all possible configurations of your authentication preferences out-of-the-box.

## Levels of abstraction

FAPI is the lowest level of abstraction that authentication flows can be built on with Clerk. However, there are several other abstraction layers that offer less work and more convenience.

### Clerk's prebuilt components

Clerk's [prebuilt UI components](/docs/components/overview) are Clerk's highest level of abstraction. They are "all in one" components, offering the most complete implementation of authentication with the least amount of effort. While it's strongly recommended to use these components, due to the amount of research we have put into delivering an optimal experience, it's not the only option if you feel that you need more control over your authentication flows.

> **Customizability:** You can [modify the CSS for any part of the prebuilt components](/docs/customization/overview), but not the HTML structure or the logic/ordering of how the authentication flow works.

### Clerk Elements

The next level of abstraction is [Clerk Elements](/docs/customization/elements/overview), a headless UI library that provides the foundational building blocks used in Clerk's prebuilt components. Similar to established libraries like [Radix](https://www.radix-ui.com), [Reach UI](https://reach.tech), and [Headless UI](https://headlessui.com), Clerk Elements exposes a set of unstyled React components that handle complex authentication logic while giving you complete control over the presentation layer. **Clerk Elements is still in beta**, and only supports sign-up and sign-in flows, with more components planned for future releases.

> **Customizability:** You have full control over both the CSS and the HTML structure of the components, but you can't change the logic/ordering of how the authentication flow works.

### Custom flows

Finally, if you need complete control over the authentication flow, Clerk provides low-level primitives that directly wrap our API endpoints. These primitives enable you to build fully custom authentication flows from scratch. Clerk refers to these as ["custom flows"](/docs/custom-flows/overview). While this approach offers maximum flexibility, it also requires significant development effort to implement and maintain. Custom flows should only be considered when you have specific requirements that cannot be met using the prebuilt components or Clerk Elements, as you'll need to handle all authentication logic, error states, and edge cases yourself.

> **Customizability:** You have full control over every part of the authentication flow, including HTML structure, CSS, and the logic/ordering of how the authentication flow works.

## The backend API

The frontend API (FAPI) is designed for use primarily from the frontend of your application. Its methods focus on signing in users and managing user-related resources and data once they are authenticated. However, as an application developer, you might also need to perform administrative tasks, such as modifying multiple user or organization details, retrieving a list of all users, banning or impersonating a user, and more.

To maintain security, these administrative tasks should only be executed on the server side using a secret key inaccessible to your users or the browser. These operations are handled by a separate API known as the backend API (BAPI). You can find the BAPI documentation [here](https://clerk.com/docs/reference/backend-api).

Although the administrative features of BAPI are useful for many applications, it's most commonly used to verify a user's authentication state when processing requests from your app's frontend. For instance, if a user submits a request to update some data associated with their account, **your server must ensure the user is authenticated and authorized to make this change.** Without proper validation, malicious actors could potentially take over user accounts.

Like FAPI, while you can interact directly with BAPI, most developers opt to use Clerk's SDKs for smoother integration with their preferred language or framework. Documentation for Clerk's SDKs is available in [the left sidenav of the docs](https://clerk.com/docs). That being said, FAPI is a much more complex and nuanced API that relies on more custom logic outside of its endpoints to create a functional SDK on top of it. As such, **interacting directly with FAPI is not recommended**, whereas interacting directly with BAPI is generally reasonable.

## Stateful authentication

To understand how authentication works in Clerk, it's important to first understand how the most common implementation of authentication logic works: the traditional "stateful authentication" model, also known as "session token authentication".

A user's process of signing in would work as follows. This example assumes that the user already signed up and their credentials are stored in a database.

1. The user initiates authentication by navigating to `example.com/sign-in`, entering their credentials (e.g. username/password), and submitting the form, usually by clicking a "submit" button. This makes a request to the server with the credentials.
1. The server validates the credentials against a database. This is normally done by [hashing](https://clerk.com/glossary#hash) the password and comparing it with a stored password hash. Upon successful validation, it creates a new [session](https://clerk.com/glossary#session) in the database associated with the user.
1. The server responds to the browser's request by setting the session ID in a [`Set-Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) header in the response, which sets a cookie with this value in the browser. This cookie will be automatically included in future requests from the browser in order to authenticate the user.
   <Video
     src="/docs/images/how-clerk-works/stateful-auth.mp4"
     width="1600"
     height="900"
     autoPlay
     muted
     loop
     playsInline
     controls
   />
1. The next time the browser sends a request to the server, it [automatically includes](/docs/backend-requests/resources/cookies) the session cookie. The server checks the database for the session ID and retrieves the associated user ID and session metadata. If the session is valid and active, the server has verified that the user has authenticated, and can then use the user ID to fetch any required user data and process the request.
   <Video
     src="/docs/images/how-clerk-works/stateful-auth-2.mp4"
     width="1600"
     height="900"
     autoPlay
     muted
     loop
     playsInline
     controls
   />

> [!NOTE]
> What happens if an attacker gets their hands on your session ID? Generally, the answer here is that you're in trouble. If an attacker gets your session ID, they can sign in as you. Therefore, it's best practice to use [HTTPS](https://developer.mozilla.org/en-US/docs/Glossary/HTTPS) (ensures attacker can't [sniff it](https://en.wikipedia.org/wiki/Sniffing_attack)) and ensure the cookie is [set as `HttpOnly`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#httponly) (ensures attacker can't get it via remote JavaScript execution).

This is a perfectly reasonable authentication model and works great for most apps as it's straightforward to understand and implement. Additionally, since it checks the database for _every request_ that requires authentication, sessions can be instantly revoked if needed (by setting the state to `revoked` and adding a check in the server logic). However, because it requires every request to query the database, it introduces additional latency and can be difficult to scale as you start to shard out your database.

## Stateless authentication

An alternative approach is "stateless" authentication, which addresses the scalability and latency challenges of stateful authentication while introducing different tradeoffs.

The stateless authentication flow operates as follows. This example assumes that the user already signed up and their credentials are stored in a database.

1. The user initiates authentication by navigating to `example.com/sign-in`, entering their credentials (e.g. username/password), and submitting the form, usually by clicking a "submit" button. This makes a request to the server with the credentials.
1. The server validates the credentials against a database. Upon successful validation, it generates a [cryptographically signed token](/docs/backend-requests/resources/tokens-and-signatures) containing essential user data like the user ID and any relevant [claims](https://clerk.com/glossary#claim).
1. The server responds to the browser's request by sending the token in a [`Set-Cookie` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) in the response. This token serves as a self-contained proof of authentication, and will be included in future requests from the browser in order to authenticate the user.
   <Video
     src="/docs/images/how-clerk-works/stateless-auth.mp4"
     width="1600"
     height="900"
     autoPlay
     muted
     loop
     playsInline
     controls
   />
1. The next time the browser sends a request to the server, it sends the cookie containing the token. The server verifies the signature of the token to ensure that it's valid, and then uses the user ID within the token to fetch any required user data and process the request.
   <Video
     src="/docs/images/how-clerk-works/stateless-auth-2.mp4"
     width="1600"
     height="900"
     autoPlay
     muted
     loop
     playsInline
     controls
   />

While more complex to implement, this stateless model offers significant advantages. Because verifying the JWT doesn't require interacting with a database, the latency overhead and scaling challenges caused by database lookups are eliminated, leading to faster request processing.

> [!QUIZ]
> How exactly does stateless authenticate mitigate database scaling challenges?
>
> ---
>
> When you are first building an application, a single database instance is often sufficient to handle your traffic. As your application grows, you'll need to scale your database to manage increased load. This typically involves creating multiple database copies or splitting the database into multiple instances through a process called [sharding](https://en.wikipedia.org/wiki/Shard_\(database_architecture\)).
>
> Sharding involves dividing a database into smaller, more manageable databases (called shards), each handling a subset of the total data. To manage this complexity, a [load balancer](https://en.wikipedia.org/wiki/Load_balancing_\(computing\)) often serves as an entry point that directs traffic to ensure no single database instance becomes overwhelmed.
>
> Keeping multiple database instances synchronized is a challenging problem that software engineers have grappled with for decades. The potential consequences of unsynchronized instances can be significant. For example, if a user signs in on one database instance and a subsequent request for that user's data is routed to an unsynchronized instance, the user might encounter a confusing authentication error.
>
> Stateless authentication offers an elegant solution. By using [signed tokens](/docs/backend-requests/resources/tokens-and-signatures) that contain all necessary authentication information, the server can verify a user's credentials **without direct database interaction**, effectively bypassing the synchronization complexities that arise in traditional, stateful authentication methods.

However, this approach also comes with important technical tradeoffs. The most significant limitation is that **JWTs cannot be revoked** due to their self-contained nature. Since JWT validation happens locally without consulting a central authority (i.e., they never "phone home"), there's no direct mechanism to invalidate them before their natural expiration.

This creates challenges for session management. To forcibly terminate a user's session, you have two suboptimal choices:

1. Wait for the JWT to expire naturally.
1. Rotate the signing keys, which invalidates all active sessions across your entire user base, signing out all of your users.

Furthermore, even after rotating keys, the revocation may be delayed if your application caches the public key used for verification - a common practice for performance optimization. The cached key would continue to validate the old tokens until the cache expires.

This limitation poses significant security risks, as it hampers your ability to quickly respond to security incidents that require immediate session termination for specific users.

## Clerk's authentication model

Clerk implements a hybrid authentication model that combines the benefits of both stateful and stateless approaches while mitigating their respective drawbacks, at the cost of adding a substantial amount of complexity to the implementation on Clerk's side. However, for a developer implementing Clerk, like you, this is all upside since the complexity is handled internally by Clerk.

The hybrid model incorporates the same flow when signing in as the stateless flow, but with a key change: **the session token's expiration is decoupled from the session lifetime**. See the following section for more details.

### Authentication flow

This example assumes that the user already signed up and their credentials are stored in a database.

1. The user initiates authentication by navigating to `example.com/sign-in`, entering their credentials (e.g. username/password), and submitting the form, usually by clicking a "submit" button. This makes a request to the server with the credentials.
1. The server validates the credentials against a database and, upon successful validation:
   - Creates a session record in the database (stateful component).
   - Generates a [signed JWT](/docs/backend-requests/resources/tokens-and-signatures) with its expiration set to the session lifetime (stateless component) - this JWT is stored on FAPI, and is not accessible to the application. Clerk calls this the **client token**.
   - Generates a **second** signed JWT that expires after 60 seconds which is returned directly to the application and contains user data like the user ID and other claims. Clerk calls this the **session token**.
1. The server responds to the browser's request by sending the **client token** in a [`Set-Cookie` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) in the response, which is set on the FAPI domain. Clerk's client-side SDK then makes a request to FAPI to get a **session token** and sets it on your app's domain.

   > [!QUIZ]
   > Why doesn't Clerk set a **session token** using the `Set-Cookie` header when its setting the **client token**?
   >
   > ---
   >
   > This is a great test of your mastery of [how cookies work](/docs/backend-requests/resources/cookies)!
   >
   > Remember, **the domain of a cookie can only be set as the domain of the server that set the cookie**. In this case, the server returning the request to your app is FAPI. For the **`__client` cookie**, this is ok, since the **`__client` cookie** needs to be set on FAPI. However, the **`__session` cookie** needs to be set on your app's domain, not on FAPI. So, FAPI returns the **JWT value** of the `__session` cookie in its response, and when the Clerk client-side SDK integrated in your app receives the response, it gets the **JWT value** and uses JavaScript to set the **`__session` cookie** on your app directly, since the JavaScript is running on your app's domain.

   <Video
     src="/docs/images/how-clerk-works/hybrid-auth.mp4"
     width="1600"
     height="900"
     autoPlay
     muted
     loop
     playsInline
     controls
   />
1. And just like stateless auth, the next time the browser sends a request to the server, it sends the cookie containing the token. The server verifies the signature of the token to ensure that it's valid, and then uses the user ID within the token to fetch any required user data and process the request.
   <Video
     src="/docs/images/how-clerk-works/hybrid-auth-2.mp4"
     width="1600"
     height="900"
     autoPlay
     muted
     loop
     playsInline
     controls
   />

So far, this is the same as stateless auth, with one key distinction: the session token's expiration time. This is because normally, in stateless authentication implementations, the token's expiration is set to match the intended session duration - commonly ranging from one week to one month. But since JWTs can't be revoked, if a token is compromised, the attacker has the entirety of the session lifetime to be able to take over the user's account. This will be several days at least on average, if not several weeks.

Clerk's model mitigates this issue by setting an extremely short session token lifetime of 60 seconds. Normally, a Clerk token will have already expired before an attacker gets the chance to even try to use it. This is great for security, but it does create a complication in the authentication flow, as signing users out every 60 seconds would not be an acceptable user experience. So, for this architecture to work, **it must decouple token expiration from session lifetime**. To make this happen, Clerk introduces a new "token refresh" mechanism that runs in the background and is responsible for refreshing the token every minute.

### Token refresh mechanism

To maintain session continuity despite the 60-second token lifetime, Clerk's frontend SDKs implement an automatic refresh mechanism that:

- Runs on a 50-second interval (allowing 10 seconds for network latency).
- Makes requests to the [`/client/sessions/<id>/tokens` endpoint](https://clerk.com/docs/reference/frontend-api/tag/Sessions#operation/createSessionToken).
- Updates the session token before expiration.

If you open the network tab in your browser's developer tools on a Clerk application, you will see this request being sent, and a session token being returned in the response.

This approach provides several security benefits:

- Minimizes the window of opportunity for token misuse
- Maintains the ability to revoke sessions quickly
- Preserves the performance benefits of stateless authentication

<Video src="/docs/images/how-clerk-works/renewal.mp4" width="1600" height="900" autoPlay muted loop playsInline />

<br />

<Video src="/docs/images/how-clerk-works/invalidation.mp4" width="1600" height="900" autoPlay muted loop playsInline />

## Clerk's cookies & tokens in detail

> [!TIP]
> To understand Clerk's architecture, it's important to have a solid foundational understanding of how browser cookies work at a detailed level. If you need a refresher on cookie fundamentals, including domain scoping, `SameSite` policies, and `HttpOnly` flags, see the [guide on cookies](/docs/backend-requests/resources/cookies).

If the token lifetime is 60 seconds, how does Clerk know how long your entire session lifetime is?

Clerk's authentication model relies on two distinct tokens - a "client token" and a "session token". Let's break down each of these tokens and how they are configured as cookies.

### Client token

The client token is a long-lived token that is stored in the `__client` cookie, which is set on your FAPI domain.

- **Cookie name:** `__client`
- **Contents:** A Clerk-signed JWT containing:
  - `session_id`: Unique session identifier
  - `rotating_token`: [Anti-session-fixation](/docs/security/fixation-protection) token that rotates on each sign-in across any device
- **Domain:** Set on your FAPI domain (`clerk.example.com`), rather than on your app domain (`example.com`). It's set on the FAPI domain as a security measure - for example, if your app logs are leaked, they wouldn't contain client token values, since it's scoped to a different domain.
- **Expiration:** Set to your session lifetime, which is 7 days by default. Can be configured in the Clerk Dashboard.
- **HttpOnly:** Yes
- **SameSite:** Lax

The client token serves as the source of truth for authentication state. When a user signs in, Clerk either creates a new client token or rotates the existing token's `rotating_token` value. A valid client token enables Clerk to generate short-lived session tokens for the application.

**The client token is only used in production environments**. When [deploying your app to production with Clerk](/docs/deployments/overview), you configure a CNAME record to alias Clerk's Frontend API (FAPI) to a subdomain of your application (e.g., `clerk.example.com`). This ensures the client token cookie remains within the same site context and does not need to be sent cross-domain.

In development environments, FAPI requests are cross-domain (from `localhost` to `<slug>.accounts.dev`). Since Clerk does not allow cross-domain cookies for security and privacy reasons (see [tracking cookies and privacy concerns](/docs/backend-requests/resources/cookies#tracking-cookies-and-privacy-concerns)), we cannot use cookies to maintain session state in development. So instead of using the client token, development environments use a construct called the "dev browser" with a `__clerk_db_jwt` object to maintain session state across the session lifetime. While this enables smooth local development workflows, it is not secure enough for production use. For this reason:

1. Never deploy a development environment to production.
1. Do not rely on `__clerk_db_jwt` in your application code, as it will break in production.

For more information on the differences between development and production environments, see the [dedicated guide on Clerk environments](/docs/deployments/environments).

### Session token

The session token is a short-lived token that is stored in the `__session` cookie, which is set on your app's domain.

- **Cookie name:** `__session`
- **Contents:** A Clerk-signed JWT containing [a set of default claims](/docs/backend-requests/resources/session-tokens#default-claims). Can be customized in the Clerk Dashboard to include additional claims.
- **Domain:** Set on your application's domain directly, scoped strictly so it cannot be shared across subdomains. This is done to prevent a different app on a different subdomain from being able to take over your users' accounts. If you need to send the session token value across subdomain boundaries, such as from `example.com` to `api.example.com`, you can [put the token in a `request` header instead](/docs/backend-requests/making-requests).
- **Expiration:** 60 seconds
- **HttpOnly:** No - must be able to be accessed by client-side SDKs
- **SameSite:** Lax

When your app makes a request from the frontend to your backend, if the backend is on the same origin, the `__session` cookie will automatically be sent along with the request. Your backend can then [cryptographically verify](/docs/backend-requests/manual-jwt) the session token's signature and extract the user ID and other claims.

> [!QUIZ]
> Why is the `__session` cookie not `HttpOnly`? Is this a security issue?
>
> ---
>
> Setting cookies as `HttpOnly` is generally recommended to prevent client-side JavaScript access, reducing the risk of cross-site scripting (XSS) attacks. However, due to Clerk's architecture, this approach wouldn't work.
>
> Remember that FAPI is hosted on a different origin than your app. Let's say, in production, your app is `example.com`. Then FAPI is `clerk.example.com`. If FAPI set the `__session` cookie as `HttpOnly`, it would be scoped to `clerk.example.com`, preventing it from being sent to `example.com`. Since cookies are only sent to the domain that matches their domain value, which is the domain that sets them, this setup would block your app from accessing the cookie.
>
> To work around this, Clerk returns the session token from FAPI after a user signs in, and the client-side SDK used by your app (e.g., React SDK) sets the `__session` cookie containing the session token on your app's domain **via JavaScript**. A benefit of this is that it allows the token's value and session claims to be accessed on the client-side. This is often quite valuable, as it allows developers to send the session token as a custom header in requests and also makes it possible to use a subdomain (like `api.example.com`) for your backend. However, because it's set client-side, it cannot be `HttpOnly`, making it more vulnerable to XSS attacks.
>
> Clerk mitigates this risk substantially by setting the session token's expiration to a very short duration of 60 seconds. For an XSS attack to succeed, the developer would need to ship a vulnerability on their site, and the attacker would need to exfiltrate users' tokens and use them to take over accounts in an average of less than 30 seconds. This is an extremely difficult scenario and extremely unlikely to be an issue for the most common type of XSS attacks, which are broad sweeps across many sites to harvest tokens, typically after a CVE is disclosed, that can take advantage of those who didn't patch their sites in time. Additionally, Clerk's fast-expiring token provides an extra layer of protection against other attacks that `HttpOnly` cookies alone wouldn't mitigate.
>
> Summary: Clerk's `__session` cookie is not `HttpOnly` because it needs to be accessible to the client-side SDKs. However, Clerk mitigates the risk of XSS attacks by setting the session token's expiration to a very short duration of 60 seconds.

## The Handshake

The short-lived nature of session tokens introduces a case that requires special handling. Consider this scenario: A user signs in to your application and then closes their browser tab. When they return after five minutes by opening a new tab, their session token will have expired since the refresh mechanism could not run while the tab was closed. At this point, Clerk needs to determine the user's authentication status and potentially issue a new session token.

For client-rendered applications, this process is straightforward. Clerk's frontend SDK makes a direct request to FAPI with the `__client` cookie. If the client token is valid, FAPI issues and returns a new session token. This is _secure by default_, because only users who are properly authenticated and signed in will have a valid client token in their browser. If the client token is invalid, the user is redirected to the sign-in flow.

However, server-rendered applications present a unique challenge. Server-to-server requests cannot include browser cookies, as cookies are stored by the browser. This means that, if your app's backend made a request directly to FAPI, the client token would not be available with that request, as the request would not flow through the browser. To solve this problem, Clerk implements a "handshake" flow:

1. The server returns a **redirect response** to the browser
1. The browser follows the redirect to FAPI
1. FAPI receives the request with the `__client` cookie
1. FAPI validates the authentication state and issues a new session token

This server -> browser -> FAPI request includes the client token, so FAPI is able to verify the user's auth state and issue a new session token securely. This handshake ensures secure token renewal while maintaining the benefits of server-side rendering.

> [!QUIZ]
> Why does handshake do a redirect? Why can't it make a fetch request to FAPI and get a new token back that way? Not needing to redirect would be a better user experience.
>
> ---
>
> First remember that with Clerk, the **session token** is the short-lived one that refreshes every 60 seconds, and the **client token** is the long-lived one whose expiration is your session's lifetime.
>
> Now let's get back to the previous scenario: you open your server-rendered application after having closed the tab for a few minutes, and now you have an expired session token. Normally, to refresh your session token, you make a request to FAPI with the `__client` cookie that contains the long-lived client token. FAPI will validate the client token and check if there's an active session. If there is, it will mint a new session token and send it back.
>
> But in this scenario, you have only an invalid (expired) session token, and since your app is rendering on the server, you cannot send a request with the client token since it's stored in a cookie in the browser and server-to-server requests don't flow through the browser. So the question becomes this: how do you get a new session token?
>
> - You could send the expired session token, but then any attacker with an expired session token would be able to mint a new one and hijack your session.
> - You could verify that the request only comes from your application's domain, but then any attacker could just send an `http` request with a spoofed domain value and get a token on your behalf.
>
> Neither of these options are secure. Clerk's unique authentication model requires a new mechanism to get a new session token. This is where handshake comes in - here's how it works:
>
> 1. A request is made to an application that uses Clerk on the server.
> 1. The Clerk SDK used by your app determines the authentication state of the request: `signed-in` (valid session token), `signed-out` (no session token), or `handshake` (expired session token).
> 1. If the authentication state is `handshake`, meaning Clerk knows the session token is expired but can't be sure if the user is signed in or out, the Clerk SDK responds with a 307 redirect to the handshake endpoint: `fapi/v1/client/handshake`.
> 1. The handshake endpoint gets information about the current session and returns a handshake payload. The encoded handshake payload contains a list of `Set-Cookie` header directives to be passed along with the final response.
>    - If the session is active, a new, valid `__session` cookie is returned.
>    - If the session is inactive, the `__session` cookie is wiped and the request will be treated as signed out.
> 1. The handshake endpoint redirects back to the host application along with the handshake payload, encoded either in the URL (development) or as a cookie (production).
> 1. The handshake payload is parsed and `Set-Cookie` headers are set on the response by the Clerk SDK.
> 1. If an updated `__session` cookie is returned, the JWT is verified. If verification is successful, the request is treated as signed in.
> 1. If an updated `__session` cookie is not returned, the request is treated as signed out.
>
> This makes it such that you can't provide proof of authentication via an API call - the proof comes from the **`__client` cookie** on FAPI which can't be tampered with by attackers since it's not set on the application domain and is `HttpOnly`.

{/*
  Future sections to add
  - the anatomy of clerk's sign up and sign in flows
  - subdomain session sharing
  - satellite domains
*/}

---
title: Identification errors
description: An index of Clerk errors related to identification, such as phone numbers and email addresses.
type: reference
---

An index of Clerk errors related to identification, such as phone numbers and email addresses.

## `IdentificationNotFound`

Signifies an error when an identification is not found.

```json
{
  "shortMessage": "Resource not found",
  "longMessage": "No resource was found for ID <resourceID>",
  "code": "resource_not_found_code"
}
```

## <code>LastIdentification<wbr />DeletionFailed</code>

Signifies an error when trying to delete an identification associated with a user, but it is the last one associated with the user. The user must have at least one identification associated with their account at all times.

```json
{
  "shortMessage": "Deletion failed",
  "longMessage": "You cannot delete your last identification.",
  "code": "identification_deletion_failed_code"
}
```

## <code>LastRequiredIdentification<wbr />DeletionFailed</code>

Signifies an error when trying to delete an identification associated with a user, but it is the last one associated with the user. The user must have at least one identification associated with their account at all times.

```json
{
  "shortMessage": "Deleting your last <sanitizedIdentType> is prohibited",
  "longMessage": "You are required to maintain at least one <sanitizedIdentType> in your account at all times",
  "code": "last_required_identification_deletion_failed_code"
}
```

## <code>LastIdentificationSet<wbr />For2FAFailed</code>

Signifies an error when trying to set the only identification associated with the user as a second factor. The user must have at least two identifications associated with their account before they can set one as a second factor.

```json
{
  "shortMessage": "Update failed",
  "longMessage": "You cannot set your last identification as second factor.",
  "code": "identification_set_for2_f_a_failed_code"
}
```

## <code>UpdateSecondFactor<wbr />Unverified</code>

Signifies an error when trying to update second factor attributes for an identification that is not verified. The identification must be verified before it can be used as a second factor.

```json
{
  "shortMessage": "Update failed",
  "longMessage": "Cannot update second factor attributes for unverified identification",
  "code": "identification_update_second_factor_unverified"
}
```

---
title: Implement basic Role Based Access Control (RBAC) with metadata
description: Learn how to leverage Clerk's publicMetadata to implement your own basic Role Based Access Controls.
---

To control which users can access certain parts of your app, you can use the [roles feature](/docs/organizations/roles-permissions#roles). Although Clerk offers roles as part of the [organizations](/docs/organizations/overview) feature set, not every app implements organizations. **This guide covers a workaround to set up a basic Role Based Access Control (RBAC) system for products that don't use Clerk's organizations or roles.**

This guide assumes that you're using Next.js App Router, but the concepts can be adapted to Next.js Pages Router and Remix.

<Steps>
  ## Configure the session token

  Clerk provides [user metadata](/docs/users/metadata), which can be used to store information, and in this case, it can be used to store a user's role. Since `publicMetadata` can only be read but not modified in the browser, it is the safest and most appropriate choice for storing information.

  To build a basic RBAC system, you first need to make `publicMetadata` available to the application directly from the session token. By attaching `publicMetadata` to the user's session, you can access the data without needing to make a network request each time.

  1. In the Clerk Dashboard, navigate to the [**Sessions**](https://dashboard.clerk.com/last-active?path=sessions) page.
  1. Under the **Customize session token** section, select **Edit**.
  1. In the modal that opens, enter the following JSON and select **Save**. If you have already customized your session token, you may need to merge this with what you currently have.

  ```json
  {
    "metadata": "{{user.public_metadata}}"
  }
  ```

  <Include src="_partials/custom-flows-callout" />

  ## Create a global TypeScript definition

  1. In your application's root folder, create a `types/` directory.
  1. Inside this directory, create a `globals.d.ts` file with the following code. This file will provide auto-completion and prevent TypeScript errors when working with roles. For this guide, only the `admin` and `moderator` roles will be defined.

  ```ts {{ filename: 'types/globals.d.ts' }}
  export {}

  // Create a type for the roles
  export type Roles = 'admin' | 'moderator'

  declare global {
    interface CustomJwtSessionClaims {
      metadata: {
        role?: Roles
      }
    }
  }
  ```

  ## Set the admin role for your user

  Later in the guide, you will add a basic admin tool to change a user's role. For now, manually add the `admin` role to your own user account.

  1. In the Clerk Dashboard, navigate to the [**Users**](https://dashboard.clerk.com/last-active?path=users) page.
  1. Select your own user account.
  1. Scroll down to the **User metadata** section and next to the **Public** option, select **Edit**.
  1. Add the following JSON and select **Save**.

  ```json
  {
    "role": "admin"
  }
  ```

  ## Create a reusable function to check roles

  Create a helper function to simplify checking roles.

  1. In your application's root directory, create a `utils/` folder.
  1. Inside this directory, create a `roles.ts` file with the following code. The `checkRole()` helper uses the [`auth()`](/docs/references/nextjs/auth) helper to access the user's session claims. From the session claims, it accesses the `metadata` object to check the user's role. The `checkRole()` helper accepts a role of type `Roles`, which you created in the [Create a global TypeScript definition](#create-a-global-type-script-definition) step. It returns `true` if the user has that role or `false` if they do not.

  ```ts {{ filename: 'utils/roles.ts' }}
  import { Roles } from '@/types/globals'
  import { auth } from '@clerk/nextjs/server'

  export const checkRole = async (role: Roles) => {
    const { sessionClaims } = await auth()
    return sessionClaims?.metadata.role === role
  }
  ```

  > [!NOTE]
  > You can customize the behavior of the `checkRole()` helper function to suit your needs. For example, you could modify it to return the roles a user has or create a `protectByRole()` function that handles role-based redirects.

  ## Create the admin dashboard

  Now, it's time to create an admin dashboard. The first step is to create the `/admin` route.

  1. In your `app/` directory, create an `admin/` folder.
  1. In the `admin/` folder, create a `page.tsx` file with the following placeholder code.

  ```tsx {{ filename: 'app/admin/page.tsx' }}
  export default function AdminDashboard() {
    return <p>This is the protected admin dashboard restricted to users with the `admin` role.</p>
  }
  ```

  ## Protect the admin dashboard

  To protect the `/admin` route, choose **one** of the two following methods:

  1. **Middleware**: Apply role-based access control globally at the route level. This method restricts access to all routes matching `/admin` before the request reaches the actual page.
  1. **Page-level role check**: Apply role-based access control directly in the `/admin` page component. This method protects this specific page. To protect other pages in the admin dashboard, apply this protection to each route.

  > [!IMPORTANT]
  > You only need to follow **one** of the following methods to secure your `/admin` route.

  ### Option 1: Protect the `/admin` route using middleware

  1. In your app's root directory, create a `middleware.ts` file with the following code. The `createRouteMatcher()` function identifies routes starting with `/admin`. `clerkMiddleware()` intercepts requests to the `/admin` route, and checks the user's role in their `metadata` to verify that they have the `admin` role. If they don't, it redirects them to the home page.

  ```tsx {{ filename: 'middleware.ts' }}
  import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'
  import { NextResponse } from 'next/server'

  const isAdminRoute = createRouteMatcher(['/admin(.*)'])

  export default clerkMiddleware(async (auth, req) => {
    // Protect all routes starting with `/admin`
    if (isAdminRoute(req) && (await auth()).sessionClaims?.metadata?.role !== 'admin') {
      const url = new URL('/', req.url)
      return NextResponse.redirect(url)
    }
  })

  export const config = {
    matcher: [
      // Skip Next.js internals and all static files, unless found in search params
      '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
      // Always run for API routes
      '/(api|trpc)(.*)',
    ],
  }
  ```

  ### Option 2: Protect the `/admin` route at the page-level

  1. Add the following code to the `app/admin/page.tsx` file. The `checkRole()` function checks if the user has the `admin` role. If they don't, it redirects them to the home page.

  ```tsx {{ filename: 'app/admin/page.tsx' }}
  import { checkRole } from '@/utils/roles'
  import { redirect } from 'next/navigation'

  export default async function AdminDashboard() {
    // Protect the page from users who are not admins
    const isAdmin = await checkRole('admin')
    if (!isAdmin) {
      redirect('/')
    }

    return <p>This is the protected admin dashboard restricted to users with the `admin` role.</p>
  }
  ```

  ## Create server actions for managing a user's role

  1. In your `app/admin/` directory, create an `_actions.ts` file with the following code. The `setRole()` action checks that the current user has the `admin` role before updating the specified user's role using Clerk's [JavaScript Backend SDK](/docs/references/backend/user/update-user). The `removeRole()` action removes the role from the specified user.

  ```ts {{ filename: 'app/admin/_actions.ts' }}
  'use server'

  import { checkRole } from '@/utils/roles'
  import { clerkClient } from '@clerk/nextjs/server'

  export async function setRole(formData: FormData) {
    const client = await clerkClient()

    // Check that the user trying to set the role is an admin
    if (!checkRole('admin')) {
      return { message: 'Not Authorized' }
    }

    try {
      const res = await client.users.updateUserMetadata(formData.get('id') as string, {
        publicMetadata: { role: formData.get('role') },
      })
      return { message: res.publicMetadata }
    } catch (err) {
      return { message: err }
    }
  }

  export async function removeRole(formData: FormData) {
    const client = await clerkClient()

    try {
      const res = await client.users.updateUserMetadata(formData.get('id') as string, {
        publicMetadata: { role: null },
      })
      return { message: res.publicMetadata }
    } catch (err) {
      return { message: err }
    }
  }
  ```

  ## Create a component for searching for users

  1. In your `app/admin/` directory, create a `SearchUsers.tsx` file with the following code. The `<SearchUsers />` component includes a form for searching for users. When submitted, it appends the search term to the URL as a search parameter. Your `/admin` route will then perform a query based on the updated URL.

  ```tsx {{ filename: 'app/admin/SearchUsers.tsx' }}
  'use client'

  import { usePathname, useRouter } from 'next/navigation'

  export const SearchUsers = () => {
    const router = useRouter()
    const pathname = usePathname()

    return (
      <div>
        <form
          onSubmit={(e) => {
            e.preventDefault()
            const form = e.currentTarget
            const formData = new FormData(form)
            const queryTerm = formData.get('search') as string
            router.push(pathname + '?search=' + queryTerm)
          }}
        >
          <label htmlFor="search">Search for users</label>
          <input id="search" name="search" type="text" />
          <button type="submit">Submit</button>
        </form>
      </div>
    )
  }
  ```

  ## Refactor the admin dashboard

  With the server action and the search form set up, it's time to refactor the `app/admin/page.tsx`.

  1. Replace the code in your `app/admin/page.tsx` file with the following code. It checks whether a search parameter has been appended to the URL by the search form. If a search parameter is present, it queries for users matching the entered term. If one or more users are found, the component displays a list of users, showing their first and last names, primary email address, and current role. Each user has `Make Admin` and `Make Moderator` buttons, which include hidden inputs for the user ID and role. These buttons use the `setRole()` server action to update the user's role.

  ```tsx {{ filename: 'app/admin/page.tsx' }}
  import { redirect } from 'next/navigation'
  import { checkRole } from '@/utils/roles'
  import { SearchUsers } from './SearchUsers'
  import { clerkClient } from '@clerk/nextjs/server'
  import { removeRole, setRole } from './_actions'

  export default async function AdminDashboard(params: {
    searchParams: Promise<{ search?: string }>
  }) {
    if (!checkRole('admin')) {
      redirect('/')
    }

    const query = (await params.searchParams).search

    const client = await clerkClient()

    const users = query ? (await client.users.getUserList({ query })).data : []

    return (
      <>
        <p>This is the protected admin dashboard restricted to users with the `admin` role.</p>

        <SearchUsers />

        {users.map((user) => {
          return (
            <div key={user.id}>
              <div>
                {user.firstName} {user.lastName}
              </div>

              <div>
                {
                  user.emailAddresses.find((email) => email.id === user.primaryEmailAddressId)
                    ?.emailAddress
                }
              </div>

              <div>{user.publicMetadata.role as string}</div>

              <form action={setRole}>
                <input type="hidden" value={user.id} name="id" />
                <input type="hidden" value="admin" name="role" />
                <button type="submit">Make Admin</button>
              </form>

              <form action={setRole}>
                <input type="hidden" value={user.id} name="id" />
                <input type="hidden" value="moderator" name="role" />
                <button type="submit">Make Moderator</button>
              </form>

              <form action={removeRole}>
                <input type="hidden" value={user.id} name="id" />
                <button type="submit">Remove Role</button>
              </form>
            </div>
          )
        })}
      </>
    )
  }
  ```

  ## Finished 

  The foundation of a custom RBAC (Role-Based Access Control) system is now set up. Roles are attached directly to the user's session, allowing your application to access them without the need for additional network requests. The `checkRole()` helper function simplifies role checks and reduces code complexity. The final component is the admin dashboard, which enables admins to efficiently search for users and manage roles.
</Steps>

---
title: Instances / Environments
description: An overview of the differences between development and production instances.
---

When creating a new application within Clerk, you are provided with two instances: `Development` and `Production`.  These instances vary slightly and should only be used appropriately.

## Development instance

A `Development` instance is Clerk's default instance type and has characteristics that allow it to be more useful for local development. To facilitate development and local authentication, `Development` instances have a more relaxed security posture and are not suitable for production workloads.

Some notable examples of `Development`-only characteristics in a Clerk application are:

- A `Development` banner is shown prominently in the Clerk Dashboard to make clear you're managing or configuring non-production data
- Email and SMS templates are prefixed with the environment type to prevent against using `Development` instances for production purposes
- Some social connections use shared credentials by default
- [The Account Portal](/docs/account-portal/overview) will use a Clerk development domain that ends with `accounts.dev` instead of your app's production domain
- OAuth consent screens will show the development domain that ends with `accounts.dev` instead of your production domain
- Search engines will not be able to crawl and index your application
- Development instances have a 100 users cap and user data can not be transferred between instances

> [!NOTE]
> All paid functionality is available in a `Development` instance. However, when you deploy your application to `Production`, you will be asked to upgrade to a `Pro` account. See [our pricing page](/pricing) for full details.

## Production instance

A `Production` instance is the more robust option of Clerk's instance types. `Production` instances are meant to support high volumes of traffic and by default, have a more strict security posture.

Some notable differences between `Production` and `Development` instances in a Clerk application are:

- You must associate a production domain within the Clerk Dashboard
- You are required to provision your own SSO credentials

When deploying to production, you must first activate your `Production` environment. See the [Deploying to Production](/docs/deployments/overview) guide to learn about the process and avoid common pitfalls.

## Staging environments

Clerk does not currently support staging instances in Clerk applications. However, you can set up a "staging environment" by creating a separate Clerk application with a separate domain. For more information, see the [staging guide](/docs/deployments/set-up-staging).

## Preview environments

See [the preview environment guide](/docs/deployments/set-up-preview-environment) to learn how to use Clerk with your preview deployments.

---
title: Integrate Clerk into your Next.js + tRPC app
description: Learn how to integrate Clerk into your Next.js app using tRPC.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Integrate Clerk into your Next.js application",
      link: "/docs/quickstarts/nextjs",
      icon: "nextjs",
    },
  ]}
  exampleRepo={[
    {
      title: "Clerk, Next.js, tRPC, Prisma Demo",
      link: "https://github.com/clerk/clerk-nextjs-trpc-prisma"

    }
  ]}
/>

Clerk's [`Auth`](/docs/references/backend/types/auth-object) object includes important authentication information like the current user's session ID, user ID, and organization ID. It also contains methods to check for the current user's permissions and to retrieve their session token. You can use the `Auth` object to access the user's authentication information in your tRPC queries.

This guide demonstrates how to create a Clerk authentication context and use it in a tRPC query. It assumes that you have already integrated Clerk into your app by following the [quickstart](/docs/quickstarts/nextjs).

<Steps>
  ## Update your providers

  When creating your tRPC client, you create a tRPC provider in order to use the tRPC client in your app. Your tRPC provider must be wrapped by Clerk's `<ClerkProvider>` component in order for tRPC to have access to Clerk's authentication context.

  ```tsx {{ filename: 'app/layout.tsx', mark: [[9, 10], [26, 27]] }}
  // ...Imports and other code...

  export default function RootLayout({
    children,
  }: Readonly<{
    children: React.ReactNode
  }>) {
    return (
      <ClerkProvider>
        <TRPCProvider>
          <html lang="en">
            <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
              <header className="flex justify-end items-center p-4 gap-4 h-16">
                <SignedOut>
                  <SignInButton />
                  <SignUpButton />
                </SignedOut>
                <SignedIn>
                  <Link href="/">Home</Link>
                  <UserButton />
                </SignedIn>
              </header>
              {children}
            </body>
          </html>
        </TRPCProvider>
      </ClerkProvider>
    )
  }
  ```

  ## Create the tRPC context

  Create a file that will be used to create the context for every tRPC query sent to the server. The context will use the [`auth()`](/docs/references/nextjs/auth) helper from Clerk to access the user's `Auth` object.

  ```ts {{ filename: 'app/server/context.ts' }}
  import { auth } from '@clerk/nextjs/server'

  export const createContext = async () => {
    return { auth: await auth() }
  }

  export type Context = Awaited<ReturnType<typeof createContext>>
  ```

  Then, in your tRPC server, pass the context to the `createContext` parameter in the `fetchRequestHandler()` function. For this guide, the context is named `createContext`, which is the same as the parameter name, so it's passed as a shorthand property. If you named the context something different, you would need to pass it as a named property, like `{ createContext: exampleContext }`.

  ```ts {{ filename: 'app/api/trpc/[trpc]/route.ts', mark: [3, 10] }}
  import { fetchRequestHandler } from '@trpc/server/adapters/fetch'
  import { appRouter } from '@/app/server/routers/posts'
  import { createContext } from '@/app/server/context'

  const handler = (req: Request) =>
    fetchRequestHandler({
      endpoint: '/api/trpc',
      req,
      router: appRouter,
      createContext,
    })

  export { handler as GET, handler as POST }
  ```

  ## Access the context data in your procedures

  The tRPC context, or `ctx`, should now have access to the Clerk `Auth` object.

  In the following example, the `ctx` is used to access the user's ID and return a greeting message. If the user is not signed in, the `greeting` will return `Hello! You are not signed in.`.

  ```ts {{ filename: 'app/server/routers/index.ts' }}
  import { router, publicProcedure } from '../trpc'

  export const exampleRouter = router({
    hello: publicProcedure.query(({ ctx }) => {
      const { userId } = ctx.auth

      if (!userId) {
        return {
          greeting: 'Hello! You are not signed in.',
        }
      }

      return {
        greeting: `Hello ${userId}!`,
      }
    }),
  })

  export type exampleRouter = typeof exampleRouter
  ```

  ## Create a protected procedure

  In many applications, it's essential to restrict access to certain routes based on user authentication status. This ensures that sensitive data and functionality are only accessible to authorized users. tRPC middleware provides a powerful mechanism for implementing this protection within your application.

  In the following example, tRPC middleware is used to access the `ctx`, which contains the user's authentication information. If the user's ID exists in the authentication context, this means that the user is signed in. If they are not signed in, an `UNAUTHORIZED` error is thrown.

  ```ts {{ filename: 'app/server/trpc.ts', mark: [[6, 17], 21] }}
  import { initTRPC, TRPCError } from '@trpc/server'
  import { Context } from './context'

  const t = initTRPC.context<Context>().create()

  // Check if the user is signed in
  // Otherwise, throw an UNAUTHORIZED code
  const isAuthed = t.middleware(({ next, ctx }) => {
    if (!ctx.auth.userId) {
      throw new TRPCError({ code: 'UNAUTHORIZED' })
    }
    return next({
      ctx: {
        auth: ctx.auth,
      },
    })
  })

  export const router = t.router
  export const publicProcedure = t.procedure
  export const protectedProcedure = t.procedure.use(isAuthed)
  ```

  ## Use your protected procedure

  Once you have created your procedure, you can use it in any router.

  In the following example, the protected procedure is used to return a secret message that includes the user's ID. If the user is not signed in, the `hello` procedure will return an `UNAUTHORIZED` error, as configured in the step above.

  ```ts {{ filename: 'src/server/routers/index.ts' }}
  import { router, protectedProcedure } from '../trpc'

  export const protectedRouter = router({
    hello: protectedProcedure.query(({ ctx }) => {
      const { userId } = ctx.auth

      return {
        secret: `${userId} is using a protected procedure`,
      }
    }),
  })
  ```
</Steps>

---
title: Integrate Convex with Clerk
description: Learn how to integrate Clerk into your Convex application.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Create a React + Convex application",
      link: "https://docs.convex.dev/quickstart/react",
      icon: "react",
    },
  ]}
/>

Convex is the full-stack TypeScript development platform. With Convex you get to build a backend with a provided realtime database, file storage, text search, scheduling and more. Paired with Clerk's user authentication and management features, you can build a powerful application with minimal effort.

This tutorial assumes that you have already [set up a Clerk application](/docs/quickstarts/setup-clerk) and a [React + Convex application](https://docs.convex.dev/quickstart/react){{ target: '_blank' }}. This tutorial will also assume that you have not added Clerk to your application yet.

<Steps>
  ## Create a JWT template based on Convex

  In the Clerk Dashboard, navigate to the [**JWT templates**](https://dashboard.clerk.com/last-active?path=jwt-templates) page. Select the **New template** button to create a new template based on Convex.

  ![The JWT templates page in the Clerk Dashboard. The 'New template' button was clicked, and a pop up titled 'New JWT template' is shown. The 'Convex' template is hovered over](/docs/images/integrations/convex/jwt-templates.webp)

  Once the Convex template is created, you will be redirected to the template's page. You can now configure the template to your needs.

  ![The 'Create new template' page of the JWT templates page in the Clerk Dashboard](/docs/images/integrations/convex/create-template.webp)

  The Convex template will pre-populate the default audience (`aud`) claim required by Convex. You can include additional claims as necessary. [Shortcodes](/docs/backend-requests/jwt-templates#shortcodes) are available to make adding dynamic user values easy.

  ![The 'Create new template' page of the JWT templates page in the Clerk Dashboard. The page is scrolled down to the 'Claims' section](/docs/images/integrations/convex/template-shortcodes.webp)

  By default, Clerk will sign the JWT with a private key automatically generated for your application, which is what most developers use for Convex. If you so choose, you can customize this key.

  ## Configure Convex with the Clerk issuer domain

  The next step is to configure Convex with the issuer domain provided by Clerk. From your Clerk **JWT template** screen, find the **Issuer** input and click to **Copy** the URL.

  ![The 'Create new template' page of the JWT templates page in the Clerk Dashboard. There is a red box surrounding the 'Issuer' section](/docs/images/integrations/convex/template-issuer.webp)

  In your `convex` folder, add an `auth.config.js` file with the following configuration:

  ```ts {{ filename: 'convex/auth.config.js' }}
  export default {
    providers: [
      {
        domain: 'https://your-issuer-url.clerk.accounts.dev/',
        applicationID: 'convex',
      },
    ],
  }
  ```

  Replace the `domain` string with the **Issuer** URL you copied.

  ## Deploy your changes to Convex

  Run `npx convex dev` to automatically sync your configuration to your backend.

  ## Install `@clerk/clerk-react`

  Run the following command to install Clerk's React SDK:

  <CodeBlockTabs options={["npm", "yarn",  "pnpm" ]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/clerk-react
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/clerk-react
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/clerk-react
    ```
  </CodeBlockTabs>

  ## Set environment variables

  In your React project's root folder, you may have an `.env` file alongside `package.json` and other configuration files. If you don't see it, create it.

  <SignedIn>
    Add your Clerk Publishable Key to your `.env` file. It can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
  </SignedIn>

  <SignedOut>
    1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
    1. In the **Quick Copy** section, copy your Clerk Publishable Key.
    1. Paste your key into your `.env` file.

    The final result should resemble the following:
  </SignedOut>

  ```env {{ filename: '.env' }}
  VITE_CLERK_PUBLISHABLE_KEY={{pub_key}}
  ```

  ## Configure the Clerk and Convex providers

  Both Clerk and Convex have provider components that are required to provide authentication and client context.

  Clerk's provider component is `<ClerkProvider>`, which should wrap your entire app at the entry point to make authentication globally accessible. See the [reference docs](/docs/components/clerk-provider) for other configuration options.

  Convex offers a provider that is specifically for integrating with Clerk called [`<ConvexProviderWithClerk>`](https://docs.convex.dev/auth/clerk).

  The following example demonstrates how to configure Clerk and Convex's providers. Clerk's `useAuth()` hook must be passed to `<ConvexProviderWithClerk>` and Clerk's `<ClerkProvider>` must be wrapped around it.

  ```ts {{ filename: 'src/main.tsx' }}
  import React from 'react'
  import ReactDOM from 'react-dom/client'
  import App from './App'
  import './index.css'
  import { ClerkProvider, useAuth } from '@clerk/clerk-react'
  import { ConvexProviderWithClerk } from 'convex/react-clerk'
  import { ConvexReactClient } from 'convex/react'

  // Import your Publishable Key
  const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  if (!PUBLISHABLE_KEY) {
    throw new Error('Missing Publishable Key')
  }

  const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string)

  ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
      <ClerkProvider publishableKey={PUBLISHABLE_KEY}>
        <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
          <App />
        </ConvexProviderWithClerk>
      </ClerkProvider>
    </React.StrictMode>,
  )
  ```

  ## Access user identity in Convex queries and mutations

  You can access the user information from the JWT in Convex queries and mutations.
  Use the `ctx.auth.getUserIdentity()` which returns the parsed information from the JWT, or `null` if the client isn't authenticated.

  ```ts
  import type { UserIdentity } from 'convex/server'
  import { query } from './_generated/server'

  export default query(async (ctx) => {
    const user = await ctx.auth.getUserIdentity()

    if (user === null) {
      return null
    }

    return user.tokenIdentifier
  })
  ```

  You can customize the information in the JWT by navigating to the [**JWT templates**](https://dashboard.clerk.com/last-active?path=jwt-templates) page in the Clerk Dashboard. Previously, Convex explicitly listed fields derived from [OpenID standard claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). Now, Convex allows keys to accept [custom claims](https://docs.convex.dev/api/interfaces/server.UserIdentity).

  ## Finished!

  You now have a fully functioning React and Convex application with Clerk authentication. Be aware that Convex may require usage of their custom hooks and methods rather than Clerk's, such as using Convex's `useConvexAuth()` hook instead of Clerk's `useAuth()` hook in some cases. For more information on how to use Convex with Clerk, see the [Convex docs](https://docs.convex.dev/auth/clerk).
</Steps>

---
title: Integrate Fauna with Clerk
description: Learn how to integrate Clerk into your Fauna application.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Integrate the appropriate Clerk SDK in your local project",
      link: "/docs/quickstarts/overview",
      icon: "code-bracket",
    },
  ]}
  exampleRepo={[
    {
      title: "Clerk, Fauna, and Next.js Demo Repo",
      link: "https://github.com/clerk/clerk-fauna-nextjs",
      icon: "code-bracket",
    },
  ]}
/>

Integrating Fauna with Clerk gives you the benefits of using a Fauna database while leveraging Clerk's authentication, prebuilt components, and webhooks.

This guide will walk you through the steps to integrate Fauna with Clerk in your Next.js app.

<Steps>
  ## Get your Clerk Frontend API URL and JWKS URL

  <SignedIn>
    Add the following keys to your `.env` file. These keys can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
  </SignedIn>

  <SignedOut>
    1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
    1. Copy the **Frontend API URL** and **JWKS URL**.
    1. Paste your keys into your `.env` file.

    The final result should resemble the following:
  </SignedOut>

  ```env {{ filename: '.env' }}
  NEXT_PUBLIC_CLERK_FRONTEND_API_URL={{fapi_url}}
  NEXT_PUBLIC_CLERK_JWKS_URL={{jwks_url}}
  ```

  ## Configure Fauna

  1. Navigate to the [Fauna Dashboard](https://dashboard.fauna.com/) and select your database.
  1. Select the **Access Providers** tab and select **Create Access Provider**.
  1. Fill out the form:
     - Enter a **Name** for the access provider, such as Clerk.
     - Copy and save the **Audience** URL. You will need this later.
     - In **Issuer**, paste the Clerk **Frontend API URL** you copied in the previous step. Do not include a trailing slash (`/`).
     - In **JWKS Endpoint**, paste the Clerk **JWKS URL** you copied in the previous step.
     - Select **Create**.
  1. Select the access provider that you just created.
  1. Update the access provider's FSL schema to include a [user-defined role](https://docs.fauna.com/fauna/current/learn/security/roles/). For example:
     ```fsl {{ mark: [6, 7] }}
     access provider Clerk {
       // Don't change the values of the issuer or jwks_uri fields.
       issuer "..."
       jwks_uri "..."

       // Adds a user-defined role to Clerk JWTs.
       role <YOUR_ROLE>
     }
     ```
  1. Select **Save**.

  ## Create a JWT template in Clerk

  Clerk's JWT templates allow you to generate a new valid Fauna authentication token (JWT) for each signed in user. These tokens allow authenticated users to access your data with Fauna's API.

  To create a JWT template for Fauna:

  1. In the Clerk Dashboard, navigate to the [**JWT templates**](https://dashboard.clerk.com/last-active?path=jwt-templates) page.
  1. Select the **New template** button, then select **Fauna** from the list of options.
  1. Configure your template:
     - The value of the **Name** field will be required when using the template in your code. For this tutorial, name it `fauna`.
     - You can leave all other fields as their default settings or customize them to your needs. See the [JWT template guide](/docs/backend-requests/jwt-templates#create-a-jwt-template) to learn more about these settings.
     - In the **Claims** section, set the `aud` claim to the **Audience URL** you copied from Fauna in Step 2. The URL format should be `https://db.fauna.com/db/<YOUR_FAUNA_DB_ID>`. You can include additional claims if youd like, but `aud` is the only required one. [Shortcodes](/docs/backend-requests/jwt-templates#shortcodes) are available to make adding dynamic user values easy.
     - Select **Save** from the notification bubble to complete setup.

  ## Install the Fauna library

  Add the Fauna library to your project.

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm i fauna
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add fauna
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add fauna
    ```

    ```bash {{ filename: 'terminal' }}
    bun add fauna
    ```
  </CodeBlockTabs>

  ## Authenticate Fauna queries in your Next.js app

  You can now create Fauna JWTs in Clerk using the JWT template you created in the previous step. Generate the Fauna JWT by calling Clerk's [`useAuth().getToken`](/docs/hooks/use-auth) method, and use it to authenticate with Fauna as an end user, as shown in the following example:

  ```jsx {{ filename: 'app/page.tsx' }}
  'use client'

  import React from 'react'
  import { useAuth } from '@clerk/nextjs'
  import { Client, fql } from 'fauna'

  export default function Page() {
    const [message, setMessage] = React.useState('')
    // The `useAuth()` hook is used to get the `getToken()` method.
    const { getToken } = useAuth()

    // Create a function to make a query to Fauna.
    const makeQuery = async () => {
      let client

      try {
        // Get the custom Fauna token from Clerk.
        const clerkToken = await getToken({ template: 'fauna' })

        if (!clerkToken) {
          setMessage('No token found')
          return
        }

        // Initialize a new Fauna client with the Clerk token.
        client = new Client({ secret: clerkToken })

        // Make a query to Fauna.
        const response = await client.query(fql`'Hello World!'`)
        setMessage(JSON.stringify(response))
      } catch (error) {
        console.error(error)
        setMessage('Error occurred')
      } finally {
        if (client) client.close()
      }
    }

    return (
      <>
        <button onClick={makeQuery}>Make authenticated query</button>
        <p>Message: {message}</p>
      </>
    )
  }
  ```

  > [!NOTE]
  > The `getToken({ template: <your-template-name> })` call is asynchronous and returns a Promise that needs to be resolved before accessing the token value. This token is short-lived for better security and should be called before every request to your Fauna database. The caching and refreshing of the token are handled automatically by Clerk.
</Steps>

---
title: Integrate Firebase with Clerk
description: Learn how to integrate Clerk into your Firebase application.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Set up a Firebase project with an app",
      link: "https://support.google.com/firebase/answer/9326094?hl=en",
      icon: "cog-6-teeth",
    },
    {
      title: "Integrate the appropriate Clerk SDK in your local project",
      link: "/docs/quickstarts/overview",
      icon: "code-bracket",
    },
  ]}
  exampleRepo={[
    {
      title: "Clerk, Firebase, and Next.js Demo Repo",
      link: "https://github.com/clerk/clerk-firebase-nextjs",
      icon: "code-bracket",
    },
  ]}
/>

Integrating Firebase with Clerk gives you the benefits of using Firebase's features while leveraging Clerk's authentication, prebuilt components, and webhooks.

<Steps>
  ## Configure the integration

  The Firebase integration enables you to use Clerk to generate a valid authentication token to send to Firebase Auth. This enables you to leverage Clerk's prebuilt components, auth provider options, and more, while accessing Firebase products like Firestore with a session validated by Firebase Auth.

  To get enable the integration:

  1. In the Clerk Dashboard, navigate to the [**Integrations**](https://dashboard.clerk.com/last-active?path=integrations) page.
  1. Toggle the **Firebase** integration on. The configuration modal will appear. Keep this open while you configure your Firebase project.

  Next, configure your integration.

  <Tabs items={["Configure automatically (Recommended)", "Configure manually"]}>
    <Tab>
      The recommended way to configure your integration is to use a service account key provided by Firebase in order to configure the integration _automatically_. To do so:

      1. In your Firebase project, visit [the Service Accounts settings](https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk).
      1. Near the bottom of the page, select the **Generate new private key** button.
      1. In the modal that pops up, select the **Generate key** button to download the JSON file that contains your service account key.
      1. In the Clerk Dashboard, the Firebase configuration modal should still be open. Select the **Upload service account key** button and upload the JSON file you downloaded.
      1. The appropriate fields in the configuration modal will be filled in automatically. Select **Apply changes** to save your configuration.

      Select the **Configure manually** tab above these instructions if you do not want to use a service account key.
    </Tab>

    <Tab>
      If you want to manually configure your Firebase integration, you must provide Clerk with the following information about your Firebase project:

      - **Service account email**  Find this in your Firebase project's [Google Cloud Console](https://console.cloud.google.com/projectselector2/iam-admin/serviceaccounts?consoleUI=FIREBASE\&hl=fi\&supportedpurview=project), or in the `client_email` field of your service account key JSON file.
      - **Firestore project ID**  Find this under **Project Settings** in the Firebase dashboard, or in the `project_id` field of your service account key JSON file.
      - **Private Key**  You can [generate this manually](https://firebase.google.com/docs/cloud-messaging/auth-server#:~:text=In%20the%20Firebase%20console%2C%20open,confirm%20by%20clicking%20Generate%20Key.), or find it in the `private_key` field of your service account key JSON file.
      - **Firebase database URL** _(Optional)_  To find this:
        - In the Firebase dashboard, select **Realtime Database**
        - Select the **Data** tab, and select the copy button to add the database URL to your clipboard.
    </Tab>
  </Tabs>

  ## Enable authentication in Firebase

  To use Firebase auth, ensure authentication is enabled in your Firebase dashboard. To do so:

  1. Navigate to your Firebase dashboard.
  1. In the navigation sidenav, select the **Build** dropdown and select [**Authentication**](https://console.firebase.google.com/u/0/project/_/authentication).
  1. Select **Get started**.
  1. Enable any sign-in method you want, such as **Email/Password**.

  ## Add a Security Rule to your Firestore database (optional)

  Adding the [Cloud Firestore](https://firebase.google.com/docs/firestore/quickstart) feature in your Firebase application is optional.

  To use Firestore with Clerk, ensure that you have defined [Security Rules](https://firebase.google.com/docs/firestore/security/get-started) that allow authenticated requests to access your database. For example:

  ```bash
  service cloud.firestore {
    match /databases/{database}/documents {
      match /{document=**} {
        allow read, write: if request.auth != null;
      }
    }
  }
  ```

  ## Get your Firebase config object

  To connect to your Firebase app in your code, you need a config object from your Firebase project. To find it:

  1. Visit [your Firebase project settings](https://console.firebase.google.com/project/_/settings/general/).
  1. In the **Your apps** section, there should be a code snippet that includes the `firebaseConfig` object. Copy this object. It should look similar to the following:
     ```ts
     const firebaseConfig = {
       apiKey: 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',
       authDomain: 'clerk-example-xxxxx.firebaseapp.com',
       databaseURL: 'https://clerk-example-xxxxx-default-xxxx.firebaseio.com',
       projectId: 'clerk-test-xxxx',
       storageBucket: 'clerk-test-xxxx.appspot.com',
       messagingSenderId: '012345678910',
       appId: '1:012345678:web:abcdef123456hijklm',
       measurementId: 'G-ABC123DEF',
     }
     ```
  1. Save this information somewhere secure. You'll need it to connect to your Firebase app.

  See [Google's Firebase documentation](https://support.google.com/firebase/answer/7015592) for more information on the config object.

  ## Use Firebase with Clerk in your code

  Now that you have configured the integration, and you have retrieved your Firebase config object, it's time to use Firebase with Clerk in your code.

  The following example:

  - Expects the user to be signed into the app with Clerk.
  - Creates a button for signing into your Firebase app, which uses Clerk to generate an authentication token for Firebase's API.
  - Creates a button for fetching example data from your Firestore database.

  This example is written for Next.js App Router, but it can be adapted to any React-based framework.

  ```tsx {{ filename: 'app/firebase/page.tsx' }}
  'use client'
  import { useAuth } from '@clerk/nextjs'
  import { initializeApp } from 'firebase/app'
  import { getAuth, signInWithCustomToken } from 'firebase/auth'
  import { getFirestore } from 'firebase/firestore'
  import { doc, getDoc } from 'firebase/firestore'

  // Add your Firebase config object
  const firebaseConfig = {
    apiKey: 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',
    authDomain: 'clerk-example-xxxxx.firebaseapp.com',
    databaseURL: 'https://clerk-example-xxxxx-default-xxxx.firebaseio.com',
    projectId: 'clerk-test-xxxx',
    storageBucket: 'clerk-test-xxxx.appspot.com',
    messagingSenderId: '012345678910',
    appId: '1:012345678:web:abcdef123456hijklm',
    measurementId: 'G-ABC123DEF',
  }

  // Connect to your Firebase app
  const app = initializeApp(firebaseConfig)
  // Connect to your Firestore database
  const db = getFirestore(app)
  // Connect to Firebase auth
  const auth = getAuth(app)

  // Remove this if you do not have Firestore set up
  // for your Firebase app
  const getFirestoreData = async () => {
    const docRef = doc(db, 'example', 'example-document')
    const docSnap = await getDoc(docRef)
    if (docSnap.exists()) {
      console.log('Document data:', docSnap.data())
    } else {
      // docSnap.data() will be undefined in this case
      console.log('No such document!')
    }
  }

  export default function FirebaseUI() {
    const { getToken, userId } = useAuth()

    // Handle if the user is not signed in
    // You could display content, or redirect them to a sign-in page
    if (!userId) {
      return <p>You need to sign in with Clerk to access this page.</p>
    }

    const signIntoFirebaseWithClerk = async () => {
      const token = await getToken({ template: 'integration_firebase' })

      const userCredentials = await signInWithCustomToken(auth, token || '')
      // The userCredentials.user object can call the methods of
      // the Firebase platform as an authenticated user.
      console.log('User:', userCredentials.user)
    }

    return (
      <main style={{ display: 'flex', flexDirection: 'column', rowGap: '1rem' }}>
        <button onClick={signIntoFirebaseWithClerk}>Sign in</button>

        {/* Remove this button if you do not have Firestore set up */}
        <button onClick={getFirestoreData}>Get document</button>
      </main>
    )
  }
  ```
</Steps>

## Next steps

<Cards>
  - [Use webhooks to sync Firebase data with Clerk](/docs/webhooks/sync-data)
  - Learn how to sync Firebase auth or Firestore data with Clerk data using webhooks.

  ---

  - [Create  a custom sign-in-or-up page in your Next.js app](/docs/references/nextjs/custom-sign-in-or-up-page)
  - Learn how add custom sign-up and sign-in pages with Clerk components in your Next.js application.

  ---

  - [Deploy to production](/docs/deployments/overview)
  - Learn how to deploy your Clerk app to production.

  ---

  - [Deploy to Vercel](/docs/deployments/deploy-to-vercel)
  - Learn how to deploy your Clerk app to production on Vercel.
</Cards>

---
title: Integrate Grafbase with Clerk
description: Learn how to integrate Clerk and Grafbase into your application
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Integrate a Clerk SDK into your app",
      link: "/docs/quickstarts/overview",
      icon: "code-bracket",
    },
    {
      title: "Integrate Grafbase into your app",
      link: "https://grafbase.com/docs/guides/introduction-to-graphql-federation",
      icon: "code-bracket",
    },
  ]}
/>

Integrating Grafbase with Clerk gives you the benefits of using a Grafbase database while leveraging Clerk's authentication, prebuilt components, and webhooks.

This tutorial will show you how to integrate Clerk into your Grafbase application.

<Steps>
  ## Create a JWT template based on Grafbase

  1. In the Clerk Dashboard, navigate to the [**JWT templates**](https://dashboard.clerk.com/last-active?path=jwt-templates) page.
  1. Select **New template** and then from the list of templates, select **Grafbase**. You'll be redirected to the template's settings page.
  1. Copy and save the **Issuer** URL somewhere secure. This URL is the issuer domain for Clerk's JWT templates, which is your application's **Frontend API URL**. In development, it's format will be `https://verb-noun-00.clerk.accounts.dev`. In production, it's format will be `https://clerk.<your-domain>.com`.

  ## Map additional claims (optional)

  In the **Claims** section, the default claims required by Grafbase are pre-mapped. You can include additional claims as necessary. For example, **if your GraphQL API restricts access based on groups, you'll need to specify the user groups in the `groups` claim.** So you would add something like:

  ```json
  {
    "groups": ["org:admin", "org:member"]
  }
  ```

  ## Configure Grafbase with the issuer domain

  1. In your `env` file, add your **Issuer** URL as the `CLERK_FRONTEND_API_URL` environment variable. If you already have it set, great!
     ```env {{ filename: '.env' }}
     NEXT_PUBLIC_CLERK_FRONTEND_API_URL={{fapi_url}}
     ```
  1. In your Grafbase app, update your schema with the following:
     ```graphql
     schema
       @auth(
         providers: [{ type: oidc, issuer: "{{ process.env.NEXT_PUBLIC_CLERK_FRONTEND_API_URL }}" }]
         rules: [{ allow: private }]
       ) {
       query: Query
     }
     ```
  1. If you're working with group-based user access, add `allow: groups` to the `@auth` rules, and provide an array of your user groups to the `groups` property:
     ```graphql
     schema
       @auth(
         providers: [{ type: oidc, issuer: "{{ process.env.NEXT_PUBLIC_CLERK_FRONTEND_API_URL }}" }]
         rules: [{ allow: groups, groups: ["backend", "admin"] }]
       ) {
       query: Query
     }
     ```

  ## Authenticate requests

  When making requests to your Grafbase API, you must send Clerk's session token as a Bearer token in the `Authorization` header.

  To retrieve Clerk's session token, use the `getToken()` method returned by the [`useAuth()`](/docs/hooks/use-auth) hook. You'll need to pass the template name you created in the previous step to the `getToken()` method. The following example uses the default template name, `grafbase`.

  <CodeBlockTabs options={["With SWR", "With Apollo"]}>
    ```tsx
    export const useQuery = (query, variables) => {
      if (!query) {
        throw Error('No query provided to `useQuery`')
      }

      // Use Clerk's `useAuth()` hook to access the `getToken()` method
      const { getToken } = useAuth()

      const fetcher = async () => {
        // Retrieve Clerk's session token using the template you created in the Clerk Dashboard
        const token = await getToken({ template: 'grafbase' })

        try {
          const response = await fetch('YOUR_GRAFBASE_API', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              authorization: `Bearer ${token}`, // Send the session token as a Bearer token in the `Authorization` header
            },
            body: JSON.stringify({ query, variables }),
          })
          return response.json()
        } catch (err) {
          console.error(err)
        }
      }
      return useSWR(query, fetcher)
    }

    const YOUR_GRAPHQL_QUERY = `
    	query {
    		__schema {
    			types {
    				name
    			}
    		}
    	}
    `

    const SchemaPage = () => {
      const { data, error } = useQuery(YOUR_GRAPHQL_QUERY)
      if (error) {
        return <div>error</div>
      }
      return <pre>{JSON.stringify({ data }, 2, null)}</pre>
    }

    export default SchemaPage
    ```

    ```tsx
    export const ApolloProviderWrapper = ({ children }: PropsWithChildren) => {
      // Use Clerk's `useAuth()` hook to access the `getToken()` method
      const { getToken } = useAuth()

      const client = useMemo(() => {
        const authMiddleware = setContext(async (operation, { headers }) => {
          // Retrieve Clerk's session token using the template you created in the Clerk Dashboard
          const token = await getToken({ template: 'grafbase' })

          return {
            headers: {
              ...headers,
              authorization: `Bearer ${token}`, // Send the session token as a Bearer token in the `Authorization` header
            },
          }
        })

        return new ApolloClient({
          link: from([authMiddleware, httpLink]),
          cache: new InMemoryCache(),
        })
      }, [getToken])

      return <ApolloProvider client={client}>{children}</ApolloProvider>
    }
    ```
  </CodeBlockTabs>
</Steps>

---
title: Integrate Hasura with Clerk
description: Learn how to integrate Clerk into your Hasura application.
---

The first step is to create a new Clerk application from the Clerk Dashboard if you havent done so already. You can choose whichever authentication strategy and social sign-in providers you prefer. For more information, see the [setup guide](/docs/quickstarts/setup-clerk).

After your Clerk application has been created, navigate to the [**JWT templates**](https://dashboard.clerk.com/last-active?path=jwt-templates) page in the Clerk Dashboard. Select **New template** to create a new template based on Hasura.

![The JWT templates page in the Clerk Dashboard. The 'New template' button was clicked, and a pop up titled 'New JWT template' is shown. The 'Hasura' template is hovered over](/docs/images/integrations/hasura/jwt-template.webp)

Once the Hasura template is created, you will be redirected to the template's page. You can now configure the template to your needs.

![The 'Create new template' page of the JWT templates page in the Clerk Dashboard](/docs/images/integrations/hasura/create-template.webp)

The Hasura template will pre-populate the default claims required by Hasura. You can include additional claims as necessary. [Shortcodes](/docs/backend-requests/jwt-templates#shortcodes) are available to make adding dynamic user values easy.

![The 'Create new template' page of the JWT templates page in the Clerk Dashboard. The page is scrolled down to the 'Claims' section](/docs/images/integrations/hasura/template-shortcodes.webp)

By default, Clerk will sign the JWT with a private key automatically generated for your application, which is what most developers use for Hasura. If you so choose, you can customize this key.

## Configure Hasura

The next step is to provide Hasura with the public keys used to verify the JWT issued by Clerk. Assuming you didnt use a custom signing key, set the **JWKS Endpoint** field to the JSON Web Key Set (JWKS) URL Clerk automatically created with your Frontend API at `https://<YOUR_FRONTEND_API>/.well-known/jwks.json`

You can find the **JWKS URL** on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.

You can set up your project either with Hasura Cloud or you can [run the Hasura GraphQL engine locally using Docker Compose](https://hasura.io/docs/2.0/getting-started/docker-simple).

### Set up with Hasura Cloud

Go to your project settings, select **Env vars**, and then add **New Env Var**.

Set the key to `HASURA_GRAPHQL_JWT_SECRET` and the value to the following:

```json
{ "jwk_url": "https://{{fapi}}/.well-known/jwks.json" }
```

### Set up with Hasura Core

To add the JWT secret locally with Hasura Core, you need to set both the `HASURA_GRAPHQL_ADMIN_SECRET` and `HASURA_GRAPHQL_JWT_SECRET` in the `docker-compose.yml` file.

`HASURA_GRAPHQL_ADMIN_SECRET` can be set to any text string.

`HASURA_GRAPHQL_JWT_SECRET` should be set to a stringified JSON object of the JWT secret which contains the JWKS Endpoint as the value of `jwk_url`.

```yaml
HASURA_GRAPHQL_ADMIN_SECRET: myadminsecretkey
HASURA_GRAPHQL_JWT_SECRET: '{"jwk_url":"https://{{fapi}}/.well-known/jwks.json"}'
```

Replace `<YOUR_FRONTEND_API>` with the Frontend API value. This value can be found on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.

### With custom signing key

If you did use a custom signing key, instead of providing the `jwk_url` you need to provide the algorithm type and key in the stringified JSON object as the `HASURA_GRAPHQL_JWT_SECRET` in the Hasura Cloud Env Vars or in the `docker-compose.yml` file.

```yaml
HASURA_GRAPHQL_JWT_SECRET: '{"type": "HS256", "key": "<YOUR_SIGNING_KEY>" }'
```

## Configure your GraphQL client

GraphQL clients (such as [Apollo Client](https://github.com/apollographql/apollo-client) and [Relay](https://github.com/facebook/relay)) can help with querying and caching your data. They can also manage UI state, keep data in sync, and boost performance. GraphQL requests can be to the Hasura backend using different clients.

The last step of integrating Clerk as the modern web authentication solution for Hasura is to pass the JWT in the `Authorization` header with your requests. You can access the token generated with the Hasura claims by calling `getToken({ template: <your-template-name> })` on the `Session` object with the name of your template.

Even if you dont have a database table set up yet, we can make use of the [built-in GraphQL introspection system](https://graphql.org/learn/introspection/) to validate that the authenticated requests are working properly.

Here is an example of using [Apollo Client](https://github.com/apollographql/apollo-client) in conjunction with the useAuth hook in a Next.js application to make a request to the Hasura GraphQL endpoint:

```jsx
import { ApolloProvider, ApolloClient, HttpLink, from, InMemoryCache } from '@apollo/client'
import { setContext } from '@apollo/client/link/context'
import { useAuth } from '@clerk/nextjs'

export const ApolloProviderWrapper = ({ children }) => {
  const { getToken } = useAuth()
  const apolloClient = useMemo(() => {
    const authMiddleware = setContext(async (req, { headers }) => {
      const token = await getToken({ template: 'template' })
      return {
        headers: {
          ...headers,
          authorization: `Bearer ${token}`,
        },
      }
    })

    const httpLink = new HttpLink({
      uri: process.env.GRAPHQL_URI,
    })

    return new ApolloClient({
      link: from([authMiddleware, httpLink]),
      cache: new InMemoryCache(),
    })
  }, [getToken])

  return <ApolloProvider client={apolloClient}>{children}</ApolloProvider>
}
```

As an alternative, here is an example of using [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) in conjunction with the [useSWR](https://swr.vercel.app/) hook in a Next.js application to make a request to the Hasura GraphQL endpoint:

```jsx
import { useAuth } from '@clerk/nextjs'
import useSWR from 'swr'

// This component needs to be a child of <ClerkProvider> and <SignedIn>
// in order to access the authenticated session object
const Main = () => {
  const { getToken } = useAuth()
  const endpoint = process.env.NEXT_PUBLIC_HASURA_GRAPHQL_API
  const query = `query { __schema { types { name } } }`
  const fetcher = async (...args) =>
    fetch(...args, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
        Authorization: `Bearer ${await getToken({ template: 'hasura' })}`,
      },
      body: JSON.stringify({ query }),
    }).then((res) => res.json())

  const { data } = useSWR(endpoint, fetcher)

  return <p>GraphQL schema has {data?.data?.__schema.types.length} types</p>
}

export default Main
```

Note that the `getToken({ template: <your-template-name> })` call is asynchronous and returns a Promise that needs to be resolved before accessing the token value. This token is short-lived for better security and should be called before every request to your GraphQL API. The caching and refreshing of the token is handled automatically by Clerk.

---
title: Integrate InstantDB with Clerk
description: Learn how to integrate Clerk into your InstantDB application.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Create an InstantDB account",
      link: "https://instantdb.com",
      icon: "cog-6-teeth",
    },
    {
      title: "Integrate the appropriate Clerk SDK in your local project",
      link: "/docs/quickstarts/overview",
      icon: "code-bracket",
    },
  ]}
  exampleRepo={[
    {
      title: "Clerk + InstantDB + Next.js Demo",
      link: "https://github.com/clerk/clerk-instantdb-nextjs",
      icon: "code-bracket",
    },
  ]}
/>

Integrating [InstantDB](https://www.instantdb.com/) with Clerk gives you the benefits of using an InstantDB database while leveraging Clerk's authentication features.

This tutorial will walk you through the steps to integrate InstantDB with Clerk in your Next.js app. If you're using a different framework, the steps are the same and the code can be adapted for any React-based framework.

<Steps>
  ## Configure your Clerk session token

  InstantDB uses Clerk's [session token](/docs/backend-requests/resources/session-tokens) to authenticate users. To use InstantDB with Clerk, you need to include the `email` claim in your session token.

  1. In the Clerk Dashboard, navigate to the [**Sessions**](https://dashboard.clerk.com/last-active?path=sessions) page.
  1. In the **Customize session token** section, select **Edit**.
  1. Add the `email` claim to your session token:
     ```json
     {
       "email": "{{user.primary_email_address}}"
     }
     ```

  You can have additional claims as long as the `email` claim is set to `{{user.primary_email_address}}`.

  ## Get your Clerk Publishable Key

  1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
  1. In the **Quick Copy** section, copy your Clerk Publishable Key.

  ## Configure InstantDB

  1. In the InstantDB dashboard, navigate to the [**Auth**](https://www.instantdb.com/dash?t=auth) tab.
  1. At the top of the page, save the **Public App ID** somewhere as you'll need this later.
  1. Select **Setup Clerk**.
  1. Add the Clerk Publishable Key you copied in the previous step.
  1. Confirm the **The session token has the "email" claim.** message.
  1. Select **Add Clerk app**. Save the **Client Name** somewhere as you'll need this later.

  ## Install the InstantDB library

  Run the following command to add the InstantDB library to your project.

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm i @instantdb/react
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @instantdb/react
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @instantdb/react
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @instantdb/react
    ```
  </CodeBlockTabs>

  ## Set your InstantDB credentials

  In your `.env` file, set the following environment variables to your InstantDB App ID and Clerk Client Name that you saved earlier:

  ```env {{ filename: '.env' }}
  NEXT_PUBLIC_INSTANTDB_APP_ID=
  NEXT_PUBLIC_CLERK_CLIENT_NAME=
  ```

  ## Initialize InstantDB in your app

  To [initialize InstantDB](https://www.instantdb.com/docs/init) in your app:

  1. Create a `db` directory.
  1. In the `db` directory, create a `instant.ts` file with the following code. It initializes InstantDB with your App ID and schema. The schema used below is necessary for this tutorial, but you can customize it as needed. Read more about InstantDB schemas in the [InstantDB docs](https://www.instantdb.com/docs/modeling-data).

  ```tsx {{ filename: 'db/instant.ts' }}
  import { i, init } from '@instantdb/react'

  const APP_ID = process.env.NEXT_PUBLIC_INSTANTDB_APP_ID

  if (!APP_ID) {
    throw new Error('Missing NEXT_PUBLIC_INSTANTDB_APP_ID in your .env file')
  }

  // Optional: Declare your schema
  export const schema = i.schema({
    entities: {
      todos: i.entity({
        text: i.string(),
        done: i.boolean(),
        createdAt: i.number(),
      }),
    },
  })

  export const db = init({ appId: APP_ID, schema })
  ```

  ## Manage the Clerk and InstantDB auth sessions

  Integrating InstantDB with Clerk means that your users will sign in to your app using Clerk, and then Clerk's session token will be used to sign the user in to InstantDB. This means that your user will have two sessions: one with Clerk and one with InstantDB. In order to handle both sessions, the following component uses Clerk to check if the user is signed in, and if they are, it uses Clerk's session token to sign the user in to InstantDB. If the user is not signed in to Clerk, it signs them out of InstantDB, ensuring that if the Clerk session ends, the InstantDB session will end as well.

  ```tsx {{ filename: 'components/InstantDBAuthSync.tsx', collapsible: true }}
  'use client'

  import { db } from '@/db/instant'
  import { useAuth, useUser } from '@clerk/nextjs'
  import { useEffect } from 'react'

  // If a user is signed in with Clerk, sign them in with InstantDB
  export default function InstantDBAuthSync() {
    const { isSignedIn } = useUser()
    const { getToken } = useAuth()

    useEffect(() => {
      if (isSignedIn) {
        getToken()
          .then((token) => {
            // Create a long-lived session with Instant for your Clerk user
            // It will look up the user by email or create a new user with
            // the email address in the session token.
            db.auth.signInWithIdToken({
              clientName: process.env.NEXT_PUBLIC_CLERK_CLIENT_NAME as string,
              idToken: token as string,
            })
          })
          .catch((error) => {
            console.error('Error signing in with Instant', error)
          })
      } else {
        db.auth.signOut()
      }
    }, [isSignedIn])

    return null
  }
  ```

  It's important to use this component in your **root** `layout.tsx` file because the `useEffect()` hook that syncs the Clerk and InstantDB sessions needs to run on every page load in order to manage the sessions properly.

  ```tsx {{ filename: 'app/layout.tsx', collapsible: true }}
  import type { Metadata } from 'next'
  import {
    ClerkProvider,
    SignInButton,
    SignUpButton,
    SignedIn,
    SignedOut,
    UserButton,
  } from '@clerk/nextjs'
  import { Geist, Geist_Mono } from 'next/font/google'
  import './globals.css'
  import InstantDBAuthSync from '@/component/InstantDBAuthSync'

  const geistSans = Geist({
    variable: '--font-geist-sans',
    subsets: ['latin'],
  })

  const geistMono = Geist_Mono({
    variable: '--font-geist-mono',
    subsets: ['latin'],
  })

  export const metadata: Metadata = {
    title: 'Clerk Next.js Quickstart',
    description: 'Generated by create next app',
  }

  export default async function RootLayout({
    children,
  }: Readonly<{
    children: React.ReactNode
  }>) {
    return (
      <ClerkProvider>
        <InstantDBAuthSync />
        <html lang="en">
          <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
            <header className="flex justify-end items-center p-4 gap-4 h-16">
              <SignedOut>
                <SignInButton />
                <SignUpButton />
              </SignedOut>
              <SignedIn>
                <UserButton />
              </SignedIn>
            </header>
            {children}
          </body>
        </html>
      </ClerkProvider>
    )
  }
  ```

  ## Update your homepage

  Update your `page.tsx` file with the following code to see InstantDB in action. This code was copied from the [InstantDB quickstart](https://www.instantdb.com/docs#quick-start). The only difference is that the initialization code was moved to `/db/instant.ts` so that the InstantDB connection could be reused across the app.

  ```tsx {{ filename: 'app/page.tsx', collapsible: true }}
  'use client'

  import { id, InstaQLEntity } from '@instantdb/react'
  import { db, schema } from '@/db/instant'

  type Todo = InstaQLEntity<typeof schema, 'todos'>

  function App() {
    // Use Instant's `useQuery()` hook to get the todos
    const { isLoading, error, data } = db.useQuery({ todos: {} })

    if (isLoading) {
      return (
        <div className="-mt-16 font-mono min-h-screen flex justify-center items-center flex-col space-y-4">
          Loading...
        </div>
      )
    }

    if (error) {
      return (
        <div className="text-red-500 p-4 -mt-16 font-mono min-h-screen flex justify-center items-center flex-col space-y-4">
          Error: {error.message}
        </div>
      )
    }

    const { todos } = data

    return (
      <div className="-mt-16 font-mono min-h-screen flex justify-center items-center flex-col space-y-4">
        <h2 className="tracking-wide text-5xl text-gray-300">todos</h2>
        <div className="border border-gray-300 max-w-xs w-full">
          <TodoForm todos={todos} />
          <TodoList todos={todos} />
          <ActionBar todos={todos} />
        </div>
        <div className="text-xs text-center">Open another tab to see todos update in realtime!</div>
      </div>
    )
  }

  // Write Data
  // ---------
  function addTodo(text: string) {
    db.transact(
      db.tx.todos[id()].update({
        text,
        done: false,
        createdAt: Date.now(),
      }),
    )
  }

  function deleteTodo(todo: Todo) {
    db.transact(db.tx.todos[todo.id].delete())
  }

  function toggleDone(todo: Todo) {
    db.transact(db.tx.todos[todo.id].update({ done: !todo.done }))
  }

  function deleteCompleted(todos: Todo[]) {
    const completed = todos.filter((todo) => todo.done)
    const txs = completed.map((todo) => db.tx.todos[todo.id].delete())
    db.transact(txs)
  }

  function toggleAll(todos: Todo[]) {
    const newVal = !todos.every((todo) => todo.done)
    db.transact(todos.map((todo) => db.tx.todos[todo.id].update({ done: newVal })))
  }

  // Components
  // ----------
  function ChevronDownIcon() {
    return (
      <svg viewBox="0 0 20 20">
        <path d="M5 8 L10 13 L15 8" stroke="currentColor" fill="none" strokeWidth="2" />
      </svg>
    )
  }

  function TodoForm({ todos }: { todos: Todo[] }) {
    return (
      <div className="flex items-center h-10 border-b border-gray-300">
        <button
          className="h-full px-2 border-r border-gray-300 flex items-center justify-center"
          onClick={() => toggleAll(todos)}
        >
          <div className="w-5 h-5">
            <ChevronDownIcon />
          </div>
        </button>
        <form
          className="flex-1 h-full"
          onSubmit={(e) => {
            e.preventDefault()
            const input = e.currentTarget.input as HTMLInputElement
            addTodo(input.value)
            input.value = ''
          }}
        >
          <input
            className="w-full h-full px-2 outline-none bg-transparent"
            autoFocus
            placeholder="What needs to be done?"
            type="text"
            name="input"
          />
        </form>
      </div>
    )
  }

  function TodoList({ todos }: { todos: Todo[] }) {
    return (
      <div className="divide-y divide-gray-300">
        {todos.map((todo) => (
          <div key={todo.id} className="flex items-center h-10">
            <div className="h-full px-2 flex items-center justify-center">
              <div className="w-5 h-5 flex items-center justify-center">
                <input
                  type="checkbox"
                  className="cursor-pointer"
                  checked={todo.done}
                  onChange={() => toggleDone(todo)}
                />
              </div>
            </div>
            <div className="flex-1 px-2 overflow-hidden flex items-center">
              {todo.done ? (
                <span className="line-through">{todo.text}</span>
              ) : (
                <span>{todo.text}</span>
              )}
            </div>
            <button
              className="h-full px-2 flex items-center justify-center text-gray-300 hover:text-gray-500"
              onClick={() => deleteTodo(todo)}
            >
              X
            </button>
          </div>
        ))}
      </div>
    )
  }

  function ActionBar({ todos }: { todos: Todo[] }) {
    return (
      <div className="flex justify-between items-center h-10 px-2 text-xs border-t border-gray-300">
        <div>Remaining todos: {todos.filter((todo) => !todo.done).length}</div>
        <button className=" text-gray-300 hover:text-gray-500" onClick={() => deleteCompleted(todos)}>
          Delete Completed
        </button>
      </div>
    )
  }

  export default App
  ```
</Steps>

---
title: Integrate Loops with Clerk
description: Learn how to add your Clerk users to your Loops audience, and send automated email sequences.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Set up a Loops account",
      link: "https://app.loops.so",
      icon: "cog-6-teeth",
    }
  ]}
/>

[Loops](https://loops.so) is an email platform that helps you send marketing and transactional emails to help increase revenue and engagement or improve your user's experience of your app.

This tutorial demonstrates how to sync your Clerk users to Loops so you can email users with Loop's email marketing tools. You will also learn how to send email sequences to new Clerk users.

<Steps>
  ## Create a Clerk webhook endpoint in Loops

  Loops' [Incoming webhooks](https://loops.so/docs/integrations/incoming-webhooks) feature lets Loops accept webhooks directly from external platforms like Clerk.

  To create a new webhook endpoint in Loops:

  1. Navigate to the **Clerk** settings page in the [Loops dashboard](https://app.loops.so/settings?page=clerk).
  1. Save the **Endpoint URL** somewhere secure; you're going to need it for Clerk's webhook configuration.

  ## Create a webhook in the Clerk Dashboard

  You must create a new Clerk webhook endpoint so that it can send data to Loops. Here is where you will provide the **Endpoint URL** from the last step, and then choose the events you want to listen to.

  1. In the Clerk Dashboard, navigate to the [**Webhooks**](https://dashboard.clerk.com/last-active?path=webhooks) page.
  1. Select the **Add Endpoint** button.
  1. In the **Endpoint URL** field, paste the **Endpoint URL** that you saved from Loops.
  1. In the **Message Filtering** section, select the `user.created` and/or `user.updated` events, depending on your desired setup.
  1. Select the **Create** button.
  1. You will be redirected to your endpoint's settings page. Leave this page open.

  ## Add your signing secret in Loops

  To keep communication secure between the two platforms:

  1. On the Clerk endpoint's settings page, copy the **Signing Secret**. It should be on the right side of the page with an eye icon next to it.
  1. Back in the Loops dashboard, add the **Signing Secret**.

  ## Configure Loops events

  The final step is to configure which events Loops should accept from Clerk and what Loops should do with the data.

  In the Loops dashboard, under **Complete Setup**, enable the events you selected in Clerk in step 2. Doing this will sync your Clerk users to Loops when they are created or updated in Clerk.

  For each event, you can optionally choose to trigger a "[loop](https://loops.so/docs/loop-builder)" when new webhooks are sent to Loops, by selecting an event in the **Trigger an event** field. This is useful, for example, if you want to send an email welcome sequence to new Clerk users.

  You can also choose to assign a user group value for each Clerk user, which will help you organize and segment contacts in Loops.
</Steps>

---
title: Integrate Neon Postgres with Clerk
description: Learn how to integrate Clerk into your Neon application.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Set up a Neon project in the Neon console",
      link: "https://console.neon.tech",
      icon: "cog-6-teeth",
    }
  ]}
/>

This tutorial demonstrates how to integrate Neon Postgres with Clerk in a Next.js application, using `drizzle-orm` and `drizzle-kit` to interact with the database. The tutorial guides you through setting up a simple application that enables users to add, view, and delete messages using Server Actions and Middleware with Clerk.

<Steps>
  ## Create a new Next.js project

  1. Create a new Next.js project using the following command:
     ```sh {{ filename: 'terminal' }}
     npx create-next-app clerk-neon-example --typescript --eslint --tailwind --use-npm --no-src-dir --app --import-alias "@/*"
     ```
  1. Navigate to the project directory and install the required dependencies:
     ```sh {{ filename: 'terminal' }}
     cd clerk-neon-example
     npm install @neondatabase/serverless
     npm install drizzle-orm --legacy-peer-deps
     npm install -D drizzle-kit
     ```

  ## Integrate the Next.js Clerk SDK

  Follow the [Next.js quickstart](/docs/quickstarts/nextjs) to integrate the Clerk Next.js SDK into your application.

  ## Protect your application routes

  To ensure that only authenticated users can access your application, modify [`clerkMiddleware`](/docs/references/nextjs/clerk-middleware) to require authentication for every route.

  ```typescript {{ filename: 'middleware.ts', mark: [[3, 5]] }}
  import { clerkMiddleware } from '@clerk/nextjs/server'

  export default clerkMiddleware(async (auth) => {
    await auth.protect()
  })

  export const config = {
    matcher: [
      // Skip Next.js internals and all static files, unless found in search params
      '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
      // Always run for API routes
      '/(api|trpc)(.*)',
    ],
  }
  ```

  ## Set your neon connection string

  Add the Neon connection string to your project's environment variables. You can find the Neon connection string in the [Neon console](https://console.neon.tech/) - see the [Neon docs](https://neon.tech/docs/connect/connect-from-any-app) for more information.

  Your environment variable file should have the following values:

  ```env {{ filename: '.env' }}
  DATABASE_URL=NEON_DB_CONNECTION_STRING
  NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
  CLERK_SECRET_KEY={{secret}}
  ```

  ## Set up the application schema and database connection

  1. Inside the `app/`, create a `db/` directory.

  1. Create a `schema.ts` file in the `db/` directory that defines the database schema. The schema will include a table called `user_messages` with the columns `user_id`, `create_ts`, and `message`.The `user_id` column will be used to store the user's Clerk ID.

     ```typescript {{ filename: 'app/db/schema.ts', mark: [4] }}
     import { pgTable, text, timestamp } from 'drizzle-orm/pg-core'

     export const UserMessages = pgTable('user_messages', {
       user_id: text('user_id').primaryKey().notNull(),
       createTs: timestamp('create_ts').defaultNow().notNull(),
       message: text('message').notNull(),
     })
     ```

  1. Create an `index.ts` file in the `db` directory to set up the database connection.

     ```typescript {{ filename: 'app/db/index.ts' }}
     import { loadEnvConfig } from '@next/env'
     import { neon } from '@neondatabase/serverless'
     import { drizzle } from 'drizzle-orm/neon-http'
     import { UserMessages } from './schema'

     loadEnvConfig(process.cwd())

     if (!process.env.DATABASE_URL) {
       throw new Error('DATABASE_URL must be a Neon postgres connection string')
     }

     const sql = neon(process.env.DATABASE_URL)
     export const db = drizzle(sql, {
       schema: { UserMessages },
     })
     ```

  ## Push the schema to the database

  1. To load the schema into the database, create a `drizzle.config.ts` file at the root of your project and add the following configuration:

     ```typescript {{ filename: 'drizzle.config.ts' }}
     import { defineConfig } from 'drizzle-kit'
     import { loadEnvConfig } from '@next/env'

     loadEnvConfig(process.cwd())

     if (!process.env.DATABASE_URL) {
       throw new Error('DATABASE_URL must be a Neon postgres connection string')
     }

     export default defineConfig({
       dialect: 'postgresql',
       dbCredentials: {
         url: process.env.DATABASE_URL,
       },
       schema: './app/db/schema.ts',
     })
     ```

  1. Run the following command to push the schema to the database:

     ```sh {{ filename: 'terminal' }}
     npx drizzle-kit push
     ```

  ## Create Server Actions to handle user interactions

  To handle form submissions for adding and deleting user messages, create two Server Actions in `app/actions.ts`. Use Clerk's [`auth()` helper](/docs/references/nextjs/auth) to obtain the user ID, which will be used to interact with the database.

  ```typescript {{ filename: 'app/actions.ts' }}
  'use server'

  import { auth } from '@clerk/nextjs/server'
  import { UserMessages } from './db/schema'
  import { db } from './db'
  import { eq } from 'drizzle-orm'

  export async function createUserMessage(formData: FormData) {
    const { userId } = await auth()
    if (!userId) throw new Error('User not found')

    const message = formData.get('message') as string
    await db.insert(UserMessages).values({
      user_id: userId,
      message,
    })
  }

  export async function deleteUserMessage() {
    const { userId } = await auth()
    if (!userId) throw new Error('User not found')

    await db.delete(UserMessages).where(eq(UserMessages.user_id, userId))
  }
  ```

  ## Create the UI for the Home Page

  In your `app/page.tsx` file, add the following code to create the UI for the home page. If a message exists, the user can view and delete it; otherwise, they can add a new message.

  To retrieve the user's messages, use Clerk's [`auth()` helper](/docs/references/nextjs/auth) to obtain the user's ID. Then, use this ID to query the database for the user's messages.

  To enable the user to delete or add a message, use the `deleteUserMessage()` and `createUserMessage()` actions created in the previous step.

  ```tsx {{ filename: 'app/page.tsx' }}
  import { createUserMessage, deleteUserMessage } from './actions'
  import { db } from './db'
  import { auth } from '@clerk/nextjs/server'

  export default async function Home() {
    const { userId } = await auth()
    if (!userId) throw new Error('User not found')
    const existingMessage = await db.query.UserMessages.findFirst({
      where: (messages, { eq }) => eq(messages.user_id, userId),
    })

    return (
      <main>
        <h1>Neon + Clerk Example</h1>
        {existingMessage ? (
          <div>
            <p>{existingMessage.message}</p>
            <form action={deleteUserMessage}>
              <button>Delete Message</button>
            </form>
          </div>
        ) : (
          <form action={createUserMessage}>
            <input type="text" name="message" placeholder="Enter a message" />
            <button>Save Message</button>
          </form>
        )}
      </main>
    )
  }
  ```

  ## Run the application

  Run your application and open `http://localhost:3000` in your browser. Sign in with Clerk and interact with the application to add and delete user messages.
</Steps>

---
title: Integrate Nhost with Clerk
description: Learn how to integrate Clerk into your Nhost project.
---

The first step is to create a new Clerk application from the Clerk Dashboard if you havent done so already. You can choose whichever authentication strategy and social sign-in providers you prefer. For more information, see the [setup guide](/docs/quickstarts/setup-clerk).

After your Clerk application has been created, navigate to the [**JWT templates**](https://dashboard.clerk.com/last-active?path=jwt-templates) page in the Clerk Dashboard. Select **New template** to create a new template based on Nhost.

![The JWT templates page in the Clerk Dashboard. The 'New template' button was clicked, and a pop up titled 'New JWT template' is shown. The 'Nhost' template is hovered over](/docs/images/integrations/nhost/jwt-template.webp)

Once the Nhost template is created, you will be redirected to the template's page. You can now configure the template to your needs.

![The 'Create new template' page of the JWT templates page in the Clerk Dashboard](/docs/images/integrations/nhost/create-template.webp)

The Nhost template will pre-populate the default claims required by Nhost and Hasura. You can include additional claims as necessary. [Shortcodes](/docs/backend-requests/jwt-templates#shortcodes) are available to make adding dynamic user values easy.

![The 'Create new template' page of the JWT templates page in the Clerk Dashboard. The page is scrolled down to the 'Claims' section](/docs/images/integrations/nhost/template-shortcodes.webp)

## Configure Nhost

The next step is to provide Nhost with the public keys used to verify the JWT issued by Clerk. Assuming you didnt use a custom signing key, set the **JWKS Endpoint** field to the JSON Web Key Set (JWKS) URL Clerk automatically created with your Frontend API at `https://<YOUR_FRONTEND_API>/.well-known/jwks.json`

You can find the **JWKS URL** on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.

From your Nhost dashboard, navigate to **Settings** --> **Environment variables**.

![The Environment variables page in the Nhost dashboard](/docs/images/integrations/nhost/nhost-env-var.webp)

Next to the **NHOST\_JWT\_SECRET**, select **Edit** and paste in the **JWKS URL** that you copied from the Clerk Dashboard.

### With custom signing key

If you used a custom signing key, instead of providing the `jwk_url`, you need to provide the algorithm `type` and `key` as a JSON object in the `NHOST_JWT_SECRET` field.

```json
{ "type": "HS256", "key": "<YOUR_SIGNING_KEY>" }
```

## Configure the providers

Both Nhost and Clerk have Provider components that are required to wrap your React application to provide the authentication context.

This is how you would set up a Next.js application using both Providers:

```jsx
import { NhostNextProvider, NhostClient } from '@nhost/nextjs'
import { ClerkProvider, RedirectToSignIn, SignedIn, SignedOut } from '@clerk/nextjs'

const nhost = new NhostClient({
  subdomain: process.env.NEXT_PUBLIC_NHOST_SUBDOMAIN || '',
  region: process.env.NEXT_PUBLIC_NHOST_REGION || '',
})

function MyApp({ Component, pageProps }) {
  return (
    <NhostNextProvider nhost={nhost} initial={pageProps.nhostSession}>
      <ClerkProvider {...pageProps}>
        <SignedIn>
          <Component {...pageProps} />
        </SignedIn>
        <SignedOut>
          <RedirectToSignIn />
        </SignedOut>
      </ClerkProvider>
    </NhostNextProvider>
  )
}

export default MyApp
```

## Configure your GraphQL client

GraphQL clients (such as [Apollo Client](https://github.com/apollographql/apollo-client) and [Relay](https://github.com/facebook/relay)) can help with querying and caching your data. They can also manage UI state, keep data in sync, and boost performance. GraphQL requests can be to the Hasura backend using different clients.

The last step of integrating Clerk as the modern web authentication solution for Hasura is to pass the JWT in the `Authorization` header with your requests. You can access the token generated with the Hasura claims by calling `getToken({ template: <your-template-name> })` on the `Session` object with the name of your template.

Even if you dont have a database table set up yet, we can make use of the [built-in GraphQL introspection system](https://graphql.org/learn/introspection/) to validate that the authenticated requests are working properly.

Here is an example of using [Apollo Client](https://github.com/apollographql/apollo-client) in conjunction with the [`useAuth()`](/docs/hooks/use-auth) hook in a Next.js application to make a request to the Hasura GraphQL endpoint:

```jsx
import { ApolloProvider, ApolloClient, HttpLink, from, InMemoryCache } from '@apollo/client'
import { setContext } from '@apollo/client/link/context'
import { useAuth } from '@clerk/nextjs'

export const ApolloProviderWrapper = ({ children }) => {
  const { getToken } = useAuth()
  const apolloClient = useMemo(() => {
    const authMiddleware = setContext(async (req, { headers }) => {
      const token = await user.getToken({ template: 'template' })
      return {
        headers: {
          ...headers,
          authorization: `Bearer ${token}`,
        },
      }
    })

    const httpLink = new HttpLink({
      uri: process.env.GRAPHQL_URI,
    })

    return new ApolloClient({
      link: from([authMiddleware, httpLink]),
      cache: new InMemoryCache(),
    })
  }, [getToken])

  return <ApolloProvider client={apolloClient}>{children}</ApolloProvider>
}
```

As an alternative, here is an example of using [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) in conjunction with the [useSWR](https://swr.vercel.app/) hook in a Next.js application to make a request to the Hasura GraphQL endpoint:

```jsx
import { useAuth } from '@clerk/nextjs'
import useSWR from 'swr'

export default function Home() {
  const { getToken } = useAuth()
  const subdomain = process.env.NEXT_PUBLIC_NHOST_SUBDOMAIN
  const endpoint = `https://${subdomain}.nhost.run/v1/graphql`
  const query = `query { __schema { types { name } } }`
  const fetcher = async (...args) =>
    fetch(...args, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
        Authorization: `Bearer ${await getToken({ template: 'nhost' })}`,
      },
      body: JSON.stringify({ query }),
    }).then((res) => res.json())

  const { data } = useSWR(endpoint, fetcher)

  return <p>GraphQL schema has {data?.data?.__schema.types.length} types</p>
}
```

Note that the `getToken({ template: <your-template-name> })` call is asynchronous and returns a Promise that needs to be resolved before accessing the token value. This token is short-lived for better security and should be called before every request to your GraphQL API. The caching and refreshing of the token is handled automatically by Clerk.

---
title: Integrate Shopify with Clerk
description: Learn how to integrate Clerk into your Shopify store.
---

<TutorialHero
  beforeYouStart={[
        {
            title: "Set up a Clerk application",
            link: "/docs/quickstarts/setup-clerk",
            icon: "clerk",
        },
        {
            title: "Create a Shopify store",
            link: "https://www.shopify.com/",
            icon: "cog-6-teeth",
        },
    ]}
/>

This tutorial outlines how to integrate Clerk's authentication with your Shopify Plus store, allowing you to use Clerk as your identity provider for customer logins. In Shopify, using [your own Identity Provider for customer login](https://changelog.shopify.com/posts/use-your-own-identity-provider-for-customer-login) is only available to stores on the **Shopify Plus plan**.

To make the setup process easier, it's recommended to keep two browser tabs open: one for your [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) and one for your [Shopify admin](https://admin.shopify.com).

<Steps>
  ## Create a new Clerk OAuth application

  1. In the Clerk Dashboard, navigate to the [**OAuth applications**](https://dashboard.clerk.com/last-active?path=/oauth-applications) page.
  1. Select **Add OAuth application**. A modal will open.
  1. Enter the **Name** of your new OAuth application.
  1. For the **Scopes**, ensure to select `openid`. The following scopes should be enabled: `openid`, `email`, and `profile`.
  1. Select **Add**. You'll be presented with the **Client Secret**.
  1. Select **Copy secret** and save the value somewhere secure. You'll be redirected to the OAuth app's settings page.
  1. Under **Application Credentials**, copy and save the **Client ID** somewhere secure.
  1. Under **Application Configuration URLs**, copy and save the **Discovery URL** somewhere secure. Keep this page open.

  ## Connect a new Shopify provider

  1. In a new tab, navigate to your [Shopify admin](https://admin.shopify.com).
  1. In the left sidenav, select **Settings**. You'll be redirected to your shop's **General** settings page.
  1. In the left sidenav, select **Customer accounts**. You'll be redirected to the **Customer accounts** page.
  1. Next to **Identity provider**, select **Manage**. You'll be redirected to the **Identity provider** page.
     > [!IMPORTANT]
     > In Shopify, using [your own Identity Provider for customer login](https://changelog.shopify.com/posts/use-your-own-identity-provider-for-customer-login) is only available to stores on the Shopify Plus plan.
  1. Select **Connect to provider**. You'll be redirected to the **Connect to identity provider** page.
  1. Fill in the required fields. Paste the **Discovery URL**, **Client ID**, and **Client Secret** that you previously copied from Clerk Dashboard.
  1. In the **Additional scopes** field, enter `profile`.
  1. In the **Post-logout redirect URI parameter name** field, enter `returnTo`.
  1. Select **Save** at the top of the page to update your Identity Provider's configuration.
  1. In the top right, select **Activate** to enable your new Identity Provider.
  1. Under **Setup configurations**, copy and save the **Callback URL** somewhere secure.
  1. Navigate back to the Clerk Dashboard and paste the **Callback URL** into the **Redirect URIs** field.
  1. Select **Save** to update your Clerk OAuth application's configuration.
</Steps>

---
title: Integrate Supabase with Clerk
description: Learn how to integrate Clerk into your Supabase application.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Integrate the appropriate Clerk SDK in your local project",
      link: "/docs/quickstarts/overview",
      icon: "code-bracket",
    },
  ]}
  exampleRepo={[
    {
      title: "Supabase, Next.js, and Clerk Demo",
      link: "https://github.com/clerk/clerk-supabase-nextjs",
      icon: "github",
    },
  ]}
/>

Integrating Supabase with Clerk gives you the benefits of using a Supabase database while leveraging Clerk's authentication, prebuilt components, and webhooks. To get the most out of Supabase with Clerk, you must implement custom [Row Level Security](https://supabase.com/docs/guides/auth/row-level-security) (RLS) policies.

RLS works by validating database queries according to the restrictions defined in the RLS policies applied to the table. This guide will show you how to create RLS policies that restrict access to data based on the user's Clerk ID. This way, users can only access data that belongs to them. To set this up, you will:

- Create a `user_id` column that defaults to the Clerk user's ID when new records are created.
- Create policies to restrict what data can be read and inserted.
- Use the Clerk Supabase integration helper in your code to authenticate with Supabase and execute queries.

This guide will have you create a new table in your [Supabase project](https://supabase.com/dashboard/projects), but you can apply these concepts to your existing tables as well.

> [!TIP]
> This integration restricts what data authenticated users can access in the database, but does not synchronize user records between Clerk and Supabase. To send additional data from Clerk to your Supabase database, use [webhooks](/docs/webhooks/overview).

<Steps>
  ## Set up Clerk as a Supabase third-party auth provider

  For your Clerk session token to work with Supabase, you need to set up Clerk as a third-party auth provider in Supabase.

  1. In the Clerk Dashboard, navigate to the [Supabase integration setup](https://dashboard.clerk.com/setup/supabase).
  1. Select your configuration options, and then select **Activate Supabase integration**. This will reveal the **Clerk domain** for your Clerk instance.
  1. Save the **Clerk domain**.
  1. In the Supabase Dashboard, navigate to [**Authentication > Sign In / Up**](https://supabase.com/dashboard/project/_/auth/third-party).
  1. Select **Add provider** and select **Clerk** from the list of providers.
  1. Paste the **Clerk domain** you copied from the Clerk Dashboard.

  ## Set up RLS policies using Clerk session token data

  You can access Clerk session token data in Supabase using the built-in `auth.jwt()` function. This is necessary to create custom RLS policies to restrict database access based on the requesting user.

  1. Create a table to enable RLS on. Open [Supabase's SQL editor](https://supabase.com/dashboard/project/_/sql/new) and run the following queries. This example creates a `tasks` table with a `user_id` column that maps to a Clerk user ID.
     ```sql
     -- Create a "tasks" table with a user_id column that maps to a Clerk user ID
     create table tasks(
       id serial primary key,
       name text not null,
       user_id text not null default auth.jwt()->>'sub'
     );

     -- Enable RLS on the table
     alter table "tasks" enable row level security;
     ```
  1. Create two policies that restrict access to the `tasks` table based on the requesting user's Clerk ID. These policies allow users to create tasks for themselves and view their own tasks.
     ```sql
     create policy "User can view their own tasks"
     on "public"."tasks"
     for select
     to authenticated
     using (
     ((select auth.jwt()->>'sub') = (user_id)::text)
     );

     create policy "Users must insert their own tasks"
     on "public"."tasks"
     as permissive
     for insert
     to authenticated
     with check (
     ((select auth.jwt()->>'sub') = (user_id)::text)
     );
     ```

  ## Install the Supabase client library

  Run the following command to add the Supabase client library to your application.

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm i @supabase/supabase-js
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @supabase/supabase-js
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @supabase/supabase-js
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @supabase/supabase-js
    ```
  </CodeBlockTabs>

  ## Set up your environment variables

  1. In the Supabase dashboard, navigate to [**Project Settings > Data API**](https://supabase.com/dashboard/project/_/settings/api).
  1. Add the **Project URL** to your `.env` file as `SUPABASE_URL`.
  1. In the **Project API keys** section, add the value beside `anon` `public` to your `.env` file as `SUPABASE_KEY`.

  <If sdk="nextjs">
    > [!IMPORTANT]
    > The `NEXT_PUBLIC_` prefix is required for environment variables that are used in the client-side code, so add this prefix to these variables.
  </If>

  ## Fetch Supabase data in your code

  In your app's `page.tsx`, paste the following code. This example shows the list of tasks for the user and allows the user to add new tasks. The `createClerkSupabaseClient()` function uses [Supabase's `createClient()` method](https://supabase.com/docs/reference/javascript/initializing) to initialize a new Supabase client with access to Clerk's session token.

  <Tabs items={["Client-side rendering", "Server-side rendering"]}>
    <Tab>
      The following example uses the [Next.js SDK](/docs/references/nextjs/overview) to access the [`useUser()`](/docs/hooks/use-user) and [`useSession()`](/docs/hooks/use-session) hooks, but you can adapt this code to work with any React-based Clerk SDK.

      ```tsx {{ filename: 'app/page.tsx', collapsible: true }}
      'use client'
      import { useEffect, useState } from 'react'
      import { useSession, useUser } from '@clerk/nextjs'
      import { createClient } from '@supabase/supabase-js'

      export default function Home() {
        const [tasks, setTasks] = useState<any[]>([])
        const [loading, setLoading] = useState(true)
        const [name, setName] = useState('')
        // The `useUser()` hook is used to ensure that Clerk has loaded data about the signed in user
        const { user } = useUser()
        // The `useSession()` hook is used to get the Clerk session object
        // The session object is used to get the Clerk session token
        const { session } = useSession()

        // Create a custom Supabase client that injects the Clerk session token into the request headers
        function createClerkSupabaseClient() {
          return createClient(
            process.env.NEXT_PUBLIC_SUPABASE_URL!,
            process.env.NEXT_PUBLIC_SUPABASE_KEY!,
            {
              async accessToken() {
                return session?.getToken() ?? null
              },
            },
          )
        }

        // Create a `client` object for accessing Supabase data using the Clerk token
        const client = createClerkSupabaseClient()

        // This `useEffect` will wait for the User object to be loaded before requesting
        // the tasks for the signed in user
        useEffect(() => {
          if (!user) return

          async function loadTasks() {
            setLoading(true)
            const { data, error } = await client.from('tasks').select()
            if (!error) setTasks(data)
            setLoading(false)
          }

          loadTasks()
        }, [user])

        async function createTask(e: React.FormEvent<HTMLFormElement>) {
          e.preventDefault()
          // Insert task into the "tasks" database
          await client.from('tasks').insert({
            name,
          })
          window.location.reload()
        }

        return (
          <div>
            <h1>Tasks</h1>

            {loading && <p>Loading...</p>}

            {!loading && tasks.length > 0 && tasks.map((task: any) => <p key={task.id}>{task.name}</p>)}

            {!loading && tasks.length === 0 && <p>No tasks found</p>}

            <form onSubmit={createTask}>
              <input
                autoFocus
                type="text"
                name="name"
                placeholder="Enter new task"
                onChange={(e) => setName(e.target.value)}
                value={name}
              />
              <button type="submit">Add</button>
            </form>
          </div>
        )
      }
      ```
    </Tab>

    <Tab>
      The following example uses the [Next.js SDK](/docs/references/nextjs/overview) to demonstrate how to integrate Supabase with Clerk in a **server-side rendered** application.

      The `createServerSupabaseClient()` function is stored in a separate file so that it can be re-used in multiple places, such as within `page.tsx` or a Server Action file. This function uses the [`auth().getToken()`](/docs/references/nextjs/auth#data-fetching-with-get-token) method to pass the Clerk session token to the Supabase client.

      ```ts {{ filename: 'app/ssr/client.ts' }}
      import { auth } from '@clerk/nextjs/server'
      import { createClient } from '@supabase/supabase-js'

      export function createServerSupabaseClient() {
        return createClient(
          process.env.NEXT_PUBLIC_SUPABASE_URL!,
          process.env.NEXT_PUBLIC_SUPABASE_KEY!,
          {
            async accessToken() {
              return (await auth()).getToken()
            },
          },
        )
      }
      ```

      The following files render the `/ssr` page and handle the "Add task" form submission. Use the following tabs to view the code for each page.

      <CodeBlockTabs options={['page.tsx', 'actions.ts', 'AddTaskForm.tsx']}>
        ```tsx {{ filename: 'app/ssr/page.tsx' }}
        import AddTaskForm from './AddTaskForm'
        import { createServerSupabaseClient } from './client'

        export default async function Home() {
          // Use the custom Supabase client you created
          const client = createServerSupabaseClient()

          // Query the 'tasks' table to render the list of tasks
          const { data, error } = await client.from('tasks').select()
          if (error) {
            throw error
          }
          const tasks = data

          return (
            <div>
              <h1>Tasks</h1>

              <div>{tasks?.map((task: any) => <p key={task.id}>{task.name}</p>)}</div>

              <AddTaskForm />
            </div>
          )
        }
        ```

        ```ts {{ filename: 'app/ssr/actions.ts' }}
        'use server'

        import { createServerSupabaseClient } from './client'

        export async function addTask(name: string) {
          const client = createServerSupabaseClient()

          try {
            const response = await client.from('tasks').insert({
              name,
            })

            console.log('Task successfully added!', response)
          } catch (error: any) {
            console.error('Error adding task:', error.message)
            throw new Error('Failed to add task')
          }
        }
        ```

        ```ts {{ filename: 'app/ssr/AddTaskForm.tsx' }}
        'use client'
        import React, { useState } from 'react'
        import { addTask } from './actions'
        import { useRouter } from 'next/navigation'

        function AddTaskForm() {
          const [taskName, setTaskName] = useState('')
          const router = useRouter()

          async function onSubmit() {
            await addTask(taskName)
            setTaskName('')
            router.refresh()
          }

          return (
            <form action={onSubmit}>
              <input
                autoFocus
                type="text"
                name="name"
                placeholder="Enter new task"
                onChange={(e) => setTaskName(e.target.value)}
                value={taskName}
              />
              <button type="submit">Add</button>
            </form>
          )
        }
        export default AddTaskForm
        ```
      </CodeBlockTabs>
    </Tab>
  </Tabs>

  ## Test your integration

  Run your project and sign in. Test creating and viewing tasks. Sign out and sign in as a different user, and repeat.

  If you have the same tasks across multiple accounts, double check that RLS is enabled, or that the RLS policies were properly created. Check the table in the Supabase dashboard. You should see all the tasks between both users, but with differing values in the `user_id` column.
</Steps>

## What does the Clerk Supabase integration do?

Requests to Supabase's APIs require that authenticated users have a `"role": "authenticated"` JWT claim. When enabled, the Clerk Supabase integration adds this claim to your instance's generated session tokens.

## Supabase JWT template deprecation

As of April 1st, 2025, the Clerk Supabase JWT template is considered deprecated. Going forward, the native Supabase integration is the recommended way to integrate Clerk with Supabase. The native integration has a number of benefits over the JWT template:

- No need to fetch a new token for each Supabase request
- No need to share your Supabase JWT secret key with Clerk

For more information on the benefits of the native integration, see [Supabase's documentation on third-party auth providers](https://supabase.com/docs/guides/auth/third-party/overview).

---
title: Integrations
description: Learn about the available integrations with Clerk.
---

## Connect with databases and more

<Cards>
  - [Convex](/docs/integrations/databases/convex)
  - Clerk integrates with Convex, the serverless state management platform, using our JSON Web Tokens (JWT) Templates feature.
  - {<svg viewBox="0 0 89 90" fill="none"><path fill="#F3B01C" d="M56.22 70.4c13.1-1.43 25.45-8.29 32.25-19.74-3.22 28.32-34.73 46.22-60.45 35.23-2.37-1.01-4.41-2.69-5.81-4.85-5.78-8.92-7.68-20.27-4.95-30.57 7.8 13.23 23.66 21.34 38.96 19.93Z"/><path fill="#8D2676" d="M16.78 42.16c-5.31 12.06-5.54 26.18.97 37.8C-5.16 63.02-4.91 26.77 17.47 10c2.07-1.55 4.53-2.47 7.11-2.61 10.61-.55 21.39 3.48 28.95 10.99-15.36.15-30.32 9.82-36.75 23.78Z"/><path fill="#EE342F" d="M60.94 22.09C53.19 11.47 41.06 4.24 27.77 4.02 53.46-7.44 85.06 11.14 88.5 38.61c.32 2.55-.1 5.15-1.25 7.45-4.8 9.58-13.7 17.01-24.1 19.76 7.62-13.89 6.68-30.86-2.21-43.73Z"/></svg>}

  ---

  - [Fauna](/docs/integrations/databases/fauna)
  - Build applications using Fauna, the distributed document-relational database, with Clerk as your authentication provider.
  - {<svg viewBox="0 0 32 37" fill="none"><path fill="#3A1AB6" d="M24.736 8.029c-2.187.745-3.24 2.08-3.957 4.162-.185.556-.648 1.171-1.168 1.585l1.793 1.963-5.692-4.068L0 .46s1.134 7.521 1.527 10.288c.278 1.952.752 2.827 2.256 3.714l.602.33 2.592 1.396-1.54-.816 7.105 3.962-.047.107-7.647-3.62c.405 1.42 1.191 4.152 1.527 5.358.359 1.3.764 1.774 2.002 2.235l2.279.851 1.411-.567-1.793 1.218L1.307 36.54c5.959-5.653 11.003-7.663 14.694-9.307 4.709-2.082 7.543-3.418 9.395-8.22 1.319-3.37 2.348-7.686 3.656-9.354l2.788-3.642s-5.773 1.561-7.104 2.01Z"/></svg>}

  ---

  - [Firebase](/docs/integrations/databases/firebase)
  - Clerk integrates directly with Firebase, a popular Platform-as-a-Service (PaaS) provider, so developers can easily add our beautiful Sign Up, Sign In, and User Profile UIs to their Firebase application.
  - {<svg viewBox="0 0 157 196" fill="none"><path fill="#FF9100" d="M49.227 190.109a77.714 77.714 0 0 0 26.359 5.568 77.468 77.468 0 0 0 35.304-7.116 109.954 109.954 0 0 1-34.417-21.609c-6.438 10.308-15.96 18.449-27.245 23.157Z"/><path fill="#FFC400" d="M76.471 166.955c-22.67-20.967-36.423-51.314-35.261-84.6.038-1.08.095-2.16.161-3.24a58.722 58.722 0 0 0-30.66.32A77.424 77.424 0 0 0 .552 115.228c-1.174 33.624 19.173 63.003 48.674 74.884a58.878 58.878 0 0 0 27.245-23.157Z"/><path fill="#FF9100" d="M76.472 166.954c5.27-8.435 8.467-18.324 8.839-28.978.978-28.026-17.863-52.135-43.939-58.862-.066 1.08-.123 2.16-.161 3.24-1.163 33.286 12.59 63.633 35.26 84.6Z"/><path fill="#DD2C00" d="M82.395.335C67.543 12.233 55.815 27.921 48.72 45.994a109.67 109.67 0 0 0-7.36 33.127c26.076 6.727 44.916 30.836 43.938 58.862a58.48 58.48 0 0 1-8.839 28.978 109.788 109.788 0 0 0 34.417 21.609c25.79-11.921 44.088-37.574 45.148-67.916.686-19.659-6.867-37.18-17.54-51.969-11.271-15.64-56.09-68.35-56.09-68.35Z"/></svg>}

  ---

  - [Google Analytics](/docs/integrations/analytics/google-analytics)
  - Send user authentication events to your Google Analytics property to enable metrics tracking on user sign up and sign in events.
  - {<svg viewBox="0 0 152 176" fill="none"><path fill="#F9AB00" d="M110 21v132c0 14.77 10.19 23 21 23 10 0 21-7 21-23V22c0-13.54-10-22-21-22s-21 9.33-21 21Z"/><path fill="#E37400" d="M55 88v65c0 14.77 10.19 23 21 23 10 0 21-7 21-23V89c0-13.54-10-22-21-22s-21 9.33-21 21ZM21 176c11.598 0 21-9.402 21-21s-9.402-21-21-21-21 9.402-21 21 9.402 21 21 21Z"/></svg>}

  ---

  - [Grafbase](/docs/integrations/databases/grafbase)
  - Build applications with serverless GraphQL backends provided by Grafbase and user authentication provided by Clerk.
  - {<svg viewBox="0 0 20 20" style={{ fill:'var(--light, black) var(--dark, white)' }}><path fillRule="evenodd" d="M10.745.46a.833.833 0 0 1-.372 1.119L2.697 5.417 10 9.068l7.232-3.615-2.649-1.204-4.238 1.926a.833.833 0 1 1-.69-1.517l4.584-2.083c.219-.1.47-.1.69 0l4.583 2.083a.833.833 0 0 1 .027 1.504l-9.166 4.583a.833.833 0 0 1-.746 0L.461 6.162a.833.833 0 0 1 0-1.49L9.627.087a.833.833 0 0 1 1.118.373ZM.088 9.628a.833.833 0 0 1 1.118-.372L10 13.652l8.794-4.397a.833.833 0 0 1 .745 1.49l-9.166 4.584a.833.833 0 0 1-.746 0L.461 10.745a.833.833 0 0 1-.373-1.118Zm0 4.584a.833.833 0 0 1 1.118-.373L10 18.235l8.794-4.397a.833.833 0 0 1 .745 1.49l-9.166 4.584a.833.833 0 0 1-.746 0L.461 15.329a.833.833 0 0 1-.373-1.118Z" clipRule="evenodd"/></svg>}

  ---

  - [Hasura](/docs/integrations/databases/hasura)
  - Easily connect to your Hasura GraphQL endpoint using Clerk as your authentication provider.
  - {<svg viewBox="0 0 32 32" fill="none"><path fill="#3970FD" d="M30.575 11.01C31.467 8.201 30.93 2.6 29.2.531a.519.519 0 0 0-.837.067l-2.13 3.378a1.629 1.629 0 0 1-2.19.36A14.527 14.527 0 0 0 16 1.92a14.527 14.527 0 0 0-8.043 2.417 1.634 1.634 0 0 1-2.19-.36L3.637.599A.52.52 0 0 0 2.8.53C1.07 2.603.533 8.205 1.426 11.008c.296.935.377 1.92.203 2.88-.175.95-.35 2.099-.35 2.899 0 8.212 6.592 14.867 14.718 14.867 8.13 0 14.717-6.659 14.717-14.867 0-.8-.174-1.949-.348-2.9a6.022 6.022 0 0 1 .209-2.878ZM15.997 28.333c-6.284 0-11.394-5.164-11.394-11.512a11.518 11.518 0 0 1 6.525-10.399A11.181 11.181 0 0 1 16 5.316c1.744 0 3.394.394 4.872 1.11a11.522 11.522 0 0 1 6.526 10.4c-.004 6.344-5.117 11.508-11.401 11.508Z"/><path fill="#3970FD" d="m20.935 21.255-2.912-5.104-2.497-4.251a.326.326 0 0 0-.284-.163h-2.385a.33.33 0 0 0-.282.5l2.39 4.056-3.206 4.94a.336.336 0 0 0-.014.337.327.327 0 0 0 .29.173h2.402a.324.324 0 0 0 .276-.152l1.734-2.734 1.555 2.723a.328.328 0 0 0 .282.167h2.368a.32.32 0 0 0 .283-.167.327.327 0 0 0 0-.327v.002Z"/></svg>}

  ---

  - [Inngest](/docs/webhooks/inngest)
  - Use events from Clerk to trigger functions defined in your codebase with Inngest. Easily handle data synchronization, onboarding campaigns, or billing workflows in code.
  - ![](data:image/webp;base64,UklGRh4EAABXRUJQVlA4WAoAAAAQAAAAPwAAPwAAQUxQSCsBAAABgGPbttrmrd+p+6VqlV5/GqHKy2WwM7ZsV2G1nkmYORpBmJmZGV5I8J8pVETEBIBcT9/9veFhkKFMGPilITKD69dorvMM8K6g5XUvNdGHtg1BiSfRyfukSoV5V9DhdS8N0YoS+4Q8JY1y79OqJPcpSl/3yBDdSNIQDjGunyLRa111xD2BhNc9zJY2gcQNYY1FkP5lklmJYEZ6LainmXGvmNVghnrNajMl+e2T+D+sJlPKzZTnzNjjZuDLjBBYZOGjDAgxKwDaCLUhFWyXzVGaLQMned0lvtI4TXFw2NVBo1UDiWXL8raLQC5vvpSkM5DMQOuQ0aIByfI1pxaqGRBVw47cpDgQ1jrstWhAvHza2kI10FfqLNykFMhI19BXfS7IVFbUd3PTVwRyAQBWUDggzAIAAFAPAJ0BKkAAQAA+bSyQRb+ioZgLBn34BsS2NhOjmcG42OcWxB5zzRbd/dPwjyhVt/Ej6ZfmA/Yb9gPeH6QD+8ei56lfoAeWZ+tfwVfuR+2HtMtEDSBM1kzDpLxf/u+uW/v4piORnc5jdBlHICkQIbU3Q9Rw1Zv+uCAbrW6IG1df/8EAAP7qGh/9l4pVVBFh+rUY1hy2oGoQV6VGbRHBB2iO0tH/tfH1yRzR3C0HtWw52pZ0QY3Z/vV9q0pqPxK/4/lkfqd2FNP7c15rLCwA8JOvCrqUwq06o83BkZP1MFUdnpr2V8QfIhwktF8gJKTzekh0l7+/J3/8Yi1u5rwesYJlTUDJaZxeZ0/QyaSj7PbEmRwoKia7uNMXgW9sCo+LA7cRYi69D1+QB3yCR8SxVeuahEJAN3IAVOiUwzBeniXMzc5T8B9e5IRgPrynbpSBzCUDWb473yJev7dzLbFtmzFn/234VUeDew/CTEy7fXMomgYBxRubyPU2Os+UNxy8j9+kG1qXNRuPnoCCFf7eempoK9f64lDFekVGNfaP0FMN0yI9fXJBMR6LzLIQ284yBv9SZqJR9yHk9vnwcr+2bcZY+fYRnwm7ed7tJWvWNG/aOZm4ixfPARv8bEWp8DBlrSSNM0fP8eK9AS6LrhQR4cIVsezbBjAAlJ0xwriFeai5RHah1NpMj1I1V6MvEtL8cyoBRz1k492Yo9Nkejreud7UO/yuLM4D1p4btGlGKDTRLgeZPVj9+RDUFTMl8CYLf9V/Wz/4xh/8jFCrLaD3wHlLZ+Wb8PD58Tmzvmvw1gSFiLOt6tdsX0DR5Nov5r6abhM8je+r0W5wX2KGXS/q+a6XpKSVE+mm49uS4cjDWPste4EBGZhmVfnH62FO6za+oovV0UW4rF8TTGp60bC3uj7wnfm6xh7FRW+BBTpGQRbGJMgbchuEdsEhgAAA)

  ---

  - [Instant](/docs/integrations/databases/instantdb)
  - Clerk has a default integration with Instant. You get all the auth features of Clerk, and a relational database you can use directly from the browser.
  - {<svg width="112" height="112" viewBox="0 0 112 112" fill="none" xmlns="http://www.w3.org/2000/svg"> <g clip-path="url(#clip0_95_2)"> <path d="M112 0H0V112H112V0Z" fill="black"/> <path d="M51.865 19.9785H21.24V92.166H51.865V19.9785Z" fill="white"/> </g> <defs> <clipPath id="clip0_95_2"> <rect width="112" height="112" fill="white"/> </clipPath></defs></svg>}

  ---

  - [Neon](/docs/integrations/databases/neon)
  - Build applications using Neon's serverless Postgres database with Clerk as your authentication provider.
  - {<svg xmlns="http://www.w3.org/2000/svg" width="22" height="24" viewBox="0 0 22 24" fill="none"><g id="Logo sign"><g id="Rectangle 3750 (Stroke)"><path fillRule="evenodd" clipRule="evenodd" d="M0 4.64838C0 2.51141 1.6527 0.779053 3.6914 0.779053H17.7187C19.7574 0.779053 21.4101 2.51141 21.4101 4.64838V17.1536C21.4101 19.3644 18.7411 20.3239 17.4467 18.5785L13.3998 13.1217V19.7387C13.3998 21.662 11.9124 23.2211 10.0775 23.2211H3.6914C1.6527 23.2211 0 21.4888 0 19.3518V4.64838ZM3.6914 3.87451C3.28366 3.87451 2.95312 4.22098 2.95312 4.64838V19.3518C2.95312 19.7792 3.28366 20.1257 3.6914 20.1257H10.1883C10.3921 20.1257 10.4467 19.9524 10.4467 19.7387V10.8653C10.4467 8.65452 13.1157 7.69501 14.4101 9.44047L18.457 14.8972V4.64838C18.457 4.22098 18.4956 3.87451 18.0879 3.87451H3.6914Z" fill="#00E0D9"/><path fillRule="evenodd" clipRule="evenodd" d="M0 4.64838C0 2.51141 1.6527 0.779053 3.6914 0.779053H17.7187C19.7574 0.779053 21.4101 2.51141 21.4101 4.64838V17.1536C21.4101 19.3644 18.7411 20.3239 17.4467 18.5785L13.3998 13.1217V19.7387C13.3998 21.662 11.9124 23.2211 10.0775 23.2211H3.6914C1.6527 23.2211 0 21.4888 0 19.3518V4.64838ZM3.6914 3.87451C3.28366 3.87451 2.95312 4.22098 2.95312 4.64838V19.3518C2.95312 19.7792 3.28366 20.1257 3.6914 20.1257H10.1883C10.3921 20.1257 10.4467 19.9524 10.4467 19.7387V10.8653C10.4467 8.65452 13.1157 7.69501 14.4101 9.44047L18.457 14.8972V4.64838C18.457 4.22098 18.4956 3.87451 18.0879 3.87451H3.6914Z" fill="url(#paint0_linear_543_202)"/><path fillRule="evenodd" clipRule="evenodd" d="M0 4.64838C0 2.51141 1.6527 0.779053 3.6914 0.779053H17.7187C19.7574 0.779053 21.4101 2.51141 21.4101 4.64838V17.1536C21.4101 19.3644 18.7411 20.3239 17.4467 18.5785L13.3998 13.1217V19.7387C13.3998 21.662 11.9124 23.2211 10.0775 23.2211H3.6914C1.6527 23.2211 0 21.4888 0 19.3518V4.64838ZM3.6914 3.87451C3.28366 3.87451 2.95312 4.22098 2.95312 4.64838V19.3518C2.95312 19.7792 3.28366 20.1257 3.6914 20.1257H10.1883C10.3921 20.1257 10.4467 19.9524 10.4467 19.7387V10.8653C10.4467 8.65452 13.1157 7.69501 14.4101 9.44047L18.457 14.8972V4.64838C18.457 4.22098 18.4956 3.87451 18.0879 3.87451H3.6914Z" fill="url(#paint1_linear_543_202)" fillOpacity="0.4"/></g><path id="Rectangle 3750 (Stroke)_2" d="M17.7193 0.779053C19.758 0.779053 21.4107 2.51141 21.4107 4.64838V17.1536C21.4107 19.3644 18.7417 20.3239 17.4472 18.5785L13.4004 13.1217V19.7387C13.4004 21.662 11.913 23.2211 10.0781 23.2211C10.282 23.2211 10.4473 23.0479 10.4473 22.8342V10.8653C10.4473 8.65452 13.1163 7.69501 14.4107 9.44047L18.4576 14.8972V1.55292C18.4576 1.12552 18.1271 0.779053 17.7193 0.779053Z" fill="#63F655"/></g><defs><linearGradient id="paint0_linear_543_202" x1="21.4101" y1="23.2211" x2="1.57912" y2="1.70524" gradientUnits="userSpaceOnUse"><stop stopColor="#62F755"/><stop offset="1" stopColor="#8FF986" stopOpacity="0"/></linearGradient><linearGradient id="paint1_linear_543_202" x1="21.4101" y1="23.2211" x2="8.5413" y2="18.4457" gradientUnits="userSpaceOnUse"><stop stopOpacity="0.9"/><stop offset="1" stopColor="#1A1A1A" stopOpacity="0"/></linearGradient></defs></svg>}

  ---

  - [Nhost](/docs/integrations/databases/nhost)
  - The open source alternative to Firebase with GraphQL seamlessly integrates with Clerk to provide authenticated queries.
  - {<svg viewBox="0 0 23 24" fill="none"><path fill="#0052CD" d="M20.406 5.144 12.041.323a2.451 2.451 0 0 0-2.434 0A2.434 2.434 0 0 0 8.39 2.425v.629l-.545-.315a2.451 2.451 0 0 0-2.435 0 2.434 2.434 0 0 0-1.215 2.106v.629l-.546-.315a2.45 2.45 0 0 0-2.433 0A2.434 2.434 0 0 0 0 7.262v15.102a1.144 1.144 0 0 0 1.853.896L6 19.995l6.398 3.685a1.16 1.16 0 0 0 1.144 0c.353-.203.572-.581.572-.989v-9.086a4.198 4.198 0 0 0-2.098-3.626L9.92 8.769V2.428a.908.908 0 0 1 1.361-.784l8.365 4.819a2.672 2.672 0 0 1 1.335 2.307v11.317a.907.907 0 0 1-.454.784l-2.216 1.277V11.186a4.196 4.196 0 0 0-2.098-3.626l-5.15-2.966V6.35l4.387 2.528a2.67 2.67 0 0 1 1.335 2.306v11.62c0 .404.22.785.573.989a1.162 1.162 0 0 0 1.144 0l2.79-1.608a2.436 2.436 0 0 0 1.216-2.103V8.766a4.207 4.207 0 0 0-2.102-3.622Zm-9.156 6.152a2.67 2.67 0 0 1 1.335 2.308v8.43l-5.297-3.051 1.7-1.337a2.41 2.41 0 0 0 .928-1.907V10.53l1.335.767h-.001v-.001ZM8.39 9.65v6.088c0 .28-.127.54-.346.71l-6.52 5.13V7.26a.907.907 0 0 1 1.361-.784l1.31.754v10.793l1.525-1.2V4.843a.907.907 0 0 1 1.362-.783l1.308.753v3.076L6.866 7.01v1.76l1.526.88H8.39Z"/></svg>}

  ---

  - [Shopify](/docs/integrations/shopify)
  - Use Clerk as your preferred Auth solution for your Shopify store.
  - {<svg width="32" height="32" viewBox="0 0 292 292" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid"><path d="M223.774 57.34c-.201-1.46-1.48-2.268-2.537-2.357-1.055-.088-23.383-1.743-23.383-1.743s-15.507-15.395-17.209-17.099c-1.703-1.703-5.029-1.185-6.32-.805-.19.056-3.388 1.043-8.678 2.68-5.18-14.906-14.322-28.604-30.405-28.604-.444 0-.901.018-1.358.044C129.31 3.407 123.644.779 118.75.779c-37.465 0-55.364 46.835-60.976 70.635-14.558 4.511-24.9 7.718-26.221 8.133-8.126 2.549-8.383 2.805-9.45 10.462C21.3 95.806.038 260.235.038 260.235l165.678 31.042 89.77-19.42S223.973 58.8 223.775 57.34zM156.49 40.848l-14.019 4.339c.005-.988.01-1.96.01-3.023 0-9.264-1.286-16.723-3.349-22.636 8.287 1.04 13.806 10.469 17.358 21.32zm-27.638-19.483c2.304 5.773 3.802 14.058 3.802 25.238 0 .572-.005 1.095-.01 1.624-9.117 2.824-19.024 5.89-28.953 8.966 5.575-21.516 16.025-31.908 25.161-35.828zm-11.131-10.537c1.617 0 3.246.549 4.805 1.622-12.007 5.65-24.877 19.88-30.312 48.297l-22.886 7.088C75.694 46.16 90.81 10.828 117.72 10.828z" fill="#95BF46"/><path d="M221.237 54.983c-1.055-.088-23.383-1.743-23.383-1.743s-15.507-15.395-17.209-17.099c-.637-.634-1.496-.959-2.394-1.099l-12.527 256.233 89.762-19.418S223.972 58.8 223.774 57.34c-.201-1.46-1.48-2.268-2.537-2.357" fill="#5E8E3E"/><path d="M135.242 104.585l-11.069 32.926s-9.698-5.176-21.586-5.176c-17.428 0-18.305 10.937-18.305 13.693 0 15.038 39.2 20.8 39.2 56.024 0 27.713-17.577 45.558-41.277 45.558-28.44 0-42.984-17.7-42.984-17.7l7.615-25.16s14.95 12.835 27.565 12.835c8.243 0 11.596-6.49 11.596-11.232 0-19.616-32.16-20.491-32.16-52.724 0-27.129 19.472-53.382 58.778-53.382 15.145 0 22.627 4.338 22.627 4.338" fill="#FFF"/></svg>}

  ---

  - [Supabase](/docs/integrations/databases/supabase)
  - Clerk embraces the open source alternative to Firebase and provides an integration to Supabase with our JSON Web Tokens (JWT) Templates feature.
  - {<svg viewBox="0 0 112 112" fill="none"><path fill="url(#paint0_linear_109_302)" d="M65.183 110.073c-2.86 3.601-8.657 1.628-8.726-2.97l-1.008-67.251h45.22c8.19 0 12.758 9.46 7.665 15.874l-43.151 54.347Z"/><path fill="url(#paint1_linear_109_302)" fillOpacity=".2" d="M65.183 110.073c-2.86 3.601-8.657 1.628-8.726-2.97l-1.008-67.251h45.22c8.19 0 12.758 9.46 7.665 15.874l-43.151 54.347Z"/><path fill="#3ECF8E" d="M46.792 1.86c2.86-3.602 8.658-1.628 8.727 2.97l.441 67.251H11.306c-8.19 0-12.758-9.46-7.665-15.875L46.792 1.86Z"/><defs><linearGradient id="paint0_linear_109_302" x1="55.449" x2="95.639" y1="54.763" y2="71.618" gradientUnits="userSpaceOnUse"><stop stopColor="#249361"/><stop offset="1" stopColor="#3ECF8E"/></linearGradient><linearGradient id="paint1_linear_109_302" x1="37.631" x2="55.96" y1="30.367" y2="64.869" gradientUnits="userSpaceOnUse"><stop/><stop offset="1" stopOpacity="0"/></linearGradient></defs></svg>}
</Cards>

<Include src="_partials/help" />

---
title: Invite users to your application
description: Learn how to invite users to your Clerk application.
---

Inviting users to your Clerk application allows you to onboard new users seamlessly by sending them a unique invitation link.

Once you create an invitation, Clerk sends an email to the invited user with a unique invitation link. When the user visits the invitation link, they will be redirected to the [Account Portal sign-up page](/docs/account-portal/overview#sign-up) and **their email address will be automatically verified.** If you want to redirect the user to a specific page in your application, you can [specify a redirect URL when creating the invitation](#redirect-url).

Invitations expire after a month. If the user clicks on an expired invitation, they will get redirected to the application's sign-up page and will have to go through the normal sign-up flow. Their email address will not be auto-verified.

> [!TIP]
> Invitations are only used to invite users to your application. The application will still be available to everyone even without an invitation. If you're looking to restrict access to invited users only, refer to the [**Restricted** sign-up mode](/docs/authentication/configuration/restrictions#sign-up-modes).

## Create an invitation

You can create an invitation in the [Clerk Dashboard](#using-clerk-dashboard) or [using the Backend API](#using-backend-api).

### Using Clerk Dashboard

To invite users, navigate to the **Users** page from the top-level menu, then select the **Invitations** tab. Select **Invite user** and enter the email address of the person you want to invite. Optionally, set an expiration date for the invitation. Once you've entered the necessary details, select **Send invite** to send the invitation email.

> [!TIP]
> The same page will be available through the top-level menu, when you are in the **Restricted** sign-up mode.

### Using Backend API

You can either use a cURL command or the [JavaScript Backend SDK](/docs/references/backend/overview) to create an invitation. Clerk's JavaScript Backend SDK is a wrapper around the Backend API that makes it easier to interact with the API. Use the following tabs to see examples for each method.

<Tabs items={["cURL", "Backend SDK"]}>
  <Tab>
    The following example demonstrates how to create an invitation using cURL.

    <SignedIn>
      Replace the email address with the email address you want to invite. Your Clerk Secret Key is already injected into the code snippet.
    </SignedIn>

    <SignedOut>
      Replace the email address with the email address you want to invite. Update `YOUR_SECRET_KEY` with your Clerk Secret Key which can be found on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
    </SignedOut>

    ```bash {{ filename: 'terminal' }}
    curl https://api.clerk.com/v1/invitations -X POST -d '{"email_address": "email@example.com"}' -H "Authorization:Bearer {{secret}}" -H 'Content-Type:application/json'
    ```
  </Tab>

  <Tab>
    To use the Backend SDK to create an invitation, see the [`createInvitation()` reference](/docs/references/backend/invitations/create-invitation).
  </Tab>
</Tabs>

See the [Backend API reference](/docs/reference/backend-api/tag/Invitations#operation/CreateInvitation){{ target: '_blank' }} for an example of the response.

### Redirect URL

When you create an invitation, you can specify a `redirect_url` parameter. This parameter tells Clerk where to redirect the user when they visit the invitation link.

The following example demonstrates how to use cURL to create an invitation with the `redirect_url` set to `https://www.example.com/accept-invitation`:

```bash
curl https://api.clerk.com/v1/invitations -X POST -d '{"email_address": "email@example.com", "redirect_url": "https://www.example.com/accept-invitation"}' -H "Authorization:Bearer {{secret}}" -H 'Content-Type:application/json'
```

Once the user visits the invitation link, they will be redirected to the page you specified, which means you must handle the sign-up flow in your code for that page. You can either embed the [`<SignUp />`](/docs/components/authentication/sign-up) component on that page, or if the prebuilt component doesn't meet your specific needs or if you require more control over the logic, you can build a [custom flow](/docs/custom-flows/application-invitations).

> [!TIP]
>
> - To test redirect URLs in your development environment, pass your port (e.g. `http://localhost:3000`).
> - To use the Account Portal, pass the URL provided by Clerk on the [**Account Portal**](https://dashboard.clerk.com/last-active?path=account-portal) page in the Clerk Dashboard. For example, `https://prepared-phoenix-98.accounts.dev/sign-up` redirects the user to the Account Portal sign-up page.

### Invitation metadata

You can also add metadata to an invitation. Once the invited user signs up using the invitation link, the invitation metadata will end up in the user's `public_metadata`. You can find more information about user metadata in the [metadata](/docs/users/metadata) docs.

To add metadata to an invitation, you can use the `public_metadata` property when the invitation is created.

The following example demonstrates how to create an invitation with metadata using cURL.

<SignedIn>
  Replace the email address with the email address you want to invite, and the `public_metadata` with the metadata you want to add. Your Secret Key is already injected into the code snippet.
</SignedIn>

<SignedOut>
  Replace the email address with the email address you want to invite, and the `public_metadata` with the metadata you want to add. Update `YOUR_SECRET_KEY` with your Clerk Secret Key which can be found on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
</SignedOut>

```bash
curl https://api.clerk.com/v1/invitations -X POST -d '{"email_address": "email@example.com", "public_metadata": {"age": "21"}}' -H "Authorization:Bearer {{secret}}" -H 'Content-Type:application/json'
```

## Revoking invitations

You can revoke an invitation at any time. Revoking an invitation prevents the user from using the invitation link that was sent to them. You can revoke an invitation in the [Clerk Dashboard](#using-clerk-dashboard-2) or [using the Backend API](#using-backend-api-2).

### Using Clerk Dashboard

To revoke an invitation, navigate to the **Users** page from the top-level menu, then select the **Invitations** tab. Find the invitation you want to revoke and select **Revoke** from the dropdown menu on the right.

> [!TIP]
> The same page will be available through the top-level menu, when you are in the **Restricted** sign-up mode.

### Using Backend API

You can either use a cURL command or the [JavaScript Backend SDK](/docs/references/backend/overview) to revoke an invitation. Use the following tabs to see examples for each method.

<Tabs items={["cURL", "Backend SDK"]}>
  <Tab>
    The following example demonstrates how to revoke an invitation using cURL.

    <SignedIn>
      Replace the `<invitation_id>` with the ID of the invitation you want to revoke. Your Secret Key is already injected into the code snippet.
    </SignedIn>

    <SignedOut>
      Replace the `<invitation_id>` with the ID of the invitation you want to revoke and replace `YOUR_SECRET_KEY` with your Clerk Secret Key. You can find your Secret Key on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
    </SignedOut>

    ```bash {{ filename: 'terminal' }}
    curl https://api.clerk.com/v1/invitations/<invitation_id>/revoke -X POST -H "Authorization:Bearer {{secret}}" -H 'Content-Type:application/json'
    ```
  </Tab>

  <Tab>
    To use the Backend SDK to revoke an invitation, see the [`revokeInvitation()`](/docs/references/backend/invitations/revoke-invitation) reference documentation.
  </Tab>
</Tabs>

See the [Backend API reference](/docs/reference/backend-api/tag/Invitations#operation/RevokeInvitation){{ target: '_blank' }} for an example of the response.

> [!WARNING]
> Revoking an invitation does **not** prevent the user from signing up on their own. If you're looking to restrict access to invited users only, refer to the [**Restricted** sign-up mode](/docs/authentication/configuration/restrictions#sign-up-modes).

## Custom flow

Clerk's [prebuilt components](/docs/components/overview) and [Account Portal pages](/docs/account-portal/overview) handle the sign-up flow for you, including the invitation flow. If Clerk's prebuilt components don't meet your specific needs or if you require more control over the logic, you can rebuild the existing Clerk flows using the Clerk API. For more information, see the [custom flow for application invitations](/docs/custom-flows/application-invitations).

---
title: Invite users to your organization
description: Learn how to invite users to your organization.
---

Organization invitations allow you to add new members to your organization. When you send an invitation, Clerk sends an email to the invited user with a unique invitation link. When the user visits the organization invitation link, they will be redirected to the [Account Portal sign-in page](/docs/account-portal/overview#sign-in). If the user is already signed in, they will be redirected to your application's homepage (`/`). If you want to redirect the user to a specific page in your application, you can [specify a redirect URL when creating the invitation](#redirect-url).

By default, only admins can invite users to an organization.

This feature requires that **Email address** is enabled as an [identifier](/docs/authentication/configuration/sign-up-sign-in-options#identifiers), as Clerk uses the user's email address to send the invitation. You can still disable **Email address** as an authentication option if you do not want users to be able to sign-in with their email address.

To configure your application's **Email address** settings:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. In the **Contact information** section, ensure that **Email address** is enabled.
1. Next to **Email address**, select the settings icon to configure the email address settings. Here, at least **Require** should be enabled in order to send invitations.

## Create an invitation

Clerk's [prebuilt components](/docs/components/overview) and [Account Portal pages](/docs/account-portal/overview) manage all organization invitation flows, including creating, managing, and accepting invitations.

However, if you want to build custom flows, see the following sections.

### Client-side

To create an organization invitation on the client-side, see the [dedicated guide](/docs/custom-flows/manage-organization-invitations). Note that this uses the [`organizations.inviteMember()`](/docs/references/javascript/organization#invite-member) method, which does not allow you to specify a redirect URL; it will always redirect to the Account Portal sign-in page. If you want to specify a redirect URL, you must create the invitation on the server-side.

### Server-side

To create organization invitations on the server-side, use the [Backend API](/docs/reference/backend-api/tag/Organization-Invitations#operation/CreateOrganizationInvitation){{ target: '_blank' }} either by using a cURL command or the [JavaScript Backend SDK](/docs/references/backend/overview). The JavaScript Backend SDK is a wrapper around the Backend API that makes it easier to interact with the API.

Use the following tabs to see examples for each method.

<Tabs items={["cURL", "Backend SDK"]}>
  <Tab>
    The following example demonstrates how to create an organization invitation using cURL.

    <SignedIn>
      - Your Secret Key is already injected into the code snippet.
      - Replace the `org_123` with the ID of the organization you want to invite the user to.
      - Replace the `user_123` with the ID of the user who is inviting the other user.
      - Replace the email address with the email address you want to invite.
      - Replace the `role` with the role you want to assign to the invited user.
    </SignedIn>

    <SignedOut>
      - Replace `YOUR_SECRET_KEY` with your Clerk Secret Key. You can find your Secret Key on the [**API Keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
      - Replace the `org_123` with the ID of the organization you want to invite the user to.
      - Replace the `user_123` with the ID of the user who is inviting the other user.
      - Replace the email address with the email address you want to invite.
      - Replace the `role` with the role you want to assign to the invited user.
    </SignedOut>

    ```bash {{ filename: 'terminal' }}
    curl 'https://api.clerk.com/v1/organizations/{org_123}/invitations' \
    -X POST \
    -H 'Authorization: Bearer {{secret}}' \
    -H 'Content-Type: application/json' \
    -d '{ "inviter_user_id": "user_123", "email_address": "email@example.com", "role": "org:member" }'
    ```
  </Tab>

  <Tab>
    To use the Backend SDK to create an invitation, see the [`createOrganizationInvitation()`](/docs/references/backend/organization/create-organization-invitation) reference documentation.
  </Tab>
</Tabs>

For an example of the response, see the [Backend API reference](/docs/reference/backend-api/tag/Organization-Invitations#operation/CreateOrganizationInvitation){{ target: '_blank' }}.

### Redirect URL

When you create an invitation, you can specify a `redirect_url` parameter. This parameter tells Clerk where to redirect the user when they visit the invitation link.

The following example demonstrates how to use cURL to create an invitation with the `redirect_url` set to `https://www.example.com/accept-invitation`.

```bash
curl 'https://api.clerk.com/v1/organizations/{org_123}/invitations' \
  -X POST \
  -H 'Authorization: Bearer {{secret}}' \
  -H 'Content-Type: application/json' \
  -d '{ "inviter_user_id": "user_123", "email_address": "email@example.com", "role": "org:member", "redirect_url": "https://www.example.com/accept-invitation" }'
```

Once the user visits the invitation link, they will be redirected to the page you specified. On that page, you must handle the authentication flow in your code. You can either embed the [`<SignIn />`](/docs/components/authentication/sign-in) component or, if the prebuilt component doesn't meet your needs or you require more control over the logic, you can build a [custom flow](/docs/custom-flows/accept-organization-invitations).

> [!TIP]
>
> - To test redirect URLs in your development environment, pass your port. For example, `http://localhost:3000/accept-invitation`.

### Invitation metadata

You can also add metadata to an invitation when creating the invitation through the Backend API. Once the invited user signs up using the invitation link, the **invitation** metadata (`OrganizationInvitation.publicMetadata`) will be stored in the organization **membership's** metadata (`OrganizationMembership.publicMetadata`). You can find more information about organization membership metadata in the [Organization Membership](/docs/references/javascript/types/organization-membership) docs.

To add metadata to an invitation, add the `public_metadata` parameter when creating the invitation.

The following example demonstrates how to use cURL to create an invitation with metadata.

```bash
curl 'https://api.clerk.com/v1/organizations/{org_123}/invitations' \
  -X POST \
  -H 'Authorization: Bearer {{secret}}' \
  -H 'Content-Type: application/json' \
  -d '{ "inviter_user_id": "user_123", "email_address": "email@example.com", "role": "org:member", "public_metadata": {"department": "marketing"} }'
```

## Revoke an invitation

Revoking an invitation prevents the user from using the invitation link that was sent to them.

### Client-side

To revoke an invitation client-side, see the [dedicated guide](/docs/custom-flows/manage-organization-invitations).

### Server-side

To revoke an invitation server-side, use the [Backend API](/docs/reference/backend-api/tag/Organization-Invitations#operation/RevokeOrganizationInvitation){{ target: '_blank' }}. either by using a cURL command or the [JavaScript Backend SDK](/docs/references/backend/overview). The JavaScript Backend SDK is a wrapper around the Backend API that makes it easier to interact with the API.

Use the following tabs to see examples for each method.

<Tabs items={["cURL", "Backend SDK"]}>
  <Tab>
    The following example demonstrates how to revoke an invitation using cURL.

    <SignedIn>
      - Your Secret Key is already injected into the code snippet.
      - Replace the `inv_123` with the ID of the invitation you want to revoke.
      - Replace the `user_123` with the ID of the user who is revoking the invitation.
    </SignedIn>

    <SignedOut>
      - Replace `YOUR_SECRET_KEY` with your Clerk Secret Key. You can find your Secret Key on the [**API Keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
      - Replace the `inv_123` with the ID of the invitation you want to revoke.
      - Replace the `user_123` with the ID of the user who is revoking the invitation.
    </SignedOut>

    ```bash {{ filename: 'terminal' }}
    curl 'https://api.clerk.com/v1/organizations/{org_123}/invitations/{inv_123}/revoke' \
      -X POST \
      -H 'Authorization: Bearer {{secret}}' \
      -H 'Content-Type: application/json' \
      -d '{ "requesting_user_id": "user_123" }'
    ```
  </Tab>

  <Tab>
    To use the Backend SDK to revoke an organization invitation, see the [`revokeOrganizationInvitation()`](/docs/references/backend/organization/revoke-organization-invitation) reference documentation.
  </Tab>
</Tabs>

---
title: iOS Quickstart
description: Add authentication and user management to your iOS app with Clerk.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    }
  ]}
/>

> [!NOTE]
> Ensure that the Native API is enabled to integrate Clerk in your native application. In the Clerk Dashboard, navigate to the [**Native Applications**](https://dashboard.clerk.com/last-active?path=/native-applications) page.

<Steps>
  ## Create an iOS Project

  To get started using Clerk with iOS, create a new project in Xcode. Select SwiftUI as your interface and Swift as your language.
  See the [Xcode documentation](https://developer.apple.com/documentation/xcode/creating-an-xcode-project-for-an-app) for more information.

  ## Install the Clerk iOS SDK

  Follow [the Swift Package Manager instructions](https://developer.apple.com/documentation/xcode/adding-package-dependencies-to-your-app) to install Clerk as a dependency.
  When prompted for the package URL, enter `https://github.com/clerk/clerk-ios`. Be sure to add the package to your target.

  ## Load Clerk

  To use Clerk in your app, you must first configure and load `Clerk`.

  - Inside your new project in Xcode, open your `@main` app file.
  - Import `Clerk`.
  - Create a reference to the shared `Clerk` instance.
  - Replace `ContentView()` with the `ZStack` in the following example. It injects your reference to the shared `clerk` instance into the environment, and attaches a `.task` modifier to the new `ZStack`. Then, in the body of the task, it configures `clerk` with your Publishable Key, and then loads `clerk`.<SignedOut>Get your Publishable Key from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.</SignedOut>

  ```swift {{ filename: 'ClerkQuickstartApp.swift', mark: [2, 6, [10, 21]] }}
  import SwiftUI
  import Clerk

  @main
  struct ClerkQuickstartApp: App {
    @State private var clerk = Clerk.shared

    var body: some Scene {
      WindowGroup {
        ZStack {
          if clerk.isLoaded {
            ContentView()
          } else {
            ProgressView()
          }
        }
        .environment(clerk)
        .task {
          clerk.configure(publishableKey: "{{pub_key}}")
          try? await clerk.load()
        }
      }
    }
  }
  ```

  ## Conditionally render content

  To render content based on whether a user is authenticated or not:

  1. Open your `ContentView` file.
  1. Import `Clerk` and access the shared `Clerk` instance that you injected into the environment in the previous step.
  1. Replace the content of the view body with a conditional that checks for a `clerk.user`.

  ```swift {{ filename: 'ContentView.swift', mark: [2, 5, [8, 14]] }}
  import SwiftUI
  import Clerk

  struct ContentView: View {
    @Environment(Clerk.self) private var clerk

    var body: some View {
      VStack {
        if let user = clerk.user {
          Text("Hello, \(user.id)")
        } else {
          Text("You are signed out")
        }
      }
    }
  }
  ```

  ## Create sign-up and sign-in views

  ### `SignUpView`

  Create a `SignUpView` with the following code. It allows users to sign up using their email address and password, and sends an email verification code to confirm their email address.

  ```swift {{ filename: 'SignUpView.swift' }}
  import SwiftUI
  import Clerk

  struct SignUpView: View {
    @State private var email = ""
    @State private var password = ""
    @State private var code = ""
    @State private var isVerifying = false

    var body: some View {
      VStack {
        Text("Sign Up")
        if isVerifying {
          TextField("Code", text: $code)
          Button("Verify") {
            Task { await verify(code: code) }
          }
        } else {
          TextField("Email", text: $email)
          SecureField("Password", text: $password)
          Button("Continue") {
            Task { await signUp(email: email, password: password) }
          }
        }
      }
      .padding()
    }
  }

  extension SignUpView {

    func signUp(email: String, password: String) async {
      do {
        let signUp = try await SignUp.create(
          strategy: .standard(emailAddress: email, password: password)
        )

        try await signUp.prepareVerification(strategy: .emailCode)

        isVerifying = true
      } catch {
        dump(error)
      }
    }

    func verify(code: String) async {
      do {
        guard let signUp = Clerk.shared.client?.signUp else {
          isVerifying = false
          return
        }

        try await signUp.attemptVerification(strategy: .emailCode(code: code))
      } catch {
        dump(error)
      }
    }

  }
  ```

  ### `SignInView`

  Create a `SignInView` with the following code. It allows users to sign in using their email address and password.

  ```swift {{ filename: 'SignInView.swift' }}
  import SwiftUI
  import Clerk

  struct SignInView: View {
    @State private var email = ""
    @State private var password = ""

    var body: some View {
      VStack {
        Text("Sign In")
        TextField("Email", text: $email)
        SecureField("Password", text: $password)
        Button("Continue") {
          Task { await submit(email: email, password: password) }
        }
      }
      .padding()
    }
  }

  extension SignInView {

    func submit(email: String, password: String) async {
      do {
        try await SignIn.create(
          strategy: .identifier(email, password: password)
        )
      } catch {
        dump(error)
      }
    }

  }
  ```

  ### `SignUpOrSignInView`

  Create a `SignUpOrSignInView` container view that allows users to switch between sign up and sign in.

  ```swift {{ filename: 'SignUpOrSignInView.swift' }}
  import SwiftUI

  struct SignUpOrSignInView: View {
    @State private var isSignUp = true

    var body: some View {
      ScrollView {
        if isSignUp {
          SignUpView()
        } else {
          SignInView()
        }

        Button {
          isSignUp.toggle()
        } label: {
          if isSignUp {
            Text("Already have an account? Sign in")
          } else {
            Text("Don't have an account? Sign up")
          }
        }
        .padding()
      }
    }
  }
  ```

  ## Render the sign-up/sign-in view

  Go back to your `ContentView` and render your newly created `SignUpOrSignInView` when the user isn't signed in.

  ```swift {{ filename: 'ContentView.swift', mark: [12] }}
  import SwiftUI
  import Clerk

  struct ContentView: View {
    @Environment(Clerk.self) private var clerk

    var body: some View {
      VStack {
        if let user = clerk.user {
          Text("Hello, \(user.id)")
        } else {
          SignUpOrSignInView()
        }
      }
    }
  }
  ```

  ## Allow users to sign out

  Finally, provide users with a way to sign out of your app. In your `ContentView`, add the following code. It adds a button that calls Clerk's [`signOut()`](https://swiftpackageindex.com/clerk/clerk-ios/main/documentation/clerk/clerk/signout\(sessionid:\)) method in order to end a user's session.

  ```swift {{ filename: 'ContentView.swift', mark: [[11, 13]] }}
  import SwiftUI
  import Clerk

  struct ContentView: View {
    @Environment(Clerk.self) private var clerk

    var body: some View {
      VStack {
        if let user = clerk.user {
          Text("Hello, \(user.id)")
          Button("Sign Out") {
            Task { try? await clerk.signOut() }
          }
        } else {
          SignUpOrSignInView()
        }
      }
    }
  }
  ```

  ## Create your first user

  Run your project. To sign up and create your first user, enter your email and password and select "Continue".
</Steps>

---
title: JavaScript Backend SDK
description: The JavaScript Backend SDK exposes Clerk's Backend API resources and low-level authentication utilities for JavaScript environments.
---

Clerk's JavaScript Backend SDK exposes the [Backend API](/docs/reference/backend-api){{ target: '_blank' }} resources and low-level authentication utilities **for JavaScript environments**.

For example, if you wanted to get a list of all users in your application, instead of creating a fetch to [`https://api.clerk.com/v1/users`](/docs/reference/backend-api/tag/Users#operation/GetUserList){{ target: '_blank' }} endpoint, you can use the [`users.getUserList()`](/docs/references/backend/user/get-user-list) method provided by the JavaScript Backend SDK.

## Installation

<Tabs items={["Backend SDK", "With other SDKs"]}>
  <Tab>
    If you are using the JavaScript Backend SDK on its own, you can install it using the following command:

    <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
      ```bash {{ filename: 'terminal' }}
      npm install @clerk/backend
      ```

      ```bash {{ filename: 'terminal' }}
      yarn add @clerk/backend
      ```

      ```bash {{ filename: 'terminal' }}
      pnpm add @clerk/backend
      ```

      ```bash {{ filename: 'terminal' }}
      bun add @clerk/backend
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    Clerk SDKs expose an instance of the JavaScript Backend SDK for use in server environments, so there is no need to install it separately.
  </Tab>
</Tabs>

## Usage

All resource operations are mounted as sub-APIs on the `clerkClient` object. For example, if you would like to get a list of all of your application's users, you can use the `getUserList()` method on the `users` sub-API. You can find the full list of available sub-APIs and their methods in the sidenav.

To access a resource, you must first instantiate a `clerkClient` instance.

<Tabs items={["Backend SDK", "With other SDKs"]}>
  <Tab>
    To instantiate a `clerkClient` instance, you must call `createClerkClient()` and pass in [`options`](#create-clerk-client-options).

    > [!NOTE]
    > This example uses `process.env` to import environment variables. You may need to use an alternative method, such as `import.meta.env`, to set environment variables for your project.

    ```ts
    import { createClerkClient } from '@clerk/backend'

    const clerkClient = createClerkClient({ secretKey: process.env.CLERK_SECRET_KEY })
    ```
  </Tab>

  <Tab>
    ### Instantiate a default `clerkClient` instance

    You can use the default instance of `clerkClient` provided by whichever SDK you are using, and skip the need to pass [configuration options](#create-clerk-client-options), unless you are using Remix. For Remix, see the following section.

    To use the default `clerkClient` instance, set your `CLERK_SECRET_KEY` [environment variable](/docs/deployments/clerk-environment-variables#clerk-publishable-and-secret-keys) and then import the `clerkClient` instance from the SDK as shown in the following example:

    <Tabs items={["Next.js", "Remix", "Fastify", "Astro", "Express", "Nuxt"]}>
      <Tab>
        ```jsx
        import { clerkClient } from '@clerk/nextjs/server'
        ```
      </Tab>

      <Tab>
        If you are using Remix, see the following section for how to instantiate `clerkClient`.
      </Tab>

      <Tab>
        ```jsx
        import { clerkClient } from '@clerk/fastify'
        ```
      </Tab>

      <Tab>
        ```js
        import { clerkClient } from '@clerk/astro/server'
        ```
      </Tab>

      <Tab>
        ```js
        import { clerkClient } from '@clerk/express'
        ```
      </Tab>

      <Tab>
        ```js
        import { clerkClient } from '@clerk/nuxt/server'
        ```
      </Tab>
    </Tabs>

    ### Instantiate a custom `clerkClient` instance

    If you would like to customize the behavior of the JavaScript Backend SDK, you can instantiate a `clerkClient` instance yourself by calling `createClerkClient()` and passing in [`options`](#create-clerk-client-options).

    <Tabs items={["Next.js", "Remix", "Fastify", "Astro", "Tanstack React Start", "Express", "Nuxt"]}>
      <Tab>
        ```jsx
        import { createClerkClient } from '@clerk/nextjs/server'

        const clerkClient = createClerkClient({ secretKey: process.env.CLERK_SECRET_KEY })

        const client = await clerkClient()

        const userList = await client.users.getUserList()
        ```
      </Tab>

      <Tab>
        If you are using Remix, you must instantiate `clerkClient` by calling the `createClerkClient()` function and passing in [`options`](#create-clerk-client-options).

        ```jsx
        import { createClerkClient } from '@clerk/remix/api.server'
        ```

        Use the following tabs to see examples of how to use the Backend SDK in Remix Loader and Action functions.

        <Tabs items={["Loader Function", "Action Function"]}>
          <Tab>
            ```tsx {{ filename: 'routes/profile.tsx' }}
            import { LoaderFunction, redirect } from '@remix-run/node'
            import { getAuth } from '@clerk/remix/ssr.server'
            import { createClerkClient } from '@clerk/remix/api.server'

            export const loader: LoaderFunction = async (args) => {
              // Use getAuth to retrieve user data
              const { userId } = await getAuth(args)

              // If there is no userId, then redirect to sign-in route
              if (!userId) {
                return redirect('/sign-in?redirect_url=' + args.request.url)
              }

              // Initialize clerkClient and perform the action,
              // which in this case is to get the user
              const user = await createClerkClient({ secretKey: process.env.CLERK_SECRET_KEY }).users.getUser(
                userId,
              )

              // Return the user
              return { serialisedUser: JSON.stringify(user) }
            }
            ```
          </Tab>

          <Tab>
            ```tsx {{ filename: 'routes/profile.tsx' }}
            import { ActionFunction, redirect } from '@remix-run/node'
            import { getAuth } from '@clerk/remix/ssr.server'
            import { createClerkClient } from '@clerk/remix/api.server'

            export const action: ActionFunction = async (args) => {
              // Use getAuth to retrieve user data
              const { userId } = await getAuth(args)

              // If there is no userId, then redirect to sign-in route
              if (!userId) {
                return redirect('/sign-in?redirect_url=' + args.request.url)
              }

              // Prepare the data for the mutation
              const params = { firstName: 'John', lastName: 'Wicker' }

              // Initialize clerkClient and perform the mutations
              const updatedUser = await createClerkClient({
                secretKey: process.env.CLERK_SECRET_KEY,
              }).users.updateUser(userId, params)

              // Return the updated user
              return { serialisedUser: JSON.stringify(updatedUser) }
            }
            ```
          </Tab>
        </Tabs>
      </Tab>

      <Tab>
        ```jsx
        import { createClerkClient } from '@clerk/fastify'

        const clerkClient = createClerkClient({ secretKey: process.env.CLERK_SECRET_KEY })

        const userList = await clerkClient.users.getUserList()
        ```
      </Tab>

      <Tab>
        If you are using Astro, you must pass the [endpoint context](https://docs.astro.build/en/reference/api-reference/#endpoint-context) when invoking the `clerkClient` function.

        ```jsx
        import { clerkClient } from '@clerk/astro/server'

        export async function GET(context) {
          const { userId, redirectToSignIn } = context.locals.auth()

          if (!userId) {
            return redirectToSignIn()
          }

          const user = await clerkClient(context).users.getUser(userId)

          return new Response(JSON.stringify({ user }))
        }
        ```
      </Tab>

      <Tab>
        ```tsx {{ filename: 'app/routes/api/example.tsx' }}
        import { createClerkClient } from '@clerk/backend'
        import { json } from '@tanstack/react-start'
        import { createAPIFileRoute } from '@tanstack/react-start/api'

        export const Route = createAPIFileRoute('/api/example')({
          GET: async ({ request, params }) => {
            const clerkClient = createClerkClient({ secretKey: import.meta.env.CLERK_SECRET_KEY })

            const userList = await clerkClient.users.getUserList()

            return json({ userList })
          },
        })
        ```
      </Tab>

      <Tab>
        <CodeBlockTabs options={["ESM", "CJS"]}>
          ```js
          import { createClerkClient } from '@clerk/express'

          const clerkClient = createClerkClient({ secretKey: process.env.CLERK_SECRET_KEY })

          const userList = await clerkClient.users.getUserList()
          ```

          ```js
          const Clerk = require('@clerk/express')

          const clerkClient = Clerk.createClerkClient({ secretKey: process.env.CLERK_SECRET_KEY })

          clerkClient.sessions
            .getSessionList()
            .then((sessions) => console.log(sessions))
            .catch((error) => console.error(error))
          ```
        </CodeBlockTabs>
      </Tab>

      <Tab>
        ```tsx {{ filename: 'server/api/users/index.ts' }}
        import { createClerkClient } from '@clerk/nuxt/server'

        export default defineEventHandler(async () => {
          const config = useRuntimeConfig()
          const clerkClient = createClerkClient({ secretKey: config.clerk.secretKey })
          const userList = await clerkClient.users.getUserList()

          return { userList }
        })
        ```
      </Tab>
    </Tabs>
  </Tab>
</Tabs>

## Error handling

Backend SDK functions throw errors (`ClerkAPIResponseError`) when something goes wrong. You'll need to catch them in a `try/catch` block and handle them gracefully. For example:

```ts {{ filename: 'example.ts' }}
try {
  const res = await someBackendApiCall()
} catch (error) {
  // Error handling
}
```

## `createClerkClient({ options })`

The `createClerkClient()` function requires an `options` object. It is recommended to set these options as [environment variables](/docs/deployments/clerk-environment-variables#api-and-sdk-configuration) where possible, and then pass them to the function. For example, you can set the `secretKey` option using the `CLERK_SECRET_KEY` environment variable, and then pass it to the function like this: `createClerkClient({ secretKey: process.env.CLERK_SECRET_KEY })`.

The following options are available:

<Include src="_partials/clerk-options" />

## Get the `userId` and other properties

The [`Auth`](/docs/references/backend/types/auth-object) object contains important information like the current user's session ID, user ID, and organization ID.

<Include src="_partials/auth-object-table" />

For example, in a Next.js App Router route handler, you can use the [`auth()`](/docs/references/nextjs/auth) helper to get the user's ID, and then use the Backend SDK's [`getUser()`](/docs/references/backend/user/get-user) method to get the [Backend User object](/docs/references/backend/types/backend-user).

```tsx {{ filename: 'app/api/example/route.ts' }}
import { auth, clerkClient } from '@clerk/nextjs/server'

export async function GET() {
  // Use `auth()` to get the user's ID
  const { userId } = await auth()

  // Protect the route by checking if the user is signed in
  if (!userId) {
    return new NextResponse('Unauthorized', { status: 401 })
  }

  const client = await clerkClient()

  // Use the Backend SDK's `getUser()` method to get the Backend User object
  const user = await client.users.getUser(userId)

  // Return the Backend User object
  return NextResponse.json({ user: user }, { status: 200 })
}
```

---
title: JavaScript Quickstart
description: Add authentication and user management to your JavaScript app with Clerk.
---

<TutorialHero
  exampleRepo={[
    {
      title: "JavaScript Quickstart Repo",
      link: "https://github.com/clerk/clerk-javascript-quickstart"

    }
  ]}
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
  ]}
/>

To add the [JavaScript SDK](/docs/references/javascript/overview) to your JavaScript app, you have two options:

1. Install the package using a package manager, like `npm`.
1. Use the `<script>` tag to load the ClerkJS package from our CDN.

Use the following tabs to choose your preferred method.

<Tabs items={["NPM module", "<script>"]}>
  {  /* NPM module tab */}

  <Tab>
    <Steps>
      ## Set up a JavaScript app using Vite

      To install Clerk's JavaScript SDK, you need to use a bundler like [Vite](https://vitejs.dev/) or [Webpack](https://webpack.js.org/).

      For this tutorial, run the following commands to create a JavaScript app using [Vite](https://vitejs.dev/guide/#scaffolding-your-first-vite-project). From the prompts, choose the **Vanilla** framework, and then choose the **JavaScript** variant.

      <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
        ```bash {{ filename: 'terminal' }}
        npm create vite@latest clerk-javascript
        cd clerk-javascript
        npm install
        npm run dev
        ```

        ```bash {{ filename: 'terminal' }}
        yarn create vite clerk-javascript
        cd clerk-javascript
        yarn install
        yarn dev
        ```

        ```bash {{ filename: 'terminal' }}
        pnpm create vite clerk-javascript
        cd clerk-javascript
        pnpm install
        pnpm dev
        ```

        ```bash {{ filename: 'terminal' }}
        bun create vite clerk-javascript
        cd clerk-javascript
        bun install
        bun dev
        ```
      </CodeBlockTabs>

      ## Install `@clerk/clerk-js`

      Run the following command to add the JavaScript SDK to your project:

      <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
        ```bash {{ filename: 'terminal' }}
        npm install @clerk/clerk-js
        ```

        ```bash {{ filename: 'terminal' }}
        yarn add @clerk/clerk-js
        ```

        ```bash {{ filename: 'terminal' }}
        pnpm add @clerk/clerk-js
        ```

        ```bash {{ filename: 'terminal' }}
        bun add @clerk/clerk-js
        ```
      </CodeBlockTabs>

      ## Set your Clerk API keys

      It's recommended to use environment variables to store your Clerk Publishable Key. In JavaScript projects, you can add these values in an `.env` file and load them into your app using a package like [`dotenv`](https://www.npmjs.com/package/dotenv). For Vite projects, environment variables in an `.env` file at the project root are automatically accessible through the [`import.meta.env` object](https://vitejs.dev/guide/env-and-mode.html#env-variables).

      <SignedIn>
        Add your Clerk Publishable Key to your `.env` file. It can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
      </SignedIn>

      <SignedOut>
        1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
        1. In the **Quick Copy** section, copy your Clerk Publishable Key.
        1. Paste your key into your `.env` file.

        The final result should resemble the following:
      </SignedOut>

      ```env {{ filename: '.env' }}
      VITE_CLERK_PUBLISHABLE_KEY={{pub_key}}
      ```

      In your `main.js` file, import the Publishable Key using Vite's `import.meta.env` object.

      ```js {{ filename: 'main.js' }}
      const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY
      ```

      ## Initialize Clerk

      To initialize Clerk, import the `Clerk` class and instantiate it with your Clerk Publishable Key. Then, call the `load()` method, as shown in the following example:

      ```js {{ filename: 'main.js' }}
      import { Clerk } from '@clerk/clerk-js'

      const publishableKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

      const clerk = new Clerk(publishableKey)
      await clerk.load({
        // Set load options here
      })
      ```

      > [!NOTE]
      > Calling the `load()` method initializes Clerk. For more information on the `load()` method and what options you can pass to it, see the [reference documentation](/docs/references/javascript/clerk#load).

      ## Add Clerk components to your app

      Clerk's [prebuilt components](/docs/components/overview) are the easiest way to add authentication and user management to your app. They come styled out-of-the-box and are customizable to fit your app's design.

      To get started, add the following components to your app:

      - [`<SignIn />`](/docs/components/authentication/sign-in): Renders a user interface for signing in.
      - [`<UserButton />`](/docs/components/user/user-button): Shows the signed-in user's avatar. Selecting it opens a dropdown menu with account management options.

      Your `main.js` file should look something like this:

      ```js {{ filename: 'main.js' }}
      import { Clerk } from '@clerk/clerk-js'

      const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

      const clerk = new Clerk(clerkPubKey)
      await clerk.load()

      if (clerk.user) {
        document.getElementById('app').innerHTML = `
          <div id="user-button"></div>
        `

        const userButtonDiv = document.getElementById('user-button')

        clerk.mountUserButton(userButtonDiv)
      } else {
        document.getElementById('app').innerHTML = `
          <div id="sign-in"></div>
        `

        const signInDiv = document.getElementById('sign-in')

        clerk.mountSignIn(signInDiv)
      }
      ```

      And your `index.html` file should look something like this:

      ```html {{ filename: 'index.html' }}
      <!doctype html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <link rel="icon" type="image/svg+xml" href="/vite.svg" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Vite App</title>
        </head>
        <body>
          <div id="app"></div>
          <script type="module" src="/main.js"></script>
        </body>
      </html>
      ```

      ## Create your first user

      Run your project with the following command:

      <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
        ```bash {{ filename: 'terminal' }}
        npm run dev
        ```

        ```bash {{ filename: 'terminal' }}
        yarn dev
        ```

        ```bash {{ filename: 'terminal' }}
        pnpm dev
        ```

        ```bash {{ filename: 'terminal' }}
        bun dev
        ```
      </CodeBlockTabs>

      Now visit your app's homepage at [`http://localhost:5173`](http://localhost:5173). Sign up to create your first user.
    </Steps>
  </Tab>

  {  /* <script> tag tab */}

  <Tab>
    <Steps>
      ## Add the SDK using a `<script>` tag

      This `<script>` tag will load Clerk's JavaScript SDK from our CDN and initialize it with your Clerk **Publishable Key** and **Frontend API URL**. It should be placed before any other `<script>` tags that use the JavaScript SDK.

      1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
      1. In the **Quick Copy** section, select **JavaScript** from the dropdown menu.
      1. Copy the `<script>` tag and paste it into your HTML file, as shown in the following example:

      ```html {{ filename: 'index.html' }}
      <!-- Rest of your HTML file -->

      <script
        async
        crossorigin="anonymous"
        data-clerk-publishable-key="{{pub_key}}"
        src="https://{{fapi_url}}/npm/@clerk/clerk-js@5/dist/clerk.browser.js"
        type="text/javascript"
      ></script>
      ```

      ## Listen for the `load` event

      Below the `<script`> tag that initializes the SDK, create another `<script>` tag that listens for the `load` event and call Clerk's [`load()`](/docs/references/javascript/clerk#load) method to load the SDK, as shown in the following example:

      ```html {{ filename: 'index.html' }}
      <!-- Rest of your HTML file -->

      <script>
        window.addEventListener('load', async function () {
          await Clerk.load()

          console.log('ClerkJS is loaded')
        })
      </script>
      ```

      ## Allow users to sign in or out

      Clerk's [prebuilt components](/docs/components/overview) are the easiest way to add authentication and user management to your app. They come styled out-of-the-box and are customizable to fit your app's design.

      To get started, you will use:

      - [`<SignIn />`](/docs/components/authentication/sign-in): renders a user interface for signing in.
      - [`<UserButton />`](/docs/components/user/user-button): Shows the signed-in user's avatar. Selecting it opens a dropdown menu with account management options.

      ```html {{ filename: 'index.html' }}
      <div id="app"></div>

      <!-- Initialize Clerk with your
      Clerk Publishable Key and Frontend API URL -->
      <script
        async
        crossorigin="anonymous"
        data-clerk-publishable-key="{{pub_key}}"
        src="https://{{fapi_url}}/npm/@clerk/clerk-js@latest/dist/clerk.browser.js"
        type="text/javascript"
      ></script>

      <script>
        window.addEventListener('load', async function () {
          await Clerk.load()

          if (Clerk.user) {
            document.getElementById('app').innerHTML = `
              <div id="user-button"></div>
            `

            const userButtonDiv = document.getElementById('user-button')

            Clerk.mountUserButton(userButtonDiv)
          } else {
            document.getElementById('app').innerHTML = `
              <div id="sign-in"></div>
            `

            const signInDiv = document.getElementById('sign-in')

            Clerk.mountSignIn(signInDiv)
          }
        })
      </script>
      ```
    </Steps>
  </Tab>
</Tabs>

## More resources

<Cards>
  - [Clerk class reference](/docs/references/javascript/clerk)
  - Learn more about the `Clerk` class and how to use it.

  ---

  - [Prebuilt components](/docs/components/overview)
  - Learn more about Clerk's suite of components that let you quickly add authentication to your app.

  ---

  - [Customization & localization](/docs/customization/overview)
  - Learn how to customize and localize Clerk components.

  ---

  - [JavaScript SDK Reference](/docs/references/javascript/overview)
  - Learn more about additional JavaScript methods.
</Cards>

---
title: Just-in-Time (JIT) Provisioning during SAML SSO
description: Learn about Clerk's support for Just-in-Time (JIT) Provisioning during SAML SSO.
---

Just-in-Time (JIT) Provisioning, or automatic account provisioning, is a process by which accounts for employees are created on-demand during the first time they authenticate via SAML SSO in your application.

Using JIT Provisioning means your IT department won't have to manually create user accounts for each of the services or apps your employees use to get work done.

Clerk supports JIT account provisioning for all [supported SAML providers](/docs/authentication/enterprise-connections/overview).

Check your preferred SAML provider's documentation to enable JIT account provisioning on their side.

## Sync user attributes during sign in

During SAML SSO and after a user has successfully authenticated, the IdP provides Clerk with the corresponding user data. After each successful sign in, Clerk handles keeping the user data up-to-date based on the response of the SAML provider. This means that if a user's data changes on the IdP side, Clerk will automatically update the user's data in the Clerk database.

To disable this behavior:

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select the SAML connection you want to disable the sync for.
1. Select the **Advanced** tab.
1. Toggle off the **Sync user attributes during Sign in** option.

---
title: JWT templates
description: Learn how to create custom JWT templates to generate JSON Web Tokens with Clerk.
---

> [!WARNING]
> This guide is for creating custom JWT templates in order to generate JSON Web Tokens with Clerk. If you are looking for how to customize your Clerk-generated session token, refer to the [Customize your session token](/docs/backend-requests/custom-session-token) guide.

Clerk offers the ability to generate [JSON Web Tokens](https://en.wikipedia.org/wiki/JSON_Web_Token) (JWTs). Each JWT, or token, represents a user that is currently signed in to your application.

You can control the claims that will go into these tokens by creating custom **JWT templates** that fit your needs. This enables you to integrate with any third-party services that support authentication with JWTs. An example use case is integrating with a third-party service that is able to consume JWTs, but requires them to be in a particular format.

## What is a JWT template?

**JWT templates** are essentially JSON objects that specify claims to be included in the generated tokens, along with their respective values.

Claim values can be either static or dynamic.

Static values can be any of the regular JSON data types (strings, numbers, booleans, arrays, objects, null) and will be included as-is in the tokens.

Dynamic values, also called **shortcodes**, are special strings that will be substituted for their actual values when the tokens are generated. Read more in the [Shortcodes](#shortcodes) section.

The following example shows a template that demonstrates both static values and shortcodes. In this example, the values of the `aud` and `interests` claims are static, and the values of the `name` and `email` claims are dynamic.

```json
{
  "aud": "https://example.com",
  "interests": ["hiking", "knitting"],
  "name": "{{user.first_name}}",
  "surname": "{{user.last_name}}",
  "email": "{{user.primary_email_address}}"
}
```

A token generated using the template above would look something like this:

```json
{
  "aud": "https://example.com",
  "interests": ["hiking", "knitting"],
  "name": "John",
  "surname": null,
  "email": "john@doe.org"
  // ...plus some automatically-included claims
  // See the following section section for more information
}
```

### Default claims

In every generated token, there are certain claims that are automatically included and cannot be overridden by templates. Clerk calls these "default claims" and you can learn more about them in the [Session tokens](/docs/backend-requests/resources/session-tokens) reference documentation.

### Shortcodes

To include dynamic values in your tokens, you can use shortcodes. Shortcodes are strings that Clerk will replace with the actual values of the corresponding user information when the token is generated.

> [!NOTE]
> Even though shortcodes are string values, their type in the generated token depends on the original type of the information that's included. For example, `{{user.public_metadata}}` will be substituted for a JSON object, not a string.

#### Metadata in shortcodes

While you can use the `{{user.public_metadata}}` or `{{user.unsafe_metadata}}` shortcodes to include the complete metadata object in the final token, there might be cases where you only need a specific piece of information.

To keep your tokens lean, you can use the dot notation to access nested fields of the metadata object.

Let's assume the user's public metadata are the following:

```json
{
  "interests": ["hiking", "knitting"],
  "addresses": {
    "Home": "2355 Pointe Lane, 56301 Minnesota",
    "Work": "3759 Newton Street, 33487 Florida"
  }
}
```

To access the `interests` array, you would use the shortcode `{{user.public_metadata.interests}}`. To access the `Home` address, you would use `{{user.public_metadata.addresses.Home}}`. See the following example:

```json {{ prettier: false }}
// The template
{
  "likes_to_do": "{{user.public_metadata.interests}}",
  "shipping_address": "{{user.public_metadata.addresses.Home}}"
}

// The generated token
{
  "likes_to_do": ["hiking", "knitting"],
  "shipping_address": "2355 Pointe Lane, 56301 Minnesota"
}
```

#### Interpolation in shortcodes

Shortcodes can be interpolated inside strings.

For example, you could use interpolation to build the user's full name:

```json
{
  "full_name": "{{user.last_name}} {{user.first_name}}"
}
```

Interpolated shortcodes will always result to string values. For example, if the user does not have a last name associated, the above full name value would be `null John`.

#### Conditional expressions in shortcodes

Conditional expressions use the `||` operator and can be used to substitute a default fallback value for shortcodes that would otherwise result in `null` or `false` values.

The format of a conditional expression is the following:

```json
{
  "key": "{{ <operand_1> || <operand_2> || <operand_n> }}"
}
```

The result of a conditional expression is that of the first operand that does not evaluate to `null` or `false` (also known as "falsy"). If all operands of the expression are falsy, the last operand is returned no matter its value. Therefore, you should always place the default value as the last operand. See the following example:

```json
{
  "has_verified_contact_info": "{{user.email_verified || user.phone_number_verified}}",

  // fallback to a string value
  "full_name": "{{user.full_name || 'Awesome User'}}",

  // fallback to a number value
  "age": "{{user.public_metadata.age || user.unsafe_metadata.age || 30 }}"
}
```

For this example, in the case that user:

- has verified their phone number
- has not verified their email
- has not provided their first or last name
- does not have any public or unsafe metadata assigned

Then, the output of the generated token would be:

```json
{
  "has_verified_contact_info": true,
  "full_name": "Awesome User",
  "age": 30
}
```

The rules that govern conditional expressions are as follows:

- The result of an expression is either the first operand that is not falsy, or the last operand (no matter its value).
- String literals should use single quotes (`'`).
- Only strings, booleans and numbers are permitted as literal (i.e. non-shortcodes) operands.

## Create a JWT template

A template consists of the following four properties:

- Template name: a unique identifier for the template. When generating a token, you will have to specify the template to use, using this name. This is a required field.
- Token lifetime: the time in seconds, after which tokens generated with this template will expire. This setting determines the value of the `exp` claim (i.e. `exp=current_time+lifetime`). Default is 60 seconds.
- Token allowed clock skew: the time in seconds, provided as a leeway to account for clock skews between different servers. This setting determines the value of the `nbf` claim (i.e. `nbf=current_time-allowed_clock_skew`). Default is 5 seconds.
- Claims: the actual template that's entered into the JSON editor (see screenshot below). A template is essentially a JSON object that describes what the final token claims will look like (shortcodes can be used here). This is a required field.

To create a JWT template:

1. In the Clerk Dashboard, navigate to the [**JWT templates**](https://dashboard.clerk.com/last-active?path=jwt-templates) page.
1. Select **New template**.
1. You can either select a blank template or choose one of the provided templates.

## Generate a JWT

To generate a token using a template, you can use the `getToken()` method. See the [reference documentation](/docs/references/backend/types/auth-object#get-token) for more information and example usage.

## Complete example

The following example demonstrates the full capabilities of JWT templates, including static claim values, dynamic claim values via shortcodes, and Clerk's "default claims".

Given the following user:

- First name: `Maria`
- Last name: `Doe`
- Profile picture URL: `https://example.com/avatar.jpg`
- Clerk ID: `user_abcdef123456789`
- Email address (verified): `maria@example.com`
- Phone number: (not provided)
- Public metadata: `{ "profile" : {"interests": ["reading", "climbing"] } }`
- Unsafe metadata: `{ "foo" : { "bar": 42 } }`

And given the following JWT template:

```json
{
  // static values
  "aud": "https://my-site.com",
  "version": 1,
  "foo": { "bar": [1, 2, 3] },

  // dynamic values
  "user_id": "{{user.id}}",
  "avatar": "{{user.image_url}}",
  "full_name": "{{user.last_name}} {{user.first_name}} ",
  "email": "{{user.primary_email_address}}",
  "phone": "{{user.primary_phone_address}}",
  "registration_date": "{{user.created_at}}",
  "likes_to_do": "{{user.public_metadata.profile.interests}}",
  "unsafe_meta": "{{user.unsafe_metadata}}",
  "invalid_shortcode": "{{user.i_dont_exist}}"
}
```

The generated token would look like this:

```json
{
  "aud": "https://my-site.com",
  "version": 1,
  "foo": { "bar": [1, 2, 3] },
  "user_id": "user_abcdef123456789",
  "avatar": "https://example.com/avatar.jpg",
  "full_name": "Doe Maria",
  "email": "maria@example.com",
  "phone": null,
  "registration_date": 1227618844,
  "likes_to_do": ["reading", "climbing"],
  "unsafe_meta": {
    "foo": {
      "bar": 42
    }
  },
  "invalid_shortcode": null,

  // default claims, included automatically
  "azp": "http://localhost:3000",
  "exp": 1639398300,
  "iat": 1639398272,
  "iss": "https://clean-mayfly-62.clerk.accounts.dev",
  "nbf": 1639398220,
  "sid": "sess_2ehYpzsasKNOZrpqPZ9yDWhrYVe",
  "sub": "user_1deJLArSTiWiF1YdsEWysnhJLLY"
}
```

---
title: Legal compliance
description: Learn how to configure your legal compliance settings in the Clerk Dashboard.
---

Clerk provides a legal compliance setting that allows you to require users to agree to your terms of service or privacy policy before they can sign up to your application. After enabling the setting, there will be a checkbox to accept the terms in your [`<SignUp />` component](/docs/components/authentication/sign-up) or [Account Portal sign-up page](/docs/account-portal/overview#sign-up).

To configure the setting:

1. In the Clerk Dashboard, navigate to the [**Legal**](https://dashboard.clerk.com/last-active?path=compliance/legal) page.
1. Enable or disable **Require express consent to legal documents**.

---
title: LinkedIn (deprecated)
description: Learn how to set up social connection with LinkedIn.
---

> [!CAUTION]
> This page is now deprecated. Please see the new [guide](/docs/authentication/social-connections/linkedin-oidc) on how to set up a social connection with LinkedIn.

## Overview

Adding social connection with LinkedIn to your app with Clerk is done in a few steps - you only need to set the **Client ID**, **Client Secret** and **Authorized Redirect URI** in your instance settings.

To make the development flow as smooth as possible, Clerk uses preconfigured shared OAuth credentials and redirect URIs for development instances - no other configuration is needed.

For production instances, you will need to generate your own Client ID and Client secret using your LinkedIn account.

> [!NOTE]
> The purpose of this guide is to help you create a LinkedIn account and a LinkedIn OAuth app - if you're looking for step-by-step instructions using Clerk to add social connection (OAuth) to your application, follow the [Social connection (OAuth) guide](/docs/authentication/social-connections/overview).

## Before you start

- You need to create a Clerk Application in the [Clerk Dashboard](https://dashboard.clerk.com/). For more information, see the [setup guide](/docs/quickstarts/setup-clerk).
- You need to have a LinkedIn account. To create one, [click here](https://developer.linkedin.com/).

## Configuring LinkedIn social connection

First, you need to create a new OAuth LinkedIn app.

![Creating an OAuth LinkedIn app](/docs/images/authentication-providers/linkedin/148540a6928a19c42d105d50c91bd4a61c1d3326-1096x978.png)

You need to set a name, associate a LinkedIn page with it, and upload a logo for your new application.

In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page. Select the **Add connection** button, and select **For all users**. In the **Choose provider** dropdown, select **LinkedIn**.

Toggle on **Use custom credentials** and copy **Authorized Redirect URI**. Paste the value into the **Redirect URL** of your LinkedIn app, as shown below.

![Obtaining the Application ID and Client secret](/docs/images/authentication-providers/linkedin/c3532a2089d98362370241bc43355e95035555da-1089x837.png)

The last thing you have to do is to enable the _Sign in with LinkedIn_ product for your OAuth application.

![Enable Sign In with LinkedIn product](/docs/images/authentication-providers/linkedin/9b2aae3fa3612dd7ae3b982b2c5a7e1d41409d49-1064x765.png)

> [!NOTE]
> If you need to ensure the longevity of the user's access token without the need for re-authentication, make sure to obtain approval as a [Marketing Developer Platform (MDP) partner](https://learn.microsoft.com/en-us/linkedin/marketing/quick-start?view=li-lms-2023-10#step-1-apply-for-api-access). This is not required if you don't directly interact with the LinkedIn API using the access token.

Copy the **Application ID** and **Secret** from the previous screen. Go back to the Clerk Dashboard and paste them into the respective fields.

Finally, select **Add connection** so that the settings are applied. Congratulations! Social connection with LinkedIn is now configured for your instance.

---
title: Linking to the Account Portal
description: Learn how to share direct links to your Account Portal pages, and how to set up fallback redirects.
---

## Redirect URL

If a user accesses an Account Portal page _directly_, the `redirect_url` query param will not be present, so the user cannot be redirected back to your application once they are finished with their Account Portal flow. To prevent this, it is recommend that you always specify the redirect in the link when sharing it.

You can use the following format for your direct links:

`https://accounts.<your-domain.com>/<account-portal-page>?redirect_url=<your-redirect-url>`

**Example**

`https://accounts.myapp.com/sign-in?redirect_url=https://myapp.com/dashboard`

The domain is `myapp.com`, the user is being linked to the sign-in Account Portal page at `http://accounts.myapp.com/sign-in` and they will be redirected to `https://myapp.com/dashboard` after they are signed in.

## Fallback redirects

In the case that a user _does_ visit an Account Portal page directly without the query param, you can set up fallback redirects to ensure that the user is redirected back to your application after they are finished with their Account Portal flow.

### Sign-in and sign-up

Set the appropriate [environment variables](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects) to configure the fallback redirects for sign-in and sign-up.

### Sign out

Set the post-sign-out redirect by passing the `afterSignOutUrl` prop to the `<ClerkProvider>` component. See the [reference doc](/docs/components/clerk-provider) for more information.

### Organization redirects

Both the `<OrganizationProfile />` and `<OrganizationSwitcher />` components accept an `afterLeaveOrganizationUrl` prop for setting the redirect after leaving an organization.

The `<OrganizationSwitcher />` component accepts an `afterSelectOrganizationUrl` prop for setting the redirect after selecting an organization, and an `afterCreateOrganizationUrl` prop for setting the redirect after creating an organization.

## Prefill sign in and sign up fields

In the case of direct links, the values to be used for prefilling the fields for sign-in or sign-up can be specified via the following query parameters:

- `email_address`
- `phone_number`
- `username`
- `first_name`
- `last_name`

For example, visiting `https://accounts.example.com/sign-in?username=nick` will result in the username field being prefilled with the value `nick`.

---
title: Localization prop (experimental)
description: Use the Clerk localizations package to override and provide predefined or custom localizations for your Clerk components, enabling you to offer localized content or tailor the wording to match your brand.
---

> [!WARNING]
> This feature is currently experimental and may not behave as expected. If you encounter any issues, [contact support](/contact/support){{ target: '_blank' }} with as much detail as possible.

Clerk offers the ability to override the strings for all of the elements in each of the Clerk components. This allows you to provide localization for your users or change the wording to suit your brand.

## `@clerk/localizations`

The `@clerk/localizations` package contains predefined localizations for the Clerk components.

### Languages

Clerk currently supports the following languages with English as the default:

| English name | Language tag (BCP 47) | Key |
| - | - | - |
| Arabic (Saudi) | ar-SA | `arSA` |
| Belarus | be-BY | `beBY` |
| Bulgarian | bg-BG | `bgBG` |
| Catalan | ca-ES | `caES` |
| Chinese (Simplified) | zh-CN | `zhCN` |
| Chinese (Traditional) | zh-TW | `zhTW` |
| Croatian | hr-HR | `hrHR` |
| Czech | cs-CZ | `csCZ` |
| Danish | da-DK | `daDK` |
| Dutch | nl-BE | `nlBE` |
| Dutch | nl-NL | `nlNL` |
| English (GB) | en-GB | `enGB` |
| English (US) | en-US | `enUS` |
| Finnish | fi-FI | `fiFI` |
| French | fr-FR | `frFR` |
| German | de-DE | `deDE` |
| Greek | el-GR | `elGR` |
| Hebrew | he-IL | `heIL` |
| Hungarian | hu-HU | `huHU` |
| Icelandic | is-IS | `isIS` |
| Italian | it-IT | `itIT` |
| Indonesian | id-ID | `idID` |
| Japanese | ja-JP | `jaJP` |
| Korean | ko-KR | `koKR` |
| Mongolian | mn-MN | `mnMN` |
| Norwegian | nb-NO | `nbNO` |
| Polish | pl-PL | `plPL` |
| Portuguese (BR) | pt-BR | `ptBR` |
| Portuguese (PT) | pt-PT | `ptPT` |
| Romanian | ro-RO | `roRO` |
| Russian | ru-RU | `ruRU` |
| Serbian | sr-RS | `srRS` |
| Slovak | sk-SK | `skSK` |
| Spanish | es-ES | `esES` |
| Spanish (Mexico) | es-MX | `esMX` |
| Spanish (Uruguay) | es-UY | `esUY` |
| Swedish | sv-SE | `svSE` |
| Thai | th-TH | `thTH` |
| Turkish | tr-TR | `trTR` |
| Ukrainian | uk-UA | `ukUA` |
| Vietnamese | vi-VN | `viVN` |

### Usage

> [!CAUTION]
> The localizations will only update the text in the [Clerk components](/docs/components/overview) used in your application. The hosted [Clerk Account Portal](/docs/account-portal/overview) will remain in English.

To get started, install the `@clerk/localizations` package.

<CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
  ```bash {{ filename: 'terminal' }}
  npm install @clerk/localizations
  ```

  ```bash {{ filename: 'terminal' }}
  yarn add @clerk/localizations
  ```

  ```bash {{ filename: 'terminal' }}
  pnpm add @clerk/localizations
  ```

  ```bash {{ filename: 'terminal' }}
  bun add @clerk/localizations
  ```
</CodeBlockTabs>

Once the `@clerk/localizations` package is installed, you can import the localizations you need by removing the "-" from the locale.

<Tabs items={["Next.js", "Remix", "Astro", "JavaScript", "Vue", "Nuxt"]}>
  <Tab>
    In the following example, the fr-FR locale is imported as `frFR`. The imported localization is then passed to the `localization` prop on the [`<ClerkProvider>`](/docs/components/clerk-provider).

    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: 'app/layout.tsx', mark: [3, 4, 8] }}
      import { ClerkProvider } from '@clerk/nextjs'
      import './globals.css'
      // fr-FR locale is imported as frFR
      import { frFR } from '@clerk/localizations'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <ClerkProvider localization={frFR}>
            <html lang="en">
              <body>{children}</body>
            </html>
          </ClerkProvider>
        )
      }
      ```

      ```tsx {{ filename: '_app.tsx', mark: [3, 4, 9] }}
      import { ClerkProvider } from '@clerk/nextjs'
      // fr-FR locale is imported as frFR
      import { frFR } from '@clerk/localizations'
      import type { AppProps } from 'next/app'

      function MyApp({ Component, pageProps }: AppProps) {
        return (
          // Add the localization prop to the ClerkProvider
          <ClerkProvider localization={frFR} {...pageProps}>
            <Component {...pageProps} />
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    In the following example, the fr-FR locale is imported as `frFR`. The imported localization is then passed to the `localization` prop in the [`ClerkApp`](/docs/references/remix/clerk-app) options.

    ```tsx {{ filename: 'app/root.tsx', mark: [[6, 7], [39, 41]] }}
    import type { MetaFunction, LoaderFunction } from '@remix-run/node'
    import { Links, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react'
    import { rootAuthLoader } from '@clerk/remix/ssr.server'
    // Import ClerkApp
    import { ClerkApp } from '@clerk/remix'
    // fr-FR locale is imported as frFR
    import { frFR } from '@clerk/localizations'

    export const meta: MetaFunction = () => [
      {
        charset: 'utf-8',
        title: 'New Remix App',
        viewport: 'width=device-width,initial-scale=1',
      },
    ]

    export const loader: LoaderFunction = (args) => rootAuthLoader(args)

    export function Layout({ children }: { children: React.ReactNode }) {
      return (
        <html lang="en">
          <head>
            <Meta />
            <Links />
          </head>
          <body>
            {children}
            <ScrollRestoration />
            <Scripts />
          </body>
        </html>
      )
    }

    function App() {
      return <Outlet />
    }

    export default ClerkApp(App, {
      localization: frFR,
    })
    ```
  </Tab>

  <Tab>
    ```js {{ filename: 'astro.config.mjs', mark: [2, 3, 8] }}
    import clerk from '@clerk/astro'
    // fr-FR locale is imported as frFR
    import { frFR } from '@clerk/localizations'

    export default defineConfig({
      integrations: [
        clerk({
          localization: frFR,
        }),
      ],
    })
    ```
  </Tab>

  <Tab>
    In the following example, the fr-FR locale is imported as `frFR`. The imported localization is then passed to the `localization` prop on the [`clerk.load()`](/docs/references/javascript/clerk#load) method.

    Use the following tabs to view the code necessary for each file.

    <CodeBlockTabs options={["main.js", "index.html"]}>
      ```js {{ filename: 'main.js', mark: [2, 3, [8, 10]] }}
      import { Clerk } from '@clerk/clerk-js'
      // fr-FR locale is imported as frFR
      import { frFR } from '@clerk/localizations'

      const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

      const clerk = new Clerk(clerkPubKey)
      await clerk.load({
        localization: frFR,
      })

      if (clerk.user) {
        document.getElementById('app').innerHTML = `
            <div id="user-button"></div>
          `

        const userButtonDiv = document.getElementById('user-button')

        clerk.mountUserButton(userButtonDiv)
      } else {
        document.getElementById('app').innerHTML = `
            <div id="sign-in"></div>
          `

        const signInDiv = document.getElementById('sign-in')

        clerk.mountSignIn(signInDiv)
      }
      ```

      ```html {{ filename: 'index.html' }}
      <!doctype html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <link rel="icon" type="image/svg+xml" href="/vite.svg" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Clerk + JavaScript App</title>
        </head>
        <body>
          <div id="app"></div>
          <script type="module" src="main.js" async crossorigin="anonymous"></script>
        </body>
      </html>
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    ```ts {{ filename: 'src/main.ts', mark: [4, 5, 9] }}
    import { createApp } from 'vue'
    import App from './App.vue'
    import { clerkPlugin } from '@clerk/vue'
    // fr-FR locale is imported as frFR
    import { frFR } from '@clerk/localizations'

    const app = createApp(App)
    app.use(clerkPlugin, {
      localization: frFR,
    })
    app.mount('#app')
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'nuxt.config.ts', mark: [1, 2, [6, 8]] }}
    // fr-FR locale is imported as frFR
    import { frFR } from '@clerk/localizations'

    export default defineNuxtConfig({
      modules: ['@clerk/nuxt'],
      clerk: {
        localization: frFR,
      },
    })
    ```
  </Tab>
</Tabs>

## Adding or updating a localization

Our localizations are customer-sourced and we encourage customers to add or update localizations. To do so, follow these steps:

1. Fork the [https://github.com/clerk/javascript/](https://github.com/clerk/javascript/) repo.
1. Clone it locally to edit it.
1. Review our [Contributing](https://github.com/clerk/javascript/blob/main/docs/CONTRIBUTING.md) guide.
1. If you are updating an existing localization locate the file in `packages/localizations/src`
1. If you are adding a new language, copy the `en-US.ts` file and name it according to your language. The naming is the abbreviated language-region. For example, for French in Canada, it would be `fr-CA.ts.`
1. Go through the file and edit the entries.
1. If you are adding a new localization, add the language to the `packages/localizations/src/index.ts` file.
1. Commit your changes to git and push them to your fork. Create a [Pull Request](https://github.com/clerk/clerk-docs/pulls) from your fork to Clerk's repo against the `main` branch. We will review and either approve or ask for updates.

## Custom localizations

You can also provide your own localizations for the Clerk components. This is useful if you want to provide limited or quick localization for a language that Clerk doesn't currently support or if you want to change the wording to suit your brand.

### Usage

```tsx {{ filename: 'app/layout.tsx' }}
import { ClerkProvider } from '@clerk/nextjs'
import './globals.css'

const localization = {
  socialButtonsBlockButton: 'Sign In with {{provider|titleize}}',
}

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <ClerkProvider localization={localization}>
      <html lang="en">
        <body>{children}</body>
      </html>
    </ClerkProvider>
  )
}
```

To find the key for your translation (like the `socialButtonsBlockButton` from the code example below), open up our [English localization file](https://github.com/clerk/javascript/blob/main/packages/localizations/src/en-US.ts). Search the file for the term that you want to customize.

For example, if you want to change the 'to continue to' string from the `<SignIn />` and `<SignUp />` components, you would search for 'to continue to'. You will find several instances of this. Some of those are in the the following `signUp` object:

```js {{ prettier: false }}
signUp: {
  start: {
    title: 'Create your account',
    subtitle: 'to continue to {{applicationName}}',
    actionText: 'Have an account?',
    actionLink: 'Sign in',
  },
  emailLink: {
    title: 'Verify your email',
    subtitle: 'to continue to {{applicationName}}',
    formTitle: 'Verification link',
    formSubtitle: 'Use the verification link sent to your email address',
    resendButton: "Didn't receive a link? Resend",
    verified: {
      title: 'Successfully signed up',
    },
    loading: {
      title: 'Signing up...',
    },
    verifiedSwitchTab: {
      title: 'Successfully verified email',
      subtitle: 'Return to the newly opened tab to continue',
      subtitleNewTab: 'Return to previous tab to continue',
    },
  },
  emailCode: {
    title: 'Verify your email',
    subtitle: 'to continue to {{applicationName}}',
    formTitle: 'Verification code',
    formSubtitle: 'Enter the verification code sent to your email address',
    resendButton: "Didn't receive a code? Resend",
  },
  phoneCode: {
    title: 'Verify your phone',
    subtitle: 'to continue to {{applicationName}}',
    formTitle: 'Verification code',
    formSubtitle: 'Enter the verification code sent to your phone number',
    resendButton: "Didn't receive a code? Resend",
  },
  continue: {
    title: 'Fill in missing fields',
    subtitle: 'to continue to {{applicationName}}',
    actionText: 'Have an account?',
    actionLink: 'Sign in',
  },
},
```

If you want to customize multiple entries from the `<SignUp />` component, the procedure would resemble the following:

```tsx
const localization = {
  signUp: {
    start: {
      subtitle: 'to access {{applicationName}}',
    },
    emailCode: {
      subtitle: 'to access {{applicationName}}',
    },
  },
}
```

---
title: Locals
description: Learn how to authenticate your Astro application with Clerk using locals.
---

Through Astro [`locals`](https://docs.astro.build/en/guides/middleware/#storing-data-in-contextlocals), Clerk's [`Auth`](/docs/references/backend/types/auth-object){{ target: '_blank' }} and current [`User`](/docs/references/javascript/user){{ target: '_blank' }} objects can be accessed between middlewares and pages. These locals are injected when you install the provided [middleware](/docs/references/astro/clerk-middleware).

This guide provides examples of using the [`auth()`](/docs/references/nextjs/auth){{ target: '_blank' }} local to validate an authenticated user and the [`currentUser()`](/docs/references/nextjs/current-user){{ target: '_blank' }} local to access the [`Backend API User`](/docs/references/backend/types/backend-user){{ target: '_blank' }} object for the authenticated user.

## `locals.auth()`

`Astro.locals.auth()` returns an `Auth` object. This JavaScript object contains important information like session data, your user's ID, as well as their active organization ID. Learn more about the `Auth` object [here](/docs/references/backend/types/auth-object){{ target: '_blank' }}.

### Example: Protect a page or form

You can use the `auth()` local to protect your pages and forms. It will return the current user's ID if they are signed in, or `null` if they are not.

<CodeBlockTabs options={["Protect a page", "Protect a form"]}>
  ```astro {{ filename: 'src/pages/protected.astro' }}
  ---
  const { userId, redirectToSignIn } = Astro.locals.auth()

  if (!userId) {
    return redirectToSignIn()
  }
  ---

  <div>Protected page</div>
  ```

  ```astro {{ filename: 'src/pages/form.astro' }}
  ---
  if (Astro.request.method === 'POST') {
    if (!Astro.locals.auth().userId) {
      throw new Error('You must be signed in to add an item to your cart')
    }

    const data = await Astro.request.formData()
    console.log('add item action', data)
  }
  ---

  <form method="POST">
    <input value="test" type="text" name="name" />
    <button type="submit">Add to Cart</button>
  </form>
  ```
</CodeBlockTabs>

## `locals.currentUser()`

Current user data is important for data enrichment. You can use the `currentUser()` local to fetch the current user's data in your pages.

Under the hood, this local:

- uses the `GET /v1/users/me` endpoint.
- counts towards the [Backend API Request Rate Limit](/docs/backend-requests/resources/rate-limits).

For more information on `currentUser()`, see the [reference](/docs/references/nextjs/current-user){{ target: '_blank' }}.

```astro {{ filename: 'src/pages/form.astro' }}
---
if (Astro.request.method === 'POST') {
  const user = await Astro.locals.currentUser()

  if (!user) {
    throw new Error('You must be signed in to use this feature')
  }

  const data = await Astro.request.formData()
  const serverData = {
    usersHobby: data.get('hobby'),
    userId: user.id,
    profileImage: user.imageUrl,
  }

  console.log('add item action completed with user details ', serverData)
}
---

<form method="POST">
  <input value="soccer" type="text" name="hobby" />
  <button type="submit">Submit your hobby</button>
</form>
```

---
title: Maintenance Mode
description: Learn about Clerk's Maintenance Mode.
---

> [!IMPORTANT]
> Maintenance mode will be deprecated in 2025 as we upgrade our infrastructure.

Once or twice per year, Clerk undergoes maintenance on its infrastructure and enters **Maintenance Mode**. During this time, users who are already signed in will not be signed out, and will continue to have access to your app. However, new sign-ups, sign-ins and user mutations will return an error. **Maintenance Mode** is a special operational state designed to minimize disruption for signed-in users during critical database upgrades or outages.

## Production instances

Mutation methods (`POST`, `PATCH`, `PUT`, `DELETE`) will be rejected with a `SystemUnderMaintenance` error. This includes all new sign-ups and sign-ins.

Active sessions, and session refresh requests **are not** affected. This applies to `GET` requests as well as session refresh requests ([`/touch`](/docs/reference/frontend-api/tag/Sessions#operation/touchSession) and [`/tokens`](/docs/reference/frontend-api/tag/Sessions#operation/createSessionToken) endpoints). Users who are already signed in will not be signed out and will continue to have access to your app. However, any mutations to their user or org data will return the same `SystemUnderMaintenance` error.

### API errors

All mutations from both the Frontend API and the Backend API will return the following `SystemUnderMaintenance` error.

```json
// 503 StatusServiceUnavailable
{
  "shortMessage": "System under maintenance",
  "longMessage": "We are currently undergoing maintenance and only essential operations are permitted. We will be back shortly.",
  "code": "maintenance_mode"
}
```

### UI components

During **Maintenance Mode**, Clerk's UI components will display the following error for sign-ins, sign-ups, and all mutations to user and org data.

![The \<SignIn /> component with a maintenance mode error.](/docs/images/maintenance-mode/maintenance-mode-error-sm.png)

## Development instances

For development instances, all requests will return a `SystemUnderMaintenance ` error, and the instance will be completely unavailable.

---
title: Making requests
description: Learn how to make requests to same-origin and cross-origin endpoints.
---

To make authenticated requests, the approach differs based on whether your client and server are on the [same origin](#same-origin-requests) or [different origins](#cross-origin-requests).

## Same-origin requests

If your client and server are on the same origin (e.g. making an API call to `foo.com/api` from JavaScript running on `foo.com`), the [session token](/docs/backend-requests/resources/session-tokens) is automatically passed to the backend in a cookie. This means that all requests to same-origin endpoints are **authenticated by default**.

### Vanilla JavaScript

You can use the native browser [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) as you normally would and the request will be authenticated.

```js
fetch('/api/foo').then((res) => res.json())
```

### React-based applications

You can use the native browser [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) as you normally would and the request will be authenticated. But when a tab loses focus, and data must be fetched in the background, the session token cookie is not automatically included. You'll need to explicitly pass the [session token](/docs/backend-requests/resources/session-tokens) as a Bearer token in the Authorization header.

Use the [`useAuth()`](/docs/hooks/use-auth) hook's `getToken()` method to get the session token. Since `getToken()` returns a Promise, you'll need to await its resolution before making the request.

<Tabs items={["Fetch", "Fetch with SWR", "Fetch with Tanstack Query"]}>
  <Tab>
    ```jsx
    export default async function useFetch() {
      // Use `useAuth()` to access the `getToken()` method
      const { getToken } = useAuth()

      // Use `getToken()` to get the current session token
      const token = await getToken()

      const authenticatedFetch = async (...args) => {
        return fetch(...args, {
          headers: { Authorization: `Bearer ${token}` }, // Include the session token as a Bearer token in the Authorization header
        }).then((res) => res.json())
      }
      return authenticatedFetch
    }
    ```
  </Tab>

  <Tab>
    ```tsx
    import useSWR from 'swr'

    export default async function useClerkSWR(url: string) {
      // Use `useAuth()` to access the `getToken()` method
      const { getToken } = useAuth()

      // Use `getToken()` to get the current session token
      const token = await getToken()

      const fetcher = async (...args: [RequestInfo]) => {
        return fetch(...args, {
          headers: { Authorization: `Bearer ${token}` }, // Include the session token as a Bearer token in the Authorization header
        }).then((res) => res.json())
      }

      return useSWR(url, fetcher)
    }
    ```
  </Tab>

  <Tab>
    When using [Tanstack Query](https://tanstack.com/query/v4/docs/react/overview) (formerly React Query), you'll need a query function that properly handles errors. The native [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) doesn't throw errors for non-200 responses, so you'll need to add explicit error handling.

    > [!NOTE]
    > Your application must be wrapped in a `<QueryClientProvider />` component with a configured `QueryClient` instance. See the [Tanstack Query docs](https://tanstack.com/query/v4/docs/react/quick-start) for setup instructions.

    ```tsx
    import { useQuery } from '@tanstack/react-query'
    import { useAuth } from '@clerk/nextjs'

    // Define your query keys as constants to avoid typos
    export const queryKeys = {
      foo: ['foo'] as const,
      // Add other query keys as needed
    }

    // Define the response type for type safety
    interface FooResponse {
      // Add your response type here
      id: string
      name: string
    }

    export function useFooQuery() {
      // Use `useAuth()` to access the `getToken()` method
      const { getToken } = useAuth()

      return useQuery({
        queryKey: queryKeys.foo,
        queryFn: async (): Promise<FooResponse> => {
          // Use `getToken()` to get the current session token
          const token = await getToken()

          // Make the request
          const response = await fetch('/api/foo', {
            headers: {
              Authorization: `Bearer ${token}`, // Include the session token as a Bearer token in the Authorization header
              'Content-Type': 'application/json',
            },
          })

          if (!response.ok) {
            // Include status code and status text in error message
            throw new Error(`API Error: ${response.status} ${response.statusText}`)
          }

          const data = await response.json()
          return data as FooResponse
        },
        // Add common configuration options
        retry: 2,
        staleTime: 5 * 60 * 1000, // 5 minutes
      })
    }

    // Usage in component:
    function MyComponent() {
      const { data, isLoading, error } = useFooQuery()

      if (isLoading) return <div>Loading...</div>
      if (error) return <div>Error: {error.message}</div>
      if (!data) return null

      return <div>{data.name}</div>
    }
    ```
  </Tab>
</Tabs>

## Cross-origin requests

If your client and server are on different origins (e.g. making an API call to a server on `api.foo.com` from JavaScript running on a client at `foo.com`), the [session token](/docs/backend-requests/resources/session-tokens) needs to be passed as a Bearer token in the Authorization header.

You can retrieve the session token using the `getToken()` method. Since `getToken()` returns a Promise, you'll need to await its resolution before making the request.

### Vanilla JavaScript

In JavaScript applications, use the global `Clerk.session` object to access the [`getToken()`](/docs/references/javascript/session#get-token) method.

```js
(async () => {
  fetch('/api/foo', {
    headers: {
      Authorization: `Bearer ${await Clerk.session.getToken()}`,
    },
  }).then((res) => res.json())
})()
```

### React-based applications

In React-based applications, use the [`useAuth()`](/docs/hooks/use-auth) hook to access the `getToken()` method.

<Tabs items={["Fetch", "Fetch with SWR", "Fetch with Tanstack Query"]}>
  <Tab>
    ```js
    export default async function useFetch() {
      // Use `useAuth()` to access the `getToken()` method
      const { getToken } = useAuth()

      // Use `getToken()` to get the current session token
      const token = await getToken()

      const authenticatedFetch = async (...args) => {
        return fetch(...args, {
          headers: { Authorization: `Bearer ${token}` }, // Include the session token as a Bearer token in the Authorization header
        }).then((res) => res.json())
      }

      return authenticatedFetch
    }
    ```
  </Tab>

  <Tab>
    ```js
    import useSWR from 'swr'
    import { useAuth } from '@clerk/nextjs'

    export default async function useClerkSWR(url) {
      // Use `useAuth()` to access the `getToken()` method
      const { getToken } = useAuth()

      // Use `getToken()` to get the current session token
      const token = await getToken()

      const fetcher = async (...args) => {
        return fetch(...args, {
          headers: { Authorization: `Bearer ${token}` }, // Include the session token as a Bearer token in the Authorization header
        }).then((res) => res.json())
      }

      return useSWR(url, fetcher)
    }
    ```
  </Tab>

  <Tab>
    The following example shows how to use [Tanstack Query](https://tanstack.com/query/v4/docs/react/overview) to create an authenticated query.

    When using [Tanstack Query](https://tanstack.com/query/v4/docs/react/overview) (formerly React Query), you'll need a query function that properly handles errors. The native [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) doesn't throw errors for non-200 responses, so you'll need to add explicit error handling.

    > [!NOTE]
    > Your application must be wrapped in a `<QueryClientProvider />` component with a configured `QueryClient` instance. See the [Tanstack Query docs](https://tanstack.com/query/v4/docs/react/quick-start) for setup instructions.

    ```tsx
    import { useQuery } from '@tanstack/react-query'
    import { useAuth } from '@clerk/nextjs'

    // Define your query keys as constants to avoid typos
    export const queryKeys = {
      foo: ['foo'] as const,
      // Add other query keys as needed
    }

    // Define the response type for type safety
    interface FooResponse {
      // Add your response type here
      id: string
      name: string
    }

    export function useFooQuery() {
      // Use `useAuth()` to access the `getToken()` method
      const { getToken } = useAuth()

      return useQuery({
        queryKey: queryKeys.foo,
        queryFn: async (): Promise<FooResponse> => {
          // Use `getToken()` to get the current session token
          const token = await getToken()

          // Make the request
          const response = await fetch('/api/foo', {
            headers: {
              Authorization: `Bearer ${token}`, // Include the session token as a Bearer token in the Authorization header
              'Content-Type': 'application/json',
            },
          })

          if (!response.ok) {
            // Include status code and status text in error message
            throw new Error(`API Error: ${response.status} ${response.statusText}`)
          }

          const data = await response.json()
          return data as FooResponse
        },
        // Add common configuration options
        retry: 2,
        staleTime: 5 * 60 * 1000, // 5 minutes
      })
    }

    // Usage in component:
    function MyComponent() {
      const { data, isLoading, error } = useFooQuery()

      if (isLoading) return <div>Loading...</div>
      if (error) return <div>Error: {error.message}</div>
      if (!data) return null

      return <div>{data.name}</div>
    }
    ```
  </Tab>
</Tabs>

---
title: Manual JWT verification
description: Learn how to manually verify Clerk-generated session tokens (JWTs).
---

Your Clerk-generated [session tokens](/docs/backend-requests/resources/session-tokens) are essentially JWTs which are signed using your instance's private key and can be verified using your instance's public key. Depending on your architecture, these tokens will be in your backend requests either via a cookie named `__session` or via the Authorization header.

For every request, you must validate the token to ensure it hasn't expired or been tampered with (i.e., it's authentic and secure). If these validations succeed, then the user is authenticated to your application and should be considered signed in. The `authenticateRequest()` method from the JavaScript Backend SDK handles these validations for you. Alternatively, you can manually verify the token without using the SDK. See the following sections for more information.

## Use `authenticateRequest()` to verify a session token

The [`authenticateRequest()`](/docs/references/backend/authenticate-request) method from the JavaScript Backend SDK accepts the `request` object and authenticates the session token in it.

The following example uses the `authenticateRequest()` method to verify the session token. It also performs networkless authentication by passing `jwtKey`. This verifies if the user is signed into the application. For more information, including usage with higher-level SDKs, see the [`authenticateRequest()` reference](/docs/references/backend/authenticate-request).

<Include src="_partials/authenticate-req" />

## Manually verify a session token

<Steps>
  ### Retrieve the session token

  Retrieve the session token from either `__session` cookie for a same-origin request or from the `Authorization` header for cross-origin requests.

  ### Get your instance's public key

  Use one of the three ways to obtain your public key:

  1. Use the Backend API in JSON Web Key Set (JWKS) format at the following endpoint [https://api.clerk.com/v1/jwks](https://clerk.com/docs/reference/backend-api/tag/JWKS#operation/GetJWKS).
  1. Use your **Frontend API URL** in JWKS format, also known as the **JWKS URL**. The format is your Frontend API URL with `/.well-known/jwks.json` appended to it. Your **Frontend API URL** or **JWKS URL** can be found on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
  1. Use your **JWKS Public Key**, which can be found on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.

  ### Verify the token signature

  To verify the token signature:

  1. Use your instance's public key to verify the token's signature.
  1. Validate that the token isn't expired by checking the `exp` ([expiration time](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.4)) and `nbf` ([not before](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.5)) claims.
  1. Validate that the `azp` (authorized parties) claim equals any of your known origins permitted to generate those tokens. For better security, it's highly recommended to explicitly set the `authorizedParties` option when authorizing requests. The value should be a list of domains allowed to make requests to your application. Not setting this value can open your application to [CSRF attacks](https://owasp.org/www-community/attacks/csrf). For example, if you're permitting tokens retrieved from `http://localhost:3000`, then the `azp` claim should equal `http://localhost:3000`. You can also pass an array of strings, such as `['http://localhost:4003', 'https://clerk.dev']`. If the `azp` claim doesn't exist, you can skip this step.

  ### Finished

  If the above process succeeds, the user is considered signed in to your application and authenticated. You can also retrieve the session ID and user ID from of the token's claims.
</Steps>

### Example

The following example manually verifies a session token.

```tsx
import Cookies from 'cookies'
import jwt from 'jsonwebtoken'

export default async function (req: Request, res: Response) {
  // Your public key should be set as an environment variable
  const publicKey = process.env.CLERK_PEM_PUBLIC_KEY
  // Retrieve session token from either `__session` cookie for a same-origin request
  // or from the `Authorization` header for cross-origin requests
  const cookies = new Cookies(req, res)
  const tokenSameOrigin = cookies.get('__session')
  const tokenCrossOrigin = req.headers.authorization

  if (!tokenSameOrigin && !tokenCrossOrigin) {
    res.status(401).json({ error: 'Not signed in' })
    return
  }

  try {
    let decoded
    const options = { algorithms: ['RS256'] } // The algorithm used to sign the token. Optional.
    const permittedOrigins = ['http://localhost:3000', 'https://example.com'] // Replace with your permitted origins

    if (tokenSameOrigin) {
      decoded = jwt.verify(tokenSameOrigin, publicKey, options)
    } else {
      decoded = jwt.verify(tokenCrossOrigin, publicKey, options)
    }

    // Validate the token's expiration (exp) and not before (nbf) claims
    const currentTime = Math.floor(Date.now() / 1000)
    if (decoded.exp < currentTime || decoded.nbf > currentTime) {
      throw new Error('Token is expired or not yet valid')
    }

    // Validate the token's authorized party (azp) claim
    if (decoded.azp && !permittedOrigins.includes(decoded.azp)) {
      throw new Error("Invalid 'azp' claim")
    }

    res.status(200).json({ sessionToken: decoded })
  } catch (error) {
    res.status(400).json({
      error: error.message,
    })
  }
}
```

---

title: Metadata
description: Types related to metadata.
---

This reference contains types related to metadata.

If you want to provide custom types for any of these types, you can redeclare them in the global namespace. See the [guide on custom types](/docs/guides/custom-types) for more information.

## `OrganizationPublicMetadata`

A type that represents the public metadata for an organization.

```ts
interface OrganizationPublicMetadata {
  [k: string]: unknown
}
```

## `OrganizationPrivateMetadata`

A type that represents the private metadata for an organization.

```ts
interface OrganizationPrivateMetadata {
  [k: string]: unknown
}
```

## `OrganizationInvitationPublicMetadata`

A type that represents the public metadata for an organization invitation.

```ts
interface OrganizationInvitationPublicMetadata {
  [k: string]: unknown
}
```

## `OrganizationInvitationPrivateMetadata`

A type that represents the private metadata for an organization invitation.

```ts
interface OrganizationInvitationPrivateMetadata {
  [k: string]: unknown
}
```

## `OrganizationMembershipPublicMetadata`

A type that represents the public metadata for an organization membership.

```ts
interface OrganizationMembershipPublicMetadata {
  [k: string]: unknown
}
```

## `OrganizationMembershipPrivateMetadata`

A type that represents the private metadata for an organization membership.

```ts
interface OrganizationMembershipPrivateMetadata {
  [k: string]: unknown
}
```

## `SignUpUnsafeMetadata`

A type that represents the unsafe metadata for a sign-up.

```ts
interface SignUpUnsafeMetadata {
  [k: string]: unknown
}
```

## `UserOrganizationInvitationPublicMetadata`

A type that represents the public metadata for a user organization invitation.

```ts
interface UserOrganizationInvitationPublicMetadata {
  [k: string]: unknown
}
```

## `UserPublicMetadata`

A type that represents the public metadata for a user.

```ts
interface UserPublicMetadata {
  [k: string]: unknown
}
```

## `UserPrivateMetadata`

A type that represents the private metadata for a user.

```ts
interface UserPrivateMetadata {
  [k: string]: unknown
}
```

## `UserUnsafeMetadata`

A type that represents the unsafe metadata for a user.

```ts
interface UserUnsafeMetadata {
  [k: string]: unknown
}
```

---
title: MetaMask
description: Learn how to set up Web3 authentication with MetaMask.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk application is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
  ]}
/>

Enabling [MetaMask](https://metamask.io/) as a Web3 provider allows your users to sign in and  up to your Clerk application with their MetaMask wallet.

## Enable MetaMask as a Web3 provider

1. In the Clerk Dashboard, navigate to the [**Web3**](https://dashboard.clerk.com/last-active?path=user-authentication/web3) page.
1. From the list of web3 providers, enable **MetaMask**.

## Test authentication

The simplest way to test authentication is to visit your Clerk application's [Account Portal](/docs/account-portal/overview), which is available for all Clerk applications out-of-the-box.

1. In the Clerk Dashboard, navigate to the [**Account Portal**](https://dashboard.clerk.com/last-active?path=account-portal) page.
1. Next to the **Sign-in** URL, select **Visit**. The URL should resemble:
   - **For development**  `https://your-domain.accounts.dev/sign-in`
   - **For production**  `https://accounts.your-domain.com/sign-in`
1. On the sign-in page, you should see **MetaMask** as an option. Use it to sign in.

## Collect additional user information during sign-up (optional)

Web3 applications typically use a hexadecimal wallet address to identify users, which offers a high level of privacy. However, when bridging the gap between Web3 and Web2, it's often necessary to gather human-readable information about the user, such as their email address, phone number, or a username.

To collect additional information about your user during sign-up:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. On this page, toggle on attributes you wish to collect from your user during sign up.
1. To set an attribute as required, select the settings icon next to the enabled attribute. Clerk will automatically prompt the user for this information after authenticating with MetaMask.

## Connect MetaMask to existing account

Users can connect their MetaMask wallet to their account at any time through their user profile page. You can configure your application to use the [Account Portal user profile page](/docs/account-portal/overview#user-profile) or the prebuilt [`<UserProfile />`](/docs/components/user/user-profile) component.

---
title: Migrate from Auth.js to Clerk
description: Learn how to migrate an application using Auth.js to use Clerk for authentication.
---

<TutorialHero
  exampleRepoTitle="Migration Script Repository"
  exampleRepo={[
    {
      title: "Migration Script",
      link: "https://github.com/clerk/migration-script"

    }
  ]}
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    }
  ]}
/>

This guide shows how to migrate an application using Auth.js (formerly NextAuth.js) to use Clerk for authentication.

<Steps>
  ## Install `@clerk/nextjs`

  Clerk's Next.js SDK gives you access to prebuilt [components](/docs/components/overview), [hooks](/docs/references/nextjs/overview#client-side-helpers), and [helpers](/docs/references/nextjs/overview) for Next.js Server Components, Route Handlers and Middleware. Run the following command to install it:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/nextjs
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/nextjs
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/nextjs
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @clerk/nextjs
    ```
  </CodeBlockTabs>

  ## Set environment variables

  Add the following code to your `.env` file to set your public and Secret Keys.

  **Pro tip!** If you are signed into the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=api-keys), your Secret Key should become visible by clicking on the eye icon.

  ```env {{ filename: '.env' }}
  NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
  CLERK_SECRET_KEY={{secret}}
  ```

  ## Wrap your Next.js app in `<ClerkProvider>`

  Remove the `<SessionProvider session={session}>` provider from Auth.js and replace it with `<ClerkProvider>`.

  <Include src="_partials/clerk-provider/explanation" />

  <CodeBlockTabs options={["App Router", "Pages Router"]}>
    ```tsx {{ filename: 'app/layout.tsx', mark: [1, 6, 10] }}
    import { ClerkProvider } from '@clerk/nextjs'
    import './globals.css'

    export default function RootLayout({ children }: { children: React.ReactNode }) {
      return (
        <ClerkProvider>
          <html lang="en">
            <body>{children}</body>
          </html>
        </ClerkProvider>
      )
    }
    ```

    ```tsx {{ filename: 'pages/_app.tsx', mark: [2, 6, 8] }}
    import '@/styles/globals.css'
    import { ClerkProvider } from '@clerk/nextjs'
    import type { AppProps } from 'next/app'
    function MyApp({ Component, pageProps }: AppProps) {
      return (
        <ClerkProvider {...pageProps}>
          <Component {...pageProps} />
        </ClerkProvider>
      )
    }
    export default MyApp
    ```
  </CodeBlockTabs>

  ## Set up sign-up and sign-in UI

  ### Account Portal

  Account Portal is the fastest way to authenticate your app. Clerk's Account Portal hosts the `<SignIn />`, `<SignUp />`, `<UserProfile />`, and other components for your application. Read more about [Account Portal](/docs/account-portal/getting-started).

  To use the Account Portal, remove the routes that mount the Auth.js sign-in and sign-up UI. Replace the links to those routes with the [`<SignInButton>`](/docs/components/unstyled/sign-in-button) or [`<SignUpButton>`](/docs/components/unstyled/sign-out-button) components.

  ### Self-hosted UI

  If Clerk's Account Portal pages aren't a good fit your app, you can build a custom sign-in and sign-up UI in one of two ways:

  - use the [prebuilt components](/docs/references/nextjs/custom-sign-in-or-up-page), such as the [`<SignIn />`](/docs/components/authentication/sign-in) and [`<SignUp />`](/docs/components/authentication/sign-up) components
  - build a [fully custom UI using the Clerk API](/docs/custom-flows/overview), leveraging Clerk's React hooks such as [`useSignIn()`](/docs/hooks/use-sign-in) and [`useSignUp()`](/docs/hooks/use-sign-up)

  ## Protect your app

  With Clerk, you can control access to your application in a few different ways. One way is to use Clerk's Middleware to protect your entire application, or specific routes. Another way is to use Clerk's components to conditionally render UI based on the user's authentication state. You can hide or show UI based on whether the user is signed in or not.

  ### Control access to your app with Clerk Middleware

  You will need to remove the Auth.js Middleware from your application, and replace it with the Clerk's Middleware helper, `clerkMiddleware()`.

  Auth.js's middleware always rejects unauthorized requests. You may have additionally configured the Next.js middleware config to protect specific private routes. You will need to make note of this configuration so you can recreate it.

  Clerk's Middleware gives you fine-grained control over handling the authenticated state and will, by default, run for your entire application.

  The example below is a basic configuration that does not protect any routes. All routes are public and you must opt-in to protection for routes. Read the [`clerkMiddleware()`](/docs/references/nextjs/clerk-middleware) documentation to learn more about how you can configure your Middleware.

  ```tsx {{ filename: 'middleware.ts' }}
  import { clerkMiddleware } from '@clerk/nextjs/server'

  export default clerkMiddleware()

  export const config = {
    matcher: [
      '/((?!.*\\..*|_next).*)', // Don't run middleware on static files
      '/', // Run middleware on index page
      '/(api|trpc)(.*)', // Run middleware on API routes
    ],
  }
  ```

  ### Control access to your app with Clerk's components

  To conditionally render UI when the user is signed in, wrap it with [`<SignedIn>`](/docs/components/control/signed-in).

  To conditionally render UI when the user is _not_ signed in, wrap it with [`<SignedOut>`](/docs/components/control/signed-out).

  ```tsx {{ filename: 'app/page.tsx' }}
  import { SignedIn, SignedOut } from '@clerk/nextjs'

  export default function Home() {
    return (
      <div>
        <SignedOut>
          <p>This content is public. Only signed out users can see this.</p>
        </SignedOut>
        <SignedIn>
          <p>This content is private. Only signed in users can see this.</p>
        </SignedIn>
      </div>
    )
  }
  ```

  ## Read user and session data

  ### Server-side

  Replace any Auth.js `getServerSession(req, res, authOptions)` with Clerk's helpers.

  <Tabs items={["App Router", "Pages Router"]}>
    <Tab>
      You can replace Auth.js's `setServerSession()` with Clerk's [`auth()`](/docs/references/nextjs/auth) helper in order to read your user data.

      ```tsx {{ filename: 'app/page.tsx' }}
      import { auth, currentUser } from '@clerk/nextjs/server'

      export default async function Page() {
        const { userId } = await auth()
        console.log(userId)

        return <p>Home Page</p>
      }
      ```
    </Tab>

    <Tab>
      You can replace Auth.js's `setServerSession()` with Clerk's [`getAuth()`](/docs/references/nextjs/get-auth) helper in order to read your user data.

      ```tsx {{ filename: 'pages/index.tsx' }}
      export async function getServerSideProps(context) {
        const session = getAuth(context.req)

        return { props: { ...buildClerkProps(ctx.req) } }
      }
      ```
    </Tab>
  </Tabs>

  ### Client Side

  Replace Auth.js's `useSession()` hook with Clerk's hooks.

  The [`useAuth()`](/docs/hooks/use-auth) hook can be used to retrieve basic authentication information. The [`useUser()`](/docs/hooks/use-user) hook can be used to retrieve the full [`User`](/docs/references/javascript/user) object, which includes information about the user, such as their first name, emails, phone numbers, and more.

  ```tsx {{ filename: 'app/page.tsx' }}
  'use client'
  import { useAuth, useUser } from '@clerk/nextjs'

  export default function Home() {
    const { userId, sessionId } = useAuth()
    const { isSignedIn, user } = useUser()
    console.log(userId, sessionId, isSignedIn, user)

    return <p>Home Page</p>
  }
  ```

  ## User IDs as Foreign Keys

  When you migrate to Clerk, you will likely need to resolve the foreign key that you used in your database. If you used the `userId` from NextAuth.js, you could resolve this issue with one of the following two options:

  - [Use Clerk's `externalId` field](#use-clerks-external-id-field)
  - [Update your Auth.js database](#update-your-database)

  ### Use Clerk's `externalId` field

  When you migrate user data from Auth.js to Clerk, Clerk generates new user IDs for each user. If you are using existing user IDs as foreign keys in your database (e.g. in a `user_id` column), you can save those IDs as the user's `externalId` in Clerk. This `externalId` can be included in the session token by adding the following [customization](/docs/backend-requests/custom-session-token). The following example will set the user's ID to be `externalId` if one is present, otherwise, it will use the Clerk's user ID.

  ```json
  {
    "userId": "{{user.external_id || user.id}}"
  }
  ```

  <Tabs items={["App Router", "Pages Router"]}>
    <Tab>
      To access the `userId` from the session claims, you can use the `auth()` helper.

      ```tsx {{ filename: 'app/page.tsx' }}
      import { auth } from '@clerk/nextjs/server'

      export default async function Page() {
        const { sessionClaims } = await auth()

        if (!sessionClaims) {
          return <p>Not signed in</p>
        }

        const userId = sessionClaims.sub

        return <p>Welcome user {userId}</p>
      }
      ```
    </Tab>

    <Tab>
      To access the `userId` from the session claims, you can use the `getAuth()` helper.

      ```tsx {{ filename: 'pages/index.tsx' }}
      import { getAuth, buildClerkProps } from '@clerk/nextjs/server'
      import { GetServerSideProps } from 'next'

      export const getServerSideProps: GetServerSideProps = async (ctx) => {
        const { userId } = getAuth(ctx.req)

        if (!userId) {
          // handle user is not signed in.
        }

        const {
          sessionClaims: { userId },
        } = getAuth(req)
        console.log(userId)

        return { props: { ...buildClerkProps(ctx.req) } }
      }
      ```
    </Tab>
  </Tabs>

  > [!NOTE]
  > You can not access the above from the client-side. If you are using one of Clerk's hooks, then you will need to check if `externalID` exists. If it doesn't, then read the `userId`.

  ### Update your database

  Alternatively, after the data migration, you can update all the user IDs stored in your database as a foreign key to the new Clerk user IDs.

  You can read more about user IDs and user data migration in the [Migration Script README](https://github.com/clerk/migration-script?tab=readme-ov-file#handling-the-foreign-key-constraint).

  ## Create a Clerk production instance

  Every Clerk application has a `Development` and a `Production` instance. Before you start migrating user data, you need to configure your Clerk `Production` instance and migrate your Auth.js users directly into that instance. The [Deploying to Production](/docs/deployments/overview) page covers creating a `Production` instance.

  You can migrate a small set of users on the `Development` instance for testing/staging. To enable importing users to your `Development` instance, add `IMPORT_TO_DEV_INSTANCE=true` to the `.env` for the migration script.

  ## Migrate user data from Auth.js to Clerk

  This walkthrough will help you move user data from your existing database to Clerk.

  To retain the user data in your database for easy querying, see the [guide on data synchronization with webhooks](/docs/webhooks/sync-data).

  1. Clone `github.com/clerk/migration-script`

  1. Create an `.env` file in the root of the cloned repository with the `CLERK_SECRET_KEY` **of your `Production` instance**.

  1. Export all the user data from your database into a `users.json` file. The file should be in the following format:

     ```json {{ filename: 'users.json' }}
     [
       {
         "userId": "string",
         "email": "email",
         "firstName": "string (optional)",
         "lastName": "string (optional)",
         "password": "string (optional)",
         "passwordHasher": "argon2 | argon | bcrypt | md5 | pbkdf2_sha256 | pbkdf2_sha256_django | pbkdf2_sha1 | scrypt_firebase"
       }
     ]
     ```

  1. If you already have an API endpoint in your Auth.js app that returns a list of users, you can use that. Otherwise, you will need to query your database to obtain the user information, or use an export function from a database management tool.

     The example below is a SQL query that would return the user information in the correct format for the migration script.

     ```sql
     SELECT id as userId, email, name FROM users
     ```

  1. Edit the `.env.` file in the migration, and add your Clerk Secret Key using `CLERK_SECRET_KEY`

  1. Run the script with `npm start`

  1. Check that your users are listed on the [**Users**](https://dashboard.clerk.com/last-active?path=users) page in the Clerk Dashboard. If the users appear to have imported correctly, verify by signing in to your application secured by Clerk with your user account.

  1. Check for an error log for any users that were not migrated successfully.

  ## Finding further support for migrating from Auth.js to Clerk

  This guide covers the most common steps that you would take for the migration. If you have more complex integrations with Auth.js that are not covered here, don't hesitate to reach out in the [Clerk Discord](https://clerk.com/discord) by creating a post in the [Support channel](https://discord.gg/bmPVkeqKzZ).
</Steps>

---
title: Migrate from Cognito
description: Seamlessly migrate AWS Cognito user passwords into Clerk.
---

## Overview

It is a known limitation that AWS Cognito does not include hashed passwords when listing user pool users.
This necessitates a password reset flow when migrating users to another platform.

To eliminate the need for a cumbersome password reset flow, Clerk provides a Cognito password migrator
that enables your end users to sign in to Clerk using their existing Cognito passwords.

In its barest form, it is simply two fields that you set on a Clerk `user` object through
the [Backend API](/docs/reference/backend-api/tag/Users#operation/CreateUser){{ target: '_blank' }}.

- `password_hasher`: `awscognito`
- `password_digest`: `awscognito#<COGNITO_USER_POOL_ID>#<COGNITO_CLIENT_ID>#<identifier>`

## Pre-flight checks

In AWS, you will need to ensure that your Cognito user pool has a **public** client with the `ALLOW_USER_PASSWORD_AUTH` auth flow enabled.

You can create a new client for your user pool at any time from the AWS console or through the [AWS CLI](https://awscli.amazonaws.com/v2/documentation/api/latest/reference/cognito-idp/create-user-pool-client.html)

> [!CAUTION]
> This step is critical for the migration to work as intended.

## One-time upload

For any Cognito user object that youd wish to migrate, you will need to have an equivalent Clerk user object,
with the `password_hasher` and `password_digest` fields set.

Below is one method of conducting a batch upload of your Cognito users into Clerk.
However, you are not limited to this approach, nor does it impact the migration flow.

Ensure that you are using `node >= v20`, and run the following to create a new script directory and project.

```shell {{ title: '~/' }}
user@~: $ mkdir cognito_to_clerk
user@~: $ cd cognito_to_clerk

user@~/cognito_to_clerk: $ npm init -y
user@~/cognito_to_clerk: $ npm i -E @aws-sdk/client-cognito-identity-provider@3.614.0
user@~/cognito_to_clerk: $ npm i -E @clerk/backend@1.4.3

user@~/cognito_to_clerk: $ touch .env
user@~/cognito_to_clerk: $ touch main.ts
```

Fill in the `.env` file with your AWS and Clerk credentials.

> [!IMPORTANT]
>
> - Always double check that the `CLERK_SECRET_KEY` points to the desired Clerk instance (development vs. production)
> - The `COGNITO_CLIENT_ID` should be the public client ID that you created earlier in the [Pre-flight checks](#pre-flight-checks) section.

```shell {{ title: '~/cognito_to_clerk/.env' }}
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_REGION=

COGNITO_USER_POOL_ID=
COGNITO_CLIENT_ID=

CLERK_SECRET_KEY=
```

The provided script below lists your Cognito user pool users, calls
`CreateUser` for each user, and sets the `password_hasher` and `password_digest` fields.

> [!CAUTION]
> As usual, rate limits apply to the `CreateUser` endpoint. [^1]

[^1]: [`CreateUser`](/docs/reference/backend-api/tag/Users#operation/CreateUser){{ target: '_blank' }} has a rate limit rule of 20 requests per 10 seconds.

```ts {{ title: '~/cognito_to_clerk/main.ts' }}
import { createClerkClient } from '@clerk/backend'
import * as IDP from '@aws-sdk/client-cognito-identity-provider'

// NOTE: The IAM user should have permissions roughly equivalent to AmazonCognitoReadOnly.
// https://docs.aws.amazon.com/aws-managed-policy/latest/reference/AmazonCognitoReadOnly.html
const { AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION } = process.env
if (!AWS_ACCESS_KEY_ID || !AWS_SECRET_ACCESS_KEY || !AWS_REGION) {
  throw new Error(
    'AWS credentials are required. Double check that your `.env` file is set up correctly. Must have AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, and AWS_REGION.',
  )
}

const { COGNITO_USER_POOL_ID, COGNITO_CLIENT_ID } = process.env
if (!COGNITO_USER_POOL_ID || !COGNITO_CLIENT_ID) {
  throw new Error(
    'Cognito user pool and client IDs are required. Double check that your `.env` file is set up correctly. Must have COGNITO_USER_POOL_ID and COGNITO_CLIENT_ID.',
  )
}

const { CLERK_SECRET_KEY } = process.env
if (!CLERK_SECRET_KEY) {
  throw new Error(
    'Clerk Secret Key is required. Double check that your `.env` file is set up correctly. Must have CLERK_SECRET_KEY.',
  )
}

const idpClient = new IDP.CognitoIdentityProviderClient({
  region: AWS_REGION,
  credentials: {
    accessKeyId: AWS_ACCESS_KEY_ID,
    secretAccessKey: AWS_SECRET_ACCESS_KEY,
  },
})

const clerk = createClerkClient({
  secretKey: CLERK_SECRET_KEY,
})

async function main() {
  const usersResponse = await idpClient.send(
    new IDP.ListUsersCommand({ UserPoolId: COGNITO_USER_POOL_ID }),
  )
  if (!usersResponse.Users) {
    throw new Error('No users found')
  }

  usersLoop: for (const cognitoUser of usersResponse.Users) {
    // Skip unconfirmed users or EXTERNAL_PROVIDER users (like Facebook, Google, etc)
    if (cognitoUser.UserStatus !== 'CONFIRMED') {
      console.log(
        'Skipping user: User is not confirmed:',
        cognitoUser.Username,
        cognitoUser.UserStatus,
      )
      continue
    }

    // This identifier must match the one that use used for sign in on the Cognito user pool.
    // Note that in AWS, this option is only configurable at the time of user creation.
    let identifier: string
    // Comment/Uncomment the block(s) below to use the identifier from the Cognito user pool.
    {
      identifier = cognitoUser.Attributes?.find((a) => a.Name === 'sub')!.Value!
    }
    {
      identifier = cognitoUser.Attributes?.find((a) => a.Name === 'email')!.Value!
    }
    {
      identifier = cognitoUser.Username!
    }

    if (!identifier) {
      console.log('Skipping user: No identifier found:', cognitoUser)
      continue
    }

    const email = cognitoUser.Attributes?.find((a) => a.Name === 'email')!.Value!

    try {
      await clerk.users.createUser({
        emailAddress: [email],
        passwordDigest: `awscognito#${COGNITO_USER_POOL_ID}#${COGNITO_CLIENT_ID}#${identifier}`,
        // @ts-expect-error - awscognito works, but is not a valid TypeScript yet
        passwordHasher: 'awscognito',
      })
      console.log('Created clerk user for:', identifier)
      await new Promise((resolve) => setTimeout(resolve, 500))
    } catch (err) {
      console.error(err)
      break usersLoop
    }
  }
}

main()
```

Run the batch upload script.

```shell {{ title: '~/cognito_to_clerk' }}
user@~/cognito_to_clerk: $ npx tsx --env-file=.env main.ts
```

## Post-upload

Once you have users with the special hasher and digest in your Clerk instance,
you will be able to validate the migration behavior.

<Steps>
  ### Validate

  We recommend validating the integration by taking a single user whose
  Cognito password you know, such as your own, uploading it to Clerk with
  the special `awscognito` hasher and custom digest, and then attempting to sign in
  via your Clerk instances managed Account Portal.

  If the password is correct, sign in should work seamlessly.

  > [!TIP]
  > If at any point you need to _reset_, you can delete the user via the Clerk Dashboard, and restart the process.
  >
  > This validation may be performed on both your `development` and `production` instances.

  ### Rollout changes

  Up until this point, you were possibly using the Cognito hosted UI for your applications user sign-in.
  With the [one-time upload](#one-time-upload) out of the way and integration validated, you should be ready to
  update your application to use Clerks managed [Account Portal](/docs/account-portal/overview) or the [`<SignIn />`](/docs/components/authentication/sign-in) component.

  Your end users will now be able to sign in to Clerk using their existing passwords without any password reset required.
</Steps>

As users successfully sign in to Clerk, their passwords will be re-hashed, and stored securely. No plaintext passwords are ever stored.

---
title: Migrate from Firebase
description: Migrating your user base from Firebase to Clerk is a 2-part process that can be accomplished with just a few steps.
---

Migrating your user base from Firebase to Clerk is a 2-part process that can be accomplished with just a few steps.

<Steps>
  ## Export your Firebase users

  ### Install the Firebase CLI

  If you haven't already, install the Firebase CLI:

  ```bash {{ filename: 'terminal' }}
  npm install -g firebase-tools
  ```

  ### Log in to Firebase

  Login to your Firebase account via the CLI.

  ```bash {{ filename: 'terminal' }}
  firebase login
  ```

  ### Find your Firebase project ID

  Use the firebase CLI to list your projects and find the project ID you want to export.

  ```bash {{ filename: 'terminal' }}
  firebase projects:list
  ```

  ### Export your Firebase users using the CLI

  Use the firebase CLI to export your users to a JSON file.

  ```bash {{ filename: 'terminal' }}
  firebase auth:export firebase-users.json --format=json --project <YOUR_PROJECT_ID>
  ```

  Here's what this command is doing:

  1. `firebase auth:export`: it tells Firebase you're trying to export the user base.

  1. `firebase-users.json`: the name of the file you're about to create.

  1. `--format=json`: make it a JSON file.

  1. `--project <YOUR_PROJECT_ID>`: it tells Firebase which project you're trying to export from. Don't forget to replace `<YOUR_PROJECT_ID>` with the Project ID you found in the previous step.

  You should now have a JSON file called `firebase-users.json` that contains all your Firebase users.

  ## Retrieve your password hash parameters

  In your Firebase projects dashboard, navigate to **Authentication** and select the 3 vertical dots at the top of the user's list, then select **Password hash parameters**.

  On the new window that opens, you'll find the following values: `base64_signer_key`, `base64_salt_separator`, `rounds` and `mem_cost`.

  You can find more information about this page and the values above on [Firebase's documentation](https://firebaseopensource.com/projects/firebase/scrypt/).

  ## Create a Node.js script

  Now you have all the information you need to import your Firebase users into Clerk. This example uses Node.js, but you can use any other language or method if you so wish.

  ### init npm

  ```bash {{ filename: 'terminal' }}
  npm init -y
  ```

  ### Install dependencies

  ```bash {{ filename: 'terminal' }}
  npm i node-fetch@2
  ```

  ### Create a script

  ```js {{ filename: 'migrate-to-clerk.js' }}
  const fetch = require('node-fetch')
  const firebaseUsers = require('./firebase-users.json')

  async function migrateToClerk() {
    // You can find these values on your Firebase project's authentication settings
    const signerKey = ''
    const saltSeparator = ''
    const rounds = ''
    const memoryCost = ''

    // You can find this value on your Clerk application's dashboard
    const clerkBackendApiKey = ''

    for (let user of firebaseUsers.users) {
      const { email, localId, passwordHash, salt } = user

      const body = passwordHash
        ? {
            email_address: [email],
            external_id: localId,
            password_hasher: 'scrypt_firebase',
            password_digest: `${passwordHash}$${salt}$${signerKey}$${saltSeparator}$${rounds}$${memoryCost}`,
          }
        : {
            email_address: [email],
            external_id: localId,
            skip_password_requirement: true,
          }

      try {
        const result = await fetch('https://api.clerk.com/v1/users', {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${clerkBackendApiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(body),
        })

        if (!result.ok) {
          throw Error(result.statusText)
        } else {
          console.log(`${email} added successfully`)
        }
      } catch (error) {
        console.error(`Error migrating ${email}: ${error}`)
      }
    }
  }

  migrateToClerk()
  ```

  Here, body will either hold the necessary information to migrate a password-based user or in the case of an OAuth-based user, it'll skip the password check. It will also have the previous user ID as `external_id`, so you can link the newly created users with their existing data.

  ## Run the script

  ```bash {{ filename: 'terminal' }}
  node migrate-to-clerk.js
  ```

  > [!WARNING]
  > This implementation does not take rate limiting into account. If you have a large user base, you may want to implement a retry mechanism. Clerk will return a `429` status code if you exceed the rate limit. You can find more information about Clerk's rate limits [here](/docs/backend-requests/resources/rate-limits). Keep [Firebase's rate limits](https://firebase.google.com/docs/functions/quotas) in mind as well when exporting your users.

  Once the script has finished running, your user base will be fully migrated to Clerk.
</Steps>

---
title: Migrate to Clerk from another platform
description: Guides on how to move your user data from another authentication platform to Clerk.
---

There are typically two main strategies for migrating your existing user management from a different platform into Clerk:

- [Basic Export / Import](#basic-export-import)
- [Trickle migration](#trickle-migration)

Each of these have trade-offs you'll need to consider on behalf of for your application and its users.

## Basic export / import

With basic export / import, you're taking an export from your previous tool and importing data into Clerk. The most common way to handle this is by making use of the [`CreateUser`](/docs/reference/backend-api/tag/Users#operation/CreateUser){{ target: '_blank' }} Backend API endpoint. It's important to note that the `CreateUser` endpoint is rate limited. For more information, see the [guide on rate limits](/docs/backend-requests/resources/rate-limits#backend-api-requests).

You'll also need to provide your `password_hasher` value (The hashing algorithm used to generate the password digest) and in some instances Clerk will transparently upgrade your users' password hashes to the more secure Bcrypt hashing algorithm. More details on this topic are available in the [Backend API reference docs](/docs/reference/backend-api/tag/Users#operation/CreateUser!path=password_hasher\&t=request){{ target: '_blank' }}.

> [!NOTE]
> If you are expecting to import 100k+ users, we recommend reaching out to [support@clerk.dev](mailto:support@clerk.dev) where we can coordinate increases to the rate limits and ensure a seamless import of your data.

### Considerations

When evaluating the Basic Import / Export workflow there are a few tradeoffs you'll need to consider.

#### Data consistency

Consider that any export of your data will be a snapshot in time. This means that there is a potential of your data being out of sync at the time of import. To work around this you might script and coordinate the export and import actions to be as close in time as possible, or you might schedule some kind of downtime or maintenance window to complete this action. Be sure to consider Clerk API rate-limits when evaluating a potentially time-sensitive migration approach.

#### Active sessions / session management

Another consideration is centered around how you handle session management. While most authentication providers don't provide session management out-of-the-box, Clerk does. This means that when you switch over to using Clerk you'll be changing the system that handles your users' active sessions. This will likely end any currently active sessions initiated by your previous session management service (unless you are able to gracefully handle this somehow within your architecture).

#### Foreign keys

In your previous system, you likely had some kind of ID / Foreign Key that you were using. As you migrate data into Clerk, you might want to continue referencing that previous ID alongside Clerk's provided user IDs. While each use case might have some variation, a common strategy is to store previous IDs as an `external_id`. You can then use Clerk's JWT customization to enrich a `userId` value with the `external_id` when present, or fallback to using Clerk's native ID when dealing with new users who don't have an `external_id` from your legacy system. You can configure this in the [**Sessions**](https://dashboard.clerk.com/last-active?path=sessions) page in the Clerk Dashboard. Under **Customize session token**, select **Edit** and add the following:

```json
{
  "userId": "{{user.external_id || user.id}}"
}
```

## Trickle migration

With a trickle migration you are slowly migrating your users from your previous system into Clerk. Depending on your application's needs this can be a great way to accomplish migration in a gradual and more controlled way. With a trickle migration, you are keeping both systems running for some period of time, handling the transition between systems opaquely to your users, and then eventually cutting over fully to Clerk as your user and session management system or record. By handling this transition gradually you'll maintain more control and put less pressure on a single coordinated event.

### Considerations

As with the Basic Import / Export workflow there are a tradeoffs you'll need to consider, to determine which strategy is best for your application.

#### The cost and overhead of running two systems in parallel

Because you'll need both systems available when doing a gradual migration, there is naturally additional short-term costs related to having both running systems at the same time.

> [!NOTE]
> It's important to note that Clerk only charges by _Monthly Active Users_ and never based on your total number of Users in the user table  so during this period you'll only be charged for users who create an active session within Clerk. Head to our [pricing page](/pricing) to get the full details on how Clerk charges.

#### Determining the appropriate length of time

As part of the trickle migration, you'll need to determine an appropriate length of time for the migration to take place. For some applications this might be a few weeks, but for others it might be more appropriate to run this for months. Your hard-costs, coordination costs, underlying complexity, and the amount of active users you expect in your migration time-window should guide your decision here.

#### Dealing with the delta

A trickle migration is great for upgrading active users and sessions to take advantage of Clerk but there will always be some users who won't create an active session within the migration window and therefore will need to be migrated by other means, typically via [Basic Import / Export](#basic-export-import). However, the benefit of a trickle migration is that the risk of coordination becomes much lower as the delta users are likely to be less active, are less in numbers, and therefore the risk of data de-synchronization is reduced.

## Migration tools

To aid in basic migrations, Clerk provides an open-source script that takes a JSON file as input, containing a list of users, and creates a user in Clerk using the Backend API. The script respects the [backend rate limits](/docs/backend-requests/resources/rate-limits#backend-api-requests) and gracefully handles errors. We suggest you customize the [Zod schema](https://github.com/clerk/migration-script/blob/main/index.ts#L25-L43){{ target: '_blank' }} to your application's needs.

To use Clerk's migration script, clone the [repository](https://github.com/clerk/migration-script) and follow the instructions in the `README`.

## Migration guides

Clerk is hard at work writing up more specific migration guides and tools. If you're interested in specific guides, contact us at [https://feedback.clerk.com](https://feedback.clerk.com)

<Cards>
  - [Firebase](/docs/deployments/migrate-from-firebase)
  - Learn how to migrate from Firebase to Clerk quickly and easily.
</Cards>

---
title: 'Migrating from the Astro community SDK'
description: Learn how to migrate from the Astro community SDK to the Clerk Astro SDK.
---

In July 2024, we introduced official support for Astro. This migration guide covers converting from the [`astro-clerk-auth`](https://github.com/panteliselef/astro-with-clerk-auth) community SDK to Clerk's official SDK. It covers the breaking changes that were introduced and provides examples on how to resolve them.

## Installation

Uninstall the community SDK and install Clerk's new official SDK for Astro.

<CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
  ```bash {{ filename: 'terminal' }}
  npm uninstall astro-clerk-auth
  npm install @clerk/astro
  ```

  ```bash {{ filename: 'terminal' }}
  yarn remove astro-clerk-auth
  yarn add @clerk/astro
  ```

  ```bash {{ filename: 'terminal' }}
  pnpm remove astro-clerk-auth
  pnpm add @clerk/astro
  ```

  ```bash {{ filename: 'terminal' }}
  bun remove astro-clerk-auth
  bun add @clerk/astro
  ```
</CodeBlockTabs>

## Breaking Changes

### The integration

With the community SDK, you could choose to either hotload Clerk's `clerk-js` library or bundle it with your application.

With Clerk's official SDK, `clerk-js` is hotloaded by default, and the option to use the bundled `clerk-js` variant has been removed.

The following changes are required in your Astro configuration file:

```js {{ del: [[4, 7]], ins: [8] }}
import { defineConfig } from 'astro/config'
import node from '@astrojs/node'

import clerk from 'astro-clerk-auth/hotload'
import clerk from 'astro-clerk-auth/integration/hotload'
import clerk from 'astro-clerk-auth'
import clerk from 'astro-clerk-auth/integration'
import clerk from '@clerk/astro'

export default defineConfig({
  integrations: [clerk()],
  adapter: node({ mode: 'standalone' }),
  output: 'server',
})
```

### Prefix for environment variables

The prefix for environment variables used in client-side code has been updated to align with Astro's [best practices](https://docs.astro.build/en/guides/environment-variables/). This change affects all [environment variables](/docs/deployments/clerk-environment-variables){{ target: '_blank' }} supported by Clerk.

```{{ del: [1, 4, 7], ins: [2, 5, 8] }}
PUBLIC_ASTRO_APP_CLERK_PUBLISHABLE_KEY=
PUBLIC_CLERK_PUBLISHABLE_KEY=

PUBLIC_ASTRO_APP_CLERK_SIGN_IN_URL=
PUBLIC_CLERK_SIGN_IN_URL=

PUBLIC_ASTRO_APP_*=
PUBLIC_*=

```

### Astro component export updates

The Astro components have been restructured to provide a more consistent API. The following changes are required to import your Astro components:

```js {{ del: [1, 4, 7], ins: [2, 5, 8] }}
import { UserProfile } from '@clerk/astro/components/interactive'
import { UserProfile } from '@clerk/astro/components'

import { Protect } from '@clerk/astro/components/control'
import { Protect } from '@clerk/astro/components'

import { SignInButton } from '@clerk/astro/components/unstyled'
import { SignInButton } from '@clerk/astro/components'
```

### Stores

Submodule `/stores` was replaced with `/client`. The following changes are required to import the [stores](/docs/references/astro/overview#client-side-helpers):

```js {{ del: [1, 4, 5], ins: [2, 6, 7] }}
import { $clerk } from 'astro-clerk-auth/stores'
import { $clerkStore } from '@clerk/astro/client'

import { $csrState } from 'astro-clerk-auth/stores'
import { $initialState } from 'astro-clerk-auth/stores'
import { $userStore } from '@clerk/astro/client'
import { $sessionStore } from '@clerk/astro/client'
```

### Submodule removal

Submodule `/v0` was dropped completely and the previously exported constants are no longer available.

```js {{ prettier: false, del: [1] }}
import { apiKey, secretKey, DOMAIN, ... } from 'astro-clerk-auth/v0'
```

### `clerkClient` changes

The `clerkClient` variable has been deprecated and should now be used as a function that accepts the Astro context.

```ts {{ del: [2, 6], ins: [3, 7] }}
import type { APIRoute } from 'astro'
import { clerkClient } from 'astro-clerk-auth/v0'
import { clerkClient } from '@clerk/astro/server'

export const GET: APIRoute = async (context) => {
  clerkClient.users.getUser(/* ... */)
  clerkClient(context).users.getUser(/* ... */)
  // ...
}
```

### React components changes

With the community SDK, there were to ways to use a React component inside a `.astro` file.

To avoid confusion, the official SDK removes the `/components/react` submodule.

```astro {{ prettier: false, del: [2, 6], ins: [3, 7] }}
---
import { SignedIn } from '@clerk/astro/components/react'
import { SignedIn } from '@clerk/astro/react'
---

<SignedIn>
<SignedIn client:load>
  {...}
</SignedIn>
```

To use a React component inside a `.jsx` or `.tsx` file, update the import path.

```jsx {{ prettier: false, del: [6], ins: [7] }}
import {
  SignInButton,
  SignedIn,
  SignedOut,
  UserButton,
} from '@clerk/astro/client/react'
} from '@clerk/astro/react'

export default function Header() {
  return (
    <>
      <p>My App</p>
      <SignedOut>
        <SignInButton />
      </SignedOut>
      <SignedIn>
        <UserButton />
      </SignedIn>
    </>
  )
}
```

---
title: Migrating from the Vue community SDK
description: Learn how to migrate from the Vue community SDK to the Clerk Vue SDK.
---

In December 2024, Clerk introduced official support for Vue. This migration guide covers converting from the [`vue-clerk`](https://vue-clerk.vercel.app) community SDK to Clerk's official SDK. It covers the breaking changes that were introduced and provides examples on how to resolve them.

## Installation

Uninstall the community SDK and install Clerk's new official SDK for Vue.

<CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
  ```bash {{ filename: 'terminal' }}
  npm uninstall vue-clerk
  npm install @clerk/vue
  ```

  ```bash {{ filename: 'terminal' }}
  yarn remove vue-clerk
  yarn add @clerk/vue
  ```

  ```bash {{ filename: 'terminal' }}
  pnpm remove vue-clerk
  pnpm add @clerk/vue
  ```

  ```bash {{ filename: 'terminal' }}
  bun remove vue-clerk
  bun add @clerk/vue
  ```
</CodeBlockTabs>

## Breaking changes

### The `useClerk()` composable

The `useClerk()` composable has two important changes:

1. Import path has changed from `vue-clerk` to `@clerk/vue`.
1. The return value is now a Vue [ref](https://vuejs.org/api/reactivity-core.html#ref) containing the Clerk instance.

The key difference is that you now need to use `clerk.value` to access Clerk methods, since the composable returns a reactive ref.

Update your code as follows:

```vue {{ del: [2, 6], ins: [3, 7] }}
<script setup>
import { useClerk } from 'vue-clerk'
import { useClerk } from '@clerk/vue'
const clerk = useClerk()
function signIn() {
  clerk.openSignIn()
  clerk.value.openSignIn()
}
</script>
<template>
  <button @click="signIn">Sign in</button>
</template>
```

---
title: Multi-tenant architecture
description: This guide outlines a number of the common architecture scenarios for building B2B, B2C, and Platform applications with Clerk, their characteristics, and limitations.
---

There are several ways to model how users and organizations fit into your application. The 3 scenarios that will be covered in this guide are:

1. B2C: Business to Consumer
1. B2B: Business to Business
1. Platforms

We will share some of the common characteristics of apps in each scenario as well as the level of support for these features in Clerk.

## B2C: Business to Consumer

B2C companies focus on selling products or services directly to consumers. Some popular examples are Netflix, Headspace, and Spotify. Clerk supports the B2C user management model out-of-the-box, with little-to-no configuration.

In a B2C scenario, applications generally share the following characteristics:

- A user creates a single account with your service
- There is a single, shared user-pool which all the users belong to
- Any connections enabled for your application are available to all users to authenticate with
- The application branding is that of your company (as in, not white-labelled per customer or organization)
- The application is accessible under a single domain (for example: `example.com` or `app.example.com`)

> [!NOTE]
> In the B2C scenario, organizations are generally not necessary since users that sign up to your application typically do not exist as part of a team, organization, or workspace.

## B2B: Business to Business

B2B companies sell to other businesses. Some examples include: GitHub, Vercel, Salesforce, Sentry, and Clerk.

In the B2B model, multi-tenant SaaS applications generally leverage organizations (sometimes called teams or workspaces) to manage users and their memberships. This approach allows for control over what resources users have access to across different organizations based on their roles.

Oftentimes such applications will also allow users to create personal accounts that are separate from other organizations. For example, GitHub allows users to create repositories under their own personal account or an organization they are part of.

The user pool for multi-tenant, SaaS applications will generally fall into one of two categories:

1. **Shared user-pool**: the application has a single pool of users. A user can create one account and belong to multiple organizations. The user can have separate roles in each organization.
1. **Isolated user-pool**: each organization has its own pool of users. A user must create a separate account for each organization.

> [!NOTE]
> Clerk supports the **shared user-pool** model for B2B scenarios which will be discussed in this section. The **isolated user-pool** model is more relevant in the Platforms scenario which will be discussed in the next section.

B2B SaaS applications with the following characteristics are well-supported with Clerk:

- A single application deployment that serves multiple business customers (multi-tenant)
- A shared user-pool model where a user can log in with a single account and belong to multiple organizations
- Enabled connections are available to all users (as in, connections cannot be configured at the organization level)
- The application may carry your own branding or some elements of your customer's branding
- The application is served from a single domain (for example: `app.example.com`)

### Integrating organizations with your application

Clerk offers a number of building blocks to help integrate organizations into your application:

- The [`<OrganizationSwitcher />` component](/docs/components/organization/organization-switcher) provides a way for your users to select which organization is active. The [`useOrganizationList()` hook](/docs/custom-flows/organization-switcher) can be used for more control.
- The [`useOrganization()` hook](/docs/hooks/use-organization) can be used to fetch the current, active organization.
- The [`<Protect>` component](/docs/components/protect) enables you to limit who can view certain pages based on their role. Additionally, Clerk exposes a number of helper functions, such as [`auth()`](/docs/references/nextjs/auth), and hooks, such as [`useAuth()`](/docs/hooks/use-auth#how-to-use-the-use-auth-hook), to check the user's authorization throughout your app and API endpoints.

The organization's ID should be stored in your database alongside each resource so that it can be used to filter and query the resources that should be rendered or returned according to the active organization.

## Platforms

> [!NOTE]
> Today, Clerk does not currently support the Platforms scenario. We are working on [Clerk for Platforms](https://feedback.clerk.com/roadmap/3b40265e-d8ae-41b0-a4b3-9c947d460218) to enable developers building platforms to offer their users Clerk's full range of features and customizability.

In the Platforms scenario, businesses can create multiple, isolated applications with their own user pools, branding, security policies, and limits. Some examples in this scenario are e-commerce platforms like Shopify, e-learning platforms, and mortgage lending platforms.

For example, you may be creating an e-learning platform that allows universities to create courses and enroll students. In this case, each customer would be a university who would have their own set of students, professors, and administrators as their users. Additionally, each university would likely have a custom domain (`courses.example.com`) with their branding where their users can authenticate and use the platform.

In the e-learning platform scenario, the users of one university should be completely isolated from another university and each university might have its own set of authentication strategies and security policies.

The following are some of the most commonly requested features for the Platforms scenario (Clerk for Platforms):

- Vanity domains (`customer.example.com`) or a custom domain (`customer.com`) for each of your customers
- Allow your customers to independently customize their branding, including their authentication screens, SMS and email templates
- Isolated user pools such that users from one customer are logically separated from users of another customer
- Independently enforce different limits based on your customer's subscription (for example: limit their number of users they can invite to an organization)
- Enable your customers to independently configure the authentication policies, enabled connections, and MFA policies available to their users

---
title: Next.js Quickstart (App Router)
description: Add authentication and user management to your Next.js app.
---

<TutorialHero
  exampleRepo={[{
      title: "App Router Quickstart Repo",
      link: "https://github.com/clerk/clerk-nextjs-app-quickstart"
    }
  ]}
/>

<Steps>
  ## Create a new Next.js application

  Run the following command to [create a new Next.js application](https://nextjs.org/docs/getting-started/installation):

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm create next-app@latest
    ```

    ```bash {{ filename: 'terminal' }}
    yarn create next-app
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm create next-app
    ```

    ```bash {{ filename: 'terminal' }}
    bun create next-app
    ```
  </CodeBlockTabs>

  ## Install `@clerk/nextjs`

  Run the following command to install the Next.js SDK:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/nextjs
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/nextjs
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/nextjs
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @clerk/nextjs
    ```
  </CodeBlockTabs>

  ## Add `clerkMiddleware()` to your app

  `clerkMiddleware()` grants you access to user authentication state throughout your app.

  1. Create a `middleware.ts` file.
     - If you're using the `/src` directory, create `middleware.ts` in the `/src` directory.
     - If you're not using the `/src` directory, create `middleware.ts` in the root directory.
  1. In your `middleware.ts` file, export the `clerkMiddleware()` helper:

     ```tsx {{ filename: 'middleware.ts' }}
     import { clerkMiddleware } from '@clerk/nextjs/server'

     export default clerkMiddleware()

     export const config = {
       matcher: [
         // Skip Next.js internals and all static files, unless found in search params
         '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
         // Always run for API routes
         '/(api|trpc)(.*)',
       ],
     }
     ```
  1. By default, `clerkMiddleware()` will not protect any routes. All routes are public and you must opt-in to protection for routes. See the [`clerkMiddleware()` reference](/docs/references/nextjs/clerk-middleware) to learn how to require authentication for specific routes.

  ## Add `<ClerkProvider>` and Clerk components to your app

  1. Add the [`<ClerkProvider>`](/docs/components/clerk-provider) component to your app's layout. This component provides Clerk's authentication context to your app.
  1. Copy and paste the following file into your `layout.tsx` file. This creates a header with Clerk's [prebuilt components](/docs/components/overview) to allow users to sign in and out.

  ```tsx {{ filename: 'app/layout.tsx', mark: [[2, 9], 34, [37, 45], 49] }}
  import type { Metadata } from 'next'
  import {
    ClerkProvider,
    SignInButton,
    SignUpButton,
    SignedIn,
    SignedOut,
    UserButton,
  } from '@clerk/nextjs'
  import { Geist, Geist_Mono } from 'next/font/google'
  import './globals.css'

  const geistSans = Geist({
    variable: '--font-geist-sans',
    subsets: ['latin'],
  })

  const geistMono = Geist_Mono({
    variable: '--font-geist-mono',
    subsets: ['latin'],
  })

  export const metadata: Metadata = {
    title: 'Clerk Next.js Quickstart',
    description: 'Generated by create next app',
  }

  export default function RootLayout({
    children,
  }: Readonly<{
    children: React.ReactNode
  }>) {
    return (
      <ClerkProvider>
        <html lang="en">
          <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
            <header className="flex justify-end items-center p-4 gap-4 h-16">
              <SignedOut>
                <SignInButton />
                <SignUpButton />
              </SignedOut>
              <SignedIn>
                <UserButton />
              </SignedIn>
            </header>
            {children}
          </body>
        </html>
      </ClerkProvider>
    )
  }
  ```

  ## Create your first user

  <Include src="_partials/nextjs/create-first-user" />

  ## It's time to build!

  You've added Clerk to your Next.js app . From here, you can continue developing your application.

  To make configuration changes to your Clerk development instance, claim the Clerk keys that were generated for you by selecting **Claim your application** in the bottom right of your app. This will associate the application with your Clerk account.
</Steps>

## Next steps

<Include src="_partials/nextjs/next-steps" />

---
title: Next.js Quickstart (Pages Router)
description: Add authentication and user management to your Next.js app with Clerk.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Create a Next.js application",
      link: "https://nextjs.org/docs/getting-started/installation",
      icon: "nextjs",
    },
  ]}
  exampleRepo={[{
      title: "Pages Router Quickstart Repo",
      link: "https://github.com/clerk/clerk-nextjs-pages-quickstart"
    }
  ]}
/>

<Steps>
  ## Install `@clerk/nextjs`

  The [Clerk Next.js SDK](/docs/references/nextjs/overview) gives you access to prebuilt components, React hooks, and helpers to make user authentication easier.

  Run the following command to install the SDK:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/nextjs
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/nextjs
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/nextjs
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @clerk/nextjs
    ```
  </CodeBlockTabs>

  ## Set your Clerk API keys

  <If condition={experiment.enabled}>
    <ExperimentCreateAccountFromDocsQuickstart params={experiment} />
  </If>

  <If condition={!experiment.enabled}>
    <SignedIn>
      Add the following keys to your `.env` file. These keys can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
    </SignedIn>

    <SignedOut>
      1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys){{ track: 'exp_create_account_nextjs_quickstart' }} page.
      1. In the **Quick Copy** section, copy your Clerk Publishable and Secret Keys.
      1. Paste your keys into your `.env` file.

      The final result should resemble the following:
    </SignedOut>
  </If>

  ```env {{ filename: '.env' }}
  NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
  CLERK_SECRET_KEY={{secret}}
  ```

  ## Add `clerkMiddleware()` to your app

  [`clerkMiddleware()`](/docs/references/nextjs/clerk-middleware) grants you access to user authentication state throughout your app, on any route or page. It also allows you to protect specific routes from unauthenticated users. To add `clerkMiddleware()` to your app, follow these steps:

  1. Create a `middleware.ts` file.
     - If you're using the `/src` directory, create `middleware.ts` in the `/src` directory.
     - If you're not using the `/src` directory, create `middleware.ts` in the root directory alongside `.env`.
  1. In your `middleware.ts` file, export the `clerkMiddleware()` helper:

     ```tsx {{ filename: 'middleware.ts' }}
     import { clerkMiddleware } from '@clerk/nextjs/server'

     export default clerkMiddleware()

     export const config = {
       matcher: [
         // Skip Next.js internals and all static files, unless found in search params
         '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
         // Always run for API routes
         '/(api|trpc)(.*)',
       ],
     }
     ```
  1. By default, `clerkMiddleware()` will not protect any routes. All routes are public and you must opt-in to protection for routes. See the [`clerkMiddleware()` reference](/docs/references/nextjs/clerk-middleware) to learn how to require authentication for specific routes.

  ## Add `<ClerkProvider>` and Clerk components to your app

  <Include src="_partials/clerk-provider/explanation" />

  You can control which content signed-in and signed-out users can see with Clerk's [prebuilt control components](/docs/components/overview#control-components). Create a header using the following components:

  - [`<SignedIn>`](/docs/components/control/signed-in): Children of this component can only be seen while **signed in**.
  - [`<SignedOut>`](/docs/components/control/signed-out): Children of this component can only be seen while **signed out**.
  - [`<UserButton />`](/docs/components/user/user-button): Shows the signed-in user's avatar. Selecting it opens a dropdown menu with account management options.
  - [`<SignInButton />`](/docs/components/unstyled/sign-in-button): An unstyled component that links to the sign-in page. In this example, since no props or [environment variables](/docs/deployments/clerk-environment-variables) are set for the sign-in URL, this component links to the [Account Portal sign-in page](/docs/account-portal/overview#sign-in).

    ```tsx {{ filename: 'pages/_app.tsx', mark: [[7, 15]] }}
    import '@/styles/globals.css'
    import { ClerkProvider, SignInButton, SignedIn, SignedOut, UserButton } from '@clerk/nextjs'
    import type { AppProps } from 'next/app'

    function MyApp({ Component, pageProps }: AppProps) {
      return (
        <ClerkProvider {...pageProps}>
          <SignedOut>
            <SignInButton />
          </SignedOut>
          <SignedIn>
            <UserButton />
          </SignedIn>
          <Component {...pageProps} />
        </ClerkProvider>
      )
    }

    export default MyApp
    ```

  ## Create your first user

  <Include src="_partials/nextjs/create-first-user" />
</Steps>

## Next steps

<Include src="_partials/nextjs/next-steps" />

---
title: Next.js rendering modes and Clerk
description: Learn how Clerk's SDK interacts with Next.js's different rendering modes.
---

By default, Next.js attempts to optimize your application by statically generating pages at build-time that do not depend on data from the request. However, authentication data is inherently dynamic and depends on the request, meaning that it is not available at build-time.

> [!TIP]
> Read more about static and dynamic rendering in the [Next.js documentation](https://nextjs.org/learn/dashboard-app/static-and-dynamic-rendering).

To facilitate Next.js's default behavior, Clerk provides an opt-in approach to accessing authentication data so that you can opt-in specific routes to dynamic rendering, while still using statically rendered pages for others.

The following options are available for accessing authentication data:

- The `auth()` helper can only be used in Server Components, but the data can be passed to Client Components if desired. It opts your entire route into dynamic rendering.
- The `useAuth()` hook can only be used in Client Components. Due to Next.js's default behavior, these components will be statically rendered. However, you can wrap them with `<ClerkProvider dynamic>` to opt them into dynamic rendering.

> [!NOTE]
> The upcoming [Partial Prerendering (PPR)](https://nextjs.org/docs/app/building-your-application/rendering/partial-prerendering) feature in Next.js gives more control over static and dynamic rendering. Wrapping components that access auth data with `<Suspense>` allows pages to be prerendered up to the `<Suspense>` boundaries.

## Access auth data with `auth()`

The [`auth()`](/docs/references/nextjs/auth) helper returns the user's authentication state in Server Components. The data can be passed to Client Components if desired. This is a dynamic API that relies on request-time data so using `auth()` will opt your entire route into dynamic rendering.

```tsx
import { auth } from '@clerk/nextjs/server'

// This page will be dynamically rendered at request time
export default async function Page() {
  const { userId } = await auth()

  // This will be immediately available on first render
  console.log(userId)

  return <p>Hello, {userId}</p>
}
```

## Access auth data with `useAuth()`

`useAuth()` provides authentication data in Client Components. Due to Next.js's default behavior, these components will be statically rendered. If that's fine with you, see the [reference docs](/docs/hooks/use-auth) for more information, like code examples.

However, if you'd like the components that use `useAuth()` to be dynamically rendered, you can wrap them with `<ClerkProvider dynamic>`. If you're using [PPR](https://nextjs.org/docs/app/building-your-application/rendering/partial-prerendering), consider wrapping `<ClerkProvider dynamic>` in `<Suspense>` so that the boundary fallback is included in the prerendered HTML.

> [!WARNING]
> It is not recommended and not optimal to wrap your entire application with `<ClerkProvider dynamic>` as this opts all routes into dynamic rendering, when some routes may be better suited for static rendering. If you're not sure if a route is better suited for static or dynamic rendering, see the [Next.js guide on static and dynamic rendering](https://nextjs.org/learn/dashboard-app/static-and-dynamic-rendering).

<CodeBlockTabs options={["Layout", "Page"]}>
  ```tsx {{ filename: 'app/example/layout.tsx' }}
  import { ClerkProvider } from '@clerk/nextjs'
  import { Suspense } from 'react'

  export default function Layout({ children }: { children: React.ReactNode }) {
    return (
      <Suspense fallback={<Skeleton />}>
        <ClerkProvider dynamic>{children}</ClerkProvider>
      </Suspense>
    )
  }

  function Skeleton() {
    return <div>Loading...</div>
  }
  ```

  ```tsx {{ filename: 'app/example/page.tsx' }}
  'use client'

  import { useAuth } from '@clerk/nextjs'

  export default function Page() {
    const { userId, sessionId, isSignedIn } = useAuth()

    // All of these will be immediately available on first render
    console.log(userId, sessionId, isSignedIn)

    return (
      <div>
        <h1>Test Page</h1>
        <p>User ID: {userId}</p>
      </div>
    )
  }
  ```
</CodeBlockTabs>

---
title: Nuxt Quickstart
description: Add authentication and user management to your Nuxt app with Clerk.
---

<TutorialHero
  exampleRepo={[
    {
      title: "Nuxt Quickstart Repo",
      link: "https://github.com/clerk/clerk-nuxt-quickstart",
    }
  ]}
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Create a Nuxt application",
      link: "https://nuxt.com/docs/getting-started/installation",
      icon: "nuxt"
    }
  ]}
/>

<Steps>
  ## Install `@clerk/nuxt`

  The [Clerk Nuxt SDK](/docs/references/nuxt/overview) gives you access to prebuilt components, Vue composables, and helpers to make user authentication easier.

  Run the following command to install the SDK:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/nuxt
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/nuxt
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/nuxt
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @clerk/nuxt
    ```
  </CodeBlockTabs>

  ## Set your Clerk API keys

  <SignedIn>
    Add the following keys to your `.env` file. These keys can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in your Clerk Dashboard.
  </SignedIn>

  <SignedOut>
    1. In the Clerk Dashboard, navigate to the [**API Keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
    1. In the **Quick Copy** section, copy your Clerk publishable and secret key.
    1. Paste your key into your `.env` file.

    The final result should resemble the following:
  </SignedOut>

  ```env {{ filename: '.env' }}
  NUXT_PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
  NUXT_CLERK_SECRET_KEY={{secret}}
  ```

  ## Configure `nuxt.config.ts`

  To enable Clerk in your Nuxt app, add `@clerk/nuxt` to your modules array in `nuxt.config.ts`. This automatically configures Clerk's middleware and plugins and imports Clerk's components.

  ```ts {{ filename: 'nuxt.config.ts', mark: [2] }}
  export default defineNuxtConfig({
    modules: ['@clerk/nuxt'],
  })
  ```

  ## Create a header with Clerk components

  Nuxt 3 automatically imports and makes all components in the `components/` directory globally available without requiring explicit imports. See the [Nuxt docs](https://nuxt.com/docs/guide/concepts/auto-imports) for details.

  You can control which content signed-in and signed-out users can see with Clerk's [prebuilt control components](/docs/components/overview#control-components).

  The following example creates a header using the following components:

  - [`<SignedIn>`](/docs/components/control/signed-in): Children of this component can only be seen while **signed in**.
  - [`<SignedOut>`](/docs/components/control/signed-out): Children of this component can only be seen while **signed out**.
  - [`<UserButton />`](/docs/components/user/user-button): Shows the signed-in user's avatar. Selecting it opens a dropdown menu with account management options.
  - [`<SignInButton />`](/docs/components/unstyled/sign-in-button): An unstyled component that links to the sign-in page or displays the sign-in modal. In this example, since no props or [environment variables](/docs/deployments/clerk-environment-variables) are set for the sign-in URL, this component links to the [Account Portal sign-in page](/docs/account-portal/overview#sign-in).

  ```vue {{ filename: 'app.vue', mark: [2, [6, 13]] }}
  <script setup lang="ts">
  // Components are automatically imported
  </script>

  <template>
    <header>
      <SignedOut>
        <SignInButton />
      </SignedOut>
      <SignedIn>
        <UserButton />
      </SignedIn>
    </header>

    <main>
      <NuxtPage />
    </main>
  </template>
  ```

  ## Create your first user

  Run your project with the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun dev
    ```
  </CodeBlockTabs>

  Visit your app's homepage at [`http://localhost:3000`](http://localhost:3000). Sign up to create your first user.
</Steps>

## More resources

Learn more about Clerk components, how to customize them, and how to use Clerk's client-side helpers using the following guides.

<Cards>
  - [Protect API routes using clerkMiddleware()](/docs/references/nuxt/clerk-middleware)
  - Learn how to protect specific API routes from unauthenticated users.

  ---

  - [Read session and user data](/docs/references/nuxt/read-session-data)
  - Learn how to use Clerk's composables and helpers to access the active session and user data in your Nuxt app.

  ---

  - [Client-side helpers](/docs/references/nuxt/overview#client-side-helpers)
  - Learn more about Nuxt client-side helpers and how to use them.

  ---

  - [Clerk + Nuxt Quickstart Repo](https://github.com/clerk/clerk-nuxt-quickstart)
  - The official companion repo for Clerk's Nuxt Quickstart.
</Cards>

---
title: OKX Wallet
description: Learn how to set up Web3 authentication with OKX Wallet.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk application is required.",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
  ]}
/>

Enabling [OKX Wallet](https://www.okx.com/web3/rewritethesystem) as a Web3 provider allows your users to sign in and up to your Clerk application with their OKX Wallet.

## Enable OKX Wallet as a Web3 provider

1. In the Clerk Dashboard, navigate to the [**Web3**](https://dashboard.clerk.com/last-active?path=user-authentication/web3) page.
1. From the list of web3 providers, enable **OKX Wallet**.

## Test authentication

The simplest way to test authentication is to visit your Clerk application's [Account Portal](/docs/account-portal/overview), which is available for all Clerk applications out-of-the-box.

1. In the Clerk Dashboard, navigate to the [**Account Portal**](https://dashboard.clerk.com/last-active?path=account-portal) page.
1. Next to the **Sign-in** URL, select **Visit**. The URL should resemble:
   - **For development**  `https://your-domain.accounts.dev/sign-in`
   - **For production**  `https://accounts.your-domain.com/sign-in`
1. On the sign-in page, you should see **OKX Wallet** as an option. Use it to sign in.

## Collect additional user information during sign-up (optional)

Web3 applications typically use a hexadecimal wallet address to identify users, which offers a high level of privacy. However, when bridging the gap between Web3 and Web2, it's often necessary to gather human-readable information about the user, such as their email address, phone number, or a username.

To collect additional information about your user during sign-up:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. On this page, enable the attributes you want to collect from your user during sign-up.
1. To set an attribute as required, select the settings icon next to the enabled attribute. Clerk will automatically prompt the user for this information after authenticating with OKX Wallet.

## Connect OKX Wallet to existing account

Users can connect their OKX Wallet to their account at any time through their user profile page. You can configure your application to use the [Account Portal user profile page](/docs/account-portal/overview#user-profile) or the prebuilt [`<UserProfile />`](/docs/components/user/user-profile) component.

---
title: Organization metadata
description: Organization objects hold a set of metadata that can be used internally to store arbitrary information.
---

Organization metadata allows you to store information about an organization that is not part of the standard fields, such as custom attributes that are specific to your application.

There are two types of metadata: **public** and **private**.

- Both **public** and **private** metadata are set and can be accessed from the [Backend API](/docs/reference/backend-api){{ target: '_blank' }}.
- Only **public** metadata can be accessed from the [Frontend API](/docs/reference/frontend-api/){{ target: '_blank' }}.

Both the `Organization` and `Organization Membership` objects have the metadata fields: `publicMetadata` and `privateMetadata`.

- Use the `publicMetadata` property if you need to set some metadata from your backend and have them displayed as read-only on the frontend.
- Use the `privateMetadata` property if the custom attributes contain sensitive information that should not be displayed on the frontend.

## Set organization metadata

There are two ways to set organization metadata:

- In the Clerk Dashboard
- Using the [Backend SDK](/docs/references/backend/overview)

### In the Clerk Dashboard

1. In the Clerk Dashboard, navigate to the [**Organizations**](https://dashboard.clerk.com/last-active?path=organizations) page.
1. Select the organization you want to update.
1. In the **Organization metadata** section, select **Edit** next to the metadata you want to update.

### Using the Backend SDK

To ease the flow of setting metadata, Clerk provides the `updateOrganizationMetadata()` and `updateOrganizationMembershipMetadata()` methods from the [Backend SDK](/docs/references/backend/overview), which is a wrapper around the [Backend API](/docs/reference/backend-api){{ target: '_blank' }}.

> [!WARNING]
> Metadata is limited to **8kb** maximum.

---
title: Organization workspaces in the Clerk Dashboard
description: Use the Clerk Dashboard to create and invite collaborators to an organization workspace, and to transfer your apps between workspaces.
---

In the Clerk Dashboard, there are two types of workspaces:

- **Personal account**: A personal account/workspace is a user's unique, individual space, independent of any organization.
- **Organization workspace**: An organization workspace is owned and managed by an organization, which can have multiple members, also known as collaborators. The organization workspace that a user is currently viewing is called the [active organization](/docs/organizations/overview#active-organization).

This guide will walk you through how to use the Clerk Dashboard to create an organization workspace, invite collaborators, and transfer your apps between workspaces.

## Create an organization workspace

1. In the top-left of the [Clerk Dashboard](https://dashboard.clerk.com), select the workspace dropdown.
1. Select **Create organization**. A modal will open.
1. Complete the form. Organization slugs are unique across all instances, so common naming conventions might already be in use by another instance.
1. Select **Create organization**. The newly created organization will be set the active organization.

## Invite collaborators to your organization workspace

1. In the top-left of the [Clerk Dashboard](https://dashboard.clerk.com), select the workspace dropdown.
1. Select **Manage**. A modal will open showing the organization's information.
1. In the left nav, select **Members**.
1. Select **Invite**.
1. In the **Invite new members** form, enter the email of the user you want to invite and select the role to assign.
1. Select **Send invitations**.

## Transfer ownership of an application

1. In the top-left of the [Clerk Dashboard](https://dashboard.clerk.com), select the workspace dropdown.
1. Select the workspace that has the application you want to transfer.
1. In the navigation sidenav, select [**Settings**](https://dashboard.clerk.com/last-active?path=settings).
1. Select **Transfer ownership**. A modal will open.
1. Complete the form and select **Transfer ownership**. The page will redirect to the **Applications** page and show the transferred application.

### Transfer to an org without billing information

**An application with an existing paid subscription can only be transferred to an organization with active billing information**. You can set up billing information on the receiving organization without being charged.

To set up a payment method without being charged:

1. In the top-left of the [Clerk Dashboard](https://dashboard.clerk.com), select the workspace dropdown.
1. Select the workspace that you want to transfer the application to.
1. Select the workspace dropdown again, and select **Manage**.
1. In the sidenav, select **Billing**, then select **Upgrade to unlimited members**.
1. Add your billing information. **You will not be charged immediately**. Doing this just ensures billing information is added to the organization.
1. Once that billing information is added, you will be able to transfer your Clerk app to the receiving organization.

> [!NOTE]
> This is a temporary solution for this issue. Clerk is actively working to improve this process.

---
title: Organization-level enterprise SSO
description: Learn how to set up and manage enterprise SSO for organizations.
---

Clerk supports enabling enterprise SSO connections for specific organizations. When users sign up or sign in using an organization's enterprise connection, they're automatically added as members of that organization and assigned the [default role](/docs/organizations/roles-permissions#default-roles), which can be either `member` or `admin`.

## Add an enterprise SSO connection for an organization

Clerk supports enterprise SSO via [SAML](/docs/authentication/enterprise-connections/overview#saml) or via the [OpenID Connect (OIDC) protocol](/docs/authentication/enterprise-connections/overview#oidc), either through EASIE or by integrating with any OIDC-compatible provider.

To add an enterprise SSO connection for an organization, follow the appropriate guide based on the platform you want to use, such as the [Google SAML guide](/docs/authentication/enterprise-connections/saml/google). When configuring the connection in the Clerk Dashboard, there will be an option to select the **Organization** for which you want to enable this connection. If you don't select an organization, the connection will be added for your entire application.

> [!WARNING]
> A domain used for enterprise SSO can't be used as a [verified domain](/docs/organizations/verified-domains) for the same organization.

## Onboarding flows

The two common onboarding flows for organizations with enterprise SSO are to either create an organization first or to have users initiate the setup themselves.

#### Organization created first (top-down approach)

This flow is common for enterprise sales where the relationship is established before users access the application.

1. [Create an organization](/docs/organizations/overview#create-an-organization) for your customer through the Clerk Dashboard.
1. Collaborate with the customer's IT administrator to obtain the necessary configuration details.
1. Configure the enterprise SSO connection for the organization.
1. Invite users to the organization, who can then sign in using enterprise SSO.

#### User-initiated setup (bottom-up approach)

This flow is common when individual users try the product before company-wide adoption.

1. An end user signs up to evaluate your application, starting with an individual account.
1. After adopting the application, the user [creates an organization](/docs/organizations/overview#create-an-organization) for their company.
1. Configure enterprise SSO for the organization through the Clerk Dashboard.
1. All subsequent users from that organization can now sign in using enterprise SSO.

## Enforce enterprise SSO by domain

Enterprise SSO connections are enforced on a per-domain basis in organizations, enabling flexible access management:

- Configure enterprise SSO for your primary domain (e.g., `company.com`) to enforce enterprise SSO authentication for employees.
- Add additional domains without enterprise SSO for external collaborators (e.g., contractors, consultants).
- Each domain in an organization can have different authentication requirements.

## Manage memberships

### Remove a member from your organization

When a user is tied to an organization through their enterprise connection, they cannot leave the organization themselves, but they can be removed either in the Clerk Dashboard, using [Clerk's Backend API](/docs/reference/backend-api/tag/Organization-Memberships#operation/DeleteOrganizationMembership) endpoint, or by another organization member with the [manage members permission](/docs/organizations/roles-permissions#system-permissions) (`org:sys_memberships:manage`). However, the user will be added back to the organization on next sign-in, unless they are removed from the IdP or the enterprise connection is no longer associated with the organization.

## Update an organization from an existing enterprise connection

When transitioning an enterprise connection to a new organization, existing members will remain part of the original organization. However, they will automatically join the new organization upon their next sign-in.

To remove members from the original organization, you have two options: utilize [Clerk's Backend API](/docs/reference/backend-api/tag/Organization-Memberships#operation/DeleteOrganizationMembership) or manage memberships directly through the Clerk Dashboard.

---
title: Organizations
description: Learn about how to create and manage Clerk organizations and their members.
---

Organizations are a flexible and scalable way to manage users and their access to resources within your Clerk application. With organizations, you can assign specific roles and permissions to users, making them useful for managing projects, coordinating teams, or facilitating partnerships.

> [!NOTE]
> To explore organizations in Clerk, see the demo repo:
> [https://github.com/clerk/organizations-demo](https://github.com/clerk/organizations-demo)

## Enable organizations in your application

Organizations are disabled by default.

To enable organizations:

1. In the Clerk Dashboard, navigate to the [**Organizations Settings**](https://dashboard.clerk.com/last-active?path=organizations-settings) page.
1. Select **Enable Organizations**.

Once organizations are enabled, you will be presented with the default settings, roles, and permissions that are applied to all organizations in that application instance. The following sections will explain these settings in more detail.

## Organization management

As the application owner, you have control over all of the organizations within your application - both those created by you and those created by your users. You can create, update, and delete organizations, as well as manage their members and settings.

1. In the top in the Clerk Dashboard, select [**Organizations**](https://dashboard.clerk.com/last-active?path=organizations). Here, you can view and manage all organizations in your application.
1. Select a specific organization to view its details, members, and settings. Here, you can update the organization's name, slug, and logo. You can also set the organization's [membership limit](#membership-limit) and public and private metadata.

For managing organizations in your application, Clerk provides a set of prebuilt components:

- [`<CreateOrganization />`](/docs/components/organization/create-organization) - A form for a user to create a new organization.
- [`<OrganizationProfile />`](/docs/components/organization/organization-profile) - A profile page for the user's currently active organization.
- [`<OrganizationList />`](/docs/components/organization/organization-list) - A list of organizations that a user is a member of.
- [`<OrganizationSwitcher />`](/docs/components/organization/organization-switcher) - A dropdown menu that handles all organization flows. It allows a user to create an organization, switch between their personal account and their organization account(s), and view their organization's profile, which allows them to manage the organization's settings, invitations, and current members.

If the prebuilt components don't meet your specific needs or if you require more control over the logic, you can rebuild and customize the existing Clerk flows using the Clerk API. See the [custom flows](/docs/custom-flows/overview) for more information.

## Active organization

When a user is a member of an organization, they can switch between their personal workspace and an organization workspace. The organization workspace that a user is currently viewing is called the **active organization**. The active organization determines which organization-specific data the user can access and which role and related permissions they have within the organization.

By default, when a user initially signs in to a Clerk-powered application, they are signed in to their personal workspace and no active organization is set. Even if they are a member of only one organization, they must explicitly set it as active or the application can have logic to set this automatically.

The easiest way to allow users to set an organization as active is to use the [`<OrganizationSwitcher />`](/docs/components/organization/organization-switcher) component.

You can also use the `setActive()` method, which is returned by the [`useOrganizationList()`](/docs/hooks/use-organization-list) hook. If you aren't using hooks, you can access the `setActive()` method from the [`Clerk`](/docs/references/javascript/clerk#set-active) object.

If you would like to hide personal workspaces and require users to always have an organization set as active, see the [dedicated guide](/docs/organizations/force-organizations).

## Monthly Active Organization (MAO)

The number of organizations you can have in a single Clerk application depends on your [Clerk plan](/pricing){{ target: '_blank' }} and the type of instance (development or production), and is measured by Monthly Active Organizations (MAOs). An MAO is an organization with at least two users that have signed in that month, at least one of which must have interacted with the organization during the current billing cycle.

With the Free plan:

- In development instances, you can have _up to_ 50 MAOs in a single Clerk application. Each MAO can have _up to_ 5 members.
- In production instances, you can have up to 100 MAOs in a single Clerk application. Each MAO can have up to 5 members.

With the Pro plan:

- In development instances, you can have an unlimited number of MAOs in a single Clerk application _for free_. Each MAO can have an unlimited number of members.
- In production instances, you can have up to 100 MAOs in a single Clerk application _for free_. Each MAO after the first 100 costs $1.00 per month. Each MAO can have an unlimited number of members.

For more information on pricing, see the [pricing page](/pricing){{ target: '_blank' }}.

If you need more organizations or custom pricing, contact the [sales team](/contact/sales){{ target: '_blank' }} to upgrade to the Enterprise plan.

## Create an organization

There are two ways to create an organization:

- [In the Clerk Dashboard](#create-an-organization-in-the-clerk-dashboard)
- [In your application](#create-an-organization-in-your-application)

How many organizations you can create depends on how many [MAOs](#monthly-active-organization-mao) you have.

### Create an organization in the Clerk Dashboard

To create an organization in the Clerk Dashboard:

1. In the top in the Clerk Dashboard, select [**Organizations**](https://dashboard.clerk.com/last-active?path=organizations).
1. Select the **Create Organization** button.
1. Enter the organization's name. Optionally, upload the organization's logo, enter the organization's slug, and select the organization's owner. The slug is a unique identifier for the organization that is used in URLs, such as `example-name`.

### Create an organization in your application

By default, users have the permission to create organizations within your application. To configure this permission for all users:

1. In the Clerk Dashboard, navigate to the [**Organizations Settings**](https://dashboard.clerk.com/last-active?path=organizations-settings) page.
1. At the bottom of the page, in the **Limit creation** section, enable/disable **Allow new users to create organizations**. You can also configure the number of organizations that can be created by each user. By default, each user can create an unlimited number of organizations.

If you want to only configure this permission for a specific user, you can override it on a per-user basis on the user's profile page in the Clerk Dashboard:

1. In the top in the Clerk Dashboard, select [**Users**](https://dashboard.clerk.com/last-active?path=users).
1. Select the user you want to update.
1. In the **User permissions** section, enable/disable **Allow user to create organizations**.

When a user creates an organization, they become the organization's admin. As the organization's admin, they have full control over the organization, including the ability to update the organization's settings, invite users to join the organization, and manage the organization's members.

A single user within one of your applications can create _up to_ 100 organizations in that application. If you need users to be able to create more organizations than this, [contact support](/contact/support){{ target: '_blank' }} to have the limit raised.

The easiest way to allow users to create organizations is to use the [`<CreateOrganization />`](/docs/components/organization/create-organization) and/or [`<OrganizationSwitcher />`](/docs/components/organization/organization-switcher) components. The `<OrganizationSwitcher />` component is more comprehensive, as it handles all organization flows.

## Roles and permissions

Roles determine a user's level of access and permissions within an organization. Learn more about [how roles and permissions work and how to create your own with Clerk](/docs/organizations/roles-permissions).

## Membership limit

There is no limit to the number of organizations a user can be a member of.

However, there is a limit to how many members total can be in a single organization. By default, the membership limit is set to 5 members. To change this limit, scroll to the **Default membership limit** section and update the membership limit.

If you are on the Free plan, you can update the membership limit to a maximum of 5 members.

If you have the Pro plan, you can set the membership limit to unlimited.

You can also change this limit on a per-organization basis:

1. In the top in the Clerk Dashboard, select [**Organizations**](https://dashboard.clerk.com/last-active?path=organizations).
1. Select the organization you want to update.
1. In the **Membership limit** section, update the membership limit. Note that this will not apply to organizations that already exist.

## Default ability to delete

By default, organizations are deletable. Any member with the "Delete organization" permission can delete an organization. To prevent organizations from being deleted, you can disable the ability to delete organizations by following these steps:

1. In the Clerk Dashboard, navigate to the [**Organizations Settings**](https://dashboard.clerk.com/last-active?path=organizations-settings) page.
1. Scroll to the **Default ability to delete** section and uncheck the option. Note that this will not apply to organizations that already exist.

## Verified domains

Verified domains can be used to streamline enrollment into an organization. For example, if the domain `@clerk.com` is added to an organization, any user with a `@clerk.com` email address can be automatically invited or be suggested to join this organization. This feature is useful for organizations that want to restrict membership to users with specific email domains. See the [guide on verified domains](/docs/organizations/verified-domains) for more information.

## Organization invitations

Organization invitations are a way to invite users to join an organization. See the [guide on organization invitations](/docs/organizations/invitations) for more information.

## Manage SSO

Single Sign-On (SSO) can be configured at the organization level, allowing organizations to use their own Identity Provider (IdP) for authentication. When configured:

- Users can sign in through their organization's configured IdP
- Users are automatically added as members of the organization upon successful authentication
- Organizations can maintain their existing identity management workflows
- SAML 2.0 and OIDC protocols are supported

For instructions on how to set up and manage SSO for your organizations, see the [dedicated guide](/docs/organizations/manage-sso).

---
title: OrganizationSuggestion
description: An interface representing an organization suggestion.
---

An interface representing an organization suggestion.

<Properties>
  - `id`
  - `string`

  The ID of the organization suggestion.

  ---

  - `publicOrganizationData`
  - `{ hasImage: boolean; imageUrl: string; name: string; id: string; slug: string | null; }`

  The public data of the organization.

  - `hasImage`: Whether the organization has an image.
  - `imageUrl`: Holds the organization logo. Compatible with Clerk's [Image Optimization](/docs/guides/image-optimization).
  - `name`: The name of the organization.
  - `id`: The ID of the organization.
  - `slug`: The slug of the organization.

  ---

  - `status`
  - `'pending' | 'accepted'`

  The status of the organization suggestion.

  ---

  - `createdAt`
  - `Date`

  The date and time when the organization suggestion was created.

  ---

  - `updatedAt`
  - `Date`

  The date and time when the organization suggestion was last updated.
</Properties>

## `accept()`

Accepts the organization suggestion. Returns the accepted `OrganizationSuggestion`.

```ts
function accept(): Promise<OrganizationSuggestionResource>
```

---
title: Override Clerk interfaces with custom types
description: Learn about the interfaces that you can use to define custom types for your application.
---

Clerk provides TypeScript interfaces that you can use to define custom types for your application. Custom types provide auto-complete and prevent TypeScript errors. You can define custom types for the following:

- `ClerkAuthorization`
- `CustomJwtSessionClaims`
- `OrganizationPublicMetadata`
- `OrganizationInvitationPublicMetadata`
- `OrganizationMembershipPublicMetadata`
- `SignUpUnsafeMetadata`
- `UserPublicMetadata`
- `UserPrivateMetadata`
- `UserUnsafeMetadata`

## Example: custom JWT claims

To override an interface, you must define a global type, as shown in the following example:

1. In your application's root folder, add a `types` directory.
1. Inside of the `types` directory, add a `globals.d.ts` file.
1. Create the `CustomJwtSessionClaims` interface and declare it globally.
1. Add the custom claims to the `CustomJwtSessionClaims` interface.

```ts {{ filename: 'types/globals.d.ts' }}
export {}

declare global {
  interface CustomJwtSessionClaims {
    firstName?: string
    primaryEmail?: string
    metadata: {
      onboardingComplete?: boolean
    }
  }
}
```

## Example: custom roles and permissions

When defining custom types for roles and permissions:

- Custom permissions are merged with [system permissions](/docs/organizations/roles-permissions#system-permissions)
- Custom roles completely replace default roles (`org:admin` and `org:member`)

```tsx {{ filename: 'types/globals.d.ts' }}
export {}

declare global {
  interface ClerkAuthorization {
    permission: 'org:quiz:create' | 'org:quiz:grade' | 'org:quiz:read' | 'org:quiz:fill'
    role: 'org:super_admin' | 'org:teacher' | 'org:student'
  }
}
```

---
title: Passkey errors
description: An index of Clerk errors related to passkeys.
type: reference
---

An index of Clerk errors related to passkeys.

## `passkey_not_supported`

Passkeys are not supported on this device.

## `passkeys_pa_not_supported`

Registration requires a platform authenticator but the device does not support it.

## `passkey_invalid_rpID_or_domain`

The relying party ID or domain associated with the passkey does not match the relying party ID or domain of the app the user is signing into.

## `passkey_already_exists`

A passkey is already registered with this device.

## `passkey_operation_aborted`

Browser canceled the passkey operation.

## `passkey_retrieval_cancelled`

Passkey verification was cancelled or timed out.

## `passkey_retrieval_failed`

Browser failed to get the passkey credential.

## `passkey_registration_cancelled`

Passkey registration was cancelled or timed out.

## `passkey_registration_failed`

Browser failed to register the passkey credential.

---
title: Password protection and rules
description: Clerk refers to the National Institute of Standards and Technology (NIST) guidelines to determine the character rules for passwords.
---

## Password rules

Clerk refers to the National Institute of Standards and Technology (NIST) guidelines to determine the character rules for passwords:

> [!NOTE]
> Verifiers SHALL require subscriber-chosen memorized secrets to be at least 8 characters in length. Verifiers SHOULD permit subscriber-chosen memorized secrets at least 64 characters in length. All printing ASCII [RFC 20](https://datatracker.ietf.org/doc/html/rfc20) characters as well as the space character SHOULD be acceptable in memorized secrets. Unicode [ISO/IEC 10646](https://en.wikipedia.org/wiki/Universal_Coded_Character_Set) characters SHOULD be accepted as well. To make allowances for likely mistyping, verifiers MAY replace multiple consecutive space characters with a single space character prior to verification, provided that the result is at least 8 characters in length. Truncation of the secret SHALL NOT be performed. For purposes of the above length requirements, each Unicode code point SHALL be counted as a single character.

[NIST Special Publication 800-63B](https://pages.nist.gov/800-63-3/sp800-63b.html#sec5)

While these rules might seem lax independently, NIST's additional compromised password protection guidelines do more to prevent the use of unsafe passwords.

Also, bear in mind, that passwords are not a requirement for using Clerk. Applications can be configured to use a passwordless strategy that relies on your users being sent one-time passwords instead.

## Reject compromised passwords

Clerk refers to the National Institute of Standards and Technology (NIST) guidelines to determine its handling of compromised passwords:

When processing requests to establish and change memorized secrets, verifiers SHALL compare the prospective secrets against a list that contains values known to be commonly-used, expected, or compromised. For example, the list MAY include, but is not limited to: [NIST Special Publication 800-63B](https://pages.nist.gov/800-63-3/sp800-63b.html#sec5)

- Passwords obtained from previous breach corpuses.

Specifically, Clerk contracts with [HaveIBeenPwned](https://haveibeenpwned.com/) to compare prospective passwords against its corpus of over 10 billion compromised credentials.

Rejection of compromised passwords is enabled by default for sign-up and password changes. It is disabled by default for sign-in - learn more in the [Reject compromised passwords on sign-in](/docs/security/password-protection#reject-compromised-passwords-on-sign-in) section.

To configure this feature:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. In the **Authentication strategies** section, next to **Password**, select the settings icon.
1. You can enable or disable **Reject compromised passwords on sign-up or password change, powered by HaveIBeenPwned**.
1. You can also enable or disable **Reject compromised passwords also on sign-in**. Learn more about this feature in the following section.

### Reject compromised passwords on sign-in

Clerk also offers the ability to check for compromised passwords on sign-in.
When the user provides the correct password, if it has been found in online breach data, they will be prompted to reset their password.

This is useful for blocking password sign-ins in the case that:

- The password has recently been added to the compromised password database
- The user was able to set a compromised password because protection was off at the time
- The user was migrated to Clerk along with their existing password digest

> [!NOTE]
> Password reset for compromised passwords uses the same flow as "forgot password". The user will need to authenticate first via an OTP code sent to their email or phone and only then they will be able to set a new  more secure  password.

#### Limitations

- Before enabling rejection of compromised passwords on sign-in, ensure your app has support for the password reset flow. You can do so by using Clerk components or [implementing a custom flow](/docs/custom-flows/forgot-password#prompting-users-to-reset-compromised-passwords-during-sign-in).
- If the user has no way of resetting their password  such as when your application does not require an email, phone number, or other communication method for sign-up  Clerk will not reject compromised passwords on sign-in.

## Password strength

Clerk uses [zxcvbn-ts](https://zxcvbn-ts.github.io/zxcvbn/) for estimating the strength of passwords and leverages the [Open Web Application Security Project (OWASP) guidelines](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html) to determine its handling of password strength:

> [!NOTE]
> OWASP recommends using a password strength estimation library like zxcvbn to evaluate the strength of passwords. This can help identify weak passwords and prevent their use.

For users that set an average/weak password that complies with your organization's policies but could be stronger - Clerk also provides a gentle recommendation to use a stronger password.

> [!NOTE]
> OWASP recommends providing feedback to users on the strength of their password and offering suggestions for improvement. This can help users create stronger passwords and improve the overall security of the application.

---
title: Philosophy
description: The guiding principle for building a Clerk SDK.
---

Clerk believes that truly optimal developer experience can only be achieved by building SDKs independently for each framework. Each framework has nuanced patterns that should be embraced to avoid mismatched implementations.

This is why Clerk offers SDKs not only for React, but also for Next.js, Remix, Astro, and many other frameworks.  Each framework has unique APIs, capabilities, and conventions, and dedicated SDKs provide better integration than a general-purpose SDK.

Heres a non-exhaustive list of things to take into consideration to deliver a great developer experience.

> [!IMPORTANT]
> **Optimize for the users developer experience.** These principles, conventions, and instructions below are not strict rules. Use your best judgement to adjust as needed. Adhere to what makes most sense for the programming language or framework.

## Performance

Developers and marketers alike care about their website's [performance scoring](https://developer.chrome.com/docs/lighthouse/performance/performance-scoring). Ensure efficient loading of your SDK and reduce bundle size & dependencies. Less dependencies also mean less maintenance and security concerns.

## Enable best practices

For your SDK, follow the framework's or language's best practices and consider using their specialized patterns over generalized ones (e.g. special script loading). For your users, provide APIs to leverage those best practices.

## Documentation

Spend time writing an exhaustive, yet organized `README` that enables your users to get started with your SDK. If you want to go above and beyond, create your own documentation site (recommended: [Starlight](https://starlight.astro.build/)). Provide examples on how to use your SDK, e.g. with a separate example repository.

## Convenience

Make using your SDK as convenient as possible for its users. For example, provide prebuilt components that users can import into their project. If the SDK can handle something under the hood which otherwise would require an action by the user, do it. Mimic the ease of use of Clerk's own SDKs.

## Compatibility

Ensure compatibility with the upstream framework or language. Have reasonable backward compatibility.

## API surface

Keep the API surface small. Most often youll only need to expose the options for the underlying Clerk SDKs and pass those through.

## Testing

Add End-to-End tests to regularly test hot paths of your SDK. Functionality like sign-in, sign-up, and other UI components have high priority. Checkout the [testing guide](https://clerk.com/docs/testing/overview) to learn which testing utilities are available and how to use Clerk's Testing Tokens to bypass bot detection.

---
title: Primitives
description: Example implementations using Clerk Elements primitives.
---

## OTP Input

The following example demonstrates how to use the `otp` input type with the render prop to create a custom OTP input field for phone and email codes, that is animated with Framer Motion.

<CodeBlockDemo
  priority
  demos={[
  {
    key: 'otp-input',
    demo: '/demo/elements/sign-in/otp-input',
    style: {
      height: `${500 / 16}rem`,
      backgroundColor: 'rgb(244 244 245)'
    }
  }
]}
>
  ```tsx {{ title: 'OTP Input', collapsible: true }}
  <Clerk.Input
    type="otp"
    required
    className="flex justify-center gap-1"
    render={({ value, status }) => (
      <div
        data-status={status}
        className="relative h-9 w-8 rounded-md bg-white ring-1 ring-inset ring-zinc-300 data-[status=selected]:bg-sky-400/10 data-[status=selected]:shadow-[0_0_8px_2px_theme(colors.sky.400/30%)] data-[status=selected]:ring-sky-400"
      >
        <AnimatePresence>
          {value && (
            <motion.span
              initial={{ opacity: 0, scale: 0.75 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.75 }}
              className="absolute inset-0 flex items-center justify-center text-zinc-950"
            >
              {value}
            </motion.span>
          )}
          {value}
        </AnimatePresence>
        {status === 'cursor' && (
          <motion.div
            layoutId="otp-input-focus"
            transition={{ ease: [0.2, 0.4, 0, 1], duration: 0.2 }}
            className="absolute inset-0 z-10 rounded-[inherit] border border-sky-400 bg-sky-400/10 shadow-[0_0_8px_2px_theme(colors.sky.400/30%)]"
          />
        )}
      </div>
    )}
  />
  ```
</CodeBlockDemo>

---
title: Programmatically lock and unlock user accounts
description: Lock users to prevent them from signing in based on your own custom criteria.
---

## Unlocking a user programmatically

You can programmatically unlock a user using the [`UnlockUser`](/docs/reference/backend-api/tag/Users#operation/LockUser){{ target: '_blank' }} Backend API endpoint.

### Use cases

#### "Unlock button"

Your custom sign-in page could expose a button or link that allows the user to request an unlock token when they are locked out of their account.

- Your app should be able to generate a random unlock token and associate it with the user.
- The unlock token can be sent to the user via email or SMS.
- After successful entry of the unlock token, your app's backend can issue an unlock request to the Clerk Backend API.

#### Send an unlock request to an admin

If your app supports users submitting admin requests, it could expose a way of requesting an admin unlock.

- A request for unlock could arrive in your app's admin dashboard.
- If an admin reviews the request and decides to grant access back to the user, they can request an unlock from your app's backend, which should in turn call the Clerk Backend API.

## Lock a user programmatically

You can programmatically lock a user using the [`LockUser`](/docs/reference/backend-api/tag/Users#operation/LockUser){{ target: '_blank' }} Backend API endpoint. Keep in mind that Clerk will still lock the user based on failed verification attempts.

### Use cases

- If a user is violating your app's code of conduct.

---
title: Protect email link sign-ins and sign-ups
description: Learn how to protect email link sign-ins and sign-ups.
---

Clerk provides an additional setting to improve security for email link sign-ins and sign-ups. When this setting is enabled, only email links opened on the same device and browser that a sign-in or sign-up was initiated on will successfully authenticate the user.

Enabling this protection means that the following scenario cannot happen:

1. A malicious actor knows the email of a user and requests an email link to sign-in or sign-up.
1. The user opens the email and visits the link, or the user's email provider follows links in emails for phishing or spam protection.
1. The malicious actor is able to gain access to the user's account because the email link has been opened successfully.

Disabling this protection means that your users are vulnerable to the scenario above, but they will be able to sign-in or sign-up with email link across devices and browsers. For example, initiating an email link sign in on a laptop and then opening the email link on a phone to sign in successfully.

With same device and browser protection on, users will see the following warning if an email link for sign-in or sign-up was opened on a different device or browser:

![Error message displayed if email link is opened in a different device or browser if email link same device/browser protection is enabled](/docs/images/security/email-link_require-same-client.webp)

To configure this security setting, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page in the Clerk Dashboard. This protection can be enabled for **sign-ins** and **sign-ups** in two ways.

Contact information section:

1. In the **Contact information** section, next to **Email address**, select the settings icon.
1. Under the **Email verification link** checkbox, ensure **Require the same device and browser** is enabled.

Authentication strategies section:

1. In the **Authentication strategies** section, next to **Email verification link**, select the settings icon.
1. Ensure **Require the same device and browser** is checked.

---
title: Protect pages in your Nuxt app with Clerk
description: Learn how to protect the pages in your Clerk + Nuxt application.
---

There are two ways to protect pages in your Nuxt application:

- [Use the `useAuth()` composable](#use-use-auth)
- [Use `createRouteMatcher()`](#use-create-route-matcher)

> [!NOTE]
> To learn how to protect API routes, see the [dedicated guide](/docs/references/nuxt/clerk-middleware#protect-api-routes).

## Use `useAuth()`

<Include src="_partials/vue-nuxt/use-auth" />

## Use `createRouteMatcher()`

The `createRouteMatcher()` is a Clerk helper function that allows you to protect multiple routes in your Nuxt application. It accepts an array of route patterns and checks if the route the user is trying to visit matches one of the patterns passed to it.

The `createRouteMatcher()` helper returns a function that, when called with the `to` route object from Nuxt's [`defineNuxtRouteMiddleware()`](https://nuxt.com/docs/api/utils/define-nuxt-route-middleware), will return `true` if the user is trying to access a route that matches one of the patterns provided.

### Configure route middleware

In your `middleware/` directory, create a file named `auth.global.ts` with the following code. This middleware:

- Uses the `userId` returned by the [`useAuth()`](/docs/references/vue/use-auth){{ target: '_blank' }} composable to check if the user is signed in
- Uses the `createRouteMatcher()` helper to check if the user is trying to access a protected route.

If they aren't signed in and are trying to access a protected route, they are redirected to the sign-in page.

```ts {{ filename: 'middleware/auth.global.ts' }}
const isProtectedRoute = createRouteMatcher(['/dashboard(.*)', '/forum(.*)'])

export default defineNuxtRouteMiddleware((to) => {
  const { userId } = useAuth()

  // If the user is not signed in, they aren't allowed to access
  // the protected route and are redirected to the sign-in page
  if (!userId.value && isProtectedRoute(to)) {
    return navigateTo('/sign-in')
  }
})
```

---
title: Proxying the Clerk Frontend API
description: Learn how to proxy the Clerk Frontend API through your domain.
---

> [!WARNING]
> This guide is for users who need to proxy the Frontend API for deployment. If your application already uses a CNAME subdomain that is required for deploying with Clerk, then you must proxy the Frontend API using a different subdomain. Refer to the [deployment guide](/docs/deployments/overview#dns-records) on how to configure DNS records for deployment.

Clerk supports two configuration methods for connecting to the Clerk Frontend API: CNAME and Proxy.

The recommended way to connect to the Clerk Frontend API is to [set up CNAME records and use DNS](/docs/deployments/overview). However, if you're unable to use this approach, or would like more control over your integration with Clerk, you can use a proxy.

When using a proxy, all requests to the Frontend API will be made through your domain. This allows you to use your own SSL certificate, and gives you more control over how you configure your application.

## How to use proxying

<Steps>
  ### Create your application and install Clerk

  To get started, you need to create an application from the [Clerk Dashboard](https://dashboard.clerk.com/). Once you create an instance via the Clerk Dashboard, you will be prompted to choose a domain. For the purposes of this guide, the domain will be `app.dev`.

  > [!NOTE]
  > For more information on creating a Clerk application, see the [setup guide](/docs/quickstarts/setup-clerk).

  ### Configure your proxy server

  For this example, `/__clerk` is used as the path for the proxy. Your proxy server must be on the same domain as your application.

  You can choose any path you'd like, but it must be unique and not conflict with any other routes in your application.

  #### Requirements

  Requests to `https://app.dev/__clerk/*` must be forwarded to `https://frontend-api.clerk.dev/*` with the body and all headers intact.

  Three additional headers must be set

  - `Clerk-Proxy-Url`: Needs to have the full proxy URL.
  - `Clerk-Secret-Key`: The Secret Key for your Clerk instance.
  - `X-Forwarded-For`: The IP address of the original client making the request.

  #### Example configuration

  <Tabs items={["Nginx", "Cloudflare Workers", "Next.js"]}>
    <Tab>
      ```nginx {{ filename: 'nginx.conf' }}
      http {
        # ...
        server {
          # ...
          location /__clerk/ {
            rewrite          ^/__clerk/(.*)$ /$1 break;
            proxy_pass       https://frontend-api.clerk.dev;
            proxy_set_header Clerk-Proxy-Url https://app.dev/__clerk;
            proxy_set_header Clerk-Secret-Key sk_live_***;
            proxy_set_header X-Forwarded-For $remote_addr;
            proxy_redirect   off;
          }
        }
      }
      ```
    </Tab>

    <Tab>
      <CodeBlockTabs options={["Handler", "Wrangler Config", "Environment", "Types"]}>
        ```ts {{ filename: 'src/index.ts' }}
        export default {
          async fetch(req: Request, env: Env, _ctx: ExecutionContext): Promise<Response> {
            const url = req.url.replace(env.CLERK_PROXY_URL, env.CLERK_FAPI)
            const proxyReq = new Request(req, {
              redirect: 'manual',
            })

            proxyReq.headers.set('Clerk-Proxy-Url', env.CLERK_PROXY_URL)
            proxyReq.headers.set('Clerk-Secret-Key', env.CLERK_SECRET_KEY)
            proxyReq.headers.set('X-Forwarded-For', req.headers.get('CF-Connecting-IP') || '')

            return fetch(url, proxyReq)
          },
        }
        ```

        ```toml {{ filename: 'wrangler.toml' }}
          name = "cloudflare-proxy"
          main = "src/index.ts"
          compatibility_date = "2023-10-02"

          [vars]
          CLERK_FAPI="https://frontend-api.clerk.dev"
        ```

        ```env {{ filename: '.dev.vars' }}
          # Do not commit this file to source control
          CLERK_PROXY_URL="https://app.dev/__clerk"
          CLERK_SECRET_KEY="sk_live_xxxxx"
        ```

        ```ts {{ filename: 'worker-configuration.d.ts' }}
        interface Env {
          CLERK_FAPI: string
          CLERK_PROXY_URL: string
          CLERK_SECRET_KEY: string
        }
        ```
      </CodeBlockTabs>
    </Tab>

    <Tab>
      ```ts {{ filename: 'middleware.ts' }}
      import { NextResponse } from 'next/server'
      import { clerkMiddleware } from '@clerk/nextjs/server'

      export default clerkMiddleware((auth, req) => {
        if (req.nextUrl.pathname.match('__clerk')) {
          const proxyHeaders = new Headers(req.headers)
          proxyHeaders.set('Clerk-Proxy-Url', process.env.NEXT_PUBLIC_CLERK_PROXY_URL || '')
          proxyHeaders.set('Clerk-Secret-Key', process.env.CLERK_SECRET_KEY || '')
          if (req.ip) {
            proxyHeaders.set('X-Forwarded-For', req.ip)
          } else {
            proxyHeaders.set('X-Forwarded-For', req.headers.get('X-Forwarded-For') || '')
          }

          const proxyUrl = new URL(req.url)
          proxyUrl.host = 'frontend-api.clerk.dev'
          proxyUrl.port = '443'
          proxyUrl.protocol = 'https'
          proxyUrl.pathname = proxyUrl.pathname.replace('/__clerk', '')

          return NextResponse.rewrite(proxyUrl, {
            request: {
              headers: proxyHeaders,
            },
          })
        }
      })

      export const config = {
        matcher: [
          // Skip Next.js internals and all static files, unless found in search params
          '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
          // Always run for API routes AND anything passed through the proxy
          '/(api|trpc|__clerk)(.*)',
        ],
      }
      ```
    </Tab>
  </Tabs>

  > [!NOTE]
  > Every proxy configuration will be different and we're here to help. [Contact support](/contact/support){{ target: '_blank' }} if there's a specific use-case you're looking to solve.

  ### Enable proxying

  In order to enable proxying, you need to set a proxy URL for your Clerk instance's domain. This can be done through the Clerk Dashboard or through the Backend API.

  > [!NOTE]
  > To avoid downtime, your proxy must be set up according to the above configuration before it can be enabled for your instance.
  > Make sure your proxy forwards requests to the Clerk Frontend API correctly and includes the required headers.

  <Tabs items={["Dashboard", "Backend API"]}>
    <Tab>
      1. In the Clerk Dashboard, navigate to the **[Domains](https://dashboard.clerk.com/last-active?path=domains)** page.
      1. In the **Frontend API** section, select the **Advanced** dropdown.
      1. In the **Proxy URL** field, enter your proxy URL. The proxy URL must be a valid URL and resolve correctly.
    </Tab>

    <Tab>
      The request below will update the domain to use the proxy URL `https://app.dev/__clerk`. In doing so, it will trigger checks to validate the proxy URL.

      ```bash
      curl -X PATCH https://api.clerk.com/v1/domains/{{DOMAIN ID}} \
          -H "Authorization: Bearer {{SECRET KEY}}" \
          -H "Content-Type: application/json" \
          -d '{"proxy_url": "https://app.dev/__clerk"}}'
      ```
    </Tab>
  </Tabs>

  ### Configure your proxy setup

  You can configure your proxy setup by either:

  - Setting environment variables
  - Using properties in your application

  #### Environment variables

  To configure your proxy setup using environment variables, your `.env` file should look like this:

  <Tabs items={["Next.js", "Remix", "JavaScript"]}>
    <Tab>
      ```env {{ filename: '.env' }}
      NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
      CLERK_SECRET_KEY={{secret}}

      NEXT_PUBLIC_CLERK_PROXY_URL=https://app.dev/__clerk
      ```
    </Tab>

    <Tab>
      ```env {{ filename: '.env' }}
      CLERK_PUBLISHABLE_KEY={{pub_key}}
      CLERK_SECRET_KEY={{secret}}

      CLERK_PROXY_URL=https://app.dev/__clerk
      ```
    </Tab>

    <Tab>
      You will only need to set environment variables in your JavaScript application if you are using a bundler (the `NPM module` method for ClerkJS installation). If you are using the `<script>` method, configure your proxy setup using [properties in your application](#properties-in-your-application) instead.

      ```env {{ filename: '.env' }}
      CLERK_PUBLISHABLE_KEY={{pub_key}}
      CLERK_SECRET_KEY={{secret}}

      CLERK_PROXY_URL=https://app.dev/__clerk
      ```
    </Tab>
  </Tabs>

  #### Properties in your application

  <Tabs items={["Next.js", "Remix", "JavaScript"]}>
    <Tab>
      To configure your proxy setup using properties in your Next.js application, set the `proxyUrl` property on the [`<ClerkProvider>`](/docs/components/clerk-provider) component.

      ```tsx {{ filename: 'app/layout.tsx', mark: [5] }}
      import { ClerkProvider } from '@clerk/nextjs'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <ClerkProvider proxyUrl="https://app.dev/__clerk">
            <html lang="en">
              <body>{children}</body>
            </html>
          </ClerkProvider>
        )
      }
      ```
    </Tab>

    <Tab>
      To configure your proxy setup using properties in your Remix application, set the `proxyUrl` property on the [`ClerkApp`](/docs/references/remix/clerk-app) wrapper.

      ```tsx {{ filename: 'root.tsx' }}
      export const loader = (args) => {
        return rootAuthLoader(
          args,
          ({ req }) => {
            const { userId, sessionId, getToken } = req.auth
            return json({
              message: `Hello from the root loader :)`,
              ENV: getBrowserEnvironment(),
            })
          },
          {
            loadUser: true,
            proxyUrl: 'https://app.dev/__clerk',
          } as const,
        )
      }

      export default ClerkApp(App, {
        proxyUrl: 'https://app.dev/__clerk',
      })
      ```
    </Tab>

    <Tab>
      To configure your proxy setup using properties in your JavaScript application, pass the `proxyUrl` option to the [`load()`](/docs/references/javascript/clerk#load) method.

      ```js {{ filename: 'main.js' }}
      import { Clerk } from '@clerk/clerk-js'

      // Initialize Clerk with your Clerk Publishable Key
      const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

      const clerk = new Clerk(clerkPubKey, {
        proxyUrl: 'https://app.dev/__clerk',
      })

      await clerk.load()
      ```
    </Tab>
  </Tabs>

  ### Ready to go 

  Your application should now be able to access the Frontend API from your proxy!
</Steps>

If you have any questions about proxying, or you're having any trouble setting this up, contact [support@clerk.com](mailto:support@clerk.com).

---
title: Quickstarts
description: See the getting started guides and tutorials.
---

## Full Stack

<Cards>
  - [Next.js](/docs/quickstarts/nextjs)
  - Easily add secure, beautiful, and fast authentication to your Next.js application with Clerk.
  - {<Include src="_partials/icons/nextjs" />}

  ---

  - [Astro](/docs/quickstarts/astro)
  - Easily add secure and SSR-friendly authentication to your Astro application with Clerk.
  - {<Include src="_partials/icons/astro" />}

  ---

  - [Nuxt](/docs/quickstarts/nuxt)
  - Easily add secure, beautiful, and fast authentication to Nuxt with Clerk.
  - {<Include src="_partials/icons/nuxt" />}

  ---

  - [React Router (Beta)](/docs/quickstarts/react-router)
  - The Clerk React Router SDK provides prebuilt components, hooks, and stores to make it easy to integrate authentication and user management in your React Router app.
  - {<Include src="_partials/icons/react-router" />}

  ---

  - [Remix](/docs/quickstarts/remix)
  - Easily add secure, edge- and SSR-friendly authentication to your Remix application with Clerk.
  - {<Include src="_partials/icons/remix" />}

  ---

  - [TanStack React Start (beta)](/docs/quickstarts/tanstack-react-start)
  - Easily add secure and SSR-friendly authentication to your TanStack React Start application with Clerk.
  - {<Include src="_partials/icons/tanstack-start" />}
</Cards>

## Frontend

<Cards>
  - [React](/docs/quickstarts/react)
  - Easily add secure, beautiful, and fast authentication to your React application with Clerk.
  - {<Include src="_partials/icons/react" />}

  ---

  - [Chrome Extension](/docs/quickstarts/chrome-extension)
  - Use the Chrome Extension SDK to authenticate users in your Chrome extension.
  - {<Include src="_partials/icons/chrome-extension" />}

  ---

  - [Expo](/docs/quickstarts/expo)
  - Use Clerk with Expo to authenticate users in your React Native application.
  - {<Include src="_partials/icons/expo" />}

  ---

  - [iOS](/docs/quickstarts/ios)
  - Use the Clerk iOS SDK to authenticate users in your native Apple applications.
  - {<Include src="_partials/icons/ios" />}

  ---

  - [JavaScript](/docs/quickstarts/javascript)
  - Easily add secure, beautiful, and fast authentication to your JavaScript application with Clerk.
  - {<Include src="_partials/icons/javascript" />}

  ---

  - [Vue](/docs/quickstarts/vue)
  - Easily add secure, beautiful, and fast authentication to your Vue application with Clerk.
  - {<Include src="_partials/icons/vue" />}
</Cards>

## Backend

<Cards>
  - [Express](/docs/quickstarts/express)
  - Easily add secure, beautiful, and fast authentication to your Express application with Clerk.
  - {<Include src="_partials/icons/express" />}

  ---

  - [Fastify](/docs/quickstarts/fastify)
  - Easily add secure, beautiful, and fast authentication to your Fastify application with Clerk.
  - {<Include src="_partials/icons/fastify" />}
</Cards>

<Include src="_partials/help" />

---
title: Rate limit errors
description: An index of Clerk errors related to rate limits.
type: reference
---

An index of Clerk errors related to rate limits.

## `TooManyRequests`

```json
{
  "shortMessage": "Too many requests",
  "longMessage": "Too many requests, retry later",
  "code": "too_many_requests"
}
```

## `VerificationCodeTooManyRequestsCode`

```json
{
  "shortMessage": "Too many verification code requests",
  "longMessage": "Too many verification code requests. Please wait at least 30 seconds to receive your code before trying again.",
  "code": "verification_code_too_many_requests"
}
```

---
title: Rate limits
description: Learn about rate limiting on the Clerk APIs.
---

Clerk rate limits certain endpoints to help protect users against brute-force attacks or to stop abuse of Clerk's platform.

## Errors

If you receive a `429` error code, you have been rate limited. All subsequent requests to that specific endpoint will be blocked for a given amount of time.

Requests that have been rate limited will receive the `Retry-After` response header, which contains the number of seconds after which the block expires.

## Frontend API requests

Frontend API requests are rate-limited per user and identified by their IP address.

<Properties>
  - Create SignIn
  - `/v1/sign_ins`

  5 requests per 10 seconds

  ---

  - Create SignUp
  - `/v1/sign_ups`

  5 requests per 10 seconds

  ---

  - Attempt SignIn
  - `/v1/sign_ins/attempt_(first|second)_factor`

  3 requests per 10 seconds

  ---

  - Attempt SignUp
  - `/v1/sign_ups/attempt_verification`

  3 requests per 10 seconds
</Properties>

## Backend API requests

Backend API requests are rate-limited per application instance which is identified by the Secret Key that is provided when making Backend API requests.

<Properties>
  - Create users
  - `POST /v1/users`

  20 requests per 10 seconds

  ---

  - All other endpoints

  100 requests per 10 seconds

  ---

  - Get the JWKS of the instance
  - `GET /v1/jwks`

  No rate limit
</Properties>

> [!NOTE]
> The `currentUser()` helper uses the `GET /v1/users/me` endpoint, so it is subject to the 100 requests per 10 seconds rate limit.

---
title: React Quickstart
description: Add authentication and user management to your React app with Clerk.
---

<TutorialHero
  exampleRepo={[
    {
      title: "React Quickstart Repo",
      link: "https://github.com/clerk/clerk-react-quickstart"

    }
  ]}
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    }
  ]}
/>

<Steps>
  ## Create a React app using Vite

  Run the following commands to create a new React app using [Vite](https://vitejs.dev/guide/#scaffolding-your-first-vite-project):

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm create vite@latest clerk-react -- --template react-ts
    cd clerk-react
    npm install
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn create vite clerk-react --template react-ts
    cd clerk-react
    yarn install
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm create vite clerk-react --template react-ts
    cd clerk-react
    pnpm install
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun create vite clerk-react --template react-ts
    cd clerk-react
    bun install
    bun dev
    ```
  </CodeBlockTabs>

  ## Install `@clerk/clerk-react`

  The [Clerk React SDK](/docs/references/react/overview) gives you access to prebuilt components, hooks, and helpers to make user authentication easier.

  Run the following command to install the SDK:

  <CodeBlockTabs options={["npm", "yarn",  "pnpm" ]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/clerk-react
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/clerk-react
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/clerk-react
    ```
  </CodeBlockTabs>

  ## Set your Clerk API keys

  <SignedIn>
    Add your Clerk Publishable Key to your `.env` file. It can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
  </SignedIn>

  <SignedOut>
    1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
    1. In the **Quick Copy** section, copy your Clerk Publishable Key.
    1. Paste your key into your `.env` file.

    The final result should resemble the following:
  </SignedOut>

  ```env {{ filename: '.env' }}
  VITE_CLERK_PUBLISHABLE_KEY={{pub_key}}
  ```

  ## Import the Clerk Publishable Key

  In your `main.tsx` file, import your Clerk Publishable Key. You can add an `if` statement to check that it is imported and that it exists. This will prevent running the app without the Publishable Key, and will also prevent TypeScript errors.

  ```tsx {{ filename: 'src/main.tsx', mark: [[6, 7], [9, 11]] }}
  import React from 'react'
  import ReactDOM from 'react-dom/client'
  import App from './App.tsx'
  import './index.css'

  // Import your Publishable Key
  const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  if (!PUBLISHABLE_KEY) {
    throw new Error('Add your Clerk Publishable Key to the .env file')
  }

  ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
      <App />
    </React.StrictMode>,
  )
  ```

  ## Add `<ClerkProvider>` to your app

  <Include src="_partials/clerk-provider/explanation" />

  Pass your Publishable Key as a prop to the component.

  ```tsx {{ filename: 'src/main.tsx', mark: [5, 16, 18] }}
  import React from 'react'
  import ReactDOM from 'react-dom/client'
  import App from './App.tsx'
  import './index.css'
  import { ClerkProvider } from '@clerk/clerk-react'

  // Import your Publishable Key
  const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  if (!PUBLISHABLE_KEY) {
    throw new Error('Add your Clerk Publishable Key to the .env file')
  }

  ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
      <ClerkProvider publishableKey={PUBLISHABLE_KEY} afterSignOutUrl="/">
        <App />
      </ClerkProvider>
    </React.StrictMode>,
  )
  ```

  ## Create a header with Clerk components

  You can control which content signed-in and signed-out users can see with the [prebuilt control components](/docs/components/overview#control-components). The following example creates a header using the following components:

  - [`<SignedIn>`](/docs/components/control/signed-in): Children of this component can only be seen while **signed in**.
  - [`<SignedOut>`](/docs/components/control/signed-out): Children of this component can only be seen while **signed out**.
  - [`<UserButton />`](/docs/components/user/user-button): Shows the signed-in user's avatar. Selecting it opens a dropdown menu with account management options.
  - [`<SignInButton />`](/docs/components/unstyled/sign-in-button): An unstyled component that links to the sign-in page or displays the sign-in modal.

  ```tsx {{ filename: 'src/App.tsx', mark: [1, [6, 11]] }}
  import { SignedIn, SignedOut, SignInButton, UserButton } from '@clerk/clerk-react'

  export default function App() {
    return (
      <header>
        <SignedOut>
          <SignInButton />
        </SignedOut>
        <SignedIn>
          <UserButton />
        </SignedIn>
      </header>
    )
  }
  ```

  ## Create your first user

  Run your project with the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun dev
    ```
  </CodeBlockTabs>

  Visit your app's homepage at [`http://localhost:5173`](http://localhost:5173). Sign up to create your first user.
</Steps>

## Next step: Add routing with React Router

React Router can be integrated with Clerk in two ways:

- As a framework: Use Clerk's built-in [React Router integration](/docs/quickstarts/react-router)
- As a library: Manually integrate React Router into your Clerk application using [library mode](/docs/references/react-router/library-mode)

## More resources

Learn more about Clerk components, how to customize them, and how to use Clerk's client-side helpers using the following guides.

<Cards>
  - [Prebuilt components](/docs/components/overview)
  - Learn more about Clerk's suite of components that let you quickly add authentication to your app.

  ---

  - [Customization & localization](/docs/customization/overview)
  - Learn how to customize and localize Clerk components.

  ---

  - [Client-side helpers (hooks)](/docs/hooks/use-user)
  - Learn more about Clerk's client-side helpers and how to use them.
</Cards>

---
title: React Router library mode
description: Learn how to use Clerk with React Router in library mode to add authentication to your application.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Install React Router as a library",
      link: "https://reactrouter.com/start/library/installation",
      icon: "react-router",
    }
  ]}
/>

React Router can be used as a framework or as a standalone library. This guide explains how to add React Router authentication to an existing React application using library mode. To use React Router as a framework instead, see the [React Router quickstart](/docs/quickstarts/react-router).

<Steps>
  ## Install `@clerk/react-router`

  The [Clerk React Router SDK](/docs/references/react-router/overview) provides prebuilt components, hooks, and helpers to make it easy to integrate authentication and user management in your React Router app.

  Run the following command to install the SDK:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/react-router
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/react-router
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/react-router
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @clerk/react-router
    ```
  </CodeBlockTabs>

  ## Set your Clerk API keys

  > [!NOTE]
  > You will not need the Clerk Secret Key in React Router's library mode, as it should never be used on the client-side.

  <SignedIn>
    Add your Clerk Publishable Key to your `.env` file. This key can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page of the Clerk Dashboard.
  </SignedIn>

  <SignedOut>
    1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
    1. In the **Quick Copy** section, copy your Clerk Publishable Key.
    1. Add your key to your `.env` file.

    The final result should resemble the following:
  </SignedOut>

  ```env {{ filename: '.env' }}
  VITE_CLERK_PUBLISHABLE_KEY={{pub_key}}
  ```

  ## Add `<ClerkProvider>` to your app

  <Include src="_partials/clerk-provider/explanation" />

  You must pass your Publishable Key as a prop, as shown in the following example:

  ```tsx {{ filename: 'src/main.tsx', mark: [4, 8, [13, 17]] }}
  import { StrictMode } from 'react'
  import { createRoot } from 'react-dom/client'
  import { BrowserRouter, Routes, Route } from 'react-router'
  import { ClerkProvider } from '@clerk/react-router'
  import './index.css'
  import App from './App.tsx'

  const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  createRoot(document.getElementById('root')!).render(
    <StrictMode>
      <BrowserRouter>
        <ClerkProvider publishableKey={PUBLISHABLE_KEY}>
          <Routes>
            <Route path="/" element={<App />} />
          </Routes>
        </ClerkProvider>
      </BrowserRouter>
    </StrictMode>,
  )
  ```

  ## Create a header with Clerk components

  You can control which content signed-in and signed-out users can see with the [prebuilt control components](/docs/components/overview#control-components). The following example creates a header using the following components:

  - [`<SignedIn>`](/docs/components/control/signed-in): Children of this component can only be seen while **signed in**.
  - [`<SignedOut>`](/docs/components/control/signed-out): Children of this component can only be seen while **signed out**.
  - [`<UserButton />`](/docs/components/user/user-button): Shows the signed-in user's avatar. Selecting it opens a dropdown menu with account management options.
  - [`<SignInButton />`](/docs/components/unstyled/sign-in-button): An unstyled component that links to the sign-in page or displays the sign-in modal.

  ```tsx {{ filename: 'src/App.tsx' }}
  import { SignInButton, SignedIn, SignedOut, UserButton } from '@clerk/react-router'

  export default function App() {
    return (
      <header>
        <SignedOut>
          <SignInButton />
        </SignedOut>
        <SignedIn>
          <UserButton />
        </SignedIn>
      </header>
    )
  }
  ```
</Steps>

---
title: React Router Quickstart
description: Learn how to use Clerk to quickly and easily add secure authentication and user management to your React Router application.
---

<TutorialHero
  exampleRepo={[
    {
      title: "React Router Quickstart Repo",
      link: "https://github.com/clerk/clerk-react-router-quickstart"

    }
  ]}
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Create a React Router application",
      link: "https://reactrouter.com/start/framework/installation",
      icon: "react-router",
    }
  ]}
/>

React Router can be used as a framework or as a standalone library. This tutorial explains how to use React Router as a framework. To use React Router as a library instead, see the [library mode tutorial](/docs/references/react-router/library-mode).

This tutorial assumes that you're using React Router **v7.1.2 or later** in framework mode.

<Steps>
  ## Install `@clerk/react-router`

  The [Clerk React Router SDK](/docs/references/react-router/overview) provides prebuilt components, hooks, and helpers to make it easy to integrate authentication and user management in your React Router app.

  Run the following command to install the SDK:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/react-router
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/react-router
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/react-router
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @clerk/react-router
    ```
  </CodeBlockTabs>

  ## Set your Clerk API keys

  <SignedIn>
    Add the following keys to your `.env` file. These keys can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
  </SignedIn>

  <SignedOut>
    1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
    1. In the **Quick Copy** section, copy your Clerk Publishable and Secret Key.
    1. Paste your keys into your `.env` file.

    The final result should resemble the following:
  </SignedOut>

  ```env {{ filename: '.env' }}
  VITE_CLERK_PUBLISHABLE_KEY={{pub_key}}
  CLERK_SECRET_KEY={{secret}}
  ```

  ## Configure `rootAuthLoader()`

  The `rootAuthLoader()` function provides access to authentication state in any React Router route.

  The following code shows how to add this function to your `root.tsx` file. If you're using [Clerk's React Router quickstart](https://github.com/clerk/clerk-react-router-quickstart) or the [React Router template](https://reactrouter.com/start/framework/installation), most of this code will already be present.

  To load additional data or configure options, see the [`rootAuthLoader()`](/docs/references/react-router/root-auth-loader) reference.

  ```tsx {{ filename: 'app/root.tsx', mark: [1, [6, 8]], collapsible: true }}
  import { rootAuthLoader } from '@clerk/react-router/ssr.server'
  import { isRouteErrorResponse, Links, Meta, Outlet, Scripts, ScrollRestoration } from 'react-router'
  import type { Route } from './+types/root'
  import stylesheet from './app.css?url'

  export async function loader(args: Route.LoaderArgs) {
    return rootAuthLoader(args)
  }

  export const links: Route.LinksFunction = () => [
    { rel: 'preconnect', href: 'https://fonts.googleapis.com' },
    {
      rel: 'preconnect',
      href: 'https://fonts.gstatic.com',
      crossOrigin: 'anonymous',
    },
    {
      rel: 'stylesheet',
      href: 'https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap',
    },
    { rel: 'stylesheet', href: stylesheet },
  ]

  export function Layout({ children }: { children: React.ReactNode }) {
    return (
      <html lang="en">
        <head>
          <meta charSet="utf-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1" />
          <Meta />
          <Links />
        </head>
        <body>
          {children}
          <ScrollRestoration />
          <Scripts />
        </body>
      </html>
    )
  }

  export default function App() {
    return <Outlet />
  }

  export function ErrorBoundary({ error }: Route.ErrorBoundaryProps) {
    let message = 'Oops!'
    let details = 'An unexpected error occurred.'
    let stack: string | undefined

    if (isRouteErrorResponse(error)) {
      message = error.status === 404 ? '404' : 'Error'
      details =
        error.status === 404 ? 'The requested page could not be found.' : error.statusText || details
    } else if (import.meta.env.DEV && error && error instanceof Error) {
      details = error.message
      stack = error.stack
    }

    return (
      <main className="pt-16 p-4 container mx-auto">
        <h1>{message}</h1>
        <p>{details}</p>
        {stack && (
          <pre className="w-full p-4 overflow-x-auto">
            <code>{stack}</code>
          </pre>
        )}
      </main>
    )
  }
  ```

  ## Add `<ClerkProvider>` and Clerk components to your app

  <Include src="_partials/clerk-provider/explanation" />

  It's required to pass `loaderData` to the `<ClerkProvider>` component. This data is provided by the `rootAuthLoader()` function. It's also recommended to pass the `signUpFallbackRedirectUrl` and `signInFallbackRedirectUrl` props to specify the fallback URL to redirect to after the user signs up or signs in, respectively, if there's no `redirect_url` in the path already. [Learn more about customizing how Clerk redirects](/docs/guides/custom-redirects).

  You can control which content signed-in and signed-out users can see with Clerk's [prebuilt control components](/docs/components/overview#control-components).

  The following example adds `<ClerkProvider>` and creates a header using the following Clerk components:

  - [`<SignedIn>`](/docs/components/control/signed-in): Children of this component can only be seen while **signed in**.
  - [`<SignedOut>`](/docs/components/control/signed-out): Children of this component can only be seen while **signed out**.
  - [`<UserButton />`](/docs/components/user/user-button): Shows the signed-in user's avatar. Selecting it opens a dropdown menu with account management options.
  - [`<SignInButton />`](/docs/components/unstyled/sign-in-button): An unstyled component that links to the sign-in page. In this example, since no props or [environment variables](/docs/deployments/clerk-environment-variables) are set for the sign-in URL, this component links to the [Account Portal sign-in page](/docs/account-portal/overview#sign-in).

  ```tsx {{ filename: 'app/root.tsx' }}
  // Other imports

  import { ClerkProvider, SignedIn, SignedOut, UserButton, SignInButton } from '@clerk/react-router'

  export default function App({ loaderData }: Route.ComponentProps) {
    return (
      <ClerkProvider
        loaderData={loaderData}
        signUpFallbackRedirectUrl="/"
        signInFallbackRedirectUrl="/"
      >
        <header className="flex items-center justify-center py-8 px-4">
          <SignedOut>
            <SignInButton />
          </SignedOut>
          <SignedIn>
            <UserButton />
          </SignedIn>
        </header>
        <main>
          <Outlet />
        </main>
      </ClerkProvider>
    )
  }

  // Rest of the root.tsx code
  ```

  ## Create your first user

  Run your project with the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun dev
    ```
  </CodeBlockTabs>

  Visit your app's homepage at [`http://localhost:5173`](http://localhost:5173). Sign up to create your first user.
</Steps>

## Next steps

<Cards>
  - [Create a custom sign-in-or-up page](/docs/references/react-router/custom-sign-in-or-up-page)
  - Learn how add custom sign-in-or-up page with Clerk components.

  ---

  - [Read session and user data](/docs/references/react-router/read-session-data)
  - Learn how to use Clerk's hooks and helpers to access the active session and user data in your React Router app.

  ---

  - [Library mode](/docs/references/react-router/library-mode)
  - Learn how to use Clerk with React Router in library mode to add authentication to your application.
</Cards>

---
title: Read session and user data in your Astro app with Clerk
description: Learn how to use Clerk's hooks and helpers to access the active session and user data in your Astro application.
---

Clerk provides helpers that you can use to access the active session and user data in your Astro application.

## Server-side

The following example uses the [`auth()`](/docs/references/nextjs/auth){{ target: '_blank' }} local to validate an authenticated user and the [`currentUser()`](/docs/references/nextjs/current-user){{ target: '_blank' }} local to access the [`Backend API User`](/docs/references/backend/types/backend-user){{ target: '_blank' }} object for the authenticated user.

<CodeBlockTabs options={[".astro component", "API Route"]}>
  ```astro {{ filename: 'src/pages/me.astro' }}
  ---
  if (!Astro.locals.auth().userId) {
    return Astro.redirect('/login')
  }

  const user = await Astro.locals.currentUser()
  ---

  <div>{JSON.stringify(user)}</div>
  ```

  ```tsx {{ filename: 'src/api/me.ts' }}
  export async function GET({ locals }) {
    if (!locals.auth().userId) {
      return new Response('Unauthorized', { status: 401 })
    }

    const currentUser = await locals.currentUser()

    return new Response(JSON.stringify(currentUser))
  }
  ```
</CodeBlockTabs>

## Client-side

Clerk Astro provides a set of useful [stores](/docs/references/astro/overview#client-side-helpers) that give you access to many important objects, such as the `Clerk`, `User`, and `Session` object.

### `$authStore`

The following example demonstrates how to use the [`$authStore`](/docs/references/astro/auth-store) to access auth information for the active user, such as the `userId` and `sessionId`.

```tsx {{ filename: 'components/example.tsx' }}
import { useStore } from '@nanostores/react'
import { $authStore } from '@clerk/astro/client'

export default function Example() {
  const { userId, sessionId } = useStore($authStore)

  // In case the user signs out while on the page.
  if (!userId) {
    return null
  }

  return (
    <div>
      Hello, {userId} your current active session is {sessionId}
    </div>
  )
}
```

### `$userStore`

The following example demonstrates how to use the [`$userStore`](/docs/references/astro/user-store) store to access information about the active user, such as their `firstName`.

```tsx {{ filename: 'components/example.tsx' }}
import { useStore } from '@nanostores/react'
import { $userStore } from '@clerk/astro/client'

export default function Example() {
  const user = useStore($userStore)

  if (!user) {
    return null
  }

  return <div>Hello, {user.firstName} welcome to Clerk</div>
}
```

---
title: Read session and user data in your Next.js app with Clerk
description: Learn how to use Clerk's hooks and helpers to access the active session and user data in your Next.js application.
---

Clerk provides a set of [hooks and helpers](/docs/references/nextjs/overview#client-side-helpers) that you can use to access the active session and user data in your Next.js application. Here are examples of how to use these helpers in both the client and server-side to get you started.

## Server-side

### App Router

[`auth()`](/docs/references/nextjs/auth) and [`currentUser()`](/docs/references/nextjs/current-user) are App Router-specific helpers that you can use inside of your Route Handlers, Middleware, Server Components, and Server Actions.

- The `auth()` helper will return the [`Auth`](/docs/references/backend/types/auth-object) object of the currently active user.
- The `currentUser()` helper will return the [`Backend User`](/docs/references/backend/types/backend-user) object of the currently active user. This is helpful if you want to render information, like their first and last name, directly from the server. Under the hood, `currentUser()` uses the [`clerkClient`](/docs/references/backend/overview) wrapper to make a call to the Backend API. **This does count towards the [Backend API request rate limit](/docs/backend-requests/resources/rate-limits)**. This also uses `fetch()` so it is automatically deduped per request.

The following example uses the [`auth()`](/docs/references/nextjs/auth) helper to validate an authenticated user and the `currentUser()` helper to access the `Backend User` object for the authenticated user.

> [!NOTE]
> Any requests from a Client Component to a Route Handler will read the session from cookies and will not need the token sent as a Bearer token.

<Tabs items={["Server components and actions", "Route Handler"]}>
  <Tab>
    ```tsx {{ filename: 'app/page.tsx' }}
    import { auth, currentUser } from '@clerk/nextjs/server'

    export default async function Page() {
      // Get the userId from auth() -- if null, the user is not signed in
      const { userId } = await auth()

      // Protect the route by checking if the user is signed in
      if (!userId) {
        return <div>Sign in to view this page</div>
      }

      // Get the Backend API User object when you need access to the user's information
      const user = await currentUser()

      // Use `user` to render user details or create UI elements
      return <div>Welcome, {user.firstName}!</div>
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/api/user/route.ts' }}
    import { NextResponse } from 'next/server'
    import { currentUser, auth } from '@clerk/nextjs/server'

    export async function GET() {
      // Use `auth()` to get the user's ID
      const { userId } = await auth()

      // Protect the route by checking if the user is signed in
      if (!userId) {
        return new NextResponse('Unauthorized', { status: 401 })
      }

      // Use `currentUser()` to get the Backend API User object
      const user = await currentUser()

      // Add your Route Handler's logic with the returned `user` object

      return NextResponse.json({ user: user }, { status: 200 })
    }
    ```
  </Tab>
</Tabs>

### Pages Router

For Next.js applications using the Pages Router, the [`getAuth()`](/docs/references/nextjs/get-auth) helper will return the [`Auth`](/docs/references/backend/types/auth-object) object of the currently active user, which contains important information like the current user's session ID, user ID, and organization ID. The `userId` can be used to protect your API routes.

In some cases, you may need the full [`Backend User`](/docs/references/backend/types/backend-user) object of the currently active user. This is helpful if you want to render information, like their first and last name, directly from the server.

The `clerkClient()` helper returns an instance of the [JavaScript Backend SDK](/docs/references/backend/overview), which exposes Clerk's Backend API resources through methods such as the [`getUser()`](/docs/references/backend/user/get-user){{ target: '_blank' }} method. This method returns the full `Backend User` object.

In the following example, the `userId` is passed to the Backend SDK's `getUser()` method to get the user's full `Backend User` object.

<Tabs items={["API Route", "getServerSideProps"]}>
  <Tab>
    ```tsx {{ filename: 'pages/api/auth.ts' }}
    import { getAuth, clerkClient } from '@clerk/nextjs/server'
    import type { NextApiRequest, NextApiResponse } from 'next'

    export default async function handler(req: NextApiRequest, res: NextApiResponse) {
      // Use `getAuth()` to get the user's ID
      const { userId } = getAuth(req)

      // Protect the route by checking if the user is signed in
      if (!userId) {
        return res.status(401).json({ error: 'Unauthorized' })
      }

      // Initialize the Backend SDK
      const client = await clerkClient()

      // Get the user's full `Backend User` object
      const user = await client.users.getUser(userId)

      return res.status(200).json({ user })
    }
    ```
  </Tab>

  <Tab>
    > [!NOTE]
    > `buildClerkProps` informs client-side features, like `useAuth()`, `<SignedIn>`, and `<SignedOut>`, of the authentication state during server-side rendering.

    ```tsx {{ filename: 'pages/example.tsx' }}
    import { getAuth, buildClerkProps } from '@clerk/nextjs/server'
    import { GetServerSideProps } from 'next'

    export const getServerSideProps: GetServerSideProps = async (ctx) => {
      // Use `getAuth()` to get the user's ID
      const { userId } = getAuth(ctx.req)

      // Protect the route by checking if the user is signed in
      if (!userId) {
        // Handle when the user is not signed in
      }

      // Initialize the Backend SDK
      const client = await clerkClient()

      // Get the user's full `Backend User` object
      const user = userId ? await client.users.getUser(userId) : undefined

      return { props: { ...buildClerkProps(ctx.req, { user }) } }
    }
    ```
  </Tab>
</Tabs>

## Client-side

### `useAuth()`

<Include src="_partials/hooks/use-auth" />

### `useUser()`

<Include src="_partials/hooks/use-user" />

---
title: Read session and user data in your Nuxt app with Clerk
description: Learn how to use Clerk's composables to access the active session and user data in your Nuxt application.
---

Clerk provides [composables](/docs/references/nuxt/overview#client-side-helpers) to access the session and user data in your Nuxt application.

## Client-side

### `useAuth()`

<Include src="_partials/vue-nuxt/use-auth" />

## `useUser()`

The `useUser()` composable provides access the [`User`](/docs/references/javascript/user) object, which contains the current user's data such as their full name.

The following example uses the `useUser()` composable to display the user's first name if they are signed in. The `isLoaded` property checks if Clerk has finished initializing and the `isSignedIn` property checks if a user is currently signed in.

```vue {{ filename: 'pages/protected-page.vue' }}
<script setup>
const { isLoaded, isSignedIn, user } = useUser()
</script>

<template>
  <div v-if="!isLoaded">Loading...</div>
  <div v-else-if="!isSignedIn">Sign in to access this page</div>
  <div v-else>Hello, {{ user.firstName }}!</div>
</template>
```

## Server-side

The `Auth` object is available at `event.context.auth()` in your [event handlers](https://h3.unjs.io/guide/event-handler). This JavaScript object contains important information like the current user's session ID, user ID, and organization ID. The `userId` can be used to protect your API routes.

In some cases, you may need the full [`Backend User`](/docs/references/backend/types/backend-user) object of the currently active user. This is helpful if you want to render information, like their first and last name, directly from the server. The `clerkClient()` helper returns an instance of the [JavaScript Backend SDK](/docs/references/backend/overview), which exposes Clerk's Backend API resources through methods such as the [`getUser()`](/docs/references/backend/user/get-user){{ target: '_blank' }} method. This method returns the full `Backend User` object.

In the following example, the `userId` is passed to the Backend SDK's `getUser()` method to get the user's full `Backend User` object.

```ts {{ filename: 'server/api/auth/index.ts' }}
import { clerkClient } from '@clerk/nuxt/server'

export default defineEventHandler(async (event) => {
  // Use `auth` to get the user's ID
  const { userId } = event.context.auth()

  // Protect the API route by checking if the user is signed in
  if (!userId) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Unauthorized: No user ID provided',
    })
  }

  // Get the user's full `Backend User` object
  const user = await clerkClient(event).users.getUser(userId)

  return user
})
```

---
title: Read session and user data in your React Router app with Clerk
description: Learn how to use Clerk's hooks and helpers to access the active session and user data in your React Router application.
---

Clerk provides a set of [hooks and helpers](/docs/references/react-router/overview#client-side-helpers) that you can use to access the active session and user data in your React Router application. Here are examples of how to use these helpers in both the client and server-side to get you started.

## Server-side

To access active session and user data on the server-side, use the [`getAuth()`](/docs/references/react-router/get-auth) helper.

### Server data loading

The [`getAuth()`](/docs/references/tanstack-react-start/get-auth) helper returns the [`Auth`](/docs/references/backend/types/auth-object) object of the currently active user, which contains important information like the current user's session ID, user ID, and organization ID. The `userId` can be used to protect your API routes.

In some cases, you may need the full [`Backend User`](/docs/references/backend/types/backend-user) object of the currently active user. This is helpful if you want to render information, like their first and last name, directly from the server. The `clerkClient()` helper returns an instance of the [JavaScript Backend SDK](/docs/references/backend/overview), which exposes Clerk's Backend API resources through methods such as the [`getUser()`](/docs/references/backend/user/get-user){{ target: '_blank' }} method. This method returns the full `Backend User` object.

In the following example, the `userId` is passed to the Backend SDK's `getUser()` method to get the user's full `Backend User` object.

```tsx {{ filename: 'app/routes/profile.tsx' }}
import { redirect } from 'react-router'
import { getAuth } from '@clerk/react-router/ssr.server'
import { createClerkClient } from '@clerk/react-router/api.server'
import type { Route } from './+types/profile'

export async function loader(args: Route.LoaderArgs) {
  // Use `getAuth()` to get the user's ID
  const { userId } = await getAuth(args)

  // Protect the route by checking if the user is signed in
  if (!userId) {
    return redirect('/sign-in?redirect_url=' + args.request.url)
  }

  // Instantiate the Backend SDK and get the user's full `Backend User` object
  const user = await createClerkClient({ secretKey: process.env.CLERK_SECRET_KEY }).users.getUser(
    userId,
  )

  return {
    user: JSON.stringify(user),
  }
}

export default function Profile({ loaderData }: Route.ComponentProps) {
  return (
    <div>
      <h1>Profile Data</h1>
      <pre>
        <code>{JSON.stringify(loaderData, null, 2)}</code>
      </pre>
    </div>
  )
}
```

### Server action

Unlike the previous example that loads data when the page loads, the following example uses `getAuth()` to only fetch user data after submitting the form. The helper runs on form submission, authenticates the user, and processes the form data.

```tsx {{ filename: 'app/routes/profile-form.tsx' }}
import { redirect, Form } from 'react-router'
import { getAuth } from '@clerk/react-router/ssr.server'
import { createClerkClient } from '@clerk/react-router/api.server'
import type { Route } from './+types/profile-form'

export async function action(args: Route.ActionArgs) {
  // Use `getAuth()` to get the user's ID
  const { userId } = await getAuth(args)

  // Protect the route by checking if the user is signed in
  if (!userId) {
    return redirect('/sign-in?redirect_url=' + args.request.url)
  }

  // Get the form data
  const formData = await args.request.formData()
  const name = formData.get('name')?.toString()

  // Instantiate the Backend SDK and get the user's full `Backend User` object
  const user = await createClerkClient({
    secretKey: process.env.CLERK_SECRET_KEY,
  }).users.getUser(userId)

  return {
    name,
    user: JSON.stringify(user),
  }
}

export default function ProfileForm({ actionData }: Route.ComponentProps) {
  return (
    <div>
      <h1>Profile Data</h1>

      <Form method="post">
        <label htmlFor="name">Name</label>
        <input type="text" name="name" id="name" />
        <button type="submit">Submit</button>
      </Form>

      {actionData ? (
        <pre>
          <code>{JSON.stringify(actionData, null, 2)}</code>
        </pre>
      ) : null}
    </div>
  )
}
```

## Client-side

To access active session and user data on the client-side, use the `useAuth()` and `useUser()` hooks.

### `useAuth()`

<Include src="_partials/hooks/use-auth" />

### `useUser()`

<Include src="_partials/hooks/use-user" />

---
title: Read session and user data in your Remix app with Clerk
description: Learn how to use Clerk's hooks and helpers to access the active session and user data in your Remix application.
---

Clerk provides a set of [hooks and helpers](/docs/references/remix/overview) that you can use to access the active session and user data in your Remix application. Here are examples of how to use these helpers in both the client and server-side to get you started.

## Server-side

### `getAuth()`

The [`getAuth()`](/docs/references/remix/overview#get-auth) helper allows you to access the [`Auth` object](/docs/references/backend/types/auth-object){{ target: '_blank' }}, which includes the current user's `userId`. You can use the `userId` to protect your routes or get the user's data.

In the following example, the `userId` is passed to the Backend SDK's [`getUser()`](/docs/references/backend/user/get-user){{ target: '_blank' }} method to get the user's full `User` object. For information on how to use the Backend SDK, see the [Backend SDK documentation](/docs/references/backend/overview){{ target: '_blank' }}.

<Tabs items={["Loader Function", "Action Function"]}>
  <Tab>
    ```tsx {{ filename: 'routes/profile.tsx' }}
    import { LoaderFunction, redirect } from '@remix-run/node'
    import { getAuth } from '@clerk/remix/ssr.server'
    import { createClerkClient } from '@clerk/remix/api.server'

    export const loader: LoaderFunction = async (args) => {
      // Use `getAuth()` to retrieve the user's ID
      const { userId } = await getAuth(args)

      // If there is no userId, then redirect to sign-in route
      if (!userId) {
        return redirect('/sign-in?redirect_url=' + args.request.url)
      }

      // Initialize the Backend SDK and get the user's full `Backend User` object
      const user = await createClerkClient({ secretKey: process.env.CLERK_SECRET_KEY }).users.getUser(
        userId,
      )

      // Return the retrieved user data
      return { serialisedUser: JSON.stringify(user) }
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'routes/profile.tsx' }}
    import { ActionFunction, redirect } from '@remix-run/node'
    import { getAuth } from '@clerk/remix/ssr.server'
    import { createClerkClient } from '@clerk/remix/api.server'

    export const action: ActionFunction = async (args) => {
      // Use `getAuth()` to retrieve the user's ID
      const { userId } = await getAuth(args)

      // If there is no userId, then redirect to sign-in route
      if (!userId) {
        return redirect('/sign-in?redirect_url=' + args.request.url)
      }

      // Initialize the Backend SDK and get the user's full `Backend User` object
      const updatedUser = await createClerkClient({
        secretKey: process.env.CLERK_SECRET_KEY,
      }).users.getUser(userId)

      // Return the retrieved user data
      return { serialisedUser: JSON.stringify(updatedUser) }
    }
    ```
  </Tab>
</Tabs>

## Client Side

### `useAuth()`

<Include src="_partials/hooks/use-auth" />

### `useUser()`

<Include src="_partials/hooks/use-user" />

---
title: Read session and user data in your TanStack React Start app with Clerk
description: Learn how to use Clerk's hooks and helpers to access the active session and user data in your TanStack React Start application.
---

Clerk provides a set of [hooks and helpers](/docs/references/tanstack-react-start/overview#client-side-helpers) that you can use to access the active session and user data in your TanStack React Start application. Here are examples of how to use these helpers in both the client and server-side to get you started.

## Server-side

The [`getAuth()`](/docs/references/tanstack-react-start/get-auth) helper returns the [`Auth`](/docs/references/backend/types/auth-object) object of the currently active user, which contains important information like the current user's session ID, user ID, and organization ID. The `userId` can be used to protect your API routes.

In some cases, you may need the full [`Backend User`](/docs/references/backend/types/backend-user) object of the currently active user. This is helpful if you want to render information, like their first and last name, directly from the server. The `clerkClient()` helper returns an instance of the [JavaScript Backend SDK](/docs/references/backend/overview), which exposes Clerk's Backend API resources through methods such as the [`getUser()`](/docs/references/backend/user/get-user){{ target: '_blank' }} method. This method returns the full `Backend User` object.

In the following example, the `userId` is passed to the Backend SDK's `getUser()` method to get the user's full `Backend User` object.

<Tabs items={["Server function", "API Route"]}>
  <Tab>
    ```tsx {{ filename: 'app/routes/index.tsx' }}
    import { createFileRoute, useRouter, redirect } from '@tanstack/react-router'
    import { createServerFn } from '@tanstack/react-start'
    import { getAuth } from '@clerk/tanstack-react-start/server'
    import { getWebRequest } from '@tanstack/react-start/server'

    const authStateFn = createServerFn({ method: 'GET' }).handler(async () => {
      // Use `getAuth()` to retrieve the user's ID
      const { userId } = await getAuth(getWebRequest())

      // Protect the server function by checking if the user is signed in
      if (!userId) {
        // This might error if you're redirecting to a path that doesn't exist yet
        // You can create a sign-in route to handle this
        throw redirect({
          to: '/sign-in/$',
        })
      }

      // Instantiate the Backend SDK
      const clerkClient = createClerkClient({
        secretKey: import.meta.env.CLERK_SECRET_KEY,
      })

      // Get the user's full `Backend User` object
      const user = userId ? await clerkClient.users.getUser(userId) : null

      return { user }
    })

    export const Route = createFileRoute('/')({
      component: Home,
      beforeLoad: () => authStateFn(),
      loader: async ({ context }) => {
        return { userId: context.userId, user: context.user }
      },
    })

    function Home() {
      const state = Route.useLoaderData()

      return (
        <div>
          <h1>Welcome, {state.user?.firstName}!</h1>
          <p>Your ID is {state.userId}</p>
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'app/routes/api/example.ts' }}
    import { getAuth } from '@clerk/tanstack-react-start/server'
    import { json } from '@tanstack/react-start'
    import { createAPIFileRoute } from '@tanstack/react-start/api'

    export const Route = createAPIFileRoute('/api/example')({
      GET: async ({ req, params }) => {
        // Use `getAuth()` to retrieve the user's ID
        const { userId } = await getAuth(req)

        // Protect the API route by checking if the user is signed in
        if (!userId) {
          return json({ error: 'Unauthorized' }, { status: 401 })
        }

        // Instantiate the Backend SDK
        const clerkClient = createClerkClient({
          secretKey: import.meta.env.CLERK_SECRET_KEY,
        })

        // Get the user's full `Backend User` object
        const user = userId ? await clerkClient.users.getUser(userId) : null

        return json({ user })
      },
    })
    ```
  </Tab>
</Tabs>

## Client-side

To access active session and user data on the client-side, use Clerk's `useAuth()` and `useUser()` hooks.

### `useAuth()`

{/* TODO: Keep in sync with _partials/hooks/use-auth */}

The [`useAuth()`](/docs/hooks/use-auth){{ target: '_blank' }} hook provides information about the current auth state, as well as helper methods to manage the current active session. The hook returns `userId`, which can be used to protect your routes, as shown in the following example:

```tsx {{ filename: 'routes/example.tsx' }}
import { useAuth } from '@clerk/tanstack-react-start'
import { createFileRoute } from '@tanstack/react-router'

export const Route = createFileRoute('/example')({
  component: Example,
})

function Example() {
  const { isLoaded, isSignedIn, userId, sessionId, getToken } = useAuth()

  if (!isLoaded) {
    return <div>Loading...</div>
  }

  if (!isSignedIn) {
    // You could also add a redirect to the sign-in page here
    return <div>Sign in to view this page</div>
  }

  return (
    <div>
      Hello, {userId}! Your current active session is {sessionId}.
    </div>
  )
}
```

### `useUser()`

{/* TODO: Keep in sync with _partials/hooks/use-user */}

The [`useUser()`](/docs/hooks/use-user){{ target: '_blank' }} hook enables you to access the [`User`](/docs/references/javascript/user) object, which contains the current user's data such as their full name.

The following example demonstrates how to use `useUser()` to check if the user is signed in and display their first name:

```tsx {{ filename: 'routes/example.tsx' }}
import { useUser } from '@clerk/tanstack-react-start'
import { createFileRoute } from '@tanstack/react-router'

export const Route = createFileRoute('/example')({
  component: Example,
})

function Example() {
  const { isLoaded, isSignedIn, user } = useUser()

  if (!isLoaded) {
    return <div>Loading...</div>
  }

  if (!isSignedIn) {
    // You could also add a redirect to the sign-in page here
    return <div>Sign in to view this page</div>
  }

  return <div>Hello, {user.firstName}!</div>
}
```

---
title: Read session and user data with Expo
description: Learn how to read session & user data in Expo with Clerk.
---

This guide demonstrates how to access active session and user data in your Expo application.

## Session data example

{/* TODO: Keep in sync with _partials/hooks/use-auth */}

The [`useAuth()`](/docs/hooks/use-auth){{ target: '_blank' }} hook provides information about the current auth state, as well as helper methods to manage the current active session. The hook returns `userId`, which can be used to protect your routes, as shown in the following example:

```tsx {{ filename: 'components/UseAuthExample.tsx' }}
import { useAuth } from '@clerk/clerk-expo'
import { Text } from 'react-native'

export default function UseAuthExample() {
  const { isLoaded, isSignedIn, userId, sessionId, getToken } = useAuth()

  if (!isLoaded) {
    return <Text>Loading...</Text>
  }

  if (!isSignedIn) {
    // You could also add a redirect to the sign-in page here
    return <Text>Sign in to view this page</Text>
  }

  return (
    <Text>
      Hello, {userId}! Your current active session is {sessionId}.
    </Text>
  )
}
```

## User data example

{/* TODO: Keep in sync with _partials/hooks/use-user */}

The [`useUser()`](/docs/hooks/use-user){{ target: '_blank' }} hook enables you to access the [`User`](/docs/references/javascript/user) object, which contains the current user's data such as their full name.

The following example demonstrates how to use `useUser()` to check if the user is signed in and display their first name:

```tsx {{ filename: 'src/Example.tsx' }}
import { useUser } from '@clerk/clerk-expo'
import { Text } from 'react-native'

export default function Example() {
  const { isSignedIn, user, isLoaded } = useUser()

  if (!isLoaded) {
    return <Text>Loading...</Text>
  }

  if (!isSignedIn) {
    return <Text>Sign in to view this page</Text>
  }

  return <Text>Hello {user.firstName}!</Text>
}
```

---
title: Reassign the Creator role
description: Learn how to assign Clerk's Creator role to any other role in an organization.
content-type: guide
---

When a user creates a new organization, that user is automatically added as the organization's first member and assigned whichever role is that org's [**Creator** role](/docs/organizations/roles-permissions#the-creator-role). By default, that role is `org:admin`.

You cannot delete an organization role if it is used as the organization **Creator** role. But, you _can_ reassign the **Creator** role to any other role with the right permissions. For example, if you want to delete the `admin` role, you will have to assign another role as the **Creator** role.

The **Creator** role must _at least_ have the following [System Permissions](/docs/organizations/roles-permissions#system-permissions):

- Manage members (`org:sys_memberships:manage`)
- Read members (`org:sys_memberships:read`)
- Delete organization (`org:sys_profile:delete`)

To reassign the **Creator** role:

1. In the Clerk Dashboard, navigate to [**Roles**](https://dashboard.clerk.com/last-active?path=organizations-settings/roles).
1. [Create a new role](/docs/organizations/create-roles-permissions#create-a-new-role-for-your-organization) or use an existing role from the list.
1. Ensure that **Manage members**, **Read members**, and **Delete organization** system permissions are selected for the role.
1. Open the "..." menu for the role.
1. From the dropdown, select the **Set as Creator role** option.

---
title: Reassign the Default role for members
description: Learn how to assign Clerk's Default role to any other role in an organization.
content-type: guide
---

New organization members are initially assigned the [**Default** role](/docs/organizations/roles-permissions#the-default-role-for-members). By default, that role is `org:member`. This role is used as a pre-filled default in `<OrganizationProfile />` invitations and for organization enrollment with [verified domains](/docs/organizations/verified-domains).

You cannot delete an organization role if it is used as the organization **Default** role. But, you _can_ reassign the **Default** role to any other role.

To reassign the **Default** role:

1. In the Clerk Dashboard, navigate to [**Roles**](https://dashboard.clerk.com/last-active?path=organizations-settings/roles).
1. [Create a new role](/docs/organizations/create-roles-permissions#create-a-new-role-for-your-organization) or use an existing role from the list.
1. Open the "..." menu for the role.
1. From the dropdown, select the **Set as Default role** option.

---
title: Remix Quickstart
description: Learn how to use Clerk to quickly and easily add secure authentication and user management to your Remix application.
---

<TutorialHero
  exampleRepo={[
    {
      title: "Remix Quickstart Repo",
      link: "https://github.com/clerk/clerk-remix-quickstart"

    }
  ]}
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Create a Remix application",
      link: "https://remix.run/docs/en/main/start/quickstart",
      icon: "remix",
    }
  ]}
/>

Learn how to use Clerk to quickly and easily add secure authentication and user management to your Remix app. This guide assumes that you are using Remix v2 or later.

> [!NOTE]
> If you are using Remix SPA mode, follow the [Remix SPA mode guide](/docs/references/remix/spa-mode).

<Steps>
  ## Install `@clerk/remix`

  The [Clerk Remix SDK](/docs/references/remix/overview) gives you access to prebuilt components, hooks, and helpers to make user authentication easier.

  Run the following command to install the SDK:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/remix
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/remix
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/remix
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @clerk/remix
    ```
  </CodeBlockTabs>

  ## Set your Clerk API keys

  <SignedIn>
    Add the following keys to your `.env` file. These keys can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
  </SignedIn>

  <SignedOut>
    1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
    1. In the **Quick Copy** section, copy your Clerk Publishable and Secret Keys.
    1. Paste your keys into your `.env` file.

    The final result should resemble the following:
  </SignedOut>

  ```env {{ filename: '.env' }}
  CLERK_PUBLISHABLE_KEY={{pub_key}}
  CLERK_SECRET_KEY={{secret}}
  ```

  ## Configure `rootAuthLoader()`

  The [`rootAuthLoader()`](/docs/references/remix/root-auth-loader) function is a helper function that provides the authentication state to your Remix application. You must export `rootAuthLoader()` as the root `loader()` function.

  Update your `root.tsx` file with the following code:

  ```tsx {{ filename: 'app/root.tsx', mark: [1, [4, 5], [15, 16]] }}
  import type { MetaFunction, LoaderFunction } from '@remix-run/node'
  import { Links, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react'

  // Import `rootAuthLoader()`
  import { rootAuthLoader } from '@clerk/remix/ssr.server'

  export const meta: MetaFunction = () => [
    {
      charset: 'utf-8',
      title: 'New Remix App',
      viewport: 'width=device-width,initial-scale=1',
    },
  ]

  // Export `rootAuthLoader()` as the root route `loader`
  export const loader: LoaderFunction = (args) => rootAuthLoader(args)

  export function Layout({ children }: { children: React.ReactNode }) {
    return (
      <html lang="en">
        <head>
          <Meta />
          <Links />
        </head>
        <body>
          {children}
          <ScrollRestoration />
          <Scripts />
        </body>
      </html>
    )
  }

  export default function App() {
    return <Outlet />
  }
  ```

  ## Configure `ClerkApp`

  Clerk provides a `ClerkApp` wrapper to provide the authentication state to your React tree. This helper works with Remix SSR out-of-the-box and follows the "higher-order component" paradigm.

  Update your `root.tsx` file with the following code:

  ```tsx {{ filename: 'app/root.tsx', mark: [[6, 7], [39, 40]] }}
  import type { MetaFunction, LoaderFunction } from '@remix-run/node'

  import { Links, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react'

  import { rootAuthLoader } from '@clerk/remix/ssr.server'
  // Import ClerkApp
  import { ClerkApp } from '@clerk/remix'

  export const meta: MetaFunction = () => [
    {
      charset: 'utf-8',
      title: 'New Remix App',
      viewport: 'width=device-width,initial-scale=1',
    },
  ]

  export const loader: LoaderFunction = (args) => rootAuthLoader(args)

  export function Layout({ children }: { children: React.ReactNode }) {
    return (
      <html lang="en">
        <head>
          <Meta />
          <Links />
        </head>
        <body>
          {children}
          <ScrollRestoration />
          <Scripts />
        </body>
      </html>
    )
  }

  function App() {
    return <Outlet />
  }

  // Wrap your app with `ClerkApp`
  export default ClerkApp(App)
  ```

  ## Protect your pages

  ### Client-side

  To protect your pages on the client-side, Clerk's [prebuilt control components](/docs/components/overview#control-components) control the visibility of content based on the user's authentication state.

  The following example uses the following components:

  - [`<SignedIn>`](/docs/components/control/signed-in): Children of this component can only be seen while **signed in**.
  - [`<SignedOut>`](/docs/components/control/signed-out): Children of this component can only be seen while **signed out**.
  - [`<UserButton />`](/docs/components/user/user-button): Shows the signed-in user's avatar. Selecting it opens a dropdown menu with account management options.
  - [`<SignInButton />`](/docs/components/unstyled/sign-in-button): An unstyled component that links to the sign-in page. In this example, since no props or [environment variables](/docs/deployments/clerk-environment-variables) are set for the sign-in URL, this component links to the [Account Portal sign-in page](/docs/account-portal/overview#sign-in).

  ```tsx {{ filename: 'routes/_index.tsx' }}
  import {
    SignInButton,
    SignOutButton,
    SignUpButton,
    SignedIn,
    SignedOut,
    UserButton,
  } from '@clerk/remix'

  export default function Index() {
    return (
      <div>
        <h1>Index Route</h1>
        <SignedIn>
          <p>You are signed in!</p>

          <UserButton />
        </SignedIn>
        <SignedOut>
          <p>You are signed out</p>

          <SignInButton />
        </SignedOut>
      </div>
    )
  }
  ```

  ### Server-side

  To protect your routes, use the [`getAuth()`](/docs/references/nextjs/get-auth) function in your loader. This function retrieves the authentication state from the request object, returning an [`Auth`](/docs/references/backend/types/auth-object) object that includes the `userId`, allowing you to determine if the user is authenticated.

  ```tsx {{ filename: 'routes/_index.tsx' }}
  import { UserButton } from '@clerk/remix'
  import { getAuth } from '@clerk/remix/ssr.server'
  import { LoaderFunction, redirect } from '@remix-run/node'

  export const loader: LoaderFunction = async (args) => {
    const { userId } = await getAuth(args)
    if (!userId) {
      return redirect('/sign-in')
    }
    return {}
  }

  export default function Index() {
    return (
      <div>
        <h1>Index route</h1>
        <p>You are signed in!</p>
        <UserButton />
      </div>
    )
  }
  ```

  ## Create your first user

  Run your project with the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun dev
    ```
  </CodeBlockTabs>

  Visit your app's homepage at [`http://localhost:5173`](http://localhost:5173). Sign up to create your first user.
</Steps>

## Next steps

<Cards>
  - [Create a custom sign-in-or-up page](/docs/references/remix/custom-sign-in-or-up-page)
  - Learn how add custom sign-in-or-up page with Clerk components.

  ---

  - [Read user and session data](/docs/references/remix/read-session-data)
  - Learn how to use Clerk's hooks and helpers to access the active session and user data in your Remix app.

  ---

  - [Customization & localization](/docs/customization/overview)
  - Learn how to customize and localize the Clerk components.

  ---

  - [Clerk components](/docs/components/overview)
  - Learn more about the prebuilt components.
</Cards>

---
title: Remix SPA Mode
description: Clerk supports Remix SPA mode out-of-the-box.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    }
  ]}
/>

This guide explains how to use Clerk with [Remix in SPA mode](https://remix.run/docs/en/main/guides/spa-mode). To use Clerk with Remix in SSR mode, follow the [Remix quickstart](/docs/quickstarts/remix).

<Steps>
  ## Install `@clerk/remix`

  The [Clerk Remix SDK](/docs/references/remix/overview) gives you access to prebuilt components, hooks, and helpers to make user authentication easier.

  Run the following command to install the SDK:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/remix
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/remix
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/remix
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @clerk/remix
    ```
  </CodeBlockTabs>

  ## Set your environment variables

  <SignedIn>
    Add your Clerk Publishable Key to your `.env` file. It can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
  </SignedIn>

  <SignedOut>
    1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
    1. In the **Quick Copy** section, copy your Clerk Publishable Key.
    1. Paste your key into your `.env` file.

    The final result should resemble the following:
  </SignedOut>

  > [!WARNING]
  > You will not need the Clerk Secret Key in Remix SPA mode, as it should never be used on the client-side.

  ```env {{ filename: '.env' }}
  VITE_CLERK_PUBLISHABLE_KEY={{pub_key}}
  ```

  ## Configure `ClerkApp`

  Clerk provides a `ClerkApp` wrapper to provide the authentication state to your React tree. You must pass your Publishable Key to `ClerkApp`.

  ```tsx {{ filename: 'app/root.tsx', mark: [1, [22, 23], [25, 28]] }}
  import { ClerkApp } from '@clerk/remix'
  import { Links, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react'

  function App() {
    return (
      <html lang="en">
        <head>
          <meta charSet="utf-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1" />
          <Meta />
          <Links />
        </head>
        <body>
          <Outlet />
          <ScrollRestoration />
          <Scripts />
        </body>
      </html>
    )
  }

  // Import your Publishable Key
  const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  // Wrap your app with `ClerkApp`
  export default ClerkApp(App, {
    publishableKey: PUBLISHABLE_KEY,
  })
  ```

  ## Update your paths through `ClerkApp` options

  Next, add paths to your `ClerkApp` [options](/docs/references/remix/clerk-app#clerk-app-options) to control the behavior of the components when you sign in or sign up.

  ```ts {{ filename: 'app/root.tsx', mark: [[3, 4]] }}
  export default ClerkApp(App, {
    publishableKey: PUBLISHABLE_KEY,
    signInFallbackRedirectUrl: '/',
    signUpFallbackRedirectUrl: '/',
  })
  ```

  ## Protect your pages

  To protect your pages on the client-side, Clerk's [prebuilt control components](/docs/components/overview#control-components) control the visibility of content based on the user's authentication state.

  The following example uses the following components:

  - [`<SignedIn>`](/docs/components/control/signed-in): Children of this component can only be seen while **signed in**.
  - [`<SignedOut>`](/docs/components/control/signed-out): Children of this component can only be seen while **signed out**.
  - [`<UserButton />`](/docs/components/user/user-button): Shows the signed-in user's avatar. Selecting it opens a dropdown menu with account management options.
  - [`<SignInButton />`](/docs/components/unstyled/sign-in-button): An unstyled component that links to the sign-in page. In this example, since no props or [environment variables](/docs/deployments/clerk-environment-variables) are set for the sign-in URL, this component links to the [Account Portal sign-in page](/docs/account-portal/overview#sign-in).

  ```tsx {{ filename: 'routes/_index.tsx' }}
  import {
    SignInButton,
    SignOutButton,
    SignUpButton,
    SignedIn,
    SignedOut,
    UserButton,
  } from '@clerk/remix'

  export default function Index() {
    return (
      <div>
        <h1>Index Route</h1>
        <SignedIn>
          <p>You are signed in!</p>

          <UserButton />
        </SignedIn>
        <SignedOut>
          <p>You are signed out</p>

          <SignInButton />
        </SignedOut>
      </div>
    )
  }
  ```
</Steps>

## Next steps

<Cards>
  - [Customization & localization](/docs/customization/overview)
  - Learn how to customize and localize the Clerk components.

  ---

  - [Clerk components](/docs/components/overview)
  - Learn more about the prebuilt components.

  ---

  - [Client-side helpers](/docs/references/remix/read-session-data#client-side)
  - Learn more about our client-side helpers and how to use them.
</Cards>

---
title: Request authentication
description: Learn about various ways to make authenticated requests to the backend when using Clerk SDKs.
---

A request is considered authenticated when the backend can securely identify the user and device that is making the request. Reasons for making authenticated requests to the backend include:

- Associating the user with the action being performed
- Ensuring the user has permission to make the request
- Keeping an audit log of which device the user is performing actions from

To authenticate requests when using a Clerk SDK, you must pass Clerk's short-lived [session token](/docs/backend-requests/resources/session-tokens) to your server. The session token contains cryptographically signed claims about the user's identity and authentication state. [Read more about making requests](/docs/backend-requests/making-requests).

## Required headers

The following headers are required for Clerk to authenticate a request. It contains information that Clerk uses to determine whether a request is in a signed in or signed out state, or if a [handshake](/docs/how-clerk-works/overview#the-handshake) must be performed.

- [`Authorization`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization): This should include the user's session token as a Bearer token.
- [`Accept`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept)
- [`Host`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host)
- [`Origin`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin)
- [`Referer`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer)
- [`Sec-Fetch-Dest`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Dest)
- [`User-Agent`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent)
- [`X-Forwarded-Host`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host)
- [`X-Forwarded-Proto`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto)
  - Alternatively, you can use [`CloudFront-Forwarded-Proto`](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/adding-cloudfront-headers.html#cloudfront-headers-other)

---
title: Restrictions
description: Learn how to manage user access to your application by configuring Clerk's access restrictions.
search:
   rank: 1
   keywords:
     - allowlist
     - blocklist
     - restricted
     - restricted mode
     - waitlist
---

Clerk provides restriction options that give you enhanced control over who can access your application. These options enable you to limit sign-ups, sign-ins, or prevent accounts with specific [identifiers](/docs/authentication/configuration/sign-up-sign-in-options#identifiers), such as email addresses, phone numbers, and even entire domains, from accessing your application.

## Sign-up modes

Clerk supports multiple sign-up modes, giving you flexibility in managing user access to your application.

To configure sign-up modes:

1. In the Clerk Dashboard, navigate to the [**Restrictions**](https://dashboard.clerk.com/last-active?path=user-authentication/restrictions) page.
1. Under the **Sign-up modes** section, you can enable one of the following options:
   - **[Public](#public)**
   - **[Restricted](#restricted)**
   - **[Waitlist](#waitlist)**

### Public

In **Public** mode, the sign-up process is open to anyone. This mode is ideal for applications that want broad user access.

### Restricted

In **Restricted** mode, user access is controlled by the application admin(s). Users can be added to the application through [invitations](/docs/users/invitations), [enterprise connections](/docs/authentication/enterprise-connections/overview) or [manual user creation](/docs/users/creating-users). This mode is ideal for applications that are in private beta or internal tools.

Additional features available in **Restricted** mode:

- The [`<SignIn />`](/docs/components/authentication/sign-in) component will keep the prompt to sign up hidden by default. This is to avoid confusion for users who don't have access.

- The [`<SignUp />`](/docs/components/authentication/sign-up) is accessible only to users who have been invited and have a valid invitation link. Users who don't have access will see a message indicating that they need an invitation to sign up.

### Waitlist

![\<Waitlist /> component](/docs/images/ui-components/waitlist.svg)

> [!NOTE]
> If you're using Next.js, the`<Waitlist />` component is available in `@clerk/nextjs@6.2.0` and above.

In **Waitlist** mode, users can register their interest in your app by joining a waitlist. This mode is ideal for apps in early development stages or those wanting to generate interest before launch.

Additional features available in **Waitlist** mode:

- The [`<SignIn />`](/docs/components/authentication/sign-in) component will only be accessible to users who have been approved from the waitlist.

- The [`<SignUp />`](/docs/components/authentication/sign-up) is accessible only to users who have been invited and have a valid invitation link. Users who don't have access will see a message indicating that they need an invitation to sign up.

- The [`<Waitlist />`](/docs/components/waitlist) component provides a form where users can submit their details to join the waitlist. Once approved by admins, users will receive an email with access instructions.

- If you're using the `<Waitlist />` component, you must provide the `waitlistUrl` prop either in the [`<ClerkProvider>`](/docs/components/clerk-provider#properties) or [`<SignIn />`](/docs/components/authentication/sign-in#properties) component to ensure proper functionality.

#### Manage waitlist entries

To manage a user on your waitlist:

1. In the Clerk Dashboard, navigate to the [**Waitlist**](https://dashboard.clerk.com/last-active?path=waitlist) page.
1. On the right-side of the user's row, select the menu icon (...).
1. Select **Invite** to invite the user to your application. Select **Deny** to deny the user access to your application.

## Allowlist

> [!NOTE]
> Allowlist is a premium feature and is not available on the Free plan. [Upgrade your plan](/pricing){{ target: '_blank' }} to enable this feature.

By adding specific identifiers to the allowlist, _only_ users with those identifiers will be able to sign up or sign in to your application, while others will be blocked. This is useful for internal tools, where you want to allow only users with your company domain to have access to the application.

After creating an account, users cannot change their identifier to bypass the allowlist, making this feature a secure way to control who can access your application. For example, if you add `clerk.dev` as an allowed email domain, any user with a `@clerk.dev` email address can sign up for your application. Email addresses from different domains will not be able to sign up.

To enable this feature:

1. In the Clerk Dashboard, navigate to the [**Restrictions**](https://dashboard.clerk.com/last-active?path=user-authentication/restrictions) page.
1. In the **Allowlist** section, toggle on **Enable allowlist**.

> [!CAUTION]
> Enabling the Allowlist without adding any identifier exceptions blocks _all_ sign-ins and sign-ups.

## Blocklist

> [!NOTE]
> Blocklist is a premium feature and is not available on the Free plan. [Upgrade your plan](/pricing){{ target: '_blank' }} to enable this feature.

By adding specific identifiers to the blocklist, users with those identifiers will be blocked from signing up and signing in to your application. This is useful for attack prevention, such as when multiple spam accounts sign up for your application. For example, if you add `clerk.dev` as a blocked email domain, it means that anybody with a `@clerk.dev` email address will not be able to sign up for your application.

To enable this feature:

1. In the Clerk Dashboard, navigate to the [**Restrictions**](https://dashboard.clerk.com/last-active?path=user-authentication/restrictions) page.
1. In the **Blocklist** section, toggle on **Enable blocklist**.

> [!WARNING]
> In the case that you have enabled the allowlist and the blocklist and have added the same identifier in both, the allowlist takes precedence.

For additional security, adding an individual email address to the blocklist will also block any attempts to sign up or sign in with the email address modified to contain a subaddress. Subaddresses are identified by the presence of any of the following characters in the local part of the email address: `+`, `#`, `=`.

For example, if you add `john.doe@clerk.dev` as a blocked email address, it means that anybody with `john.doe@clerk.dev` email address will not be able to sign up for your application, including `john.doe+anything@clerk.dev` and any other subaddress.

## Block email subaddresses

**Block email subaddresses** allows you to block all email addresses that contain the characters `+`, `=` or `#` from signing up or being added to existing accounts. For example, an email address like `user+sub@clerk.com` will be blocked.

> [!NOTE]
> Existing accounts with email subaddresses will not be affected by this restriction, and will still be allowed to sign in.
>
> This feature is designed to prevent malicious sign-in attempts. The first email containing a subaddress will be allowed, but any subsequent sign-ins using additional subaddresses will be blocked.

To enable this feature:

1. In the Clerk Dashboard, navigate to the [**Restrictions**](https://dashboard.clerk.com/last-active?path=user-authentication/restrictions) page.
1. In the **Restrictions** section, toggle on **Block email subaddresses**.

### Block sign-ups that use disposable email addresses

**Block disposable email addresses** allows you to block all email addresses that are _known to be disposable_ from signing up for your application. This is useful to prevent spam accounts from signing up.

To enable this feature:

1. In the Clerk Dashboard, navigate to the [**Restrictions**](https://dashboard.clerk.com/last-active?path=user-authentication/restrictions) page.
1. In the **Restrictions** section, toggle on **Block sign-ups that use disposable email addresses**.

---
title: Roles and permissions
description: Learn about how to create and manage roles and permissions for Clerk organizations and their members.
---

Clerk supports modeling your own custom role and permissions to control access to resources within your application when you use [organizations](/docs/organizations/overview).

## Roles

Roles determine a user's level of access to the organization. You can extend a role's privileges and access to resources by adding [permissions](#permissions).

### Default roles

For each instance, there are currently two default roles:

- **Admin (`org:admin`)** - Offers full access to organization resources. Members with the admin role have all the [System Permissions](#system-permissions). They can fully manage the organization and organization memberships.
- **Member (`org:member`)** - Offers limited access to organization resources. Access to organization resources is limited to the "Read members" permission only, by default. They cannot manage the organization and organization memberships, but they can view information about other members in it.

> [!NOTE]
> If you enabled organizations for your application before December 2023, the **Admin** role is `admin` and the **Member** role is `basic_member`, instead of `org:admin` and `org:member`, respectively.

### Custom role

You can create up to 10 custom organization roles per application instance to meet your application needs. If you need more than 10 roles, [contact support](/contact/support){{ target: '_blank' }}.

Custom roles can be granted permissions and access. For example, you can create a new role of **Billing** (`org:billing`) which can be used to group users who belong to a specific department of the organization and have permission to manage credit card information, invoices, and other resources related to billing.

To learn more about creating custom roles, see the [Create roles and permissions](/docs/organizations/create-roles-permissions) guide.

### The Default role for members

The **Default** role for members is the role that users are initially assigned as a new organization member. Initially, this role is the **Member** (`org:member`) role. This is the role that is used as a pre-filled default for invitations in `<OrganizationProfile />` and for organization enrollment with [verified domains](/docs/organizations/verified-domains).

> [!WARNING]
> You can't delete a role if it's used as the organization's **Default** role. However, you can [reassign the **Default** role to another role](/docs/organizations/default-role).

### The **Creator** role

When a user creates a new organization, that user is automatically added as the organization's first member and is assigned the **Creator** role. By default, **Admin** (`org:admin`) is the **Creator** role.

> [!WARNING]
> You can't delete a role if it's used as the organization's **Creator** role. However, you can [reassign the **Creator** role to another role](/docs/organizations/creator-role).

## Permissions

Permissions grant users privileged access to resources and operations, like creating and deleting. Clerk supports two types of permissions: System and Custom.

### System permissions

Clerk provides a set of system permissions that power [Clerk's Frontend API](/docs/reference/frontend-api){{ target: '_blank' }} and [organization-related Clerk components](/docs/components/overview). These permissions serve as the baseline required for Clerk to operate effectively.

Clerk's system permissions consist of the following:

- Manage Organization (`org:sys_profile:manage`)
- Delete Organization (`org:sys_profile:delete`)
- Read members (`org:sys_memberships:read`)
- Manage members (`org:sys_memberships:manage`)
- Read domains (`org:sys_domains:read`)
- Manage domains (`org:sys_domains:manage`)

You can assign these system permissions to any role.

> [!WARNING]
> System permissions aren't included in [session claims](/docs/backend-requests/resources/session-tokens#default-claims). To check permissions on the server-side, you must [create custom permissions](/docs/organizations/create-roles-permissions).

### Custom permissions

When creating a new permission, follow the format `org:<feature>:<action>`. You can then assign the permission to an existing role.

For example, you could create a new role called **Sales** (`org:sales`) and a new permission called **Create invoices** (`org:invoices:create`) which allows only users with this permission to edit invoices. You could also grant this permission to the **Billing** role.

To learn more about creating custom permissions, see the [Create roles and permissions](/docs/organizations/create-roles-permissions) guide.

## Next steps

- [Learn how to create roles and permissions in the Clerk Dashboard](/docs/organizations/create-roles-permissions)
- [Learn how to use roles and permissions to limit the content a user can see with the prebuilt `<Protect>` component](/docs/components/protect)
- [Learn how to allow and limit access to resources by role and permissions](/docs/organizations/verify-user-permissions)
- [Learn how to reassign the **Creator** role](/docs/organizations/creator-role)

---
title: Route Handlers
description: Learn how to use Clerk with your Route Handlers.
---

Clerk provides helpers that allow you to protect your Route Handlers, fetch the current user, and interact with the Clerk Backend API.

## Protect your Route Handlers

If you aren't protecting your Route Handler using [`clerkMiddleware()`](/docs/references/nextjs/clerk-middleware), you can protect your Route Handler in two ways:

- Use [`auth.protect()`](/docs/references/nextjs/auth#auth-protect) if you want Clerk to return a `404` error when there is no signed in user.
- Use [`auth().userId`](/docs/references/nextjs/auth#protect-pages-and-routes) if you want to customize the behavior or error message.

<CodeBlockTabs options={["auth.protect()", "auth().userId()"]}>
  ```tsx {{ filename: 'app/api/route.ts' }}
  import { auth } from '@clerk/nextjs/server'

  export async function GET() {
    // If there is no signed in user, this will return a 404 error
    await auth.protect()

    // Add your Route Handler logic here

    return Response.json({ message: 'Hello world!' })
  }
  ```

  ```tsx {{ filename: 'app/api/route.ts' }}
  import { auth } from '@clerk/nextjs/server'
  import { NextResponse } from 'next/server'

  export async function GET() {
    const { userId } = await auth()

    if (!userId) {
      return NextResponse.json({ error: 'Error: No signed in user' }, { status: 401 })
    }

    // Add your Route Handler logic here

    return NextResponse.json({ userId })
  }
  ```
</CodeBlockTabs>

## Retrieve data from external sources

Clerk provides integrations with a number of popular databases.

The following example demonstrates how to use [`auth().getToken()`](/docs/references/backend/types/auth-object#get-token) to retrieve a token from a JWT template and use it to fetch data from the external source.

```ts {{ filename: 'app/api/route.ts' }}
import { NextResponse } from 'next/server'
import { auth } from '@clerk/nextjs/server'
export async function GET() {
  const { userId, getToken } = await auth()

  if (!userId) {
    return new Response('Unauthorized', { status: 401 })
  }

  const token = await getToken({ template: 'supabase' })

  // Fetch data from Supabase and return it.
  const data = { supabaseData: 'Hello World' }

  return NextResponse.json({ data })
}
```

## Retrieve the current user

In some cases, you might need the current user in your Route Handler. Clerk provides an asynchronous helper called [`currentUser()`](/docs/references/nextjs/current-user) to retrieve the current [`Backend User`](/docs/references/backend/types/backend-user) object.

```ts {{ filename: 'app/api/route.ts' }}
import { NextResponse } from 'next/server'
import { currentUser } from '@clerk/nextjs/server'
export async function GET() {
  const user = await currentUser()

  if (!user) {
    return new Response('Unauthorized', { status: 401 })
  }

  return NextResponse.json({ user })
}
```

## Interact with Clerk's Backend API

The [JavaScript Backend SDK](/docs/references/backend/overview) exposes the [Backend API](/docs/reference/backend-api){{ target: '_blank' }} resources and low-level authentication utilities for JavaScript environments.

`clerkClient` exposes an instance of the JavaScript Backend SDK for use in server environments.

```ts {{ filename: 'app/api/route.ts' }}
import { NextResponse, NextRequest } from 'next/server'
import { auth, clerkClient } from '@clerk/nextjs/server'

export async function POST(req: NextRequest) {
  const { userId } = await auth()

  if (!userId) return NextResponse.redirect(new URL('/sign-in', req.url))

  const params = { firstName: 'John', lastName: 'Wick' }

  const client = await clerkClient()

  const user = await client.users.updateUser(userId, params)

  return NextResponse.json({ user })
}
```

---
title: Routing in Clerk
description: Learn how Clerk handles routing in your application.
---

Some of Clerk's components have their own internal routing.

For example, say a user uses their email address to fill out the [`<SignUp />`](/docs/components/authentication/sign-up) form. Once they submit the form, they are redirected from `/sign-up` to `/sign-up/verify-email-address`, which renders Clerk's UI for verifying a user's email address. This redirect is handled by Clerk's internal routing.

## `routing` prop

The following Clerk components accept a `routing` prop in order to define the routing strategy:

- [`<SignUp />`](/docs/components/authentication/sign-up)
- [`<SignIn />`](/docs/components/authentication/sign-in)
- [`<UserProfile />`](/docs/components/user/user-profile)
- [`<CreateOrganization />`](/docs/components/organization/create-organization)
- [`<OrganizationProfile />`](/docs/components/organization/organization-profile)

There following routing strategies can be passed:

- [`path`](#path-routing)
- [`hash`](#hash-routing)

Clerk will attempt to select the routing strategy that best integrates with your framework of choice. If for some reason the default routing strategy doesn't work for you, use the information below to pick a strategy that will work for your setup.

### `path` routing

`path` routing uses the path in the URL to determine the route. This is useful for server-rendered pages where SEO and server-side routing are crucial, such as Next.js or Remix applications.

For example, say you have a Clerk + Next.js application with the `<SignUp />` component on a dedicated `/sign-up` page. A user visit this page and uses their email address to fill out the `<SignUp />` form. Once they submit the form, they are redirected from `/sign-up` to `/sign-up/verify-email-address`.

For the following SDKs, `path` routing is set _by default_ on all Clerk components, as these frameworks support server-side routing out-of-the-box. There is no need to pass the `routing` or `path` props to Clerk components in these frameworks.

- Next.js
- Remix
- Tanstack React Start
- React Router

### `hash` routing

`hash` routing uses [the hash (#) portion of the URL](https://developer.mozilla.org/en-US/docs/Web/API/URL/hash) to determine the route. This is useful for single-page applications that use client-side routing.

For example, say you have a Clerk + React application with the `<SignUp />` component on a dedicated `/sign-up` page. A user visit this page and uses their email address to fill out the `<SignUp />` form. Once they submit the form, they are redirected from `/sign-up` to `/sign-up#verify-email-address`.

In Clerk applications that use any SDK other than Next.js or Remix, `hash` routing is set _by default_ on all Clerk components.

---
title: Ruby on Rails integration
description: The Clerk Ruby SDK provides a Rack middleware and a gem to integrate Clerk into your Rails app.
---

The Clerk Ruby SDK provides a seamless integration with Ruby on Rails through a Rack middleware and dedicated Rails helpers. When you add the Clerk gem to your Rails application, the middleware is automatically included in your application's middleware stack.

<Steps>
  ## Install `clerk-sdk-ruby`

  <Include src="_partials/ruby/installation" />

  ## Configuration

  <Include src="_partials/ruby/configuration" />
</Steps>

## Example: Access the `clerk` object

To access Clerk's authentication functionality in your controllers, include the `Clerk::Authenticatable` concern. This gives your controller and views access to the `clerk` helper, which provides access to the current session claims such as `clerk.user` and `clerk.organization`.

```ruby {{ filename: 'app/controllers/application_controller.rb' }}
class ApplicationController < ActionController::Base
  include Clerk::Authenticatable

  private

  # If the user is not authenticated, redirect to the sign-in page
  def require_clerk_session!
    # The `CLERK_SIGN_IN_URL` env var must be set or the `sign_in_url` method will fail
    redirect_to clerk.sign_in_url unless clerk.session
  end
end
```

## Example: Protect routes

To protect specific controllers or actions, you can add a `before_action` callback that uses the `require_clerk_session!` method to check for an authenticated Clerk session. This is particularly useful for securing admin sections or sensitive operations.

```ruby
class AdminController < ApplicationController
  # Protect routes with the `require_clerk_session!` method
  before_action :require_clerk_session!

  def index
    # ...
  end
end
```

## Example: Reverification

For actions requiring additional security, Clerk provides a `:require_reverification!` filter that prompts users to re-authenticate. This filter accepts an optional [preset](/docs/references/ruby/overview#reverification) parameter to customize the reverification requirements.

In the following example, all actions in the `AdminController` will be protected from unauthenticated users. If the user is authenticated, they will be required to reverify their session before accessing the `destroy` action.

```ruby
class AdminController < ApplicationController
  # Protect routes with the `require_clerk_session!` method
  before_action :require_clerk_session!
  # Protect `destroy` with the `require_reverification!` method
  # Reverification preset is set to `LAX`
  before_action :require_reverification!, only: :destroy, preset: Clerk::StepUp::Preset::LAX


  def index
    # ...
  end

  def destroy
    # ...
  end
end
```

---
title: Ruby Quickstart
description: Learn how to use Clerk to quickly and easily add secure authentication and user management to your Ruby application.
---

<TutorialHero
  exampleRepo={[
    {
      title: "Ruby Quickstart Repo",
      link: "https://github.com/clerk/clerk-sdk-ruby/tree/main/apps"

    }
  ]}
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    }
  ]}
/>

Learn how to use Clerk to quickly and easily add secure authentication and user management to your Ruby app. If you would like to use a framework, see the [reference docs](/docs/references/ruby/overview).

<Steps>
  ## Install `clerk-sdk-ruby`

  <Include src="_partials/ruby/installation" />

  ## Configuration

  <Include src="_partials/ruby/configuration" />

  ## Instantiate a `Clerk::SDK` instance

  All available methods are listed in the [Ruby HTTP Client documentation](https://github.com/clerk/clerk-http-client-ruby/tree/main/.generated#documentation-for-api-endpoints){{ target: '_blank' }}. The Ruby HTTP Client is a generated wrapper around the [Backend API](/docs/reference/backend-api){{ target: '_blank' }} that provides a more Ruby-friendly interface.

  To access available methods, you must instantiate a `Clerk::SDK` instance.

  ```ruby
  sdk = Clerk::SDK.new

  create_user_request = Clerk::SDK::CreateUserRequest.new(
    first_name: "John",
    last_name: "Doe",
    email_address: ["john.doe@example.com"],
    password: "password"
  )

  # Create a user
  sdk.users.create(create_user_request)

  # List all users and ensure the user was created
  sdk.users.get_user_list

  # Get the first user created in your instance
  user = sdk.users.get_user_list(limit: 1).first

  # Use the user's ID to lock the user
  sdk.users.lock_user(user["id"])

  # Then, unlock the user so they can sign in again
  sdk.users.unlock_user(user["id"])
  ```
</Steps>

## Next steps

<Cards>
  - [Ruby SDK Reference](/docs/references/ruby/overview)
  - Learn more about the Ruby SDK.

  ---

  - [Deploy to Production](/docs/deployments/overview)
  - Learn how to deploy your Clerk app to production.
</Cards>

---
title: Ruby with Rack
description: The Clerk Ruby SDK provides a Rack middleware to integrate Clerk into your Rack-based application.
---

The Clerk Ruby SDK provides a Rack middleware to integrate Clerk into your Rack-based application.

<Steps>
  ## Install `clerk-sdk-ruby`

  <Include src="_partials/ruby/installation" />

  ## Configuration

  <Include src="_partials/ruby/configuration" />

  ## Add Clerk's Rack middleware

  Add the Clerk middleware to your Rack application by updating your `config.ru` file with the following code:

  ```ruby {{ filename: 'config.ru' }}
  require "rack"
  require "clerk/rack"

  require_relative "app"

  use Clerk::Rack::Middleware
  run App.new
  ```

  ## Access the `clerk` object

  Once you've added the middleware, you can access the `clerk` object in your actions and views. The `clerk` object provides access to the [Ruby SDK's available methods](/docs/references/ruby/overview#available-methods).

  The following example demonstrates a simple Rack application that protects all routes. If the user is authenticated, it returns the user's first name and ID. If the user is not authenticated, it returns a `401` status code.

  ```ruby {{ filename: 'app.rb' }}
  require "erb"
  require "clerk"

  class App
    def call(env)
      clerk = env["clerk"]

      # Check if the user is authenticated
      user = clerk.user
      user ?
        [200, {"Content-Type" => "text/plain"}, ["Authenticated User: #{user.first_name} (#{user.id})"]]:
        [401, {"Content-Type" => "text/plain"}, ["Not Authenticated"]]
    end
  end
  ```
</Steps>

## Example: Reverification

The reverification feature provides an additional layer of security by requiring users to reverify their session before accessing sensitive routes.

There are two ways to handle reverification in a Rack application:

1. [In your middleware](#in-your-middleware)
1. [In your application logic](#in-your-application-logic)

### In your middleware

To handle reverification in your Rack middleware, use the `Clerk::Rack::Reverification` middleware. It accepts an optional [preset](/docs/references/ruby/overview#reverification) parameter to customize the reverification requirements and an optional `routes` parameter to specify which routes should be protected.

In the following example, the reverification preset is set to `LAX` and reverification is required for all routes that match the `/*` pattern.

```ruby {{ filename: 'config.ru' }}
require "rack"
require "clerk/rack"

require_relative "app"

use Clerk::Rack::Middleware
# Reverification preset is set to `LAX`
use Clerk::Rack::Reverification,
  preset: Clerk::StepUp::Preset::LAX,
  routes: ["/*"]

run App.new
```

### In your application logic

To handle reverification in your app logic,

- Use the `clerk.user_needs_reverification?` method to check if the user needs to reverify their session, which accepts an optional [preset](/docs/references/ruby/overview#reverification) parameter to customize the reverification requirements.
- Use the `clerk.user_reverification_rack_response` method to get the response.

The following example demonstrates a simple Rack application that requires authentication and reverification for all routes.

```ruby {{ filename: 'app.rb' }}
require "erb"
require "clerk"

STEP_UP_PRESET = Clerk::StepUp::Preset::LAX

class App
  def call(env)
    clerk = env["clerk"]

    # Check if the user needs to reverify their session
    if clerk.user_needs_reverification?(STEP_UP_PRESET)
      # Get the response
      return clerk.user_reverification_rack_response(STEP_UP_PRESET)
    end

    # Check if the user is authenticated
    user = clerk.user
    user ?
      [200, {"Content-Type" => "text/plain"}, ["Authenticated User: #{user.first_name} (#{user.id})"]]:
      [401, {"Content-Type" => "text/plain"}, ["Not Authenticated"]]
  end
end
```

---
title: Script loading
description: Troubleshooting strategies for cases when Clerk doesn't successfully load
---

It sometimes might happen that Clerk doesn't successfully load and initialize during page rendering. This could happen for a myriad of reasons, including but not limited to:

- You have no internet connection
- The CDN which is used for the [ClerkJS script](/docs/references/javascript/overview) is offline or blocked
- Another script is colliding with Clerk
- Missing or invalid Publishable Key

Check your internet access and that e.g. no Ad-Blocker is blocking Clerk's scripts.

If Clerk stops working after you've added another script (e.g. through a React component), you can try delaying the loading of that other script. For example, to only mount `@monaco-editor/react` after Clerk loaded you can use the [`useClerk()` hook](/docs/hooks/use-clerk):

```jsx
import { Editor } from '@monaco-editor/react'
import { useClerk } from '@clerk/nextjs'

export default function Home() {
  const clerk = useClerk()

  return <main>{clerk.loaded && <Editor />}</main>
}
```

---
title: SDK development
description: A reference for implementing a new Clerk SDK from scratch.
---

Clerk believes that truly optimal developer experience can only be achieved by building SDKs independently for each framework. Each framework differentiates itself with nuanced patterns, and it's important to lean into those patterns to avoid feeling like a square peg in a round hole.

The following guides provide contributors with all the necessary guidance on how to build a new SDK from scratch.

> [!TIP]
> Need help while developing a new SDK? Join the `#sdk-community-devs` channel on [Discord](https://clerk.com/discord) to chat with fellow SDK maintainers. You can also look at existing SDKs [on GitHub](https://github.com/clerk/javascript). **Note:** Clerk does not have an official support system for community developers.

## Get started

Before building a new Clerk SDK, familiarize yourself with terminology and core concepts:

- [Terminology](/docs/references/sdk/terminology)
- [Philosophy](/docs/references/sdk/philosophy)
- [Conventions](/docs/references/sdk/conventions)
- [SDK Types](/docs/references/sdk/types)

## Guides

After understanding the fundamentals, follow these guides to start developing your SDK:

- [Frontend-only SDK](/docs/references/sdk/frontend-only)
- [Backend-only SDK](/docs/references/sdk/backend-only)
- [Fullstack SDK](/docs/references/sdk/fullstack)

---
title: SDK References
description: Learn about the Clerk and community SDK's available for integrating Clerk into your application.
---

{/* TODO: Keep aligned with /index */}

## Frontend SDKs

<Cards>
  - [Next.js](/docs/references/nextjs/overview)
  - Easily add secure, beautiful, and fast authentication to Next.js with Clerk.
  - {<Include src="_partials/icons/nextjs" />}

  ---

  - [React](/docs/references/react/overview)
  - Get started installing and initializing Clerk in a new React + Vite app.
  - {<Include src="_partials/icons/react" />}

  ---

  - [Astro](/docs/references/astro/overview)
  - Easily add secure and SSR-friendly authentication to your Astro application with Clerk.
  - {<Include src="_partials/icons/astro" />}

  ---

  - [Chrome Extension](/docs/references/chrome-extension/overview)
  - Use the Chrome Extension SDK to authenticate users in your Chrome extension.
  - {<Include src="_partials/icons/chrome-extension" />}

  ---

  - [Expo](/docs/references/expo/overview)
  - Use Clerk with Expo to authenticate users in your React Native application.
  - {<Include src="_partials/icons/expo" />}

  ---

  - [iOS](/docs/references/ios/overview)
  - Use the Clerk iOS SDK to authenticate users in your native Apple applications.
  - {<Include src="_partials/icons/ios" />}

  ---

  - [JavaScript](/docs/references/javascript/overview)
  - The Clerk JavaScript SDK gives you access to prebuilt components and helpers to make user authentication easier.
  - {<Include src="_partials/icons/javascript" />}

  ---

  - [Nuxt](/docs/references/nuxt/overview)
  - Easily add secure, beautiful, and fast authentication to Nuxt with Clerk.
  - {<Include src="_partials/icons/nuxt" />}

  ---

  - [React Router](/docs/references/react-router/overview)
  - Easily add secure, edge- and SSR-friendly authentication to React Router with Clerk.
  - {<Include src="_partials/icons/react-router" />}

  ---

  - [Remix](/docs/references/remix/overview)
  - Easily add secure, edge- and SSR-friendly authentication to Remix with Clerk.
  - {<Include src="_partials/icons/remix" />}

  ---

  - [TanStack React Start (beta)](/docs/references/tanstack-react-start/overview)
  - Easily add secure and SSR-friendly authentication to your TanStack React Start application with Clerk.
  - {<Include src="_partials/icons/tanstack-start" />}

  ---

  - [Vue](/docs/references/vue/overview)
  - Get started installing and initializing Clerk in a new Vue + Vite app.
  - {<Include src="_partials/icons/vue" />}
</Cards>

## Backend SDKs

<Cards>
  - [JS Backend SDK](/docs/references/backend/overview)
  - The Clerk Backend SDK exposes our Backend API resources and low-level authentication utilities for JavaScript environments.
  - {<Include src="_partials/icons/backend-sdk" />}

  ---

  - [C#](https://github.com/clerk/clerk-sdk-csharp/blob/main/README.md)
  - The Clerk C# SDK is a wrapper around our Backend API to make it easier to integrate Clerk into your backend.
  - {<Include src="_partials/icons/c-sharp" />}

  ---

  - [Express](/docs/references/express/overview)
  - Quickly add authentication and user management to your Express application.
  - {<Include src="_partials/icons/express" />}

  ---

  - [Go](/docs/references/go/overview)
  - The Clerk Go SDK is a wrapper around the Backend API written in Golang to make it easier to integrate Clerk into your backend.
  - {<Include src="_partials/icons/go" />}

  ---

  - [Fastify](/docs/references/fastify/overview)
  - Build secure authentication and user management flows for your Fastify server.
  - {<Include src="_partials/icons/fastify" />}

  ---

  - [Python](https://github.com/clerk/clerk-sdk-python/blob/main/README.md)
  - The Clerk Python SDK is a wrapper around the Backend API written in Python to make it easier to integrate Clerk into your backend.
  - {<Include src="_partials/icons/python" />}

  ---

  - [Ruby on Rails](/docs/references/ruby/overview)
  - Integrate authentication and user management into your Ruby application.
  - {<Include src="_partials/icons/ruby.mdx" />}
</Cards>

## Build with community-maintained SDKs

<Include src="_partials/community-sdks" />

<Include src="_partials/help" />

---
title: SDK types
description: "Learn about the three different types of SDKs: frontend-only, backend-only, and fullstack."
---

Clerk categorizes its SDKs into three different types:

- Frontend-only
- Backend-only
- Fullstack

Take a look at your framework and check which type it enables. Then place your SDK into one of these three categories when first creating it. Arguably, creating a fullstack SDK is the most work so feel free to start off with frontend-only/backend-only SDK  you can still make it fullstack at a later point. Also, the framework youre building the SDK for might evolve in the future, so maybe naturally your SDK will also need to change over time.

| SDK Type | FAPI HTTP client | BAPI HTTP client | Hotloading ClerkJS | `window.Clerk` UI components | Authorization header verification | `__session` cookie verification | Handshake support |
| - | - | - | - | - | - | - | - |
| Frontend-only |  | |  |  | | | |
| Backend-only | |  | | |  |  | |
| Fullstack |  |  |  |  |  |  |  |

## Frontend-only

Frontend-only SDKs are used in frameworks that only support client-side rendering (CSR) or static site generation (SSG) with rehydration. The app is rendered in the browser using JavaScript and this bundle doesnt contain any authenticated information itself but uses client-side code to fetch the authenticated data.

**Examples:** Vite React, Vue, iOS/Swift

**SDK Examples:** [`@clerk/clerk-react`](https://github.com/clerk/javascript/tree/main/packages/react)

## Backend-only

Backend-only SDKs are used in frameworks to build APIs without directly serving HTML. They provide authenticated data to power your frontend.

**Examples:** Express.js/Hono with a Vite React/Vue frontend

**SDK Examples:** [`@clerk/express`](https://github.com/clerk/javascript/tree/main/packages/express), `@hono/clerk-auth`, [`clerk-sdk-go`](https://github.com/clerk/clerk-sdk-go)

## Fullstack

Fullstack SDKs are used in frameworks that support SSR and subsequently can render HTML from a server with authenticated data.

**Examples:** Next.js, Rails

**SDK Examples:** [`@clerk/nextjs`](https://github.com/clerk/javascript/tree/main/packages/nextjs), [`clerk-sdk-ruby`](https://github.com/clerk/clerk-sdk-ruby)

---
title: Security
description: Account security is Clerk's most important responsibility and the top concern of every feature we build. Maintaining best-practice account security has become too challenging and time-consuming for most organizations, and we have seen too many organizations cut corners as a result.
---

Account security is Clerk's most important responsibility and the top concern of every feature we build. Maintaining best-practice account security has become too challenging and time-consuming for most organizations, and we have seen too many organizations cut corners as a result.

Clerk has a secure-by-default philosophy. Our goal is to help customers overcome as many challenges as possible without additional configuration, and we work to avoid options that may lead to an insecure application.

This documentation lists some of the many protections included with Clerk. These features do not cost extra  they are included for every application by default.

- [Vulnerability disclosure policy](/docs/security/vulnerability-disclosure-policy)
- [XSS Leak Protection](/docs/security/xss-leak-protection)
- [CSRF Protection](/docs/security/csrf-protection)
- [Fixation Protection](/docs/security/fixation-protection)
- [Password protection and rules](/docs/security/password-protection)
- [Brute force protection and user account locking](/docs/security/user-lock-guide)

If we are missing a protection you'd like to see, [contact support](/contact/support){{ target: '_blank' }}.

---
title: Server Actions
description: Learn how to use Clerk with Server Actions.
---

Clerk provides helpers to allow you to protect your Server Actions, fetch the current user, and interact with the Clerk API.

The following guide provides examples for using Server Actions in Server Components and in Client Components.

## With Server Components

### Protect your Server Actions

You can use the [`auth()`](/docs/references/nextjs/auth) helper to protect your server actions. This helper will return the current user's ID if they are signed in, or `null` if they are not.

```tsx {{ filename: 'actions.ts' }}
import { auth } from '@clerk/nextjs/server'

export default function AddToCart() {
  async function addItem(formData: FormData) {
    'use server'

    const { userId } = await auth()

    if (!userId) {
      throw new Error('You must be signed in to add an item to your cart')
    }

    console.log('add item server action', formData)
  }

  return (
    <form action={addItem}>
      <input value={'test'} type="text" name="name" />
      <button type="submit">Add to Cart</button>
    </form>
  )
}
```

When performing organization-related operations, you can use `auth().orgId` to check a user's organization ID before performing an action.

```tsx {{ filename: 'actions.ts' }}
import { auth } from '@clerk/nextjs/server'

export default function AddVerifiedDomain() {
  async function addVerifiedDomain(formData: FormData) {
    'use server'

    const { userId, orgId } = await auth()

    if (!userId) {
      throw new Error('You must be signed in to add a verified domain')
    }

    if (!orgId) {
      throw new Error('No active organization found. Set one as active or create/join one')
    }

    const domain = formData.get('domain')?.toString()
    if (!domain) {
      throw new Error('Domain is required')
    }

    await clerkClient().organizations.createOrganizationDomain({
      organizationId: orgId,
      name: domain,
      enrollmentMode: 'automatic_invitation',
    })

    console.log(`Added domain ${domain} to organization ${orgId}`)
  }

  return (
    <form action={addVerifiedDomain}>
      <input placeholder="example.com" type="text" name="domain" />
      <button type="submit">Add Domain</button>
    </form>
  )
}
```

### Accessing the current user

Current user data is important for data enrichment. You can use the [`currentUser()`](/docs/references/nextjs/current-user) helper to fetch the current user's data in your server actions.

```tsx {{ filename: 'app/page.tsx' }}
import { currentUser } from '@clerk/nextjs/server'

export default function AddHobby() {
  async function addHobby(formData: FormData) {
    'use server'

    const user = await currentUser()

    if (!user) {
      throw new Error('You must be signed in to use this feature')
    }

    const serverData = {
      usersHobby: formData.get('hobby'),
      userId: user.id,
      profileImage: user.imageUrl,
    }

    console.log('add item server action completed with user details ', serverData)
  }

  return (
    <form action={addHobby}>
      <input value={'soccer'} type="text" name="hobby" />
      <button type="submit">Submit your hobby</button>
    </form>
  )
}
```

## With Client Components

When using Server Actions in Client Components, you need to make sure you use prop drilling to ensure that headers are available.

### Protect your Server Actions

Use the following tabs to see an example of how to protect a Server Action that is used in a Client Component.

<CodeBlockTabs options={["Server Action", "Client Component", "Page"]}>
  ```tsx {{ filename: 'app/actions.ts' }}
  'use server'
  import { auth } from '@clerk/nextjs/server'

  export async function addItem(formData: FormData) {
    const { userId } = await auth()

    if (!userId) {
      throw new Error('You must be signed in to add an item to your cart')
    }

    console.log('add item server action', formData)
  }
  ```

  ```tsx {{ filename: 'app/components/AddItem.tsx' }}
  'use client'

  export default function AddItem({ addItem }) {
    return (
      <form action={addItem}>
        <input value={'test'} type="text" name="name" />
        <button type="submit">Add to Cart</button>
      </form>
    )
  }
  ```

  ```tsx {{ filename: 'app/page.tsx' }}
  import AddItem from './components/AddItem'
  import { addItem } from './actions'
  export default function Hobby() {
    return <AddItem addItem={addItem} />
  }
  ```
</CodeBlockTabs>

### Accessing the current user

Use the following tabs to see an example of how to access the current user in a Server Action that is used in a Client Component.

<CodeBlockTabs options={["Server Action", "Client Component", "Page"]}>
  ```tsx {{ filename: 'app/actions.ts' }}
  'use server'
  import { currentUser } from '@clerk/nextjs/server'

  export async function addHobby(formData: FormData) {
    const user = await currentUser()

    if (!user) {
      throw new Error('You must be signed in to use this feature')
    }

    const serverData = {
      usersHobby: formData.get('hobby'),
      userId: user.id,
      profileImage: user.imageUrl,
    }

    console.log('add Hobby completed with user details ', serverData)
  }
  ```

  ```tsx {{ filename: 'app/components/AddHobby.tsx' }}
  'use client'

  export default function UI({ addHobby }) {
    return (
      <form action={addHobby}>
        <input value={'soccer'} type="text" name="hobby" />
        <button type="submit">Submit your hobby</button>
      </form>
    )
  }
  ```

  ```tsx {{ filename: 'app/page.tsx' }}
  import AddHobby from './components/AddHobby'
  import { addHobby } from './actions'
  export default function Hobby() {
    return <AddHobby addHobby={addHobby} />
  }
  ```
</CodeBlockTabs>

---
title: Session
description: The Session object is an abstraction over an HTTP session. It models the period of information exchange between a user and the server.
---

The `Session` object is an abstraction over an HTTP session. It models the period of information exchange between a user and the server.

The `Session` object includes methods for recording session activity and ending the session client-side. For security reasons, sessions can also expire server-side.

As soon as a [`User`](/docs/references/javascript/user) signs in, Clerk creates a `Session` for the current [`Client`][client-ref]. Clients can have more than one sessions at any point in time, but only one of those sessions will be **active**.

In certain scenarios, a session might be replaced by another one. This is often the case with [multi-session applications](/docs/authentication/configuration/session-options#multi-session-applications).

All sessions that are **expired**, **removed**, **replaced**, **ended** or **abandoned** are not considered valid.

> [!NOTE]
> For more information regarding the different session states, see the [guide on session management](/docs/authentication/configuration/session-options).

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for the session.

  ---

  - `user`
  - [`User`](/docs/references/javascript/user)

  The user associated with the session.

  ---

  - `publicUserData`
  - [`PublicUserData`](/docs/references/javascript/types/public-user-data)

  Public information about the user that this session belongs to.

  ---

  - `status`
  - [`SessionStatus`](/docs/references/javascript/types/session-status)

  The current state of the session.

  ---

  - `lastActiveAt`
  - `Date`

  The time the session was last active on the [`Client`][client-ref].

  ---

  - `abandonAt`
  - `Date`

  The time when the session was abandoned by the user.

  ---

  - `expireAt`
  - `Date`

  The time the session expires and will cease to be active.

  ---

  - `updatedAt`
  - `Date`

  The last time the session recorded activity of any kind.

  ---

  - `createdAt`
  - `Date`

  The date when the session was created.

  ---

  - `lastActiveToken`
  - `TokenResource | null`

  The last active token for the session

  ---

  - `lastActiveOrganizationId`
  - `string | null`

  The ID of the last active organization.

  ---

  - `factorVerificationAge`
  - `[number, number] | null`

  An array where each item represents the number of minutes since the last verification of a first or second factor: `[firstFactorAge, secondFactorAge]`.

  ---

  - `actor`
  - `ActJWTClaim | null`

  The JWT actor for the session. Holds identifier for the user that is impersonating the current user. Read more about [impersonation](/docs/users/user-impersonation).
</Properties>

## Methods

### `attemptFirstFactorVerification()`

Attempts to complete the first factor verification process. Returns a [`SessionVerification`](/docs/references/javascript/types/session-verification) instance with its status and supported factors.

```typescript
function attemptFirstFactorVerification(
  params: SessionVerifyAttemptFirstFactorParams,
): Promise<SessionVerificationResource>
```

#### `SessionVerifyAttemptFirstFactorParams`

```ts
type SessionVerifyAttemptFirstFactorParams = EmailCodeAttempt | PhoneCodeAttempt | PasswordAttempt

type EmailCodeAttempt = {
  strategy: 'email_code'
  code: string
}

type PhoneCodeAttempt = {
  strategy: 'phone_code'
  code: string
}

type PasswordAttempt = {
  strategy: 'password'
  password: string
}
```

#### Example

```js
await clerk.session.attemptFirstFactorVerification({
  strategy: 'email_code',
  code: '123456',
})
```

### `attemptSecondFactorVerification()`

Attempts to complete the second factor verification process. Returns a [`SessionVerification`](/docs/references/javascript/types/session-verification) instance with its status and supported factors.

```typescript
function attemptSecondFactorVerification(
  params: SessionVerifyAttemptSecondFactorParams,
): Promise<SessionVerificationResource>
```

#### `SessionVerifyAttemptSecondFactorParams`

```ts
type SessionVerifyAttemptSecondFactorParams = PhoneCodeAttempt | TOTPAttempt | BackupCodeAttempt

type PhoneCodeAttempt = {
  strategy: 'phone_code'
  code: string
}

type TOTPAttempt = {
  strategy: 'totp'
  code: string
}

type BackupCodeAttempt = {
  strategy: 'backup_code'
  code: string
}
```

#### Example

```js
await clerk.session.attemptSecondFactorVerification({
  strategy: 'phone_code',
  code: '123456',
})
```

### `checkAuthorization()`

Checks if the user is authorized for the specified role or permission.

```ts
function checkAuthorization(param: CheckAuthorizationParams): boolean
```

#### `CheckAuthorizationParams`

```typescript
type CheckAuthorizationParams =
  | {
      role: ClerkDefaultRole | CustomRole
      permission?: never
    }
  | {
      role?: never
      permission: ClerkDefaultPermission | CustomPermission
    }
```

<Properties>
  - `role`
  - `string`

  Accepts [role](/docs/organizations/roles-permissions#roles) key

  ---

  - `permission`
  - `string`

  Accepts [permission](/docs/organizations/roles-permissions#permissions) key

  ---

  - `reverification?`
  - <code>[ReverificationConfig](/docs/references/backend/types/auth-object#reverification-config)</code>

  The reverification configuration to check for.
</Properties>

#### Example

```js
await clerk.session.checkAuthorization({
  role: 'admin',
})
```

### `end()`

Terminates the current session, invalidating it for this `Client` instance. Upon completion, the session's status transitions to **ended** and all associated authentication tokens are revoked. This operation cannot be undone and requires re-authentication to establish a new session.

```typescript
function end(): Promise<Session>
```

#### Example

```js
await clerk.session.end()
```

### `getToken()`

Retrieves the current user's [session token](/docs/backend-requests/resources/session-tokens) or a [custom JWT template](/docs/backend-requests/jwt-templates).

This method uses a cache so a network request will only be made if the token in memory has expired. The TTL for a Clerk token is one minute.

Tokens can only be generated if the user is signed in.

```typescript
function getToken(options?: GetTokenOptions): Promise<string | null>
```

#### `GetTokenOptions`

<Properties>
  - `leewayInSeconds`
  - `number`

  The number of seconds to allow the token to be cached for.

  ---

  - `template?`
  - `string`

  The name of the JWT template from the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=jwt-templates) to generate a new token from. E.g. 'firebase', 'grafbase', or your custom template's name.

  ---

  - `throwOnError?`
  - `boolean`

  Whether to throw an error or return an empty string, if an error occurs.

  ---

  - `skipCache?`
  - `boolean`

  Whether to skip the cache lookup and force a call to the server instead, even within the TTL. Useful if the token claims are time-sensitive or depend on data that can be updated (e.g. user fields). Defaults to `false`.

  ---

  - `organizationId?`
  - `string`

  The organization associated with the generated session token. _Does not modify the session's currently active organization._
</Properties>

#### Example

```js
await clerk.session.getToken({ template: 'Test' })
```

### `prepareFirstFactorVerification()`

Initiates the first factor verification process. This is a required step to complete a reverification flow when using a preparable factor. Returns a [`SessionVerification`](/docs/references/javascript/types/session-verification) instance with its status and supported factors.

```typescript
function prepareFirstFactorVerification(
  params: SessionVerifyPrepareFirstFactorParams,
): Promise<SessionVerificationResource>
```

#### `SessionVerifyPrepareFirstFactorParams`

```ts
type SessionVerifyPrepareFirstFactorParams = EmailCodeConfig | PhoneCodeConfig

type EmailCodeConfig = {
  strategy: 'email_code'
  primary?: boolean | undefined
  emailAddressId: string
}

type PhoneCodeConfig = {
  strategy: 'phone_code'
  phoneNumberId: string
  primary?: boolean
  default?: boolean
}
```

#### Example

```js
await clerk.session.prepareFirstFactorVerification({
  strategy: 'email_code',
  emailAddressId: 'email_address_123',
})
```

### `prepareSecondFactorVerification()`

Initiates the second factor verification process. This is a required step to complete a reverification flow when using a preparable factor. Returns a [`SessionVerification`](/docs/references/javascript/types/session-verification) instance with its status and supported factors.

```typescript
function prepareSecondFactorVerification(
  params: SessionVerifyPrepareSecondFactorParams,
): Promise<SessionVerificationResource>
```

#### `SessionVerifyPrepareSecondFactorParams`

```ts
type SessionVerifyPrepareSecondFactorParams = PhoneCodeSecondFactorConfig

type PhoneCodeSecondFactorConfig = {
  strategy: 'phone_code'
  phoneNumberId?: string
}
```

#### Example

```js
await clerk.session.prepareSecondFactorVerification({
  strategy: 'phone_code',
})
```

### `remove()`

Invalidates the current session by marking it as removed. Once removed, the session will be deactivated for the current Client instance and its `status` will be set to `removed`. This operation cannot be undone.

```typescript
function remove(): Promise<Session>
```

#### Example

```js
await clerk.session.remove()
```

### `startVerification()`

Initiates the reverification flow. Returns a [`SessionVerification`](/docs/references/javascript/types/session-verification) instance with its status and supported factors.

```typescript
function startVerification(params: SessionVerifyCreateParams): Promise<SessionVerificationResource>
```

#### `SessionVerifyCreateParams`

```typescript
type SessionVerifyCreateParams = {
  status: 'pending' | 'verified' | 'failed'
}
```

#### Example

```js
await clerk.session.startVerification({
  status: 'pending',
})
```

### `touch()`

Updates the session's last active timestamp to the current time. This method should be called periodically to indicate ongoing user activity and prevent the session from becoming stale. The updated timestamp is used for session management and analytics purposes.

```typescript
function touch(): Promise<Session>
```

#### Example

```js
await clerk.session.touch()
```

[client-ref]: /docs/references/javascript/client

---
title: Session options
description: Clerk provides session management options for fine-tuning user visits to your application.
---

Clerk provides session management options for fine-tuning user visits to your application, including options for session lifetime, multi-session handling, and session token customization.

## Session lifetime

Depending on the business domain of an application, there might be different requirements for how long users should remain signed in. Criteria to base this decision upon typically revolve around user activity on the application and how long it has been since the user first signed in.

Ultimately, picking the ideal session lifetime is a trade-off between security and user experience. Longer sessions are generally better for UX but worse for security; and vice-versa.

Fortunately, with Clerk, you have the ability to fully control the lifetime of your users' sessions. There are two settings for doing so and you can set them via your instance settings in the [Clerk Dashboard](https://dashboard.clerk.com/): Inactivity timeout and Maximum lifetime.

> [!NOTE]
> Note that either one or both must be enabled at all times. For security reasons, you are not allowed to disable both settings.

### Inactivity timeout

Inactivity timeout is the duration after which a session will expire and the user will have to sign in again, if they haven't been active on your site.

A user is considered inactive when the application is closed, or when the app stops refreshing the token.

By default, the inactivity timeout is set to 7 days. You can set a custom inactivity timeout by following these steps:

1. In the Clerk Dashboard, navigate to the [**Sessions**](https://dashboard.clerk.com/last-active?path=sessions) page.
1. Toggle on **Inactivity timeout**.
1. Set your desired duration.

> [!NOTE]
> You should be aware of [browser limitations](#browser-limitations-on-cookies), which may cause users to be signed out before the configured inactivity timeout.

### Maximum lifetime

The duration after which a session will expire and the user will have to sign in again, regardless of their activity on your site.

By default, this setting is enabled with a default value of 7 days for all newly created instances. To find this setting and change the value:

1. In the Clerk Dashboard, navigate to the [**Sessions**](https://dashboard.clerk.com/last-active?path=sessions) page.
1. Toggle on **Maximum lifetime**.
1. Set your desired duration.

> [!NOTE]
> You should be aware of [browser limitations](#browser-limitations-on-cookies), which may cause users to be signed out before the configured maximum lifetime.

## Browser limitations on cookies

Regardless of how [session lifetimes](#session-lifetime) are configured, there are certain browser limitations & behaviors which may clear Clerk's session cookie. This will cause users to be signed out, even if your session lifetimes are set to a longer duration. As a result, it is impossible to achieve a setup where your users are never signed out.

### User behaviors

In the event that a user manually clears their cookies, Clerk's session cookie will be lost. Similarly, if a user signs in via an incognito window and they then close all incognito windows, Clerk's session cookie will be lost. Both of these scenarios will cause the user to have to sign in again.

### Google Chrome

Cookies set in Google Chrome have a `Max-Age` upper limit of [400 days](https://developer.chrome.com/blog/cookie-max-age-expires). Users who are using Google Chrome will be signed out within 400 days, even if session lifetime is set to a longer duration. There is no workaround for this.

This is per the [HTTP Working Group Specification](https://httpwg.org/http-extensions/draft-ietf-httpbis-rfc6265bis.html#section-5.5) which is likely to get implemented by other browsers in the near future.

## Multi-session applications

A multi-session application is an application that allows multiple accounts to be signed in from the same browser at the same time. The user can switch from one account to another seamlessly. Each account is independent from the rest and has access to different resources.

To enable multi-session in your application, you need to configure it in the Clerk Dashboard.

1. In the Clerk Dashboard, navigate to the [**Sessions**](https://dashboard.clerk.com/last-active?path=sessions) page.
1. Toggle on **Multi-session handling**.
1. Select **Save**.

### Add multi-session support to your app

There are two main ways to add the multi-session feature to your application:

- Use the [`<UserButton />`](/docs/components/user/user-button) component if you want to use a prebuilt UI.
- [Build a custom flow](/docs/custom-flows/multi-session-applications) if you want to rebuild the existing Clerk flow using the Clerk API.

It's highly recommended to wrap your application with the following `<MultisessionAppSupport />` component. The fragment's `key` is set to the session ID. Every time the session ID changes, the `key` changes, forcing React to recreate the entire component tree under the fragment and guaranteeing a full rerendering cycle.

```tsx
function MultisessionAppSupport({ children }: { children: React.ReactNode }) {
  const { session } = useSession()

  return <React.Fragment key={session ? session.id : 'no-users'}>{children}</React.Fragment>
}
```

The following example demonstrates adding multi-session support to a Next.js App Router application. It requires creating the `<MultisessionAppSupport />` as a client component, and then using it in the `app/layout.tsx` file to wrap the entire application. This ensures the `layout.tsx` remains a server component.

<CodeBlockTabs options={["app/layout.tsx", "MultisessionAppSupport.tsx"]}>
  ```tsx {{ filename: 'app/layout.tsx' }}
  import React from 'react'
  import { ClerkProvider } from '@clerk/nextjs'
  import { MultisessionAppSupport } from './components/MultisessionAppSupport'

  export default function RootLayout({ children }: { children: React.ReactNode }) {
    return (
      <html lang="en">
        <ClerkProvider afterMultiSessionSingleSignOutUrl="/">
          <MultisessionAppSupport>
            <body>{children}</body>
          </MultisessionAppSupport>
        </ClerkProvider>
      </html>
    )
  }
  ```

  ```tsx {{ filename: 'app/components/MultisessionAppSupport.tsx' }}
  'use client'

  import React from 'react'
  import { useSession } from '@clerk/nextjs'

  export default function MultisessionAppSupport({ children }: { children: React.ReactNode }) {
    const { session } = useSession()

    return <React.Fragment key={session ? session.id : 'no-users'}>{children}</React.Fragment>
  }
  ```
</CodeBlockTabs>

### Sign out behavior

By default, signing out from a currently active account in a multi-session app will navigate to the sign-in page's `/choose` route.

If a sign-in URL is not set, signing out will navigate to Clerk's Account Portal `/sign-in/choose` page, allowing the user to choose which account to switch into.

If a sign-in URL is set, either through the [`signInUrl`](/docs/components/clerk-provider) prop on `<ClerkProvider>` or the [`CLERK_SIGN_IN_URL` environment variable](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects), signing out will navigate to that URL's `/choose` route. For example, if `signInUrl` or `CLERK_SIGN_IN_URL` is set to `https://example.com/sign-in`, signing out of a multi-session app will navigate to `https://example.com/sign-in/choose`.

<If sdk={["nextjs", "react", "expo", "react-router", "tanstack-react-start"]}>
  To redirect to a custom route, pass the [`afterMultiSessionSingleSignOutUrl`](/docs/components/clerk-provider#properties) property to `<ClerkProvider>`.
</If>

## Customize session token

Session tokens are JWTs that contain a set of [default claims](/docs/backend-requests/resources/session-tokens) required by Clerk. You can customize these tokens by providing additional claims of your own.

To learn how to customize session tokens, see the [dedicated guide](/docs/backend-requests/custom-session-token).

---
title: Session tokens
description: Learn about session tokens and how to validate them in your backend.
---

When a user is authenticated in your application, Clerk generates a short-lived session token that you can use to authenticate requests to your backend. This token is a JSON Web Token (JWT) that contains information about the user and their session.

Read more about Clerk session tokens and how they work in [the guide on how Clerk works](/docs/how-clerk-works/overview).

## Default claims

<Tabs items={["Version 2", "Version 1"]}>
  <Tab>
    > [!IMPORTANT]
    > You are reading about version 2 of Clerk's session token claims. To read about version 1, select the respective tab above.

    Every generated token has default claims that cannot be overridden by templates. Clerk's default claims include:

    | Claim | Abbreviation expanded | Description | Example |
    | - | - | - | - |
    | `azp` | authorized party | The `Origin` header that was included in the original Frontend API request made from the user. Most commonly, it will be the URL of the application. This claim could be omitted if, for privacy-related reasons, `Origin` is empty or null. | `https://example.com` |
    | `exp` | expiration time | The time after which the token will expire, as a Unix timestamp. Determined using the **Token lifetime** JWT template setting in the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=jwt-templates). See [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.4) for more information. | `1713158400` |
    | `fva` | factor verification age | Each item represents the minutes that have passed since the last time a first or second factor, respectively, was verified. | `[7, -1]` which means it has been 7 minutes since the first factor was verified, and there either is not a second factor or the second factor has never been verified. |
    | `iat` | issued at | The time at which the token was issued as a Unix timestamp. See [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.6) for more information. | `1713158400` |
    | `iss` | issuer | The Frontend API URL of your instance. See [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.1) for more information. | `https://clerk.your-site.com` for a production instance, `https://your-site.clerk.accounts.dev` for a development instance |
    | `nbf` | not before | The time before which the token is considered invalid, as a Unix timestamp. Determined using the **Allowed Clock Skew** JWT template setting in the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=jwt-templates). See [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.5) for more information. | `1713158400` |
    | `sid` | session ID | The ID of the current session. | `sess_123` |
    | `sub` | subject | The ID of the current user of the session. See [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.2) for more information. | `user_123` |
    | `v` | version | The version number of the session token. | `2` |
    | `fea` | features | A list of enabled features and their scope. The scope can either be `o` for org-level features, `u` for user-level features, or `uo` for both. | `o:dashboard,o:impersonation` |

    The **`o` claim**, or organization claim, is only included if the user is part of an [organization](/docs/organizations/overview) and that organization is [active](/docs/organizations/overview#active-organization). Its value is an object that contains the following properties:

    | Claim | Abbreviation expanded | Description | Example |
    | - | - | - | - |
    | `id` | ID | The ID of the organization. | `org_123` |
    | `slg` | slug | The slug of the organization. | `org-slug` |
    | `rol` | role | The role of the user in the organization, without the `org:` prefix. | `admin` |
    | `per` | permissions | The names of the permissions the user has in the organization. | `read,manage` |
    | `fpm` | feature-permission map | The mapping of features with permissions, where the value of the integer, when converted to binary, represents a bitmask where each bit's position corresponds to a permission in the `o.per` list, and where `0` = `not-allowed` and `1` = `allowed`. | `3,2` |

    > [!WARNING]
    > The organization claims above are intentionally designed to be as compact as possible to keep JWT tokens small.
    > As a result, they can be difficult to decode manually. We strongly recommend using one of our SDKs that support API version [2025-04-10](/docs/versioning/available-versions#2025-04-10) to handle decoding reliably.

    The **`act` (actor) claim** is only included if the user is [impersonating](/docs/users/user-impersonation) another user. It's value is an object that contains the following properties:

    | Claim | Abbreviation expanded | Description | Example |
    | - | - | - | - |
    | `iss` | issuer | The referrer of the token. | `https://dashboard.clerk.com` |
    | `sid` | session ID | The session ID of the impersonated session. | `sess_456` |
    | `sub` | subject | The ID of the impersonator. | `user_456` |
  </Tab>

  <Tab>
    > [!IMPORTANT]
    > Version 1 was deprecated on April 14, 2025. To upgrade to version 2, go to the [**Updates**](https://dashboard.clerk.com/last-active?path=updates) page in the Clerk Dashboard.

    Every generated token has default claims that cannot be overridden by templates. Clerk's default claims include:

    | Claim | Abbreviation expanded | Description | Example |
    | - | - | - | - |
    | `azp` | authorized party | The `Origin` header that was included in the original Frontend API request made from the user. Most commonly, it will be the URL of the application. This claim could be omitted if, for privacy-related reasons, `Origin` is empty or null. | `https://example.com` |
    | `exp` | expiration time | The time after which the token will expire, as a Unix timestamp. Determined using the **Token lifetime** JWT template setting in the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=jwt-templates). See [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.4) for more information. | `1713158400` |
    | `fva` | factor verification age | Each item represents the minutes that have passed since the last time a first or second factor, respectively, was verified. | `[7, -1]` which means it has been 7 minutes since the first factor was verified, and there either is not a second factor or the second factor has never been verified. |
    | `iat` | issued at | The time at which the token was issued as a Unix timestamp. See [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.6) for more information. | `1713158400` |
    | `iss` | issuer | The Frontend API URL of your instance. See [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.1) for more information. | `https://clerk.your-site.com` for a production instance, `https://your-site.clerk.accounts.dev` for a development instance |
    | `nbf` | not before | The time before which the token is considered invalid, as a Unix timestamp. Determined using the **Allowed Clock Skew** JWT template setting in the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=jwt-templates). See [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.5) for more information. | `1713158400` |
    | `sid` | session ID | The ID of the current session. | `sess_123` |
    | `sub` | subject | The ID of the current user of the session. See [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.2) for more information. | `user_123` |

    The following claims are only included if the user is part of an organization and that organization is [active](/docs/organizations/overview#active-organization):

    | Claim | Abbreviation expanded | Description | Example |
    | - | - | - | - |
    | `org_id` | organization ID | The ID of the active organization that the user belongs to. | `org_123` |
    | `org_permissions` | organization permissions | The permissions of the user in the currently active organization. System permissions are not included in the session token. | `["org:admin:example_permission", "org:member:example_permission"]` |
    | `org_slug` | organization slug | The slug of the currently active organization that the user belongs to. | `org-slug` |
    | `org_role` | organization role | The role of the user in the currently active organization. | `org:admin` |

    The **`act` (actor) claim** is only included if the user is [impersonating](/docs/users/user-impersonation) another user. It's value is an object that contains the following properties:

    | Claim | Abbreviation expanded | Description | Example |
    | - | - | - | - |
    | `iss` | issuer | The referrer of the token. | `https://dashboard.clerk.com` |
    | `sid` | session ID | The session ID of the impersonated session. | `sess_456` |
    | `sub` | subject | The ID of the impersonator. | `user_456` |
  </Tab>
</Tabs>

If you would like to add custom claims to your session token, you can [customize it](/docs/backend-requests/custom-session-token).

You can also create custom tokens using a [JWT template](/docs/backend-requests/jwt-templates).

## Size limitations

The Clerk session token is stored in a cookie. All modern browsers [limit the maximum size of a cookie to 4kb](https://datatracker.ietf.org/doc/html/rfc2109#section-6.3). Exceeding this limit can have adverse effects, including a possible infinite redirect loop for users who exceed this size in Next.js applications.

A session token with the [default session claims](#default-claims) won't run into this issue, as this configuration produces a cookie significantly smaller than 4kb. However, this limitation becomes relevant when implementing a [custom session token](/docs/backend-requests/custom-session-token). In this case, it's recommended to move particularly large claims out of the token and fetch these using a separate API call from your backend.

Claims to monitor for size limits:

- `user.organizations`
- `user.public_metadata`
- `user.unsafe_metadata`
- `org.public_metadata`
- `org_membership.public_metadata`

If you include any of these claims in your token, use caution to ensure the stored data doesn't exceed the size limit.

> [!NOTE]
> If your application encounters this issue, the Clerk Dashboard will display a warning: **"Some users are exceeding cookie size limits"**. To resolve this, update your [custom session token](/docs/backend-requests/custom-session-token).

## Validate session tokens

If you're using the middleware provided by our Clerk SDKs, validating session tokens is handled automatically in every request. If you're not using the middleware, you can still use the respective helpers provided by the SDKs to validate the tokens.

To learn how to manually verify a session token, refer to the [dedicated guide](/docs/backend-requests/manual-jwt).

---
title: SessionVerification
description: The SessionVerification interface represents the state of a session reverification process.
---

An interface that represents the state of the session verification process.

## Properties

<Properties>
  - `status`
  - `'needs_first_factor' | 'needs_second_factor' | 'complete'`

  The current state of the session verification.

  ---

  - `level`
  - `'first_factor' | 'second_factor' | 'multi_factor'`

  The requested level of the session verification.

  ---

  - `session`
  - [`Session`](/docs/references/javascript/session)

  The `Session` object that the session verification is attached to.

  ---

  - `firstFactorVerification`
  - [`Verification`](/docs/references/javascript/types/verification)

  The state of the verification process for the selected first factor. Initially, this property contains an empty `Verification` object, since there is no first factor selected. You need to call the [`prepareFirstFactorVerification()`](/docs/references/javascript/session#prepare-first-factor-verification) method in order to start the verification process.

  ---

  - `secondFactorVerification`
  - [`Verification`](/docs/references/javascript/types/verification)

  The state of the verification process for the selected second factor. Initially, this property contains an empty `Verification` object, since there is no second factor selected. For the `phone_code` strategy, you need to call the [`prepareSecondFactorVerification()`](/docs/references/javascript/session#prepare-second-factor-verification) method in order to start the verification process. For the `totp` or `backup_code` strategies, you can directly attempt the verification by calling the [`attemptSecondFactorVerification()`](/docs/references/javascript/session#attempt-second-factor-verification) method.

  ---

  - `supportedFirstFactors`
  - <code>[EmailCodeFactor](/docs/references/javascript/types/sign-in-first-factor#email-code-factor)\[] | [PhoneCodeFactor](/docs/references/javascript/types/sign-in-first-factor#phone-code-factor)\[] | [PasswordFactor](/docs/references/javascript/types/sign-in-first-factor#password-factor)\[]</code>

  Array of the first factors that are supported in the current session verification. Each factor contains information about the verification strategy that can be used.

  ---

  - `supportedSecondFactors`
  - <code>[TOTPFactor](/docs/references/javascript/types/sign-in-second-factor#totp-factor)\[] | [PhoneCodeFactor](/docs/references/javascript/types/sign-in-first-factor#phone-code-factor)\[] | [BackupCodeFactor](/docs/references/javascript/types/sign-in-second-factor#backup-code-factor)\[]</code>

  Array of the second factors that are supported in the current session verification. Each factor contains information about the verification strategy that can be used.
</Properties>

---
title: Set up a preview environment with Clerk
description: Learn how to set up a preview environment with Clerk authentication.
---

Some popular hosting providers like Vercel and Netlify offer preview deployments, which enable you to view changes to your site in a live environment before merging and deploying them to production.

There are two high-level approaches to using Clerk in a preview environment:

1. Sharing production settings and user data
1. Using independent settings and user data

## Sharing production settings and user data

To share production settings and user data with your preview environment, your preview environment must be hosted on the same root domain (but a separate subdomain) as your production application. The preview environment must also be configured to use the same API keys as your production environment.

Generally, hosts have a special feature to host the preview environment on a subdomain of your root domain, for example:

- **Vercel:** use the [Preview Deployment Suffix](https://vercel.com/docs/concepts/deployments/generated-urls#preview-deployment-suffix) feature. This feature is only available on Vercel's Pro and Enterprise plans.
- **Netlify:** use the [Automatic Deploy Subdomain](https://docs.netlify.com/domains-https/custom-domains/automatic-deploy-subdomains/) feature.

## Using independent settings and user data

There are two approaches to creating a preview environment with independent settings and user data:

1. **Easiest:** Use your host's provided preview domain, like \*.vercel.app or \*.netlify.app, with development API keys from Clerk.
1. Acquire an additional root domain for your preview environment, completely separate from your production application's root domain.

### Use your host's provided preview domain

Configure the preview environment to use development API keys from Clerk. It is currently not possible to use Clerk production API keys with your host's provided preview domain.

### Acquire an additional root domain

> [!WARNING]
> To use an independent environment, it is critical that you acquire an additional domain. An independent environment will not work if it is configured on the same domain as your production application, even if it is on a separate subdomain.

To use an additional root domain, you must first configure your host to deploy preview environments to that domain:

- **Vercel:** use the [Preview Deployment Suffix](https://vercel.com/docs/concepts/deployments/generated-urls#preview-deployment-suffix) feature. This feature is only available on Vercel's Pro and Enterprise plans.
- **Netlify:** use the [Automatic Deploy Subdomain](https://docs.netlify.com/domains-https/custom-domains/automatic-deploy-subdomains/) feature.

You can configure this environment with either your development API keys (recommended) or you can create an additional production instance and use those production API keys.

---
title: Set up a staging environment with Clerk
description: Learn how to set up a staging environment with Clerk authentication.
---

Staging environments enable you to internally test and demo changes to your application or website before deploying them to production. Currently, Clerk only offers **Development** and **Production** instances. Official support for **Staging** instances is still on the [roadmap](https://feedback.clerk.com/roadmap/de417dd1-fa2e-4997-868f-4c9248027e7d). However, you can set up a "staging environment" by creating a subdomain for a separate Clerk application.

Creating a separate Clerk application will prevent you from using live production environment data in your staging environment. If you are on a Pro, Enterprise, or Startup plan, **Clerk will fully upgrade your staging application for free.**

It is important to note that when you use a separate Clerk application for your staging environment, changes to this application will not be automatically mirrored in your main application for your production environment. You must manually make these changes yourself if you want them to be reflected in both applications.

## Set up a staging Clerk application

The following steps will help you set up a new Clerk application with a staging-specific domain:

1. **Set up a subdomain** - This will be your staging domain. For example, if your domain is `my-site.com`, you could use `staging.my-site.com`.
1. **Create a new Clerk app** - Your staging environment will connect to this app instead of your main one. See [the Clerk quickstart guide](/docs/quickstarts/setup-clerk) to learn how to create a Clerk app.
1. **Deploy and configure your staging app's production instance** - Using production API keys will make your staging app more secure. Follow the [Deploy to production](/docs/deployments/overview) guide to do so.
1. **Contact Clerk support to upgrade your staging app for free** - If you are on a Pro, Enterprise, or Startup plan, Clerk will fully upgrade your staging app for free.

## Alternatives

### Preview environments

While staging environments are typically long-lived, preview environments are typically generated on-demand for specific pull requests. See [the guide on using Clerk in a preview environment](/docs/deployments/set-up-preview-environment) to learn about your options.

### Shared production credentials

If you would like to share settings and data between your production and staging environments, see [the dedicated guide](/docs/deployments/staging-alternatives). This is not recommended because you will be sharing a user table between your production and staging environments.

---
title: Set up a waitlist in your Next.js app
description: Learn how to add a waitlist to your Next.js application.
---

In [**Waitlist** mode](/docs/authentication/configuration/restrictions#waitlist), users can register their interest in your app by joining a waitlist. This mode is ideal for apps in early development stages or those wanting to generate interest before launch. This guide shows you how to get Clerk integrated and how to add a waitlist to your Next.js application.

<Steps>
  ## Install `@clerk/nextjs`

  The [Clerk Next.js SDK](/docs/references/nextjs/overview) gives you access to prebuilt components, React hooks, and helpers to make user authentication easier.

  Run the following command to install the SDK:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/nextjs
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/nextjs
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/nextjs
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @clerk/nextjs
    ```
  </CodeBlockTabs>

  ## Set your Clerk API keys

  <If condition={experiment.enabled}>
    <ExperimentCreateAccountFromDocsQuickstart params={experiment} />
  </If>

  <If condition={!experiment.enabled}>
    <SignedIn>
      Add the following keys to your `.env` file. These keys can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
    </SignedIn>

    <SignedOut>
      1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys){{ track: 'exp_create_account_nextjs_quickstart' }} page.
      1. In the **Quick Copy** section, copy your Clerk Publishable and Secret Keys.
      1. Paste your keys into your `.env` file.

      The final result should resemble the following:
    </SignedOut>
  </If>

  ```env {{ filename: '.env' }}
  NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
  CLERK_SECRET_KEY={{secret}}
  ```

  ## Enable Waitlist mode

  To enable **Waitlist** mode, follow these steps:

  1. In the Clerk Dashboard, navigate to the [**Restrictions**](https://dashboard.clerk.com/last-active?path=user-authentication/restrictions) page.
  1. Under the **Sign-up modes** section, enable **Waitlist**.

  To manage users on your waitlist:

  1. In the Clerk Dashboard, navigate to the [**Waitlist**](https://dashboard.clerk.com/last-active?path=waitlist) page.
  1. On the right-side of a user's row, select the menu icon (...).
  1. Select **Invite** to invite the user to your application. Select **Deny** to deny the user access to your application.

  ## Add the `<Waitlist />` component

  The [`<Waitlist />`](/docs/components/waitlist) component renders a form that allows users to join for early access to your app.

  The following example includes a basic implementation of the `<Waitlist />` component hosted on the `/` route (the home page). You can use this as a starting point for your own implementation.

  ```jsx {{ filename: 'app/page.tsx' }}
  import { Waitlist } from '@clerk/nextjs'

  export default function Page() {
    return <Waitlist />
  }
  ```

  ## Add `<ClerkProvider>` to your app

  <Include src="_partials/clerk-provider/explanation" />

  To use the `<Waitlist />` component in your app, you must provide the `waitlistUrl` prop, which points to the URL of your waitlist page.

  ```tsx {{ filename: 'app/layout.tsx', mark: [6] }}
  import { ClerkProvider } from '@clerk/nextjs'
  import './globals.css'

  export default function RootLayout({ children }: { children: React.ReactNode }) {
    return (
      <ClerkProvider waitlistUrl="/">
        <html lang="en">
          <body>{children}</body>
        </html>
      </ClerkProvider>
    )
  }
  ```

  ## Add sign-in functionality

  To allow users to sign in once they've been approved from the waitlist, you must:

  - [Add `clerkMiddleware()` to your app.](#add-clerk-middleware-to-your-app)
  - [Add a sign-in page.](#add-a-sign-in-page)

  ### Add `clerkMiddleware()` to your app

  [`clerkMiddleware()`](/docs/references/nextjs/clerk-middleware) grants you access to user authentication state throughout your app, on any route or page. It also allows you to protect specific routes from unauthenticated users. To add `clerkMiddleware()` to your app, follow these steps:

  1. Create a `middleware.ts` file.

  - If you're using the `/src` directory, create `middleware.ts` in the `/src` directory.
  - If you're not using the `/src` directory, create `middleware.ts` in the root directory alongside `.env`.

  1. In your `middleware.ts` file, export the `clerkMiddleware()` helper:

  ```tsx {{ filename: 'middleware.ts' }}
  import { clerkMiddleware } from '@clerk/nextjs/server'

  export default clerkMiddleware()

  export const config = {
    matcher: [
      // Skip Next.js internals and all static files, unless found in search params
      '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
      // Always run for API routes
      '/(api|trpc)(.*)',
    ],
  }
  ```

  1. By default, `clerkMiddleware()` will not protect any routes. All routes are public and you must opt-in to protection for routes. See the [`clerkMiddleware()` reference](/docs/references/nextjs/clerk-middleware) to learn how to require authentication for specific routes.

  ### Add a sign-in page

  The following example demonstrates how to render the `<SignIn />` component.

  ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx' }}
  import { SignIn } from '@clerk/nextjs'

  export default function Page() {
    return <SignIn />
  }
  ```

  Update your environment variables to point to your custom sign-in page. For more information on building a custom sign-in-or-up page, see the [dedicated guide](/docs/references/nextjs/custom-sign-in-or-up-page).

  ```env {{ filename: '.env' }}
  NEXT_PUBLIC_CLERK_SIGN_IN_URL="/sign-in"
  ```
</Steps>

---
title: Set up your Clerk account
description: Set up a new Clerk account and integrate it into a new application.
---

Before you can start integrating Clerk into your application, you need to create a Clerk account and set up a new application in the Clerk Dashboard. This guide will walk you through those steps.

> [!NOTE]
> If you're migrating from another platform, see the [migration guides](/docs/deployments/migrate-overview) to learn how to move your data to Clerk.

<Steps>
  ## Sign into Clerk

  [Create a Clerk account](https://dashboard.clerk.com/sign-up) or [sign into the Clerk Dashboard](https://dashboard.clerk.com/).

  ## Create a Clerk application

  If you've just created an account for the first time, you'll be taken directly to the interactive authentication setup form.

  Otherwise, you'll be redirected to the [Clerk Dashboard](https://dashboard.clerk.com/). To create a new app, select the **Create application** card. You'll be redirected to the interactive authentication setup form.

  ## Select identifiers and social providers

  Once you are in the interactive authentication setup form, you will be asked to build your authentication flow. Here, Clerk provides various options for setting up your sign-up and sign-in flows. You can choose to use email, phone, or username as [identifiers](/docs/authentication/configuration/sign-up-sign-in-options#identifiers), and you can enable [social authentication providers](/docs/authentication/social-connections/oauth).

  Once the application is created, you can also customize your authentication flow by selecting different authentication strategies, verification methods, and more. [Learn more about sign-up and sign-in options](/docs/authentication/configuration/sign-up-sign-in-options).

  ## Integrate Clerk into your application

  Now that your application is created in the Clerk Dashboard, you can integrate it into your codebase. To integrate Clerk into your application, use one of our [quickstarts](/docs/quickstarts/overview).
</Steps>

---
title: shadcn/ui
description: Learn how to compose Clerk Elements with shadcn/ui to build custom sign in and sign up flows.
---

The following examples demonstrate how to compose Clerk Elements with shadcn/ui to build custom sign-in and sign-up flows.

## Before you start

To use these examples, you must first:

1. Complete the [shadcn/ui Next.js installation guide](https://ui.shadcn.com/docs/installation/next)
1. Install the [Button](https://ui.shadcn.com/docs/components/button), [Card](https://ui.shadcn.com/docs/components/card), [Input](https://ui.shadcn.com/docs/components/input), and [Label](https://ui.shadcn.com/docs/components/label) components within your project

```shell {{ title: 'Install shadcn/ui components' }}
npx shadcn@latest add button card input label
```

1. Add the [`Icons` component from the shadcn/ui docs](https://github.com/shadcn-ui/ui/blob/main/apps/www/components/icons.tsx) to an `icons.tsx` file within your `component/ui/` directory.
1. Add the following animations to your `tailwind.config.js` file:

```js {{ filename: 'tailwind.config.js' }}
/** @type {import('tailwindcss').Config} */
module.exports = {
  theme: {
    extend: {
      keyframes: {
        'caret-blink': {
          '0%,70%,100%': { opacity: '1' },
          '20%,50%': { opacity: '0' },
        },
      },
      animation: {
        'caret-blink': 'caret-blink 1.25s ease-out infinite',
      },
    },
  },
}
```

You must also configure the appropriate settings in Clerk:

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Ensure that **Google** and **GitHub** are enabled. If they are not in the list of connections, select the **Add connection** button, and select **For all users**. Enable **Google** and **GitHub**.
1. Make sure you have your sign in and sign up URLs set in your [environment variables](https://clerk.com/docs/guides/custom-redirects#environment-variables).

## Sign up

<CodeBlockDemo
  demos={[
  {
    key: 'sign-up',
    demo: '/demo/shadcn/elements/sign-up',
    style: {
      height: `${616 / 16}rem`,
      backgroundColor: 'var(--light, hsl(0 0% 100%)) var(--dark, hsl(0 0% 3.9%))'
    },
    bordered: true
  },
]}
>
  ```tsx {{ filename: 'app/sign-up/[[...sign-up]]/page.tsx', collapsible: true }}
  'use client'
  import * as Clerk from '@clerk/elements/common'
  import * as SignUp from '@clerk/elements/sign-up'
  import { Button } from '@/components/ui/button'
  import {
    Card,
    CardContent,
    CardDescription,
    CardFooter,
    CardHeader,
    CardTitle,
  } from '@/components/ui/card'
  import { Input } from '@/components/ui/input'
  import { Label } from '@/components/ui/label'
  import { Icons } from '@/components/ui/icons'
  import { cn } from '@/lib/utils'

  export default function SignUpPage() {
    return (
      <div className="grid w-full grow items-center px-4 sm:justify-center">
        <SignUp.Root>
          <Clerk.Loading>
            {(isGlobalLoading) => (
              <>
                <SignUp.Step name="start">
                  <Card className="w-full sm:w-96">
                    <CardHeader>
                      <CardTitle>Create your account</CardTitle>
                      <CardDescription>
                        Welcome! Please fill in the details to get started.
                      </CardDescription>
                    </CardHeader>
                    <CardContent className="grid gap-y-4">
                      <div className="grid grid-cols-2 gap-x-4">
                        <Clerk.Connection name="github" asChild>
                          <Button
                            size="sm"
                            variant="outline"
                            type="button"
                            disabled={isGlobalLoading}
                          >
                            <Clerk.Loading scope="provider:github">
                              {(isLoading) =>
                                isLoading ? (
                                  <Icons.spinner className="size-4 animate-spin" />
                                ) : (
                                  <>
                                    <Icons.gitHub className="mr-2 size-4" />
                                    GitHub
                                  </>
                                )
                              }
                            </Clerk.Loading>
                          </Button>
                        </Clerk.Connection>
                        <Clerk.Connection name="google" asChild>
                          <Button
                            size="sm"
                            variant="outline"
                            type="button"
                            disabled={isGlobalLoading}
                          >
                            <Clerk.Loading scope="provider:google">
                              {(isLoading) =>
                                isLoading ? (
                                  <Icons.spinner className="size-4 animate-spin" />
                                ) : (
                                  <>
                                    <Icons.google className="mr-2 size-4" />
                                    Google
                                  </>
                                )
                              }
                            </Clerk.Loading>
                          </Button>
                        </Clerk.Connection>
                      </div>
                      <p className="flex items-center gap-x-3 text-sm text-muted-foreground before:h-px before:flex-1 before:bg-border after:h-px after:flex-1 after:bg-border">
                        or
                      </p>
                      <Clerk.Field name="emailAddress" className="space-y-2">
                        <Clerk.Label asChild>
                          <Label>Email address</Label>
                        </Clerk.Label>
                        <Clerk.Input type="email" required asChild>
                          <Input />
                        </Clerk.Input>
                        <Clerk.FieldError className="block text-sm text-destructive" />
                      </Clerk.Field>
                      <Clerk.Field name="password" className="space-y-2">
                        <Clerk.Label asChild>
                          <Label>Password</Label>
                        </Clerk.Label>
                        <Clerk.Input type="password" required asChild>
                          <Input />
                        </Clerk.Input>
                        <Clerk.FieldError className="block text-sm text-destructive" />
                      </Clerk.Field>
                    </CardContent>
                    <CardFooter>
                      <div className="grid w-full gap-y-4">
                        <SignUp.Captcha className="empty:hidden" />
                        <SignUp.Action submit asChild>
                          <Button disabled={isGlobalLoading}>
                            <Clerk.Loading>
                              {(isLoading) => {
                                return isLoading ? (
                                  <Icons.spinner className="size-4 animate-spin" />
                                ) : (
                                  'Continue'
                                )
                              }}
                            </Clerk.Loading>
                          </Button>
                        </SignUp.Action>
                        <Button variant="link" size="sm" asChild>
                          <Clerk.Link navigate="sign-in">Already have an account? Sign in</Clerk.Link>
                        </Button>
                      </div>
                    </CardFooter>
                  </Card>
                </SignUp.Step>

                <SignUp.Step name="continue">
                  <Card className="w-full sm:w-96">
                    <CardHeader>
                      <CardTitle>Continue registration</CardTitle>
                    </CardHeader>
                    <CardContent>
                      <Clerk.Field name="username" className="space-y-2">
                        <Clerk.Label>
                          <Label>Username</Label>
                        </Clerk.Label>
                        <Clerk.Input type="text" required asChild>
                          <Input />
                        </Clerk.Input>
                        <Clerk.FieldError className="block text-sm text-destructive" />
                      </Clerk.Field>
                    </CardContent>
                    <CardFooter>
                      <div className="grid w-full gap-y-4">
                        <SignUp.Action submit asChild>
                          <Button disabled={isGlobalLoading}>
                            <Clerk.Loading>
                              {(isLoading) => {
                                return isLoading ? (
                                  <Icons.spinner className="size-4 animate-spin" />
                                ) : (
                                  'Continue'
                                )
                              }}
                            </Clerk.Loading>
                          </Button>
                        </SignUp.Action>
                      </div>
                    </CardFooter>
                  </Card>
                </SignUp.Step>

                <SignUp.Step name="verifications">
                  <SignUp.Strategy name="email_code">
                    <Card className="w-full sm:w-96">
                      <CardHeader>
                        <CardTitle>Verify your email</CardTitle>
                        <CardDescription>
                          Use the verification link sent to your email address
                        </CardDescription>
                      </CardHeader>
                      <CardContent className="grid gap-y-4">
                        <div className="grid items-center justify-center gap-y-2">
                          <Clerk.Field name="code" className="space-y-2">
                            <Clerk.Label className="sr-only">Email address</Clerk.Label>
                            <div className="flex justify-center text-center">
                              <Clerk.Input
                                type="otp"
                                className="flex justify-center has-[:disabled]:opacity-50"
                                autoSubmit
                                render={({ value, status }) => {
                                  return (
                                    <div
                                      data-status={status}
                                      className={cn(
                                        'relative flex size-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md',
                                        {
                                          'z-10 ring-2 ring-ring ring-offset-background':
                                            status === 'cursor' || status === 'selected',
                                        },
                                      )}
                                    >
                                      {value}
                                      {status === 'cursor' && (
                                        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
                                          <div className="animate-caret-blink h-4 w-px bg-foreground duration-1000" />
                                        </div>
                                      )}
                                    </div>
                                  )
                                }}
                              />
                            </div>
                            <Clerk.FieldError className="block text-center text-sm text-destructive" />
                          </Clerk.Field>
                          <SignUp.Action
                            asChild
                            resend
                            className="text-muted-foreground"
                            fallback={({ resendableAfter }) => (
                              <Button variant="link" size="sm" disabled>
                                Didn&apos;t receive a code? Resend (
                                <span className="tabular-nums">{resendableAfter}</span>)
                              </Button>
                            )}
                          >
                            <Button type="button" variant="link" size="sm">
                              Didn&apos;t receive a code? Resend
                            </Button>
                          </SignUp.Action>
                        </div>
                      </CardContent>
                      <CardFooter>
                        <div className="grid w-full gap-y-4">
                          <SignUp.Action submit asChild>
                            <Button disabled={isGlobalLoading}>
                              <Clerk.Loading>
                                {(isLoading) => {
                                  return isLoading ? (
                                    <Icons.spinner className="size-4 animate-spin" />
                                  ) : (
                                    'Continue'
                                  )
                                }}
                              </Clerk.Loading>
                            </Button>
                          </SignUp.Action>
                        </div>
                      </CardFooter>
                    </Card>
                  </SignUp.Strategy>
                </SignUp.Step>
              </>
            )}
          </Clerk.Loading>
        </SignUp.Root>
      </div>
    )
  }
  ```
</CodeBlockDemo>

## Sign in

<CodeBlockDemo
  demos={[
  {
    key: 'sign-in',
    demo: '/demo/shadcn/elements/sign-in',
    style: {
      height: `${528 / 16}rem`,
      backgroundColor: 'var(--light, hsl(0 0% 100%)) var(--dark, hsl(0 0% 3.9%))'
    },
    bordered: true
  },
]}
>
  ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx', collapsible: true }}
  'use client'
  import * as Clerk from '@clerk/elements/common'
  import * as SignIn from '@clerk/elements/sign-in'
  import { Button } from '@/components/ui/button'
  import {
    Card,
    CardContent,
    CardDescription,
    CardFooter,
    CardHeader,
    CardTitle,
  } from '@/components/ui/card'
  import { Input } from '@/components/ui/input'
  import { Label } from '@/components/ui/label'
  import { Icons } from '@/components/ui/icons'

  export default function SignInPage() {
    return (
      <div className="grid w-full grow items-center px-4 sm:justify-center">
        <SignIn.Root>
          <Clerk.Loading>
            {(isGlobalLoading) => (
              <>
                <SignIn.Step name="start">
                  <Card className="w-full sm:w-96">
                    <CardHeader>
                      <CardTitle>Sign in to Acme Co</CardTitle>
                      <CardDescription>Welcome back! Please sign in to continue</CardDescription>
                    </CardHeader>
                    <CardContent className="grid gap-y-4">
                      <div className="grid grid-cols-2 gap-x-4">
                        <Clerk.Connection name="github" asChild>
                          <Button
                            size="sm"
                            variant="outline"
                            type="button"
                            disabled={isGlobalLoading}
                          >
                            <Clerk.Loading scope="provider:github">
                              {(isLoading) =>
                                isLoading ? (
                                  <Icons.spinner className="size-4 animate-spin" />
                                ) : (
                                  <>
                                    <Icons.gitHub className="mr-2 size-4" />
                                    GitHub
                                  </>
                                )
                              }
                            </Clerk.Loading>
                          </Button>
                        </Clerk.Connection>
                        <Clerk.Connection name="google" asChild>
                          <Button
                            size="sm"
                            variant="outline"
                            type="button"
                            disabled={isGlobalLoading}
                          >
                            <Clerk.Loading scope="provider:google">
                              {(isLoading) =>
                                isLoading ? (
                                  <Icons.spinner className="size-4 animate-spin" />
                                ) : (
                                  <>
                                    <Icons.google className="mr-2 size-4" />
                                    Google
                                  </>
                                )
                              }
                            </Clerk.Loading>
                          </Button>
                        </Clerk.Connection>
                      </div>
                      <p className="flex items-center gap-x-3 text-sm text-muted-foreground before:h-px before:flex-1 before:bg-border after:h-px after:flex-1 after:bg-border">
                        or
                      </p>
                      <Clerk.Field name="identifier" className="space-y-2">
                        <Clerk.Label asChild>
                          <Label>Email address</Label>
                        </Clerk.Label>
                        <Clerk.Input type="email" required asChild>
                          <Input />
                        </Clerk.Input>
                        <Clerk.FieldError className="block text-sm text-destructive" />
                      </Clerk.Field>
                    </CardContent>
                    <CardFooter>
                      <div className="grid w-full gap-y-4">
                        <SignIn.Action submit asChild>
                          <Button disabled={isGlobalLoading}>
                            <Clerk.Loading>
                              {(isLoading) => {
                                return isLoading ? (
                                  <Icons.spinner className="size-4 animate-spin" />
                                ) : (
                                  'Continue'
                                )
                              }}
                            </Clerk.Loading>
                          </Button>
                        </SignIn.Action>

                        <Button variant="link" size="sm" asChild>
                          <Clerk.Link navigate="sign-up">
                            Don&apos;t have an account? Sign up
                          </Clerk.Link>
                        </Button>
                      </div>
                    </CardFooter>
                  </Card>
                </SignIn.Step>

                <SignIn.Step name="choose-strategy">
                  <Card className="w-full sm:w-96">
                    <CardHeader>
                      <CardTitle>Use another method</CardTitle>
                      <CardDescription>
                        Facing issues? You can use any of these methods to sign in.
                      </CardDescription>
                    </CardHeader>
                    <CardContent className="grid gap-y-4">
                      <SignIn.SupportedStrategy name="email_code" asChild>
                        <Button type="button" variant="link" disabled={isGlobalLoading}>
                          Email code
                        </Button>
                      </SignIn.SupportedStrategy>
                      <SignIn.SupportedStrategy name="password" asChild>
                        <Button type="button" variant="link" disabled={isGlobalLoading}>
                          Password
                        </Button>
                      </SignIn.SupportedStrategy>
                    </CardContent>
                    <CardFooter>
                      <div className="grid w-full gap-y-4">
                        <SignIn.Action navigate="previous" asChild>
                          <Button disabled={isGlobalLoading}>
                            <Clerk.Loading>
                              {(isLoading) => {
                                return isLoading ? (
                                  <Icons.spinner className="size-4 animate-spin" />
                                ) : (
                                  'Go back'
                                )
                              }}
                            </Clerk.Loading>
                          </Button>
                        </SignIn.Action>
                      </div>
                    </CardFooter>
                  </Card>
                </SignIn.Step>

                <SignIn.Step name="verifications">
                  <SignIn.Strategy name="password">
                    <Card className="w-full sm:w-96">
                      <CardHeader>
                        <CardTitle>Check your email</CardTitle>
                        <CardDescription>
                          Enter the verification code sent to your email
                        </CardDescription>
                        <p className="text-sm text-muted-foreground">
                          Welcome back <SignIn.SafeIdentifier />
                        </p>
                      </CardHeader>
                      <CardContent className="grid gap-y-4">
                        <Clerk.Field name="password" className="space-y-2">
                          <Clerk.Label asChild>
                            <Label>Password</Label>
                          </Clerk.Label>
                          <Clerk.Input type="password" asChild>
                            <Input />
                          </Clerk.Input>
                          <Clerk.FieldError className="block text-sm text-destructive" />
                        </Clerk.Field>
                      </CardContent>
                      <CardFooter>
                        <div className="grid w-full gap-y-4">
                          <SignIn.Action submit asChild>
                            <Button disabled={isGlobalLoading}>
                              <Clerk.Loading>
                                {(isLoading) => {
                                  return isLoading ? (
                                    <Icons.spinner className="size-4 animate-spin" />
                                  ) : (
                                    'Continue'
                                  )
                                }}
                              </Clerk.Loading>
                            </Button>
                          </SignIn.Action>
                          <SignIn.Action navigate="choose-strategy" asChild>
                            <Button type="button" size="sm" variant="link">
                              Use another method
                            </Button>
                          </SignIn.Action>
                        </div>
                      </CardFooter>
                    </Card>
                  </SignIn.Strategy>

                  <SignIn.Strategy name="email_code">
                    <Card className="w-full sm:w-96">
                      <CardHeader>
                        <CardTitle>Check your email</CardTitle>
                        <CardDescription>
                          Enter the verification code sent to your email
                        </CardDescription>
                        <p className="text-sm text-muted-foreground">
                          Welcome back <SignIn.SafeIdentifier />
                        </p>
                      </CardHeader>
                      <CardContent className="grid gap-y-4">
                        <Clerk.Field name="code">
                          <Clerk.Label className="sr-only">Email verification code</Clerk.Label>
                          <div className="grid gap-y-2 items-center justify-center">
                            <div className="flex justify-center text-center">
                              <Clerk.Input
                                type="otp"
                                autoSubmit
                                className="flex justify-center has-[:disabled]:opacity-50"
                                render={({ value, status }) => {
                                  return (
                                    <div
                                      data-status={status}
                                      className="relative flex h-9 w-9 items-center justify-center border-y border-r border-input text-sm shadow-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md data-[status=selected]:ring-1 data-[status=selected]:ring-ring data-[status=cursor]:ring-1 data-[status=cursor]:ring-ring"
                                    >
                                      {value}
                                    </div>
                                  )
                                }}
                              />
                            </div>
                            <Clerk.FieldError className="block text-sm text-destructive text-center" />
                            <SignIn.Action
                              asChild
                              resend
                              className="text-muted-foreground"
                              fallback={({ resendableAfter }) => (
                                <Button variant="link" size="sm" disabled>
                                  Didn&apos;t receive a code? Resend (
                                  <span className="tabular-nums">{resendableAfter}</span>)
                                </Button>
                              )}
                            >
                              <Button variant="link" size="sm">
                                Didn&apos;t receive a code? Resend
                              </Button>
                            </SignIn.Action>
                          </div>
                        </Clerk.Field>
                      </CardContent>
                      <CardFooter>
                        <div className="grid w-full gap-y-4">
                          <SignIn.Action submit asChild>
                            <Button disabled={isGlobalLoading}>
                              <Clerk.Loading>
                                {(isLoading) => {
                                  return isLoading ? (
                                    <Icons.spinner className="size-4 animate-spin" />
                                  ) : (
                                    'Continue'
                                  )
                                }}
                              </Clerk.Loading>
                            </Button>
                          </SignIn.Action>
                          <SignIn.Action navigate="choose-strategy" asChild>
                            <Button size="sm" variant="link">
                              Use another method
                            </Button>
                          </SignIn.Action>
                        </div>
                      </CardFooter>
                    </Card>
                  </SignIn.Strategy>
                </SignIn.Step>
              </>
            )}
          </Clerk.Loading>
        </SignIn.Root>
      </div>
    )
  }
  ```
</CodeBlockDemo>

## OTP input

The following example demonstrates how to make a one-time password (OTP) input with Clerk Elements. This example will only work if placed within a `Step` in a sign-up or sign-in authentication flow, as shown in [the sign-in](#sign-in) and [sign-up](#sign-up) examples.

<CodeBlockDemo
  demos={[
  {
    key: 'otp-input',
    demo: '/demo/shadcn/elements/otp-input',
    style: {
      height: `${528 / 16}rem`,
      backgroundColor: 'var(--light, hsl(0 0% 100%)) var(--dark, hsl(0 0% 3.9%))'
    },
    bordered: true
  },
]}
>
  ```tsx {{ title: 'OTP Input', collapsible: true }}
  <Clerk.Input
    type="otp"
    className="flex justify-center has-[:disabled]:opacity-50"
    autoSubmit
    render={({ value, status }) => {
      return (
        <div
          data-status={status}
          className={cn(
            'relative flex size-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md',
            {
              'z-10 ring-2 ring-ring ring-offset-background':
                status === 'cursor' || status === 'selected',
            },
          )}
        >
          {value}
          {status === 'cursor' && (
            <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
              <div className="animate-caret-blink h-4 w-px bg-foreground duration-1000" />
            </div>
          )}
        </div>
      )
    }}
  />
  ```
</CodeBlockDemo>

---
title: Sign in token errors
description: An index of Clerk errors related to sign in tokens.
type: reference
---

An index of Clerk errors related to sign in tokens.

## `SignInTokenRevoked`

```json
{
  "shortMessage": "sign in token has been revoked",
  "longMessage": "This sign in token has been revoked and cannot be used anymore.",
  "code": "sign_in_token_revoked_code"
}
```

## `SignInTokenAlreadyUsed`

```json
{
  "shortMessage": "sign in token has already been used",
  "longMessage": "This sign in token has already been used. Each token can only be used once.",
  "code": "sign_in_token_already_used_code"
}
```

## `SignInTokenCannotBeUsed`

```json
{
  "shortMessage": "sign in token cannot be used",
  "longMessage": "This sign in token cannot be used anymore. Please request a new one.",
  "code": "sign_in_token_cannot_be_used_code"
}
```

## <code>SignInTokenCanBeUsed<wbr />OnlyInSignIn</code>

```json
{
  "shortMessage": "not in sign in",
  "longMessage": "Sign in tokens can only be used during sign in.",
  "code": "sign_in_token_not_in_sign_in_code"
}
```

## <code>SignInTokenCannot<wbr />BeRevoked</code>

```json
{
  "shortMessage": "cannot revoke",
  "longMessage": "Sign in token cannot be revoked because its status is <status>. Only pending tokens can be revoked.",
  "code": "sign_in_token_cannot_be_revoked_code"
}
```

---
title: Sign in with Apple
description: Learn how to use Clerk to natively Sign in with Apple.
---

This guide will teach you how to add native Sign in with Apple to your Clerk apps on Apple platforms.

<Steps>
  ## Add your Native Application

  Add your iOS application to the [**Native Applications**](https://dashboard.clerk.com/last-active?path=/native-applications) page in the Clerk dashboard. You will need your iOS app's **App ID Prefix** and **Bundle ID**.

  ## Enable Apple as a social connection

  1. In the Clerk Dashboard, navigate to the [**SSO Connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
  1. Select **Add connection** and select **For all users**.
  1. In the **Choose provider** dropdown, select **Apple**.
  1. Ensure that **Enable for sign-up and sign-in** is toggled on.

  > [!NOTE]
  > Apple provides a privacy feature called [Hide My Email](https://support.apple.com/en-us/HT210425#hideemail), allowing users to sign in to your app with Apple without disclosing their actual email addresses. Instead, your instance receives an app-specific email address that forwards any emails to the user's real address. To be able to send emails properly to users with hidden addresses, you must configure an additional setting in the Apple Developer portal. See [Configure Email Source for Apple Private Relay](/docs/authentication/social-connections/apple#configure-email-source-for-apple-private-relay){{ target: '_blank' }} for more information.

  ## Add the Sign in with Apple capability to your app

  [Add the Sign in with Apple capability to your app](https://developer.apple.com/documentation/xcode/configuring-sign-in-with-apple#Add-the-Sign-in-with-Apple-capability-to-your-app).

  ## Obtain an Apple ID Credential

  To authenticate with Apple and Clerk, you need to obtain an [Apple ID Credential](https://developer.apple.com/documentation/authenticationservices/asauthorizationappleidcredential).

  To obtain an Apple ID Credential, you can do one of the following:

  - Use one of [Apple's built-in Sign in with Apple buttons](https://developer.apple.com/documentation/signinwithapple/displaying-sign-in-with-apple-buttons-in-your-app).
  - Use Clerk's [`SignInWithAppleHelper`](https://swiftpackageindex.com/clerk/clerk-ios/main/documentation/clerk/signinwithapplehelper) class.
  - Obtain it manually by following [the Apple docs](https://developer.apple.com/documentation/signinwithapple).

  > [!NOTE]
  > You must set the nonce property of the `ASAuthorizationAppleIDRequest` when requesting an Apple ID Credential in order to authenticate with Clerk.

  ## Build your sign-in flow

  Once you have obtained your [Apple ID Credential](https://developer.apple.com/documentation/authenticationservices/asauthorizationappleidcredential), you can use it to authenticate with Clerk by calling [`SignIn.authenticateWithIdToken(provider:idToken:)`](https://swiftpackageindex.com/clerk/clerk-ios/main/documentation/clerk/signin/authenticatewithidtoken\(provider:idtoken:\)) with a provider of `.apple` and the `idToken` you have obtained.

  The following example uses Apple's built-in `SignInWithAppleButton` to obtain an Apple ID Credential and calls `SignIn.authenticateWithIdToken(provider:idToken:)` to authenticate with Clerk.

  ```swift {{ filename: 'SignInWithAppleView.swift' }}
  import SwiftUI
  import Clerk
  import AuthenticationServices

  struct SignInWithAppleView: View {
    var body: some View {
      // Use Apple's built-in SignInWithAppleButton
      SignInWithAppleButton { request in
        request.requestedScopes = [.email, .fullName]
        request.nonce = UUID().uuidString // Setting the nonce is mandatory
      } onCompletion: { result in
        Task {
          // Access the Apple ID Credential
          guard let credential = try result.get().credential as? ASAuthorizationAppleIDCredential else {
            dump("Unable to get credential of type ASAuthorizationAppleIDCredential")
            return
          }

          // Access the necessary identity token on the Apple ID Credential
          guard let idToken = credential.identityToken.flatMap({ String(data: $0, encoding: .utf8) }) else {
            dump("Unable to get ID token from Apple ID Credential.")
            return
          }

          // Authenticate with Clerk
          let authResult = try await SignIn.authenticateWithIdToken(provider: .apple, idToken: idToken)
        }
      }
    }
  }
  ```
</Steps>

---
title: Sign-in
description: Examples of prebuilt sign-in flows with Clerk Elements.
---

## Username/password

The following example demonstrates a simple username/password sign-in flow.

Before you build your sign-in flow, you need to configure the appropriate settings in Clerk:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. In the **Contact information** section, ensure that _only_ **Password** is enabled.
1. In the **Username** section, ensure that **Username** is enabled.

<CodeBlockDemo
  priority
  demos={[
  {
    key: 'sign-in-username-password',
    demo: '/demo/elements/sign-in/username-password',
    style: {
      height: `${568 / 16}rem`,
      backgroundColor: 'rgb(244 244 245)'
    }
  }
]}
>
  ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx', collapsible: true }}
  'use client'

  import * as Clerk from '@clerk/elements/common'
  import * as SignIn from '@clerk/elements/sign-in'

  export default function SignInPage() {
    return (
      <div className="grid w-full flex-grow items-center bg-zinc-100 px-4 sm:justify-center">
        <SignIn.Root>
          <SignIn.Step
            name="start"
            className="w-full space-y-6 rounded-2xl bg-white px-4 py-10 shadow-md ring-1 ring-black/5 sm:w-96 sm:px-8"
          >
            <header className="text-center">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 40 40"
                className="mx-auto size-10 text-zinc-950"
                aria-hidden
              >
                <mask id="a" width="40" height="40" x="0" y="0" maskUnits="userSpaceOnUse">
                  <circle cx="20" cy="20" r="20" fill="#D9D9D9" />
                </mask>
                <g fill="currentColor" mask="url(#a)">
                  <path d="M43.5 3a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V2ZM43.5 8a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V7ZM43.5 13a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 18a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 23a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 28a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 33a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 38a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1Z" />
                  <path d="M27 3.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 8.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM23 13.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM21.5 18.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM20.5 23.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM22.5 28.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 33.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM27 38.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2Z" />
                </g>
              </svg>
              <h1 className="mt-4 text-xl font-medium tracking-tight text-zinc-950">
                Sign in to Clover
              </h1>
            </header>
            <Clerk.GlobalError className="block text-sm text-red-400" />
            <div className="space-y-4">
              <Clerk.Field name="identifier" className="space-y-2">
                <Clerk.Label className="text-sm font-medium text-zinc-950">Username</Clerk.Label>
                <Clerk.Input
                  type="text"
                  required
                  className="w-full rounded-md bg-white px-3.5 py-2 text-sm outline-none ring-1 ring-inset ring-zinc-300 hover:ring-zinc-400 focus:ring-[1.5px] focus:ring-zinc-950 data-[invalid]:ring-red-400"
                />
                <Clerk.FieldError className="block text-sm text-red-400" />
              </Clerk.Field>
              <Clerk.Field name="password" className="space-y-2">
                <Clerk.Label className="text-sm  font-medium text-zinc-950">Password</Clerk.Label>
                <Clerk.Input
                  type="password"
                  required
                  className="w-full rounded-md bg-white px-3.5 py-2 text-sm outline-none ring-1 ring-inset ring-zinc-300 hover:ring-zinc-400 focus:ring-[1.5px] focus:ring-zinc-950 data-[invalid]:ring-red-400"
                />
                <Clerk.FieldError className="block text-sm text-red-400" />
              </Clerk.Field>
            </div>
            <SignIn.Action
              submit
              className="w-full rounded-md bg-zinc-950 px-3.5 py-1.5 text-center text-sm font-medium text-white shadow outline-none ring-1 ring-inset ring-zinc-950 hover:bg-zinc-800 focus-visible:outline-[1.5px] focus-visible:outline-offset-2 focus-visible:outline-zinc-950 active:text-white/70"
            >
              Sign In
            </SignIn.Action>
            <p className="text-center text-sm text-zinc-500">
              No account?{' '}
              <Clerk.Link
                navigate="sign-up"
                className="font-medium text-zinc-950 decoration-zinc-950/20 underline-offset-4 outline-none hover:text-zinc-700 hover:underline focus-visible:underline"
              >
                Create an account
              </Clerk.Link>
            </p>
          </SignIn.Step>
        </SignIn.Root>
      </div>
    )
  }
  ```
</CodeBlockDemo>

## Google OAuth

The following example demonstrates a simple Google OAuth sign-in flow.

Before you build your sign-in flow, you need to configure the appropriate settings in Clerk:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. Ensure that all settings are disabled.
1. In the navigation sidenav, select [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections).
1. Ensure that _only_ **Google** is enabled.

<CodeBlockDemo
  demos={[
  {
    key: 'sign-in-google-oauth',
    demo: '/demo/elements/sign-in/google-oauth',
    style: {
      height: `${392 / 16}rem`,
      backgroundColor: 'black'
    }
  }
]}
>
  ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx', collapsible: true }}
  'use client'

  import * as Clerk from '@clerk/elements/common'
  import * as SignIn from '@clerk/elements/sign-in'

  export default function SignInPage() {
    return (
      <div className="grid w-full flex-grow items-center bg-black px-4 sm:justify-center">
        <SignIn.Root>
          <SignIn.Step
            name="start"
            className="w-full flex-grow space-y-6 rounded-2xl bg-neutral-900 bg-[radial-gradient(circle_at_50%_0%,theme(colors.white/10%),transparent)] px-4 py-10 ring-1 ring-inset ring-white/5 sm:w-96 sm:px-8"
          >
            <header className="text-center">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 40 40"
                className="mx-auto size-10"
              >
                <mask id="a" width="40" height="40" x="0" y="0" maskUnits="userSpaceOnUse">
                  <circle cx="20" cy="20" r="20" fill="#D9D9D9" />
                </mask>
                <g fill="#fff" mask="url(#a)">
                  <path d="M43.5 3a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V2ZM43.5 8a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V7ZM43.5 13a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 18a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 23a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 28a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 33a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 38a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1Z" />
                  <path d="M27 3.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 8.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM23 13.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM21.5 18.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM20.5 23.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM22.5 28.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 33.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM27 38.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2Z" />
                </g>
              </svg>
              <h1 className="mt-4 text-xl font-medium tracking-tight text-white">
                Sign in to Clover
              </h1>
            </header>
            <Clerk.GlobalError className="block text-sm text-red-400" />
            <div className="space-y-2">
              <Clerk.Connection
                name="google"
                className="flex w-full items-center justify-center gap-x-3 rounded-md bg-neutral-700 px-3.5 py-1.5 text-sm font-medium text-white shadow-[0_1px_0_0_theme(colors.white/5%)_inset,0_0_0_1px_theme(colors.white/2%)_inset] outline-none hover:bg-gradient-to-b hover:from-white/5 hover:to-white/5 focus-visible:outline-[1.5px] focus-visible:outline-offset-2 focus-visible:outline-white active:bg-gradient-to-b active:from-black/20 active:to-black/20 active:text-white/70"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 17 16"
                  className="w-4"
                  aria-hidden
                >
                  <path
                    fill="currentColor"
                    d="M8.82 7.28v2.187h5.227c-.16 1.226-.57 2.124-1.192 2.755-.764.765-1.955 1.6-4.035 1.6-3.218 0-5.733-2.595-5.733-5.813 0-3.218 2.515-5.814 5.733-5.814 1.733 0 3.005.685 3.938 1.565l1.538-1.538C12.998.96 11.256 0 8.82 0 4.41 0 .705 3.591.705 8s3.706 8 8.115 8c2.382 0 4.178-.782 5.582-2.24 1.44-1.44 1.893-3.475 1.893-5.111 0-.507-.035-.978-.115-1.369H8.82Z"
                  />
                </svg>
                Login with Google
              </Clerk.Connection>
            </div>
            <p className="text-center text-sm text-neutral-400">
              No account?{' '}
              <Clerk.Link
                navigate="sign-up"
                className="font-medium text-white decoration-white/20 underline-offset-4 outline-none hover:underline focus-visible:underline"
              >
                Create an account
              </Clerk.Link>
            </p>
          </SignIn.Step>
        </SignIn.Root>
      </div>
    )
  }
  ```
</CodeBlockDemo>

## Multi-factor authentication (MFA)

The following example demonstrates a simple multi-factor authentication (MFA) sign-in flow. The user can sign in with their email and password. If they have two-factor authentication enabled, they will need to verify their sign-in attempt with an SMS code.

Before you build your sign-in flow, you need to configure the appropriate settings in Clerk:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. Ensure that **Email address**, **Phone number**, and **Password** are enabled.
1. Next to **Phone number**, select the settings icon and enable **Require**.
1. In the navigation sidenav, select [**Multi-factor**](https://dashboard.clerk.com/last-active?path=user-authentication/multi-factor).
1. Ensure that _only_ **SMS verification code** is enabled.

<CodeBlockDemo
  demos={[
  {
    key: 'sign-in-multi-factor-auth',
    demo: '/demo/elements/sign-in/multi-factor-auth',
    style: {
      height: `${560 / 16}rem`,
      backgroundColor: 'black'
    }
  }
]}
>
  ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx', collapsible: true }}
  'use client'

  import * as Clerk from '@clerk/elements/common'
  import * as SignIn from '@clerk/elements/sign-in'

  export default function SignInPage() {
    return (
      <div className="relative grid w-full flex-grow items-center bg-black px-4 sm:justify-center">
        <SignIn.Root>
          <SignIn.Step
            name="start"
            className="relative isolate w-full space-y-8 rounded-2xl bg-emerald-950 px-4 py-10 shadow-md ring-1 ring-inset ring-white/10 before:absolute before:inset-0 before:-z-10 before:rounded-2xl before:bg-black/50 sm:w-96 sm:px-8"
          >
            <header className="text-center">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 40 40"
                className="mx-auto size-10"
              >
                <mask id="a" width="40" height="40" x="0" y="0" maskUnits="userSpaceOnUse">
                  <circle cx="20" cy="20" r="20" fill="#D9D9D9" />
                </mask>
                <g fill="#34D399" mask="url(#a)">
                  <path d="M43.5 3a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V2ZM43.5 8a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V7ZM43.5 13a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 18a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 23a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 28a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 33a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 38a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1Z" />
                  <path d="M27 3.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 8.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM23 13.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM21.5 18.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM20.5 23.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM22.5 28.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 33.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM27 38.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2Z" />
                </g>
              </svg>
              <h1 className="mt-4 text-xl font-medium tracking-tight text-white">
                Sign in to Clover
              </h1>
            </header>
            <Clerk.GlobalError className="block text-sm text-rose-400" />
            <Clerk.Field name="identifier" className="group/field relative">
              <Clerk.Label className="absolute left-2 top-0 -translate-y-1/2 bg-emerald-950 px-2 font-mono text-xs/4 text-white before:absolute before:inset-0 before:-z-10 before:bg-black/50 group-focus-within/field:text-emerald-300 group-data-[invalid]/field:text-rose-400">
                Email address
              </Clerk.Label>
              <Clerk.Input
                type="text"
                required
                className="w-full rounded-lg bg-transparent px-4 py-2.5 text-sm text-white outline-none ring-1 ring-inset ring-white/20 hover:ring-white/30 focus:shadow-[0_0_6px_0] focus:shadow-emerald-500/20 focus:ring-[1.5px] focus:ring-emerald-300 data-[invalid]:shadow-rose-400/20 data-[invalid]:ring-rose-400"
              />
              <Clerk.FieldError className="mt-2 block text-xs text-rose-400" />
            </Clerk.Field>
            <Clerk.Field name="password" className="group/field relative">
              <Clerk.Label className="absolute left-2 top-0 -translate-y-1/2 bg-emerald-950 px-2 font-mono text-xs/4 text-white before:absolute before:inset-0 before:-z-10 before:bg-black/50 group-focus-within/field:text-emerald-300 group-data-[invalid]/field:text-rose-400">
                Password
              </Clerk.Label>
              <Clerk.Input
                type="password"
                required
                className="w-full rounded-lg bg-transparent px-4 py-2.5 text-sm text-white outline-none ring-1 ring-inset ring-white/20 hover:ring-white/30 focus:shadow-[0_0_6px_0] focus:shadow-emerald-500/20 focus:ring-[1.5px] focus:ring-emerald-300 data-[invalid]:shadow-rose-400/20 data-[invalid]:ring-rose-400"
              />
              <Clerk.FieldError className="mt-2 block text-xs text-rose-400" />
            </Clerk.Field>
            <SignIn.Action
              submit
              className="relative isolate w-full rounded-lg bg-gradient-to-b from-emerald-400 to-emerald-500 px-3.5 py-2.5 text-center text-sm font-medium text-emerald-950 shadow-[0_1px_0_0_theme(colors.white/30%)_inset,0_-1px_1px_0_theme(colors.black/5%)_inset] outline-none before:absolute before:inset-0 before:-z-10 before:rounded-lg before:bg-white/10 before:opacity-0 hover:before:opacity-100 focus-visible:outline-[1.5px] focus-visible:outline-offset-2 focus-visible:outline-white active:text-emerald-950/80 active:before:bg-black/10"
            >
              Sign In
            </SignIn.Action>
            <p className="text-center text-sm text-white/60">
              No account?{' '}
              <Clerk.Link
                navigate="sign-up"
                className="text-white decoration-white/30 underline-offset-4 outline-none hover:underline focus-visible:underline"
              >
                Create an account
              </Clerk.Link>
            </p>
          </SignIn.Step>
          <SignIn.Step
            name="verifications"
            className="relative isolate w-full space-y-8 rounded-2xl bg-emerald-950 px-4 py-10 shadow-md ring-1 ring-inset ring-white/10 before:absolute before:inset-0 before:-z-10 before:rounded-2xl before:bg-black/50 sm:w-96 sm:px-8"
          >
            <header className="text-center">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 40 40"
                className="mx-auto size-10"
              >
                <mask id="a" width="40" height="40" x="0" y="0" maskUnits="userSpaceOnUse">
                  <circle cx="20" cy="20" r="20" fill="#D9D9D9" />
                </mask>
                <g fill="#34D399" mask="url(#a)">
                  <path d="M43.5 3a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V2ZM43.5 8a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V7ZM43.5 13a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 18a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 23a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 28a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 33a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 38a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1Z" />
                  <path d="M27 3.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 8.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM23 13.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM21.5 18.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM20.5 23.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM22.5 28.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 33.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM27 38.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2Z" />
                </g>
              </svg>
              <h1 className="mt-4 text-xl font-medium tracking-tight text-white">
                Verify phone code
              </h1>
            </header>
            <Clerk.GlobalError className="block text-sm text-rose-400" />
            <SignIn.Strategy name="phone_code">
              <Clerk.Field name="code" className="group/field relative">
                <Clerk.Label className="absolute left-2 top-0 -translate-y-1/2 bg-emerald-950 px-2 font-mono text-xs/4 text-white before:absolute before:inset-0 before:-z-10 before:bg-black/50 group-focus-within/field:text-emerald-300 group-data-[invalid]/field:text-rose-400">
                  Phone code
                </Clerk.Label>
                <Clerk.Input
                  type="otp"
                  required
                  className="w-full rounded-lg bg-transparent px-4 py-2.5 text-sm text-white outline-none ring-1 ring-inset ring-white/20 hover:ring-white/30 focus:shadow-[0_0_6px_0] focus:shadow-emerald-500/20 focus:ring-[1.5px] focus:ring-emerald-300 data-[invalid]:shadow-rose-400/20 data-[invalid]:ring-rose-400"
                />
                <Clerk.FieldError className="mt-2 block text-xs text-rose-400" />
              </Clerk.Field>
              <SignIn.Action
                submit
                className="relative isolate w-full rounded-lg bg-gradient-to-b from-emerald-400 to-emerald-500 px-3.5 py-2.5 text-center text-sm font-medium text-emerald-950 shadow-[0_1px_0_0_theme(colors.white/30%)_inset,0_-1px_1px_0_theme(colors.black/5%)_inset] outline-none before:absolute before:inset-0 before:-z-10 before:rounded-lg before:bg-white/10 before:opacity-0 hover:before:opacity-100 focus-visible:outline-[1.5px] focus-visible:outline-offset-2 focus-visible:outline-white active:text-emerald-950/80 active:before:bg-black/10"
              >
                Continue
              </SignIn.Action>
            </SignIn.Strategy>
            <p className="text-center text-sm text-white/60">
              No account?{' '}
              <Clerk.Link
                navigate="sign-up"
                className="text-white decoration-white/30 underline-offset-4 outline-none hover:underline focus-visible:underline"
              >
                Create an account
              </Clerk.Link>
            </p>
          </SignIn.Step>
        </SignIn.Root>
      </div>
    )
  }
  ```
</CodeBlockDemo>

## Email + Google + MFA

The following example demonstrates a simple sign-in flow that combines email, Google OAuth, and multi-factor authentication (MFA). The user can sign in with their email and an email code, or with Google OAuth. If they have two-factor authentication enabled, they will need to verify their sign-in attempt with an SMS code.

Before you build your sign-in flow, you need to configure the appropriate settings in Clerk:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. In the **Contact information** section, ensure that _only_ **Email address** and **Phone number** is enabled.
1. Next to **Phone number**, select the settings icon and enable **Require**.
1. In the **Authentication strategies** section, ensure that _only_ **Email verification code** is enabled.
1. In the navigation sidenav, select [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections).
1. Ensure that _only_ **Google** is enabled.
1. In the navigation sidenav, select [**Multi-factor**](https://dashboard.clerk.com/last-active?path=user-authentication/multi-factor).
1. Ensure that _only_ **SMS verification code** is enabled.

<CodeBlockDemo
  demos={[
  {
    key: 'sign-in-google-email-mfa',
    demo: '/demo/elements/sign-in/google-email-mfa',
    style: {
      height: `${582 / 16}rem`,
      backgroundColor: 'black'
    },
    bordered: true
  }
]}
>
  ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx', collapsible: true }}
  'use client'

  import * as Clerk from '@clerk/elements/common'
  import * as SignIn from '@clerk/elements/sign-in'

  export default function SignInPage() {
    return (
      <div className="grid w-full flex-grow items-center bg-white px-4 sm:justify-center">
        <SignIn.Root>
          <SignIn.Step
            name="start"
            className="w-full space-y-6 rounded-2xl px-4 py-10 sm:w-96 sm:px-8"
          >
            <header className="text-center">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 40 40"
                className="mx-auto size-10"
              >
                <mask id="a" width="40" height="40" x="0" y="0" maskUnits="userSpaceOnUse">
                  <circle cx="20" cy="20" r="20" fill="#D9D9D9" />
                </mask>
                <g fill="#0A0A0A" mask="url(#a)">
                  <path d="M43.5 3a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V2ZM43.5 8a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V7ZM43.5 13a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 18a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 23a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 28a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 33a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 38a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1Z" />
                  <path d="M27 3.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 8.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM23 13.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM21.5 18.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM20.5 23.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM22.5 28.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 33.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM27 38.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2Z" />
                </g>
              </svg>
              <h1 className="mt-4 text-xl font-medium tracking-tight text-neutral-950">
                Sign in to Clover
              </h1>
            </header>
            <Clerk.GlobalError className="block text-sm text-red-600" />
            <Clerk.Field name="identifier">
              <Clerk.Label className="sr-only">Email</Clerk.Label>
              <Clerk.Input
                type="email"
                required
                placeholder="Email"
                className="w-full border-b border-neutral-200 bg-white pb-2 text-sm/6 text-neutral-950 outline-none placeholder:text-neutral-400 hover:border-neutral-300 focus:border-neutral-600 data-[invalid]:border-red-600 data-[invalid]:text-red-600"
              />
              <Clerk.FieldError className="mt-2 block text-xs text-red-600" />
            </Clerk.Field>
            <SignIn.Action
              submit
              className="relative w-full rounded-md bg-neutral-600 bg-gradient-to-b from-neutral-500 to-neutral-600 py-1.5 text-sm font-medium text-white shadow-[0_1px_1px_0_theme(colors.white/10%)_inset,0_1px_2.5px_0_theme(colors.black/36%)] outline-none ring-1 ring-inset ring-neutral-600 before:absolute before:inset-0 before:rounded-md before:bg-white/10 before:opacity-0 hover:before:opacity-100 focus-visible:outline-offset-2 focus-visible:outline-neutral-600 active:bg-neutral-600 active:text-white/60 active:before:opacity-0"
            >
              Sign In
            </SignIn.Action>
            <div className="rounded-xl bg-neutral-100 p-5">
              <p className="mb-4 text-center text-sm/5 text-neutral-500">
                Alternatively, sign in with these platforms
              </p>
              <div className="space-y-2">
                <Clerk.Connection
                  name="google"
                  className="flex w-full items-center justify-center gap-x-3 rounded-md bg-gradient-to-b from-white to-neutral-50 px-2 py-1.5 text-sm font-medium text-neutral-950 shadow outline-none ring-1 ring-black/5 hover:to-neutral-100 focus-visible:outline-offset-2 focus-visible:outline-neutral-600 active:text-neutral-950/60"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 16 16"
                    aria-hidden
                    className="size-4"
                  >
                    <g clipPath="url(#a)">
                      <path
                        fill="currentColor"
                        d="M8.32 7.28v2.187h5.227c-.16 1.226-.57 2.124-1.192 2.755-.764.765-1.955 1.6-4.035 1.6-3.218 0-5.733-2.595-5.733-5.813 0-3.218 2.515-5.814 5.733-5.814 1.733 0 3.005.685 3.938 1.565l1.538-1.538C12.498.96 10.756 0 8.32 0 3.91 0 .205 3.591.205 8s3.706 8 8.115 8c2.382 0 4.178-.782 5.582-2.24 1.44-1.44 1.893-3.475 1.893-5.111 0-.507-.035-.978-.115-1.369H8.32Z"
                      />
                    </g>
                    <defs>
                      <clipPath id="a">
                        <path fill="#fff" d="M0 0h16v16H0z" />
                      </clipPath>
                    </defs>
                  </svg>
                  Login with Google
                </Clerk.Connection>
              </div>
            </div>
            <p className="text-center text-sm text-neutral-500">
              Don&apos;t have an account?{' '}
              <Clerk.Link
                navigate="sign-up"
                className="rounded px-1 py-0.5 text-neutral-700 outline-none hover:bg-neutral-100 focus-visible:bg-neutral-100"
              >
                Sign up
              </Clerk.Link>
            </p>
          </SignIn.Step>
          <SignIn.Step
            name="verifications"
            className="w-full space-y-6 rounded-2xl px-4 py-10 sm:w-96 sm:px-8"
          >
            <SignIn.Strategy name="email_code">
              <header className="text-center">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 40 40"
                  className="mx-auto size-10"
                >
                  <mask id="a" width="40" height="40" x="0" y="0" maskUnits="userSpaceOnUse">
                    <circle cx="20" cy="20" r="20" fill="#D9D9D9" />
                  </mask>
                  <g fill="#0A0A0A" mask="url(#a)">
                    <path d="M43.5 3a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V2ZM43.5 8a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V7ZM43.5 13a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 18a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 23a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 28a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 33a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 38a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1Z" />
                    <path d="M27 3.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 8.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM23 13.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM21.5 18.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM20.5 23.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM22.5 28.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 33.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM27 38.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2Z" />
                  </g>
                </svg>
                <h1 className="mt-4 text-xl font-medium tracking-tight text-neutral-950">
                  Verify email code
                </h1>
              </header>
              <Clerk.GlobalError className="block text-sm text-red-600" />
              <Clerk.Field name="code">
                <Clerk.Label className="sr-only">Email code</Clerk.Label>
                <Clerk.Input
                  type="otp"
                  required
                  placeholder="Email code"
                  className="w-full border-b border-neutral-200 bg-white pb-2 text-sm/6 text-neutral-950 outline-none placeholder:text-neutral-400 hover:border-neutral-300 focus:border-neutral-600 data-[invalid]:border-red-600 data-[invalid]:text-red-600"
                />
                <Clerk.FieldError className="mt-2 block text-xs text-red-600" />
              </Clerk.Field>
              <SignIn.Action
                submit
                className="relative w-full rounded-md bg-neutral-600 bg-gradient-to-b from-neutral-500 to-neutral-600 py-1.5 text-sm text-white shadow-[0_1px_1px_0_theme(colors.white/10%)_inset,0_1px_2.5px_0_theme(colors.black/36%)] outline-none ring-1 ring-inset ring-neutral-600 before:absolute before:inset-0 before:rounded-md before:bg-white/10 before:opacity-0 hover:before:opacity-100 focus-visible:outline-offset-2 focus-visible:outline-neutral-600 active:bg-neutral-600 active:text-white/60 active:before:opacity-0"
              >
                Continue
              </SignIn.Action>
            </SignIn.Strategy>
            <SignIn.Strategy name="phone_code">
              <header className="text-center">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 40 40"
                  className="mx-auto size-10"
                >
                  <mask id="a" width="40" height="40" x="0" y="0" maskUnits="userSpaceOnUse">
                    <circle cx="20" cy="20" r="20" fill="#D9D9D9" />
                  </mask>
                  <g fill="#0A0A0A" mask="url(#a)">
                    <path d="M43.5 3a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V2ZM43.5 8a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V7ZM43.5 13a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 18a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 23a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 28a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 33a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 38a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1Z" />
                    <path d="M27 3.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 8.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM23 13.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM21.5 18.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM20.5 23.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM22.5 28.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 33.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM27 38.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2Z" />
                  </g>
                </svg>
                <h1 className="mt-4 text-xl font-medium tracking-tight text-neutral-950">
                  Verify phone code
                </h1>
              </header>
              <Clerk.GlobalError className="block text-sm text-red-600" />
              <Clerk.Field name="code">
                <Clerk.Label className="sr-only">Phone code</Clerk.Label>
                <Clerk.Input
                  type="otp"
                  required
                  placeholder="Phone code"
                  className="w-full border-b border-neutral-200 bg-white pb-2 text-sm/6 text-neutral-950 outline-none placeholder:text-neutral-400 hover:border-neutral-300 focus:border-neutral-600 data-[invalid]:border-red-600 data-[invalid]:text-red-600"
                />
                <Clerk.FieldError className="mt-2 block text-xs text-red-600" />
              </Clerk.Field>
              <SignIn.Action
                submit
                className="relative w-full rounded-md bg-neutral-600 bg-gradient-to-b from-neutral-500 to-neutral-600 py-1.5 text-sm text-white shadow-[0_1px_1px_0_theme(colors.white/10%)_inset,0_1px_2.5px_0_theme(colors.black/36%)] outline-none ring-1 ring-inset ring-neutral-600 before:absolute before:inset-0 before:rounded-md before:bg-white/10 before:opacity-0 hover:before:opacity-100 focus-visible:outline-offset-2 focus-visible:outline-neutral-600 active:bg-neutral-600 active:text-white/60 active:before:opacity-0"
              >
                Login
              </SignIn.Action>
            </SignIn.Strategy>
            <p className="text-center text-sm text-neutral-500">
              Don&apos;t have an account?{' '}
              <Clerk.Link
                navigate="sign-up"
                className="rounded px-1 py-0.5 text-neutral-700 outline-none hover:bg-neutral-100 focus-visible:bg-neutral-100"
              >
                Sign up
              </Clerk.Link>
            </p>
          </SignIn.Step>
        </SignIn.Root>
      </div>
    )
  }
  ```
</CodeBlockDemo>

---
title: Sign-in components
description: Reference documentation for Clerk Elements sign-in components.
---

The following components are used when creating sign-in flows. They are imported from `@clerk/elements/sign-in`. It is recommended to import them all under the `SignIn` namespace to make discovery easier and reduce naming conflicts with other components throughout your application. The code snippets on this page assume you have imported the components this way.

```tsx {{ filename: 'Anatomy' }}
import * as SignIn from '@clerk/elements/sign-in'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step name="start" />
      <SignIn.Step name="verifications" />
      <SignIn.Step name="choose-strategy" />
      <SignIn.Step name="forgot-password" />
      <SignIn.Step name="reset-password" />
    </SignIn.Root>
  )
}
```

## `<Root>`

The root sign-in component. Sets up providers and state management for the sign-in flow. Must wrap all other sign-in components.

`<Root>` will validate your sign-in flow to ensure the implementation is correct based on instance settings and best practices. In development instances, if the flow is invalid, it will throw an error.

### Properties {{ toc: false }}

<Properties>
  - `path?`
  - `string`

  The root path the sign-in flow is mounted at. If not provided, will be automatically inferred (either through the current pathname or [environment variables](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects)). Fallback: `/sign-in`

  ---

  - `fallback?`
  - `React.ReactNode`

  Fallback markup to render while Clerk is loading. Default: `null`

  ---

  - `routing?`
  - `'path' | 'virtual'`

  If you want to render Clerk Elements in e.g. a modal, use the `'virtual'` routing mode. Default: `'path'`
</Properties>

The following data attributes are also added to the underlying element:

- `data-global-error` - Refers to the [`<GlobalError>`](/docs/customization/elements/reference/common#global-error) status

## `<Step>`

A step in the sign-in flow. Conditionally renders its children based on the status of the current sign-in attempt. `start` is the initial step.

### Properties {{ toc: false }}

<Properties>
  - `name`
  - `'start' | 'verifications' | 'choose-strategy' | 'forgot-password' | 'reset-password'`

  The `name` of the step for which its children will be rendered.
</Properties>

### `<Step name="start">`

Renders the beginning sign-in form. Once a sign-in attempt has been created from this step, `<Step name="verifications">` will be rendered.

Typically, this step will contain an `identifier` field and social connection buttons to create a sign-in attempt, however the exact fields that should be rendered depend on your instance configuration.

#### Usage {{ toc: false }}

```tsx {{ filename: 'page.tsx' }}
<SignIn.Step name="start">
  <Clerk.Field name="identifier">
    <Clerk.Label>Email</Clerk.Label>
    <Clerk.Input />
    <Clerk.FieldError />
  </Clerk.Field>
  <SignIn.Action submit>Sign In with Email</SignIn.Action>
</SignIn.Step>
```

### `<Step name="verifications">`

Will render its children if a sign-in attempt is in progress. Any nested `<Strategy>` components will conditionally render based on the status of the sign-in attempt.

You'll typically also want to link to `choose-strategy` to allow for alternative login methods.

#### Usage {{ toc: false }}

```tsx {{ filename: 'page.tsx' }}
<SignIn.Step name="verifications">
  <SignIn.Strategy name="password">
    <Clerk.Field name="password">
      <Clerk.Label>password</Clerk.Label>
      <Clerk.Input />
      <Clerk.FieldError />
    </Clerk.Field>
    <SignIn.Action submit>Sign In</SignIn.Action>
  </SignIn.Strategy>
  <SignIn.Action navigate="choose-strategy">Use another method</SignIn.Action>
</SignIn.Step>
```

### `<Step name="choose-strategy">`

Allows a user to pick a new strategy to verify. This step can be rendered by navigating to `choose-strategy` using `<Action>`.

#### Usage {{ toc: false }}

```tsx {{ filename: 'page.tsx' }}
<SignIn.Step name="choose-strategy">
  <SignIn.SupportedStrategy name="phone_code">Send a code to your phone</SignIn.SupportedStrategy>
</SignIn.Step>
```

### `<Step name="forgot-password">`

If the currently requested strategy is `password`, but a user can't remember their password, you can navigate them to the `forgot-password` step. They can begin the reset password flow or choose a new strategy. This step can be rendered by navigating to `forgot-password` using `<Action>`.

#### Usage {{ toc: false }}

```tsx {{ filename: 'page.tsx' }}
<SignIn.Step name="forgot-password">
  <SignIn.SupportedStrategy name="reset_password_email_code">
    Reset your password via Email
  </SignIn.SupportedStrategy>
  <p>or</p>
  <SignIn.SupportedStrategy name="google">Sign in with Google</SignIn.SupportedStrategy>
</SignIn.Step>
```

### `<Step name="reset-password">`

If a user has requested a password reset and verified their identity, they will be navigated to `reset-password`. A password field should be rendered in this step to allow the user to set a new password.

#### Usage {{ toc: false }}

```tsx {{ filename: 'page.tsx' }}
<SignIn.Step name="reset-password">
  <Clerk.Field name="password">
    <Clerk.Label>New password</Clerk.Label>
    <Clerk.Input />
    <Clerk.FieldError />
  </Clerk.Field>
  <Clerk.Field name="confirmPassword">
    <Clerk.Label>Confirm password</Clerk.Label>
    <Clerk.Input />
    <Clerk.FieldError />
  </Clerk.Field>
  <SignIn.Action submit>Update password</SignIn.Action>
</SignIn.Step>
```

## `<Strategy>`

Conditionally renders its children depending on the authentication strategy that needs to be verified. Does not render any markup on its own.

### Properties {{ toc: false }}

<Properties>
  - `name`
  - <code>'saml' | 'ticket' | 'password' | 'passkey' | 'phone\_code' | 'email\_code' | 'web3\_metamask\_signature' | 'web3\_coinbase\_wallet\_signature' | 'web3\_okx\_wallet\_signature' | 'reset\_password\_email\_code' | 'reset\_password\_phone\_code' | 'email\_link' | 'totp' | 'backup\_code' | 'oauth' | 'web3' | [OAuthStrategy](https://github.com/clerk/javascript/blob/956d8792fefe9d6a89022f1e938149b25503ec7f/packages/types/src/strategies.ts#L15)</code>

  The name of the strategy for which its children will be rendered.
</Properties>

### Usage {{ toc: false }}

```tsx {{ filename: 'page.tsx' }}
<SignIn.Strategy name="email_code">
  <Clerk.Field name="code">
    <Clerk.Label>Code</Clerk.Label>
    <Clerk.Input />
    <Clerk.FieldError />
  </Clerk.Field>
  <SignIn.Action submit>Verify</SignIn.Action>
</SignIn.Strategy>
```

#### `<Strategy name="passkey">`

```tsx {{ filename: 'page.tsx' }}
<SignIn.Strategy name="passkey">
  <SignIn.Action submit>Continue with Passkey</SignIn.Action>
</SignIn.Strategy>
```

## `<SupportedStrategy>`

Renders a button that will change the current strategy that needs to be verified when in the `choose-strategy` or `forgot-password` steps.

### Properties {{ toc: false }}

<Properties>
  - `name`
  - `'email_code' | 'email_link' | 'password' | 'passkey' | 'phone_code' | 'reset_password_email_code' | 'reset_password_phone_code' | 'web3_metamask_signature' | 'web3_coinbase_wallet_signature' | 'web3_okx_wallet_signature'`

  The name of the strategy to switch to.
</Properties>

### Usage {{ toc: false }}

```tsx {{ filename: 'page.tsx' }}
<SignIn.Step name="choose-strategy">
  <SignIn.SupportedStrategy name="password">Sign in with password</SignIn.SupportedStrategy>
</SignIn.Step>
```

## `<Action>`

Exposes various flow-related actions. It can be used to submit forms, navigate between steps, and re-trigger sending of verification codes. By default, renders a `<button>`.

### Properties {{ toc: false }}

<Properties>
  - `submit?`
  - `boolean`

  If `true`, the action will submit the form. Default: `false`

  ---

  - `navigate?`
  - `'choose-strategy' | 'forgot-password' | 'previous' | 'start'`

  The name of the step to navigate to. Default: `undefined`

  ---

  - `resend?`
  - `boolean`

  If `true`, the action will resend the verification code for the currently active strategy, if applicable. Default: `false`

  ---

  - `fallback?`
  - `({ resendableAfter: number }) => React.ReactNode`

  Only used when `resend` is `true`. If provided, the fallback markup will be rendered before the resend delay has expired. Default: `null`
</Properties>

### Usage {{ toc: false }}

#### `<Action submit>`

```tsx {{ filename: 'page.tsx', mark: [7] }}
<SignIn.Step name="start">
  <Clerk.Field name="identifier">
    <Clerk.Label>Email</Clerk.Label>
    <Clerk.Input />
    <Clerk.FieldError />
  </Clerk.Field>
  <SignIn.Action submit>Sign in</SignIn.Action>
</SignIn.Step>
```

#### `<Action navigate>`

```tsx {{ filename: 'page.tsx', mark: [9] }}
<SignIn.Step name="verifications">
  <SignIn.Strategy name="password">
    <Clerk.Field name="password">
      <Clerk.Label>Password</Clerk.Label>
      <Clerk.Input />
      <Clerk.FieldError />
    </Clerk.Field>
    <SignIn.Action submit>Sign in</SignIn.Action>
    <SignIn.Action navigate="forgot-password">Forgot password?</SignIn.Action>
  </SignIn.Strategy>
</SignIn.Step>
```

#### `<Action resend>`

```tsx {{ filename: 'page.tsx', mark: [[9, 14]] }}
<SignIn.Step name="verifications">
  <SignIn.Strategy name="email_code">
    <Clerk.Field name="code">
      <Clerk.Label>Code</Clerk.Label>
      <Clerk.Input />
      <Clerk.FieldError />
    </Clerk.Field>
    <SignIn.Action submit>Verify</SignIn.Action>
    <SignIn.Action
      resend
      fallback={({ resendableAfter }) => <p>Resend code in {resendableAfter} second(s)</p>}
    >
      Resend code
    </SignIn.Action>
  </SignIn.Strategy>
</SignIn.Step>
```

## `<SafeIdentifier />`

Renders a masked identifier corresponding to the parent `Strategy` or `SupportedStrategy`, falling back to the identifier that has been provided by the user during a sign-in attempt. Renders a `string` (or empty string if it can't find an identifier). Must be a child of either `<Strategy>` or `<SupportedStrategy>`.

### Properties {{ toc: false }}

<Properties>
  - `transform?`
  - `(identifier: string) => string`

  If provided, modify the supplied `identifier` string before rendering. Useful when interpolating the identifier into localized strings.
</Properties>

### Usage {{ toc: false }}

```tsx {{ filename: 'page.tsx' }}
<SignIn.Strategy name="email_code">
  <h1>Check your email</h1>
  <p>
    We sent a code to <SignIn.SafeIdentifier />.
  </p>
</SignIn.Strategy>
```

```tsx {{ filename: 'page.tsx' }}
<SignIn.Strategy name="email_code">
  <h1>{t('checkEmail')}</h1>
  <p>
    <SignIn.SafeIdentifier transform={(identifier) => t('sentCodeTo', { identifier })} />
  </p>
</SignIn.Strategy>
```

## `<Salutation />`

Renders a salutation for the user during a sign-in attempt. It attempts to resolve these values in this specific order:

1. First name
1. Last name
1. Identifier

Renders a `string` (or empty string if it can't find an identifier).

### Usage {{ toc: false }}

```tsx {{ filename: 'page.tsx' }}
<SignIn.Strategy name="password">
  <p>
    Welcome back <SignIn.Salutation />!
  </p>
</SignIn.Strategy>
```

## `<Passkey />`

Trigger an autofill suggestion dialog with the stored passkeys. After selecting a passkey a sign-in attempt will be created. By default, renders a `<button>`.

### Usage {{ toc: false }}

```tsx {{ filename: 'page.tsx', mark: [2] }}
<SignIn.Step name="start">
  <SignIn.Passkey>Continue with Passkey</SignIn.Passkey>
</SignIn.Step>
```

---
title: Sign-in errors
description: An index of Clerk errors related to sign-in.
type: reference
---

An index of Clerk errors related to sign-in.

## `SingleModeSessionExists`

```json
{
  "shortMessage": "Session already exists",
  "longMessage": "You're currently in single session mode. You can only be signed into one account at a time.",
  "code": "session_exists"
}
```

## `AlreadySignedIn`

```json
{
  "shortMessage": "You're already signed in",
  "code": "identifier_already_signed_in",
  "meta": {
    "SessionID": "<session ID>"
  }
}
```

## `AccountTransferInvalid`

```json
{
  "shortMessage": "Invalid account transfer",
  "longMessage": "There is no account to transfer",
  "code": "account_transfer_invalid"
}
```

## `InvalidClientStateForAction`

```json
{
  "shortMessage": "Invalid action",
  "longMessage": "We were unable to complete %s for this Client. %s",
  "code": "client_state_invalid"
}
```

## `InvalidStrategyForUser`

```json
{
  "shortMessage": "Invalid verification strategy",
  "longMessage": "The verification strategy is not valid for this account",
  "code": "strategy_for_user_invalid"
}
```

## `IdentificationClaimed`

```json
{
  "shortMessage": "Identification claimed by another user",
  "longMessage": "One or more identifiers on this sign up have since been connected to a different User. Please sign up again.",
  "code": "identification_claimed"
}
```

## <code>MutationOnOlderSignIn<wbr />NotAllowed</code>

```json
{
  "shortMessage": "Update operations are not allowed on older sign ins",
  "code": "resource_forbidden"
}
```

## `SignInNotFound`

```json
{
  "shortMessage": "not found",
  "longMessage": "No sign in was found with id <signInID>",
  "code": "resource_not_found"
}
```

## <code>IdentificationBelongs<wbr />ToDifferentUser</code>

```json
{
  "shortMessage": "belongs to different user",
  "longMessage": "The given identification belongs to a different user.",
  "code": "resource_forbidden"
}
```

## `NoSecondFactorsForStrategy`

```json
{
  "shortMessage": "no second factors",
  "longMessage": "No second factors were found for strategy <strategy>.",
  "code": "no_second_factors"
}
```

## `SignInNoIdentificationForUser`

```json
{
  "shortMessage": "no identification for user",
  "longMessage": "The given token doesn't have an associated identification for the user who created it.",
  "code": "sign_in_no_identification_for_user"
}
```

## <code>SignInIdentification<wbr />OrUserDeleted</code>

```json
{
  "shortMessage": "identification or user deleted",
  "longMessage": "Either the user or the selected identification were deleted. Please start over.",
  "code": "sign_in_identification_or_user_deleted"
}
```

---
title: Sign-up
description: Examples of prebuilt sign-up flows with Clerk Elements.
---

## Email/password + email verification

The following example demonstrates a sign-up flow with email and password fields. After the user submits their email and password, they are prompted to verify their email address.

Before you build your sign-up flow, you need to configure the appropriate settings in Clerk:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. In the **Contact information** section, ensure that _only_ **Email address** and **Password** are enabled.

<CodeBlockDemo
  priority
  demos={[
  {
    key: 'email-password-phone-verification',
    demo: '/demo/elements/sign-up/email-password-phone-verification',
    style: {
      height: `${568 / 16}rem`,
      backgroundColor: 'black'
    }
  }
]}
>
  ```tsx {{ filename: 'app/sign-up/[[...sign-up]]/page.tsx', collapsible: true }}
  'use client'

  import * as Clerk from '@clerk/elements/common'
  import * as SignUp from '@clerk/elements/sign-up'

  export default function SignUpPage() {
    return (
      <div className="grid w-full flex-grow items-center bg-black px-4 sm:justify-center">
        <SignUp.Root>
          <SignUp.Step
            name="start"
            className="w-full space-y-6 rounded-2xl bg-neutral-900 bg-[radial-gradient(circle_at_50%_0%,theme(colors.white/10%),transparent)] px-4 py-10 ring-1 ring-inset ring-white/5 sm:w-96 sm:px-8"
          >
            <header className="text-center">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 40 40"
                className="mx-auto size-10"
              >
                <mask id="a" width="40" height="40" x="0" y="0" maskUnits="userSpaceOnUse">
                  <circle cx="20" cy="20" r="20" fill="#D9D9D9" />
                </mask>
                <g fill="#fff" mask="url(#a)">
                  <path d="M43.5 3a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V2ZM43.5 8a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V7ZM43.5 13a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 18a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 23a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 28a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 33a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 38a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1Z" />
                  <path d="M27 3.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 8.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM23 13.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM21.5 18.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM20.5 23.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM22.5 28.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 33.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM27 38.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2Z" />
                </g>
              </svg>
              <h1 className="mt-4 text-xl font-medium tracking-tight text-white">
                Create an account
              </h1>
            </header>
            <Clerk.GlobalError className="block text-sm text-red-400" />
            <div className="space-y-4">
              <Clerk.Field name="emailAddress" className="space-y-2">
                <Clerk.Label className="text-sm font-medium text-white">Email address</Clerk.Label>
                <Clerk.Input
                  type="text"
                  required
                  className="w-full rounded-md bg-neutral-900 px-3.5 py-2 text-sm text-white outline-none ring-1 ring-inset ring-zinc-700 hover:ring-zinc-600 focus:bg-transparent focus:ring-[1.5px] focus:ring-blue-400 data-[invalid]:ring-red-400"
                />
                <Clerk.FieldError className="block text-sm text-red-400" />
              </Clerk.Field>
              <Clerk.Field name="password" className="space-y-2">
                <Clerk.Label className="text-sm font-medium text-white">Password</Clerk.Label>
                <Clerk.Input
                  type="password"
                  required
                  className="w-full rounded-md bg-neutral-900 px-3.5 py-2 text-sm text-white outline-none ring-1 ring-inset ring-zinc-700 hover:ring-zinc-600 focus:bg-transparent focus:ring-[1.5px] focus:ring-blue-400 data-[invalid]:ring-red-400"
                />
                <Clerk.FieldError className="block text-sm text-red-400" />
              </Clerk.Field>
            </div>
            <SignUp.Captcha className="empty:hidden" />
            <SignUp.Action
              submit
              className="relative isolate w-full rounded-md bg-blue-500 px-3.5 py-1.5 text-center text-sm font-medium text-white shadow-[0_1px_0_0_theme(colors.white/10%)_inset,0_0_0_1px_theme(colors.white/5%)] outline-none before:absolute before:inset-0 before:-z-10 before:rounded-md before:bg-white/5 before:opacity-0 hover:before:opacity-100 focus-visible:outline-[1.5px] focus-visible:outline-offset-2 focus-visible:outline-blue-400 active:text-white/70 active:before:bg-black/10"
            >
              Sign Up
            </SignUp.Action>
            <p className="text-center text-sm text-zinc-400">
              Have an account?{' '}
              <Clerk.Link
                navigate="sign-in"
                className="font-medium text-white decoration-white/20 underline-offset-4 outline-none hover:underline focus-visible:underline"
              >
                Sign in
              </Clerk.Link>
            </p>
          </SignUp.Step>
          <SignUp.Step
            name="verifications"
            className="w-full space-y-6 rounded-2xl bg-neutral-900 bg-[radial-gradient(circle_at_50%_0%,theme(colors.white/10%),transparent)] px-4 py-10 ring-1 ring-inset ring-white/5 sm:w-96 sm:px-8"
          >
            <header className="text-center">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 40 40"
                className="mx-auto size-10"
              >
                <mask id="a" width="40" height="40" x="0" y="0" maskUnits="userSpaceOnUse">
                  <circle cx="20" cy="20" r="20" fill="#D9D9D9" />
                </mask>
                <g fill="#fff" mask="url(#a)">
                  <path d="M43.5 3a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V2ZM43.5 8a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V7ZM43.5 13a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 18a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 23a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 28a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 33a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 38a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1Z" />
                  <path d="M27 3.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 8.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM23 13.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM21.5 18.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM20.5 23.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM22.5 28.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 33.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM27 38.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2Z" />
                </g>
              </svg>
              <h1 className="mt-4 text-xl font-medium tracking-tight text-white">
                Verify email code
              </h1>
            </header>
            <Clerk.GlobalError className="block text-sm text-red-400" />
            <SignUp.Strategy name="email_code">
              <Clerk.Field name="code" className="space-y-2">
                <Clerk.Label className="text-sm font-medium text-white">Email code</Clerk.Label>
                <Clerk.Input
                  required
                  className="w-full rounded-md bg-neutral-900 px-3.5 py-2 text-sm text-white outline-none ring-1 ring-inset ring-zinc-700 hover:ring-zinc-600 focus:bg-transparent focus:ring-[1.5px] focus:ring-blue-400 data-[invalid]:ring-red-400"
                />
                <Clerk.FieldError className="block text-sm text-red-400" />
              </Clerk.Field>
              <SignUp.Action
                submit
                className="relative isolate w-full rounded-md bg-blue-500 px-3.5 py-1.5 text-center text-sm font-medium text-white shadow-[0_1px_0_0_theme(colors.white/10%)_inset,0_0_0_1px_theme(colors.white/5%)] outline-none before:absolute before:inset-0 before:-z-10 before:rounded-md before:bg-white/5 before:opacity-0 hover:before:opacity-100 focus-visible:outline-[1.5px] focus-visible:outline-offset-2 focus-visible:outline-blue-400 active:text-white/70 active:before:bg-black/10"
              >
                Finish registration
              </SignUp.Action>
            </SignUp.Strategy>
            <p className="text-center text-sm text-zinc-400">
              Have an account?{' '}
              <Clerk.Link
                navigate="sign-in"
                className="font-medium text-white decoration-white/20 underline-offset-4 outline-none hover:underline focus-visible:underline"
              >
                Sign in
              </Clerk.Link>
            </p>
          </SignUp.Step>
        </SignUp.Root>
      </div>
    )
  }
  ```
</CodeBlockDemo>

## Email/password + username + email verification

The following example demonstrates a sign-up flow with email, password, and username fields. After the user submits their email, password, and username, they are prompted to verify their email address.

Before you build your sign-up flow, you need to configure the appropriate settings in Clerk:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. In the **Contact information** section, ensure that _only_ **Email address** and **Password** are enabled.
1. In the **Username** section, ensure that **Username** is enabled.

<CodeBlockDemo
  demos={[
  {
    key: 'email-password-username-email-verification',
    demo: '/demo/elements/sign-up/email-password-username-email-verification',
    style: {
      height: `${568 / 16}rem`,
      backgroundColor: 'rgb(244 244 245)'
    }
  }
]}
>
  ```tsx {{ filename: 'app/sign-up/[[...sign-up]]/page.tsx', collapsible: true }}
  'use client'

  import * as Clerk from '@clerk/elements/common'
  import * as SignUp from '@clerk/elements/sign-up'

  export default function SignUpPage() {
    return (
      <div className="grid w-full flex-grow items-center bg-zinc-100 px-4 sm:justify-center">
        <SignUp.Root>
          <SignUp.Step
            name="start"
            className="w-full space-y-6 rounded-2xl bg-white px-4 py-10 shadow-md ring-1 ring-black/5 sm:w-96 sm:px-8"
          >
            <header className="text-center">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 40 40"
                className="mx-auto size-10 text-zinc-950"
                aria-hidden
              >
                <mask id="a" width="40" height="40" x="0" y="0" maskUnits="userSpaceOnUse">
                  <circle cx="20" cy="20" r="20" fill="#D9D9D9" />
                </mask>
                <g fill="currentColor" mask="url(#a)">
                  <path d="M43.5 3a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V2ZM43.5 8a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V7ZM43.5 13a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 18a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 23a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 28a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 33a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 38a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1Z" />
                  <path d="M27 3.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 8.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM23 13.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM21.5 18.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM20.5 23.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM22.5 28.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 33.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM27 38.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2Z" />
                </g>
              </svg>
              <h1 className="mt-4 text-xl font-medium tracking-tight text-zinc-950">
                Create an account
              </h1>
            </header>
            <Clerk.GlobalError className="block text-sm text-red-400" />
            <div className="space-y-4">
              <Clerk.Field name="emailAddress" className="space-y-2">
                <Clerk.Label className="text-sm font-medium text-zinc-950">Email</Clerk.Label>
                <Clerk.Input
                  type="email"
                  required
                  className="w-full rounded-md bg-white px-3.5 py-2 text-sm outline-none ring-1 ring-inset ring-zinc-300 hover:ring-zinc-400 focus:ring-[1.5px] focus:ring-zinc-950 data-[invalid]:ring-red-400"
                />
                <Clerk.FieldError className="block text-sm text-red-400" />
              </Clerk.Field>
              <Clerk.Field name="password" className="space-y-2">
                <Clerk.Label className="text-sm font-medium text-zinc-950">Password</Clerk.Label>
                <Clerk.Input
                  type="password"
                  required
                  className="w-full rounded-md bg-white px-3.5 py-2 text-sm outline-none ring-1 ring-inset ring-zinc-300 hover:ring-zinc-400 focus:ring-[1.5px] focus:ring-zinc-950 data-[invalid]:ring-red-400"
                />
                <Clerk.FieldError className="block text-sm text-red-400" />
              </Clerk.Field>
            </div>
            <SignUp.Action
              submit
              className="w-full rounded-md bg-zinc-950 px-3.5 py-1.5 text-center text-sm font-medium text-white shadow outline-none ring-1 ring-inset ring-zinc-950 hover:bg-zinc-800 focus-visible:outline-[1.5px] focus-visible:outline-offset-2 focus-visible:outline-zinc-950 active:text-white/70"
            >
              Sign Up
            </SignUp.Action>

            <p className="text-center text-sm text-zinc-500">
              Already have an account?{' '}
              <Clerk.Link
                navigate="sign-in"
                className="font-medium text-zinc-950 decoration-zinc-950/20 underline-offset-4 outline-none hover:text-zinc-700 hover:underline focus-visible:underline"
              >
                Sign in
              </Clerk.Link>
            </p>
          </SignUp.Step>
          <SignUp.Step
            name="verifications"
            className="w-full space-y-6 rounded-2xl bg-white px-4 py-10 shadow-md ring-1 ring-black/5 sm:w-96 sm:px-8"
          >
            <header className="text-center">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 40 40"
                className="mx-auto size-10 text-zinc-950"
                aria-hidden
              >
                <mask id="a" width="40" height="40" x="0" y="0" maskUnits="userSpaceOnUse">
                  <circle cx="20" cy="20" r="20" fill="#D9D9D9" />
                </mask>
                <g fill="currentColor" mask="url(#a)">
                  <path d="M43.5 3a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V2ZM43.5 8a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V7ZM43.5 13a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 18a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 23a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 28a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 33a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 38a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1Z" />
                  <path d="M27 3.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 8.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM23 13.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM21.5 18.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM20.5 23.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM22.5 28.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 33.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM27 38.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2Z" />
                </g>
              </svg>
              <h1 className="mt-4 text-xl font-medium tracking-tight text-zinc-950">
                Verify email code
              </h1>
            </header>
            <Clerk.GlobalError className="block text-sm text-red-400" />
            <SignUp.Strategy name="email_code">
              <Clerk.Field name="code" className="space-y-2">
                <Clerk.Label className="text-sm font-medium text-zinc-950">Email code</Clerk.Label>
                <Clerk.Input
                  type="otp"
                  required
                  className="w-full rounded-md bg-white px-3.5 py-2 text-sm outline-none ring-1 ring-inset ring-zinc-300 hover:ring-zinc-400 focus:ring-[1.5px] focus:ring-zinc-950 data-[invalid]:ring-red-400"
                />
                <Clerk.FieldError className="block text-sm text-red-400" />
              </Clerk.Field>
              <SignUp.Action
                submit
                className="w-full rounded-md bg-zinc-950 px-3.5 py-1.5 text-center text-sm font-medium text-white shadow outline-none ring-1 ring-inset ring-zinc-950 hover:bg-zinc-800 focus-visible:outline-[1.5px] focus-visible:outline-offset-2 focus-visible:outline-zinc-950 active:text-white/70"
              >
                Verify
              </SignUp.Action>
            </SignUp.Strategy>
            <p className="text-center text-sm text-zinc-500">
              Already have an account?{' '}
              <Clerk.Link
                navigate="sign-in"
                className="font-medium text-zinc-950 decoration-zinc-950/20 underline-offset-4 outline-none hover:text-zinc-700 hover:underline focus-visible:underline"
              >
                Sign in
              </Clerk.Link>
            </p>
          </SignUp.Step>
          <SignUp.Step
            name="continue"
            className="w-full space-y-6 rounded-2xl bg-white px-4 py-10 shadow-md ring-1 ring-black/5 sm:w-96 sm:px-8"
          >
            <header className="text-center">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 40 40"
                className="mx-auto size-10 text-zinc-950"
                aria-hidden
              >
                <mask id="a" width="40" height="40" x="0" y="0" maskUnits="userSpaceOnUse">
                  <circle cx="20" cy="20" r="20" fill="#D9D9D9" />
                </mask>
                <g fill="currentColor" mask="url(#a)">
                  <path d="M43.5 3a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V2ZM43.5 8a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46V7ZM43.5 13a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 18a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 23a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 28a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 33a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1ZM43.5 38a.5.5 0 0 0 0-1v1Zm0-1h-46v1h46v-1Z" />
                  <path d="M27 3.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 8.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM23 13.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM21.5 18.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM20.5 23.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM22.5 28.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM25 33.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2ZM27 38.5a1 1 0 1 0 0-2v2Zm0-2h-46v2h46v-2Z" />
                </g>
              </svg>
              <h1 className="mt-4 text-xl font-medium tracking-tight text-zinc-950">
                Continue registration
              </h1>
            </header>
            <Clerk.GlobalError className="block text-sm text-red-400" />
            <Clerk.Field name="username" className="space-y-2">
              <Clerk.Label className="text-sm font-medium text-zinc-950">Username</Clerk.Label>
              <Clerk.Input
                type="text"
                required
                className="w-full rounded-md bg-white px-3.5 py-2 text-sm outline-none ring-1 ring-inset ring-zinc-300 hover:ring-zinc-400 focus:ring-[1.5px] focus:ring-zinc-950 data-[invalid]:ring-red-400"
              />
              <Clerk.FieldError className="block text-sm text-red-400" />
            </Clerk.Field>
            <SignUp.Action
              submit
              className="w-full rounded-md bg-zinc-950 px-3.5 py-1.5 text-center text-sm font-medium text-white shadow outline-none ring-1 ring-inset ring-zinc-950 hover:bg-zinc-800 focus-visible:outline-[1.5px] focus-visible:outline-offset-2 focus-visible:outline-zinc-950 active:text-white/70"
            >
              Continue
            </SignUp.Action>
            <p className="text-center text-sm text-zinc-500">
              Already have an account?{' '}
              <Clerk.Link
                navigate="sign-in"
                className="font-medium text-zinc-950 decoration-zinc-950/20 underline-offset-4 outline-none hover:text-zinc-700 hover:underline focus-visible:underline"
              >
                Sign in
              </Clerk.Link>
            </p>
          </SignUp.Step>
        </SignUp.Root>
      </div>
    )
  }
  ```
</CodeBlockDemo>

---
title: Sign-up & sign-in overview
description: Learn how to configure authentication and user management for your Clerk application.
---

Clerk supports multiple authentication strategies so that you can implement the strategy that makes sense for _your_ users. You can use the [Account Portal](/docs/account-portal/overview), [prebuilt components](/docs/components/overview), or build your own [custom flows](/docs/custom-flows/overview).

## Configuration

Configuring your application is done through the [Clerk Dashboard](https://dashboard.clerk.com). The Clerk Dashboard is where you, as the application owner, can manage your application's settings, users, and organizations. For example, if you want to enable phone number authentication, multi-factor authentication, social providers like Google, delete users, or create organizations, you can do all of this and more in the Clerk Dashboard. You can even invite other users to join your [organization workspace](/docs/organizations/organization-workspaces) and help configure and manage your application with you.

## SSO authentication

SSO authentication allows users to sign in to your application using an existing account from an external identity provider (IdP), such as Google.

Clerk supports the following SSO types:

- [OAuth SSO, also known as social connections or social providers](/docs/authentication/social-connections/oauth)
- [Enterprise SSO](/docs/authentication/enterprise-connections/overview)
  - SAML
  - OIDC
    - EASIE

## Web3 authentication

Clerk supports the following Web3 providers:

- [Coinbase Wallet](/docs/authentication/web3/coinbase-wallet)
- [Metamask](/docs/authentication/web3/metamask)
- [OKX Wallet](/docs/authentication/web3/okx-wallet)

---
title: Sign-up and sign-in options
description: Clerk provides various options for configuring a sign-up and sign-in flow.
---

Clerk provides multiple options for configuring a sign-up and sign-in flow for your application, such as [identifiers](#identifiers) and [authentication strategies](#authentication-strategies). This guide will walk you through each option.

You can modify your authentication options after your application has been created by navigating to the [Clerk Dashboard](https://dashboard.clerk.com/) and selecting any of the options under **User & Authentication**.

## Identifiers

Identifiers are how your application recognizes an individual user. There are three primary identifiers:

- **Email address**
- **Phone number**
- **Username**

In the application configuration screen, you can select multiple identifiers, but at least one is required.

**Email address** is the most common primary identifier. When it is the only enabled identifier, users are required to supply an email address during sign-up and keep one on their account at all times. The email address that was supplied during sign-up can be later changed from the user's profile page.

When **phone number** is selected as the identifier, a user can sign up with their phone number and receive a code via SMS to verify it. SMS functionality is restricted to phone numbers from countries enabled on your [SMS allowlist](#sms-allowlist).

> [!NOTE]
> SMS authentication is a premium feature and not available on the Free plan. [Upgrade your plan](/pricing){{ target: '_blank' }} to enable this feature.

Choosing **username** as the identifier enables users to sign up without requiring personal contact information. A username should be from 4 to 64 characters in length and can contain alphanumeric characters, underscores (\_), and dashes (-).

> [!NOTE]
> If you choose not to collect any contact information, you can enable **Username** authentication and later disable it in settings, opting to authenticate only with a social provider.

To update your identifiers after your application has been created:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. In the **Contact information** section, you can select **Email address** and **Phone number** as identifiers. In the **Username** section, you can select **Username** as an identifier.

## Personal information

Personal information is extra information that you can collect from users during the sign-up process. Currently, the only personal information that you can collect is a first name and last name. By default, this information is not collected. To configure this feature:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. In the **Personal information** section, enable **Name**. By default, providing a first name and last name is optional. To make it required, select the settings icon next to **Name** and enable **Required**.

## Authentication strategies

Authentication strategies are methods that users can use to sign up and sign in to your application.

There are two kinds of authentication strategies: **password** and **passwordless**.

Choosing the **password** strategy requires users to set a password during the sign up process. Passwords are required to be at least 8 characters long, and have built-in protection against weak and compromised passwords.

> [!NOTE]
> Passwordless authentication remains available to users, even if the password strategy is enabled.

The **passwordless** strategy provides a more secure and convenient sign-in method, as users don't need to remember complex passwords.

**Passwordless** authentication strategies include:

- **[Passkeys](#passkeys)**
- **[One-time password (OTP)](#one-time-password-otp)**
- **[Email link](#email-link)**

To configure authentication strategies:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. In the **Authentication strategies** section, toggle on the authentication strategies you would like to enable. Note that disabling **Password** will only affect new users. Existing users will still be able to sign in with their existing password.

### Passkeys

A passkey is a type of sign-in credential that requires one user action, but uses two authentication factors:

1. A pin number or biometric data
1. A physical device

Users can only create passkeys after signing up, so you'll need to enable another authentication strategy for the sign-up process. After signing in, users can create a passkey.

#### Manage user passkeys

The easiest way to allow your users to create and manage their passkeys is to use the prebuilt [`<UserProfile>`](/docs/components/user/user-profile) component, which includes passkey management in the **Security** tab.

If you're building a custom user interface, refer to the [passkeys custom flow](/docs/custom-flows/passkeys) guide to learn how to create a custom passkey management flow using the Clerk API.

#### Passkey limitations

- Passkeys are not currently available as an [MFA](#multi-factor-authentication) option.
- Not all devices and browsers are compatible with passkeys. Passkeys are built on WebAuthn technology and you should check [the Browser Compatibility docs](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API#browser_compatibility) for an up-to-date list.
- Passkey related APIs will not work with Expo.
- Your users can have a max of 10 passkeys per account.

#### Domain restrictions for passkeys in development

<Include src="_partials/authentication/passkeys-restriction" />

### One-time password (OTP)

When one of the OTP options is selected as an authentication strategy, users receive a one-time code to complete the sign-in process. OTPs are more secure than passwords, as they allow user verification without storing passwords in your database.

There are two **one-time password (OTP)**, or one-time code, strategies to choose from:

- **Email verification code**
- **SMS verification code**

When email address is chosen as the identifier, **Email verification code** is set as the _default_ authentication option.

> [!NOTE]
> SMS authentication is a premium feature and is not available on the Free plan. [Upgrade your plan](/pricing){{ target: '_blank' }} to enable this feature.

#### SMS allowlist

SMS functionality, including SMS OTPs, is restricted to phone numbers from countries that are enabled on your SMS allowlist. This can be useful for avoiding extraneous SMS fees from countries from which your app is not expected to attract traffic.

Every instance starts off with a default set of enabled SMS country tiers. To tailor it to your needs:

1. In the Clerk Dashboard, navigate to the [**SMS**](https://dashboard.clerk.com/last-active?path=customization/sms) page.
1. Select the **Settings** tab.
1. Enable or disable countries as needed.

If a country is disabled, then phone numbers starting with the corresponding country calling code:

- Cannot receive OTPs and a request to receive an OTP will be rejected with an error
- Cannot receive notifications for password or passkey modifications
- Cannot be used upon sign-up
- Cannot be added to an existing user profile

### Email link

<If sdk="expo">
  > [!WARNING]
  > Expo does not support email links. You can request this feature on [Clerk's roadmap](https://feedback.clerk.com/).
</If>

When the **Email verification link** option is selected as an authentication strategy, users receive an email message with a link to complete the authentication process. Email links can be used to sign up new users, sign in existing ones, or allow existing users to verify newly entered email addresses to user profiles.

As a security measure, email links expire after 10 minutes to prevent the use of compromised or stale links.

#### Require the same device and browser

By default, the **Require the same device and browser** setting is enabled. This means that email links are required to be verified from the same device and browser on which the sign-up or sign-in was initiated. For example:

- A user tries to sign in from their desktop browser.
- They open the email link on their mobile phone to verify their email address.
- The user's sign-in on the desktop browser **gets an error**, because the link was verified on a different device and browser.

To configure this setting:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. In the **Authentication strategies** section, next to **Email verification link**, select the settings icon.
1. Enable or disable the **Require the same device and browser** setting.

## Verification methods

Verification methods are the methods that users can use to verify their identifier during the sign-up process, or to verify a new identifier that they add to their profile.

Clerk offers three verification methods:

- **Email verification link**
- **Email verification code**
- **SMS verification code**

These methods work similarly to their authentication strategy counterparts but are used for verifying identifiers rather than authentication. For example, when a user adds an email address to their profile, they can receive an **Email verification link** or **Email verification code** to verify the new email address.

To configure verification methods:

1. In the Clerk Dashboard, navigate to the [**Email, phone, username**](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username) page.
1. Select the settings icon next to the identifier, such as **Email address** or **Phone number**, to open the configuration settings.
1. Under the **Verification methods** section, toggle on the verification methods you would like to enable.
1. Select **Continue** to save your changes.

## Social connections (OAuth)

Clerk offers several [social providers](/docs/authentication/social-connections/oauth) for use during sign-up and sign-in. This authentication option is appealing because users often don't need to enter additional contact information since the provider already has it.

Clerk's OAuth process is designed to be seamless. If an existing user attempts to sign up with a social provider, the system automatically switches to sign-in. Similarly, if a user tries to sign in with a social provider but doesn't have an account, Clerk will automatically create one.

Users can link multiple social providers to their account, depending on your application's setup. You can configure your application to use the [Account Portal User Profile page](/docs/account-portal/overview#user-profile), the prebuilt [`<UserProfile />`](/docs/components/user/user-profile) component, or [build your own custom user interface using the Clerk API.](/docs/custom-flows/oauth-connections).

To enable social connections:

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select the **Add connection** button, and select **For all users**.
1. For development instances, simply select the social providers that you would like to enable. For production instances, you'll need to configure credentials for each social provider. See [the social provider's dedicated guide](/docs/authentication/social-connections/oauth) to learn how to configure credentials.

## Web3 authentication

Clerk provides Web3 authentication with either [MetaMask](/docs/authentication/web3/metamask), [Coinbase Wallet](/docs/authentication/web3/coinbase-wallet), or [OKX Wallet](/docs/authentication/web3/okx-wallet). As part of validating the accuracy of the returned Web3 account address, Clerk handles the signing of a message and verifying the signature. Because sign-in with Web3 uses the same abstraction as our other authentication factors, like passwords or email links, other Clerk features like multi-factor authentication and profile enrichment work for Web3 users out-of-the-box.

To enable Web3 authentication:

1. In the Clerk Dashboard, navigate to the [**Web3**](https://dashboard.clerk.com/last-active?path=user-authentication/web3) page.
1. Enable your preferred Web3 provider.

## Multi-factor authentication

Clerk supports multi-factor authentication (MFA), also known as two-factor authentication (2FA). If a user enables MFA for their account, they are required to complete a second verification step during sign-in. This enhances security by enforcing two different types of verification. Many websites offer this as an optional step, giving users control over their own security.

MFA is not available on the new application screen, but it can be enabled in the Clerk Dashboard.

1. In the Clerk Dashboard, navigate to the [**Multi-factor**](https://dashboard.clerk.com/last-active?path=user-authentication/multi-factor) page.
1. Toggle on the MFA strategies you would like to enable.

The following MFA strategies are currently available:

- **SMS verification code**
- **Authenticator application (also known as TOTP - Time-based One-time Password)**
- **Backup codes**

Enabling MFA allows users of your app to turn it on for their own accounts through their [User Profile](/docs/account-portal/overview#user-profile) page. Enabling MFA does not automatically turn on MFA for all users.

If you're building a custom user interface instead of using the [Account Portal](/docs/account-portal/overview) or [prebuilt components](/docs/components/overview), you can use [elements](/docs/customization/elements/examples/sign-in#multi-factor-authentication-mfa) or [the Clerk API](/docs/custom-flows/email-password-mfa) to build a custom sign-in flow that allows users to sign in with MFA.

### Reset a user's MFA

You can reset a user's MFA by deleting their MFA enrollments. This will remove all of their MFA methods and they will have to enroll in MFA again.

To reset a user's MFA:

1. At the top of the [Clerk Dashboard](https://dashboard.clerk.com/), select **Users**.
1. Select the user from the list.
1. Select the **Reset MFA enrollments** button.

## Restrictions

Clerk provides a set of restriction options designed to provide you with enhanced control over who can gain access to your application. Restrictions can limit sign-ups or prevent accounts with specific identifiers, such as email addresses, phone numbers, and even entire domains, from accessing your application. [Learn more about restrictions](/docs/authentication/configuration/restrictions).

---
title: Sign-up components
description: Reference documentation for Clerk Elements sign-up components.
---

The following components are used when creating sign-up flows. They are imported from `@clerk/elements/sign-up`. It is recommended to import them all under the `SignUp` namespace to make discovery easier and reduce naming conflicts with other components throughout your application. The code snippets on this page assume you have imported the components this way.

```tsx {{ filename: 'Anatomy' }}
import * as SignUp from '@clerk/elements/sign-up'

export default function SignUpPage() {
  return (
    <SignUp.Root>
      <SignUp.Step name="start" />
      <SignUp.Step name="continue" />
      <SignUp.Step name="verifications" />
    </SignUp.Root>
  )
}
```

## `<Root>`

The root sign-up component. Sets up providers and state management for the sign-up flow. Must wrap all other sign-up components. `<Root>` will validate your built sign-up flow to ensure the implementation is correct based on instance settings and best practices.

### Properties {{ toc: false }}

<Properties>
  - `path?`
  - `string`

  The root path the sign-up flow is mounted at. If not provided, will be automatically inferred (either through the current pathname or [environment variables](/docs/deployments/clerk-environment-variables#sign-in-and-sign-up-redirects)). Fallback: `/sign-up`

  ---

  - `fallback?`
  - `React.ReactNode`

  Fallback markup to render while Clerk is loading. Default: `null`

  ---

  - `routing?`
  - `'path' | 'virtual'`

  If you want to render Clerk Elements in e.g. a modal, use the `'virtual'` routing mode. Default: `'path'`
</Properties>

The following data attributes are also added to the underlying element:

- `data-global-error` - Refers to the [`<GlobalError>`](/docs/customization/elements/reference/common#global-error) status

## `<Step>`

A step in the sign-up flow. Controls conditionally rendering its children based on the status of the current sign up attempt. `start` is the initial step.

### Properties {{ toc: false }}

<Properties>
  - `name`
  - `'start' | 'continue' | 'verifications'`

  The `name` of the step for which its children will be rendered.
</Properties>

### `<Step name="start">`

Renders the beginning sign-up form. Once a sign up attempt has been created from this step, the `continue` or `verification` step will be rendered. The exact fields that should be rendered depend on your instance configuration.

#### Usage

```tsx {{ filename: 'page.tsx' }}
<SignUp.Step name="start">
  <Clerk.Connection name="google">Sign up with Google</Clerk.Connection>
  <Clerk.Field name="identifier">
    <Clerk.Label>Email</Clerk.Label>
    <Clerk.Input />
    <Clerk.FieldError />
  </Clerk.Field>

  <SignUp.Captcha />

  <SignUp.Action submit>Sign up</SignUp.Action>
</SignUp.Step>
```

### `<Step name="continue">`

Collects additional required fields from the user during a sign up attempt. This step will be rendered if a user initiates a sign up, but does not provide all required fields (e.g. through social connection).

#### Usage

```tsx {{ filename: 'page.tsx' }}
<SignUp.Step name="continue">
  <Clerk.Field name="username">
    <Clerk.Label>Username</Clerk.Label>
    <Clerk.Input />
    <Clerk.FieldError />
  </Clerk.Field>

  <SignUp.Action submit>Sign up</SignUp.Action>
</SignUp.Step>
```

### `<Step name="verifications">`

Verifies certain fields provided during sign up. Will render if your instance is configured to require verification of emails or phone numbers.

#### Usage

```tsx {{ filename: 'page.tsx' }}
<SignUp.Step name="verifications">
  <SignUp.Strategy name="email_code">
    <Clerk.Field name="code">
      <Clerk.Label>Email code</Clerk.Label>
      <Clerk.Input />
      <Clerk.FieldError />
    </Clerk.Field>

    <SignUp.Action submit>Verify email</SignUp.Action>
  </SignUp.Strategy>
</SignUp.Step>
```

## `<Strategy>`

Conditionally renders its children depending on the authentication strategy that needs to be verified. Does not render any markup on its own.

### Properties {{ toc: false }}

<Properties>
  - `name`
  - `'code' | 'email_code' | 'email_link' | 'phone_code'`

  The name of the strategy for which its children will be rendered.
</Properties>

### Usage {{ toc: false }}

```tsx {{ filename: 'page.tsx' }}
<SignUp.Strategy name="email_code">
  <Clerk.Field name="code">
    <Clerk.Label>Code</Clerk.Label>
    <Clerk.Input />
    <Clerk.FieldError />
  </Clerk.Field>

  <SignUp.Action submit>Verify</SignUp.Action>
</SignUp.Strategy>
```

## `<Action>`

Exposes various flow-related actions. It can be used to submit forms, navigate between steps, and re-trigger sending of verification codes. By default, renders a `<button>`.

### Properties {{ toc: false }}

<Properties>
  - `submit?`
  - `boolean`

  If `true`, the action will submit the form. Default: `false`

  ---

  - `navigate?`
  - `'start' | 'previous'`

  The name of the step to navigate to. Default: `undefined`

  ---

  - `resend?`
  - `boolean`

  If `true`, the action will resend the verification code for the currently active strategy, if applicable. Default: `false`

  ---

  - `fallback?`
  - `({ resendableAfter: number }) => React.ReactNode`

  Only used when `resend` is `true`. If provided, the fallback markup will be rendered before the resend delay has expired. Default: `null`
</Properties>

### Usage {{ toc: false }}

#### `<Action submit>`

```tsx {{ filename: 'page.tsx', mark: [8] }}
<SignUp.Step name="start">
  <Clerk.Field name="identifier">
    <Clerk.Label>Email</Clerk.Label>
    <Clerk.Input />
    <Clerk.FieldError />
  </Clerk.Field>

  <SignUp.Action submit>Sign up</SignUp.Action>
</SignUp.Step>
```

#### `<Action navigate>`

```tsx {{ filename: 'page.tsx', mark: [9] }}
<SignUp.Step name="continue">
  <Clerk.Field name="username">
    <Clerk.Label>Username</Clerk.Label>
    <Clerk.Input />
    <Clerk.FieldError />
  </Clerk.Field>

  <SignUp.Action submit>Sign up</SignUp.Action>
  <SignUp.Action navigate="start">Go back</SignUp.Action>
</SignUp.Step>
```

#### `<Action resend>`

```tsx {{ filename: 'page.tsx', mark: [[10, 15]] }}
<SignUp.Step name="verifications">
  <SignUp.Strategy name="email_code">
    <Clerk.Field name="code">
      <Clerk.Label>Code</Clerk.Label>
      <Clerk.Input />
      <Clerk.FieldError />
    </Clerk.Field>

    <SignUp.Action submit>Verify</SignUp.Action>
    <SignUp.Action
      resend
      fallback={({ resendableAfter }) => <p>Resend code in {resendableAfter} second(s)</p>}
    >
      Resend code
    </SignUp.Action>
  </SignUp.Strategy>
</SignUp.Step>
```

## `<Captcha>`

Renders the Cloudflare Turnstile widget. It must be used within the `<Step name="start">` component. By default, renders a `<div>`.

### Properties {{ toc: false }}

<Properties>
  - `asChild?`
  - `boolean`

  If `true`, `<Captcha>` will render as its child element. The element must be a self-closing element or component. Any children passed to the immediate child component of `<Captcha>` will be ignored. Default: `false`
</Properties>

### `<Captcha>` usage

```tsx {{ filename: 'page.tsx', mark: [2] }}
<SignUp.Step name="start">
  <SignUp.Captcha />

  <SignUp.Action submit>Sign up</SignUp.Action>
</SignUp.Step>
```

#### With `asChild`

```tsx {{ filename: 'page.tsx', mark: [[2, 4]] }}
<SignUp.Step name="start">
  <SignUp.Captcha asChild>
    <aside />
  </SignUp.Captcha>

  <SignUp.Action submit>Sign up</SignUp.Action>
</SignUp.Step>
```

---
title: Sign-up errors
description: An index of Clerk errors related to sign-up.
type: reference
---

An index of Clerk errors related to sign-up.

## `SignUpNotFound`

```json
{
  "shortMessage": "Sign up not found",
  "longMessage": "No sign up was found with id %s",
  "code": "resource_not_found"
}
```

## `SignUpForbiddenAccess`

```json
{
  "shortMessage": "Sign up forbidden",
  "longMessage": "Access to this sign up is forbidden",
  "code": "resource_forbidden"
}
```

## `SignUpCannotBeUpdated`

```json
{
  "shortMessage": "Sign up cannot be updated",
  "longMessage": "This sign up has reached a terminal state and cannot be updated",
  "code": "sign_up_cannot_be_updated"
}
```

## `CaptchaNotEnabled`

```json
{
  "shortMessage": "CAPTCHA not enabled",
  "longMessage": "Bot detection can be applied only for instances which have enabled CAPTCHA.",
  "code": "captcha_not_enabled"
}
```

## `CaptchaInvalid`

```json
{
  "shortMessage": "Invalid token",
  "code": "captcha_invalid"
}
```

## `SignUpOutdatedVerification`

```json
{
  "shortMessage": "Outdated verification",
  "longMessage": "There is a more recent verification pending for this signup. Try attempting the verification again.",
  "code": "sign_up_outdated_verification"
}
```

---
title: Sign-up with application invitations
description: Learn how to use the Clerk API to build a custom flow for handling application invitations.
---

<Include src="_partials/custom-flows-callout" />

When a user visits an [invitation](/docs/users/invitations) link, and no custom redirect URL was specified, then they will be redirected to the [Account Portal sign-up page](/docs/account-portal/overview#sign-up) and **their email address will be automatically verified.**

However, if you specified [a redirect URL when creating the invitation](/docs/users/invitations#redirect-url), you must handle the sign-up flow in your code for that page. You can either embed the [`<SignUp />`](/docs/components/authentication/sign-up) component on that page, or if the prebuilt component doesn't meet your specific needs or if you require more control over the logic, you can rebuild the existing Clerk flows using the Clerk API.

This guide demonstrates how to use Clerk's API to build a custom flow for accepting application invitations.

## Build the custom flow

Once the user visits the invitation link and is redirected to the specified URL, the query parameter `__clerk_ticket` will be appended to the URL. This query parameter contains the invitation token.

For example, if the redirect URL was `https://www.example.com/accept-invitation`, the URL that the user would be redirected to would be `https://www.example.com/accept-invitation?__clerk_ticket=.....`.

To create a sign-up flow using the invitation token, you need to extract the token from the URL and pass it to the [`signUp.create()`](/docs/references/javascript/sign-up#create) method, as shown in the following example. The following example also demonstrates how to collect additional user information for the sign-up; you can either remove these fields or adjust them to fit your application.

<Tabs items={["Next.js", "JavaScript"]}>
  <Tab>
    ```tsx {{ filename: 'app/accept-invitation/page.tsx', collapsible: true }}
    'use client'

    import * as React from 'react'
    import { useSignUp, useUser } from '@clerk/nextjs'
    import { useSearchParams, useRouter } from 'next/navigation'

    export default function Page() {
      const { user } = useUser()
      const router = useRouter()
      const { isLoaded, signUp, setActive } = useSignUp()
      const [firstName, setFirstName] = React.useState('')
      const [lastName, setLastName] = React.useState('')
      const [password, setPassword] = React.useState('')

      // Handle signed-in users visiting this page
      // This will also redirect the user once they finish the sign-up process
      React.useEffect(() => {
        if (user?.id) {
          router.push('/')
        }
      }, [user])

      // Get the token from the query params
      const token = useSearchParams().get('__clerk_ticket')

      // If there is no invitation token, restrict access to this page
      if (!token) {
        return <p>No invitation token found.</p>
      }

      // Handle submission of the sign-up form
      const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault()

        if (!isLoaded) return

        try {
          if (!token) return null

          // Create a new sign-up with the supplied invitation token.
          // Make sure you're also passing the ticket strategy.
          // After the below call, the user's email address will be
          // automatically verified because of the invitation token.
          const signUpAttempt = await signUp.create({
            strategy: 'ticket',
            ticket: token,
            firstName,
            lastName,
            password,
          })

          // If the sign-up was completed, set the session to active
          if (signUpAttempt.status === 'complete') {
            await setActive({ session: signUpAttempt.createdSessionId })
          } else {
            // If the status is not complete, check why. User may need to
            // complete further steps.
            console.error(JSON.stringify(signUpAttempt, null, 2))
          }
        } catch (err) {
          console.error(JSON.stringify(err, null, 2))
        }
      }

      return (
        <>
          <h1>Sign up</h1>
          <form onSubmit={handleSubmit}>
            <div>
              <label htmlFor="firstName">Enter first name</label>
              <input
                id="firstName"
                type="text"
                name="firstName"
                value={firstName}
                onChange={(e) => setFirstName(e.target.value)}
              />
            </div>
            <div>
              <label htmlFor="lastName">Enter last name</label>
              <input
                id="lastName"
                type="text"
                name="lastName"
                value={lastName}
                onChange={(e) => setLastName(e.target.value)}
              />
            </div>
            <div>
              <label htmlFor="password">Enter password</label>
              <input
                id="password"
                type="password"
                name="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
            </div>
            <div>
              <button type="submit">Next</button>
            </div>
          </form>
        </>
      )
    }
    ```
  </Tab>

  <Tab>
    <CodeBlockTabs options={["index.html", "main.js"]}>
      ```html {{ filename: 'index.html', collapsible: true }}
      <!doctype html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Clerk + JavaScript App</title>
        </head>
        <body>
          <div id="signed-in"></div>

          <div id="sign-up">
            <h2>Sign up</h2>
            <form id="sign-up-form">
              <label for="firstName">Enter first name</label>
              <input name="firstName" id="firstName" />
              <label for="lastName">Enter last name</label>
              <input name="lastName" id="lastName" />
              <label for="password">Enter password</label>
              <input name="password" id="password" />
              <button type="submit">Continue</button>
            </form>
          </div>

          <script type="module" src="/src/main.js" async crossorigin="anonymous"></script>
        </body>
      </html>
      ```

      ```js {{ filename: 'main.js', collapsible: true }}
      import { Clerk } from '@clerk/clerk-js'

      const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

      const clerk = new Clerk(pubKey)
      await clerk.load()

      if (clerk.user) {
        // Mount user button component
        document.getElementById('signed-in').innerHTML = `
          <div id="user-button"></div>
        `

        const userbuttonDiv = document.getElementById('user-button')

        clerk.mountUserButton(userbuttonDiv)
      } else {
        // Get the token from the query parameter
        const param = '__clerk_ticket'
        const token = new URL(window.location.href).searchParams.get(param)

        // Handle the sign-up form
        document.getElementById('sign-up-form').addEventListener('submit', async (e) => {
          e.preventDefault()

          const formData = new FormData(e.target)
          const firstName = formData.get('firstName')
          const lastName = formData.get('lastName')
          const password = formData.get('password')

          try {
            // Start the sign-up process using the ticket method
            const signUpAttempt = await clerk.client.signUp.create({
              strategy: 'ticket',
              ticket: token,
              firstName,
              lastName,
              password,
            })

            // If sign-up was successful, set the session to active
            if (signUpAttempt.status === 'complete') {
              await clerk.setActive({ session: signUpAttempt.createdSessionId })
            } else {
              // If the status is not complete, check why. User may need to
              // complete further steps.
              console.error(JSON.stringify(signUpAttempt, null, 2))
            }
          } catch (err) {
            // See https://clerk.com/docs/custom-flows/error-handling
            // for more info on error handling
            console.error(JSON.stringify(err, null, 2))
          }
        })
      }
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

---
title: Sinatra integration
description: The Clerk Ruby SDK provides a Sinatra extension to integrate Clerk into your Sinatra app.
---

The Clerk Ruby SDK provides a seamless integration with Sinatra through a dedicated extension that gives you access to authentication, user management, and organization management features.

<Steps>
  ## Install `clerk-sdk-ruby`

  <Include src="_partials/ruby/installation" />

  ## Configuration

  <Include src="_partials/ruby/configuration" />

  ## Add Clerk's Sinatra extension

  The `clerk` object provides access to the [Ruby SDK's available methods](/docs/references/ruby/overview#available-methods). To get access to the `clerk` object, you must `register` the `Sinatra::Clerk` extension.

  The following example demonstrates how to register the `Sinatra::Clerk` extension and access the user's [`User`](https://github.com/clerk/clerk-http-client-ruby/blob/main/.generated/docs/User.md) object.

  ```ruby {{ filename: 'app.rb' }}
  require "clerk/sinatra"
  require "sinatra/base"

  class App < Sinatra::Base
    register Sinatra::Clerk

    # Access the user's `User` object
    get "/" do
      @user = clerk.user
      erb :index, format: :html5
    end

    run! if app_file == $0
  end
  ```
</Steps>

## Example: Protect routes

The `auth` filter can be added to any route to protect it from unauthenticated users. If a user is not authenticated, by default, `auth` will redirect them to the sign-in page.

```ruby
require "clerk/sinatra"
require "sinatra/base"

class App < Sinatra::Base
  register Sinatra::Clerk

  get "/" do
    erb :index, format: :html5
  end

  # Protect the "/admin" route with the `auth` filter
  # If the user is not authenticated, they will be redirected to the sign-in page
  get "/admin", auth: true do
    @user = clerk.user
    erb :admin, format: :html5
  end

  run! if app_file == $0
end
```

### Override the default behavior of the `auth` filter

By default, the `auth` filter will redirect to the sign-in page if the user is not authenticated. You can override this behavior by using `set(:auth)`.

In the following example, the `auth` filter is overridden to redirect to the homepage if the user is not authenticated.

```ruby {{ filename: 'app.rb' }}
require "clerk/sinatra"
require "sinatra/base"

class App < Sinatra::Base
  register Sinatra::Clerk

  # Set `auth` to perform custom behavior
  set(:auth) do |active|
    condition do
      # If the user is not authenticated, redirect to the homepage
      if active && !clerk.session
        puts "User is not authenticated, redirecting to the homepage"
        redirect '/'
      end
    end
  end

  get "/" do
    erb :index, format: :html5
  end

  # Protect the "/admin" route with the `auth` filter
  # which will perform the custom behavior set in `set(:auth)`
  get "/admin", auth: true do
    @user = clerk.user
    erb :admin, format: :html5
  end

  run! if app_file == $0
end
```

## Example: Reverification

For actions requiring additional security, Clerk provides a `reverify` filter that prompts users to re-authenticate. This filter accepts an optional [preset](/docs/references/ruby/overview#reverification) parameter to customize the reverification requirements.

In the following example, the `/super-secret-admin` or `/chill-admin` routes will be protected from unauthenticated users. If the user is authenticated, they will be required to reverify their session, depending on when they last verified their session.

```ruby
require "clerk/sinatra"
require "sinatra/base"

class App < Sinatra::Base
  register Sinatra::Clerk

  get "/" do
    erb :index, format: :html5
  end

  # Protect the "/super-secret-admin" route with the `auth` and `reverify` filters
  # Reverification preset defaults to `STRICT`
  post "/super-secret-admin", auth: true, reverify: true do
    {message: clerk.user? ? "Valid session" : "Not logged in"}.to_json
  end

  # Protect the "/chill-admin" route with the `auth` and `reverify` filters
  # Reverification preset is set to `LAX`
  post "/chill-admin", auth: true, reverify: Clerk::StepUp::Preset::LAX do
    {message: clerk.user? ? "Valid session" : "Not logged in"}.to_json
  end

  run! if app_file == $0
end
```

---
title: Social connection (OAuth) providers
description: Browse the wide range of social providers that Clerk provides to ease your user's sign-up and sign-in processes.
---

Clerk provides a wide range of social providers to ease your user's sign-up and sign-in processes.

<Cards>
  - [Apple](/docs/authentication/social-connections/apple)
  - Add Apple as an authentication provider for your Clerk app.
  - {<svg viewBox="0 0 814 1000"><path d="M788.1 340.9c-5.8 4.5-108.2 62.2-108.2 190.5 0 148.4 130.3 200.9 134.2 202.2-.6 3.2-20.7 71.9-68.7 141.9-42.8 61.6-87.5 123.1-155.5 123.1s-85.5-39.5-164-39.5c-76.5 0-103.7 40.8-165.9 40.8s-105.6-57-155.5-127C46.7 790.7 0 663 0 541.8c0-194.4 126.4-297.5 250.8-297.5 66.1 0 121.2 43.4 162.7 43.4 39.5 0 101.1-46 176.3-46 28.5 0 130.9 2.6 198.3 99.2zm-234-181.5c31.1-36.9 53.1-88.1 53.1-139.3 0-7.1-.6-14.3-1.9-20.1-50.6 1.9-110.8 33.7-147.1 75.8-28.5 32.4-55.1 83.6-55.1 135.5 0 7.8 1.3 15.6 1.9 18.1 3.2.6 8.4 1.3 13.6 1.3 45.4 0 102.5-30.4 135.5-71.3z" style={{ fill: 'var(--light, black) var(--dark, white)' }} /></svg>}

  ---

  - [Atlassian](/docs/authentication/social-connections/atlassian)
  - Add Atlassian as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/atlassian.svg)

  ---

  - [Bitbucket](/docs/authentication/social-connections/bitbucket)
  - Add Bitbucket as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/bitbucket.svg)

  ---

  - [Box](/docs/authentication/social-connections/box)
  - Add Box as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/box.svg)

  ---

  - [Coinbase](/docs/authentication/social-connections/coinbase)
  - Add Coinbase as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/coinbase.svg)

  ---

  - [Discord](/docs/authentication/social-connections/discord)
  - Add Discord as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/discord.svg)

  ---

  - [Dropbox](/docs/authentication/social-connections/dropbox)
  - Add Dropbox as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/dropbox.svg)

  ---

  - [Facebook](/docs/authentication/social-connections/facebook)
  - Add Facebook as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/facebook.svg)

  ---

  - [GitHub](/docs/authentication/social-connections/github)
  - Add GitHub as an authentication provider for your Clerk app.
  - {<svg viewBox="0 0 98 96"><path fillRule="evenodd" clipRule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" style={{ fill: 'var(--light, #24292f) var(--dark, white)' }} /></svg>}

  ---

  - [GitLab](/docs/authentication/social-connections/gitlab)
  - Add GitLab as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/gitlab.svg)

  ---

  - [Google](/docs/authentication/social-connections/google)
  - Add Google as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/google.svg)

  ---

  - [HubSpot](/docs/authentication/social-connections/hubspot)
  - Add HubSpot as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/hubspot.svg)

  ---

  - [Hugging Face](/docs/authentication/social-connections/huggingface)
  - Add Hugging Face as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/huggingface.svg)

  ---

  - [LINE](/docs/authentication/social-connections/line)
  - Add LINE as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/line.svg)

  ---

  - [Linear](/docs/authentication/social-connections/linear)
  - Add Linear as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/linear.svg)

  ---

  - [LinkedIn ](/docs/authentication/social-connections/linkedin-oidc)
  - Add LinkedIn as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/linkedin.svg)

  ---

  - [Microsoft](/docs/authentication/social-connections/microsoft)
  - Add Microsoft as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/microsoft.svg)

  ---

  - [Notion](/docs/authentication/social-connections/notion)
  - Add Notion as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/notion.svg)

  ---

  - [Slack](/docs/authentication/social-connections/slack)
  - Add Slack as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/slack.svg)

  ---

  - [Spotify](/docs/authentication/social-connections/spotify)
  - Add Spotify as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/spotify.svg)

  ---

  - [TikTok](/docs/authentication/social-connections/tiktok)
  - Add TikTok as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/tiktok.svg)

  ---

  - [Twitch](/docs/authentication/social-connections/twitch)
  - Add Twitch as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/twitch.svg)

  ---

  - [Twitter](/docs/authentication/social-connections/twitter)
  - Add Twitter as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/twitter.svg)

  ---

  - [X/Twitter v2](/docs/authentication/social-connections/twitter)
  - Add X (Twitter v2) as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/x-twitter.svg)

  ---

  - [Xero](/docs/authentication/social-connections/xero)
  - Add Xero as an authentication provider for your Clerk app.
  - ![](/docs/images/logos/auth_providers/xero.svg)
</Cards>

Don't see the provider you're looking for? You can [configure a custom OIDC-compatible provider](/docs/authentication/social-connections/custom-provider) or [request a new one](https://feedback.clerk.com/roadmap/f9045ac8-0c8e-4f30-b84f-8d551b0767b9?_gl=1*1ywoqdy*_gcl_au*OTUwODgxMjg2LjE3MTI1OTEwNzMuMTczNjk0NTcxMC4xNzE1MTk4MTEyLjE3MTUxOTgxMTI.).

---
title: Social connections (OAuth)
description: Learn how to effortlessly add social connections to your application using popular social providers like Google, Facebook, Github and more.
---

Social connections, also known as OAuth connections in Clerk, allow users to gain access to your application by using their existing credentials from an Identity Provider (IdP), like Google or Microsoft. For example, if you enable Google as a social provider, then when a user wants to sign in to your application, they can select Google and use their Google account to sign in.

> [!NOTE]
> When using social connections, the sign-up and sign-in flows are equivalent. If a user doesn't have an account and tries to sign in, an account will be made for them, and vice versa.

The easiest way to add social connections to your Clerk app is by using [prebuilt components](/docs/components/overview). If prebuilt components don't meet your specific needs or if you require more control over the logic, you can [rebuild the existing Clerk flows using the Clerk API](/docs/custom-flows/oauth-connections).

## Before you start

- You need to create a Clerk application in the [Clerk Dashboard](https://dashboard.clerk.com/). For more information, check out the [setup guide](/docs/quickstarts/setup-clerk).
- You need to install the correct SDK for your application. For more information, see the [quickstart guides](/docs/quickstarts/overview).

## Enable a social connection

### Development instances

For **development** instances, Clerk uses **pre-configured shared** OAuth credentials and redirect URIs to make the development flow as smooth as possible. This means that you can enable most social providers **without additional configuration**.

To enable a social connection:

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select the **Add connection** button, and select **For all users**.
1. In the **Choose provider** dropdown, select the provider you want to use.
1. Select **Add connection**.

### Production instances

For **production** instances, you will need to configure the provider with custom OAuth credentials. See the social provider's [dedicated guide](/docs/authentication/social-connections/oauth) for more information.

## Configure additional OAuth scopes

Each OAuth provider requires a specific set of scopes that are necessary for proper authentication with Clerk. These essential scopes are pre-configured and automatically included by Clerk. They typically include permissions for basic profile information and email access, which are fundamental for user authentication and account creation.

In addition to the core scopes, you can specify additional scopes supported by the provider. These scopes can be used to access additional user data from the provider.

To add additional OAuth scopes, when you are [enabling a new social connection](enable-a-social-connection), enable **Use custom credentials**. The **Scopes** field will appear.

## Request additional OAuth scopes after sign-up

Clerk allows you to request additional OAuth scopes even after a user has signed up.

Pass the [`additionalOAuthScopes`](/docs/components/user/user-profile) prop to the [`<UserProfile/>`](/docs/components/user/user-profile) or [`<UserButton />`](/docs/components/user/user-button) component, with any additional OAuth scope you would like per provider. The user will be prompted to reconnect their account on their user profile page.

Use the following tabs to see how to add additional OAuth scopes to the `<UserProfile/>` and `<UserButton/>` components.

<CodeBlockTabs options={["<UserProfile />", "<UserButton />"]}>
  ```tsx {{ filename: 'app/page.tsx' }}
  <UserProfile
    additionalOAuthScopes={{
      google: ['foo', 'bar'],
      github: ['qux'],
    }}
  />
  ```

  ```tsx {{ filename: 'app/page.tsx' }}
  <UserButton
    userProfileProps={{
      additionalOAuthScopes: {
        google: ['foo', 'bar'],
        github: ['qux'],
      },
    }}
  />
  ```
</CodeBlockTabs>

## Get an OAuth access token for a social provider

You can use a social provider's OAuth access token to access user data from that provider in addition to their data from Clerk.

To retrieve the OAuth access token for a user, use the [`getUserOauthAccessToken()`](/docs/references/backend/user/get-user-oauth-access-token) method from the JavaScript Backend SDK. This method must be used in a server environment, and cannot be run on the client.

Clerk ensures that the OAuth access token will be always fresh so that you don't have to worry about refresh tokens.

The following example demonstrates how to retrieve the OAuth access token for a user and use it to fetch user data from the Notion API. It assumes:

- You have already [enabled the Notion social connection in the Clerk Dashboard](/docs/authentication/social-connections/notion).
- The user has already connected their Notion account to your application.
- The user has the correct permissions to access the Notion API.

The example is written for Next.js App Router, but is supported by any React-based framework.

```tsx {{ filename: 'app/api/notion/route.tsx' }}
import { auth, clerkClient } from '@clerk/nextjs/server'
import { NextResponse } from 'next/server'

export async function GET() {
  const { userId } = await auth()

  if (!userId) {
    return NextResponse.json({ message: 'User not found' })
  }

  // Get the OAuth access token for the user
  const provider = 'notion'

  const client = await clerkClient()

  const clerkResponse = await client.users.getUserOauthAccessToken(userId, provider)

  const accessToken = clerkResponse[0].token || ''

  if (!accessToken) {
    return NextResponse.json({ message: 'Access token not found' }, { status: 401 })
  }

  // Fetch the user data from the Notion API
  // This endpoint fetches a list of users
  // https://developers.notion.com/reference/get-users
  const notionUrl = 'https://api.notion.com/v1/users'

  const notionResponse = await fetch(notionUrl, {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      'Notion-Version': '2022-06-28',
    },
  })

  // Handle the response from the Notion API
  const notionData = await notionResponse.json()

  return NextResponse.json({ message: notionData })
}
```

## Add a social connection after sign-up

For each social provider, you can disable the option to sign up and sign in to your application using the provider. This is especially useful for users that want to connect their OAuth account _after_ authentication.

For example, say your application wants to read a user's GitHub repository data but doesn't want to allow the user to authenticate with their GitHub account. The user can sign up with their email and password, or whatever authentication method you choose, and then afterwards, connect their GitHub account to your application through their user profile. The easiest way to enable this for your users is by using the [`<UserProfile />`](/docs/components/user/user-profile) component. If you prefer to build a custom user interface, see how to [build a social connection flow using the Clerk API](/docs/custom-flows/oauth-connections).

To configure the option for users to sign up and sign in with a social provider:

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Select the social provider you want to configure.
1. Enable or disable **Enable for sign-up and sign-in**.
1. Save the changes.

## Connecting to social providers while signed in

When signed in, a user can connect to further social providers. There is no need to perform another sign-up.

When using the [Account Portal](/docs/account-portal/overview) pages, users can see which providers they have already connected to and which ones they can still connect to on their [user profile page](/docs/account-portal/overview#user-profile).

When using the [prebuilt components](/docs/components/overview), you can use the [`<UserProfile/>`](/docs/components/user/user-profile) component to allow users to connect to further social providers.

## OAuth for native applications

Currently, the prebuilt components are not supported in native applications, but you can use the Clerk API to [build a custom flow for authenticating with social connections](/docs/custom-flows/oauth-connections).

Clerk ensures that security critical nonces are passed only to allowlisted URLs when the OAuth flow is completed in native browsers or webviews. For maximum security in your **production** instances, you need to allowlist your custom redirect URLs via the [Clerk Dashboard](https://dashboard.clerk.com/) or the [Clerk Backend API](/docs/references/backend/redirect-urls/create-redirect-url).

To allowlist a redirect URL via the Clerk Dashboard:

1. In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page.
1. Scroll to the **Allowlist for mobile OAuth redirect** section and add your redirect URLs.

## OAuth for Apple native applications

You can use [Sign in with Apple](https://developer.apple.com/sign-in-with-apple/) to offer a native authentication experience in your iOS, watchOS, macOS or tvOS apps.

Instead of the typical OAuth flow that performs redirects in a browser context, you can utilize Apple's native authorization and provide the openID token and grant code to Clerk. Clerk ensures that the user will be verified in a secure and reliable way with the information that Apple has provided about the user.

For additional information on how to configure Apple as a social provider for your Clerk instance, see the [dedicated guide](/docs/authentication/social-connections/apple).

---
title: SSO Types
description: Types related to SSO providers and strategies.
---

## `OAuthStrategy`

A type that represents the OAuth strategy for a given provider.

For example, when creating a [`SignIn`](/docs/references/javascript/sign-in#sign-in-create-params) or [`SignUp`](/docs/references/javascript/sign-up#sign-up-create-params), you can pass the `strategy` option to specify the OAuth strategy to use.

```ts
type OAuthStrategy = `oauth_${OAuthProvider}` | CustomOAuthStrategy
```

## `OAuthProvider`

A type that represents the OAuth provider.

```ts
type OAuthProvider =
  | 'facebook'
  | 'google'
  | 'hubspot'
  | 'github'
  | 'tiktok'
  | 'gitlab'
  | 'discord'
  | 'twitter'
  | 'twitch'
  | 'linkedin'
  | 'linkedin_oidc'
  | 'dropbox'
  | 'atlassian'
  | 'bitbucket'
  | 'microsoft'
  | 'notion'
  | 'apple'
  | 'line'
  | 'instagram'
  | 'coinbase'
  | 'spotify'
  | 'xero'
  | 'box'
  | 'slack'
  | 'linear'
  | 'x'
  | 'huggingface'
  | `custom_${string}`
```

## `CustomOAuthStrategy`

A type that represents a [custom OAuth strategy](/docs/authentication/social-connections/custom-provider).

```ts
type CustomOAuthStrategy = `oauth_custom_${string}`
```

## `EnterpriseSSOStrategy`

A type that represents an [Enterprise SSO](/docs/authentication/enterprise-connections/authentication-flows) strategy.

```ts
type EnterpriseSSOStrategy = `enterprise_sso`
```

---
title: Staging alternatives
description:
---

## Shared production credentials

> [!CAUTION]
> This is not recommended. Instead, you should either [set up a staging environment with a subdomain and separate Clerk app](/docs/deployments/set-up-staging) or [use a preview deployment](/docs/deployments/set-up-preview-environment).

If you would like to share settings and data between your production and staging environments, you can use a subdomain of your production domain to set up a staging environment.

### Limitations of shared production credentials

The limitations of using shared production credentials to set up a staging environment with Clerk include:

- You will be combining staging data with live production data.
- When you enable Clerk features to test in staging, they will be enabled in your Production environment as well.

### Set up staging with shared production credentials

1. **Add your subdomain to your hosting provider** - Ensure that your subdomain is associated with your staging branch so that it will point to new staging deployments. This process will vary based on your provider. The following are some guides from popular hosting providers:
   - [Vercel](https://vercel.com/guides/set-up-a-staging-environment-on-vercel)
   - [Netlify](https://docs.netlify.com/domains-https/netlify-dns/delegate-a-subdomain-to-netlify-dns/)
   - [Cloudflare](https://developers.cloudflare.com/dns/manage-dns-records/how-to/create-subdomain/)
1. **Add your CNAME record to your domain provider** - Depending on the provider, the verification process can take hours or days.
1. **Add your production instance's API keys to your staging deployment** - In your staging deployment's environment variables, add your production instance's API keys. To find them, visit the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard and ensure that the instance at the top of the Dashboard is set to **Production**. The following are environment variable guides from some popular providers:
   - [Vercel](https://vercel.com/docs/projects/environment-variables#declare-an-environment-variable)
   - [Netlify](https://docs.netlify.com/environment-variables/get-started/#create-environment-variables)
   - [Cloudflare](https://developers.cloudflare.com/workers/configuration/environment-variables/#add-environment-variables-via-the-dashboard)

---
title: Styling for Clerk Elements
description: Learn how to style Clerk Elements.
---

> [!NOTE]
> Clerk Elements is for [advanced use-cases](/docs/customization/elements/overview#why-use-clerk-elements) that require a high-level of customization. If you are using our [all-in-one UI components](/docs/components/overview), learn more about customization through our [Appearance Prop](/docs/customization/overview).

You can style Clerk Elements components with the following props:

- `className`  Can be used on any Clerk Elements component that renders markup.
- `asChild`  Can be used to change the rendered element entirely.

This guide will demonstrate multiple different styling approaches using the following basic sign-in flow as a starting point:

```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx' }}
'use client'

import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step name="start">
        <Clerk.Connection name="google">Sign in with Google</Clerk.Connection>
        <Clerk.Field name="identifier">
          <Clerk.Label>Email</Clerk.Label>
          <Clerk.Input />
          <Clerk.FieldError />
        </Clerk.Field>
        <SignIn.Action submit>Continue</SignIn.Action>
      </SignIn.Step>
      <SignIn.Step name="verifications">
        <SignIn.Strategy name="email_code">
          <Clerk.Field name="code">
            <Clerk.Label>Code</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>
          <SignIn.Action submit>Verify</SignIn.Action>
        </SignIn.Strategy>
      </SignIn.Step>
    </SignIn.Root>
  )
}
```

## Tailwind CSS

If you are already using [Tailwind CSS](https://tailwindcss.com/), no additional setup is required. Classes from Tailwind can be applied to most Clerk Elements components. Use your editor's IntelliSense to see if `className` is a valid prop on a component you want to style.

```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx' }}
'use client'

import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step
        name="start"
        className="bg-white w-96 rounded-2xl py-10 px-8 shadow-sm border space-y-6"
      >
        <div className="grid grid-cols-2 gap-x-4">
          <Clerk.Connection
            name="google"
            className="flex items-center gap-x-3 justify-center font-medium border shadow-sm py-1.5 px-2.5 rounded-md"
          >
            <Clerk.Icon className="size-4" />
            Google
          </Clerk.Connection>
          <Clerk.Connection
            name="github"
            className="flex items-center gap-x-3 justify-center font-medium border shadow-sm py-1.5 px-2.5 rounded-md"
          >
            <Clerk.Icon className="size-4" />
            GitHub
          </Clerk.Connection>
        </div>
        <Clerk.Field name="identifier" className="space-y-2">
          <Clerk.Label className="text-sm font-medium">Email</Clerk.Label>
          <Clerk.Input className="w-full border rounded-md py-1.5 px-2.5" />
          <Clerk.FieldError className="block text-red-500 text-sm" />
        </Clerk.Field>
        <SignIn.Action submit className="bg-black text-white rounded-md py-1.5 px-2.5">
          Continue
        </SignIn.Action>
      </SignIn.Step>
    </SignIn.Root>
  )
}
```

## With existing components via `asChild`

Many of the Clerk Elements components accept an `asChild` prop that allows you to swap out the rendered element. This is useful if you have an existing design system or component library that you wish to use with Clerk Elements.

```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx' }}
'use client'

import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'

import { Button } from '@components/button'
import { Input } from '@components/input'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step name="start">
        <Clerk.Connection name="google" asChild>
          <Button>Sign in with Google</Button>
        </Clerk.Connection>
        <Clerk.Field name="identifier">
          <Clerk.Label>Email</Clerk.Label>
          <Clerk.Input asChild>
            <Input />
          </Clerk.Input>
          <Clerk.FieldError />
        </Clerk.Field>
        <SignIn.Action submit asChild>
          <Button>Continue</Button>
        </SignIn.Action>
      </SignIn.Step>
      <SignIn.Step name="verifications">
        <SignIn.Strategy name="email_code">
          <Clerk.Field name="code">
            <Clerk.Label>Code</Clerk.Label>
            <Clerk.Input asChild>
              <Input />
            </Clerk.Input>
            <Clerk.FieldError />
          </Clerk.Field>
          <SignIn.Action submit asChild>
            <Button>Continue</Button>
          </SignIn.Action>
        </SignIn.Strategy>
      </SignIn.Step>
    </SignIn.Root>
  )
}
```

Notice how the Clerk Elements components are wrapping the rendered `<Input>` and `<Button>` when `asChild` is used. This ensures the underlying event handlers and necessary props are passed along automatically.

### Configure your components for `asChild`

To use the `asChild` prop, your component must spread its incoming props and return [`forwardRef()`](https://react.dev/reference/react/forwardRef). Here's an example of how you might implement a custom `<Input />` component:

```tsx
import { forwardRef } from 'react'

const CustomInput = forwardRef(function CustomInput(props, forwardedRef) {
  return <input ref={forwardedRef} {...props} className="custom-class" />
})
```

## CSS Modules

Classes from an imported CSS module can be applied to most Clerk Elements components with `className`.

```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx' }}
'use client'

import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'
import styles from './sign-in.module.css'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step name="start" className={styles.startStep}>
        <Clerk.Connection name="google" className={styles.provider}>
          Sign in with Google
        </Clerk.Connection>
        <Clerk.Field name="identifier">
          <Clerk.Label className={styles.label}>Email</Clerk.Label>
          <Clerk.Input className={styles.input} />
          <Clerk.FieldError className={styles.error} />
        </Clerk.Field>
        <SignIn.Action submit className={styles.submit}>
          Continue
        </SignIn.Action>
      </SignIn.Step>
      <SignIn.Step name="verifications" className={styles.verificationsStep}>
        <SignIn.Strategy name="email_code">
          <Clerk.Field name="code">
            <Clerk.Label className={styles.label}>Code</Clerk.Label>
            <Clerk.Input className={styles.input} />
            <Clerk.FieldError className={styles.error} />
          </Clerk.Field>
          <SignIn.Action submit className={styles.submit}>
            Verify
          </SignIn.Action>
        </SignIn.Strategy>
      </SignIn.Step>
    </SignIn.Root>
  )
}
```

### Inline styles

You can also use inline styles with Clerk Elements. This is useful when you need to apply styles conditionally or  avoid creating a separate CSS file.

```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx' }}
'use client'

import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step
        name="start"
        style={{
          backgroundColor: 'white',
          padding: '1rem',
          border: '1px solid #dddddd',
          borderRadius: '4px',
        }}
      >
        <Clerk.Field name="identifier">
          <Clerk.Label
            style={{
              color: '#dddddd',
              fontSize: '0.875rem',
            }}
          >
            Email
          </Clerk.Label>
          <Clerk.Input
            style={{
              border: '1px solid #dddddd',
              borderRadius: '4px',
              padding: '1rem',
            }}
          />
        </Clerk.Field>
        <SignIn.Action
          submit
          style={{
            backgroundColor: '#111111',
            color: 'white',
            padding: '1rem',
            borderRadius: '4px',
          }}
        >
          Continue
        </SignIn.Action>
      </SignIn.Step>
    </SignIn.Root>
  )
}
```

## State-based styling

In some cases you might want to style components based on their state. Clerk Elements exposes data attributes for this purpose, as well as components that expose the state programmatically to support more complex logic.

### Data attributes

`<Field>` and `<Input>` can be styled based on their validity state by targeting the `data-valid` or `data-invalid` attributes:

```css {{ filename: 'style.css' }}
.input {
  --border-color: gray;
  border: 1px solid var(--border-color);

  &[data-invalid] {
    --border-color: red;
  }
}
```

```tsx {{ filename: 'page.tsx' }}
<Clerk.Input className="input" />
```

### Function as children

If you need programmatic access to state for more complex styling, several components accept a function as children. This is useful when dealing with animations, or for conditionally rendering elements based on state.

For example, to access a field's state, use `<FieldState>`.

```tsx {{ filename: 'page.tsx' }}
<Clerk.Field name="email">
  <Clerk.FieldState>{(state) => state === 'invalid' && <ErrorIcon />}</Clerk.FieldState>
  <Clerk.Label>Email</Clerk.Label>
  <Clerk.Input />
  <Clerk.FieldError />
</Clerk.Field>
```

---
title: Sync auth status between your Chrome Extension and web app
description: Learn how to configure your Chrome Extension to sync user authentication with your web application.
---

Clerk allows you to sync the authentication state from your web app to your Chrome Extension using Clerk's Sync Host feature. When a user authenticates in your web app, they will also be authenticated in your Chrome Extension.

> [!WARNING]
> Our Chrome Extension SDK currently does not fully support Sync Host on side panels. Currently, if a user authenticates in your web app, they need to close and reopen the side panel to update their auth status.

> [!WARNING]
> This guide assumes assumes that you have followed the [Chrome Extension Quickstart](/docs/quickstarts/chrome-extension) and then the [Add React Router](/docs/references/chrome-extension/add-react-router) guide.

<Steps>
  ## Add `PLASMO_PUBLIC_CLERK_SYNC_HOST` to your environment variables

  The `PLASMO_PUBLIC_CLERK_SYNC_HOST` environment variable defines the host that the Chrome Extension will sync with.

  The values for `PLASMO_PUBLIC_CLERK_SYNC_HOST` will differ between development and production environments. Using separate `.env.development` and `.env.production` files allows you to seamlessly pass the appropriate values to your builds.

  Use the following tabs to view the instructions for development versus production instances.

  <Tabs items={["Development", "Production"]}>
    <Tab>
      Add `PLASMO_PUBLIC_CLERK_SYNC_HOST` to your `.env.development` file. The value should be `http://localhost`.

      ```env {{ filename: '.env.development', mark: [3] }}
      PLASMO_PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
      CLERK_FRONTEND_API=https://{{fapi_url}}
      PLASMO_PUBLIC_CLERK_SYNC_HOST=http://localhost
      ```
    </Tab>

    <Tab>
      Add `PLASMO_PUBLIC_CLERK_SYNC_HOST` to your `.env.production` file. The value should be the domain your web app's production server runs on. For example, `https://clerk.com`.

      ```env {{ filename: '.env.production', mark: [3] }}
      PLASMO_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_live_123
      CLERK_FRONTEND_API=https://yourdomain.com
      PLASMO_PUBLIC_CLERK_SYNC_HOST=https://yourdomain.com
      ```
    </Tab>
  </Tabs>

  ## Add `syncHost` prop to your `<ClerkProvider>`

  Add the `syncHost` prop to your Chrome Extension's `<ClerkProvider>` component. This prop tells the `<ClerkProvider>` which host to sync with.

  ```tsx {{ filename: 'src/popup/layouts/root-layout.tsx', mark: [5, [7, 11], 22] }}
  import { ClerkProvider, SignedIn, SignedOut, UserButton } from '@clerk/chrome-extension'
  import { Link, Outlet, useNavigate } from 'react-router-dom'

  const PUBLISHABLE_KEY = process.env.PLASMO_PUBLIC_CLERK_PUBLISHABLE_KEY
  const SYNC_HOST = process.env.PLASMO_PUBLIC_CLERK_SYNC_HOST

  if (!PUBLISHABLE_KEY || !SYNC_HOST) {
    throw new Error(
      'Please add the PLASMO_PUBLIC_CLERK_PUBLISHABLE_KEY and PLASMO_PUBLIC_CLERK_SYNC_HOST to the .env.development file',
    )
  }

  export const RootLayout = () => {
    const navigate = useNavigate()

    return (
      <ClerkProvider
        routerPush={(to) => navigate(to)}
        routerReplace={(to) => navigate(to, { replace: true })}
        publishableKey={PUBLISHABLE_KEY}
        afterSignOutUrl="/"
        syncHost={SYNC_HOST}
      >
        <div className="plasmo-w-[785px] plasmo-h-[600px]">
          <main>
            <Outlet />
          </main>
          <footer>
            <SignedIn>
              <Link to="/settings">Settings</Link>
              <UserButton />
            </SignedIn>
            <SignedOut>
              <Link to="/">Home</Link>
              <Link to="/sign-in">Sign In</Link>
              <Link to="/sign-up">Sign Up</Link>
            </SignedOut>
          </footer>
        </div>
      </ClerkProvider>
    )
  }
  ```

  ### Hide unsupported authentication methods

  When using the Sync Host feature, authentication methods that you want to use in your web app [may not be fully supported in the Chrome Extension environment](/docs/references/chrome-extension/overview#authentication-options). To hide unsupported methods in your Chrome Extension, you can use the [`appearance`](https://clerk.com/docs/customization/overview) prop with your extension's `<SignUp>` and `<SignIn>` components as demonstrated in the following examples.

  <CodeBlockTabs options={["<SignUp>", "<SignIn>"]}>
    ```tsx {{ filename: 'src/popup/pages/sign-up.tsx', mark: [[3, 7]] }}
    <SignUp
      appearance={{
        elements: {
          socialButtonsRoot: 'plasmo-hidden',
          dividerRow: 'plasmo-hidden',
        },
      }}
    />
    ```

    ```tsx {{ filename: 'src/popup/pages/sign-in.tsx', mark: [[3, 7]] }}
    <SignIn
      appearance={{
        elements: {
          socialButtonsRoot: 'plasmo-hidden',
          dividerRow: 'plasmo-hidden',
        },
      }}
    />
    ```
  </CodeBlockTabs>

  ## Configure `host_permissions`

  `host_permissions` specifies which hosts, or websites, will have permission to sync auth state with your app. It accepts an array, allowing you to add more than one host.

  In the `package.json` file, in the `manifest` object, update the `host_permissions` array. Remove `http://localhost/*` and replace with `$PLASMO_PUBLIC_CLERK_SYNC_HOST/*`, as shown in the following example:

  ```json {{ filename: 'package.json', mark: [6] }}
  {
    // The rest of your package.json file
    "manifest": {
      "key": "$CRX_PUBLIC_KEY",
      "permissions": ["cookies", "storage"],
      "host_permissions": ["$PLASMO_PUBLIC_CLERK_SYNC_HOST/*", "$CLERK_FRONTEND_API/*"]
    }
  }
  ```

  ## Add the Extension's ID to your web app's `allowed_origins`

  To allow your Chrome Extension to sync with your web app, you must add the extension's ID to your web app's `allowed_origins`.

  > [!NOTE]
  > If you have not [configured a consistent key](/docs/references/chrome-extension/configure-consistent-crx-id), you will have to repeat this step every time your extension's ID changes.

  1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
  1. Copy your Secret Key. It should start with `sk_test_` or `sk_live_` for your development and production instances, respectively.
  1. In your terminal, paste the following command. Replace `YOUR_SECRET_KEY` with your Clerk Secret Key and the `<CHROME_EXTENSION_KEY>` with your extension's ID.

  The final result should resemble the following:

  ```bash {{ filename: 'terminal' }}
  curl -X PATCH https://api.clerk.com/v1/instance \
    -H "Authorization: Bearer {{secret}}" \
    -H "Content-type: application/json" \
    -d '{"allowed_origins": ["chrome-extension://<CHROME_EXTENSION_ID>"]}'
  ```
</Steps>

---
title: Sync Clerk data to your app with webhooks
description: Learn how to sync Clerk data to your app with webhooks.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "A Clerk app is required.",
      link: "/docs/quickstarts/overview",
    },
    {
      title: "A ngrok account is required.",
      link: "https://dashboard.ngrok.com/signup",
      icon: "user-circle",
    }
  ]}
/>

The recommended way to sync Clerk data to your app is through webhooks.

In this guide, you'll set up a webhook in your app to listen for the `user.created` event, create an endpoint in the Clerk Dashboard, build a handler for verifying the webhook, and test it locally using ngrok and the Clerk Dashboard.

Clerk offers many events, but three key events include:

- `user.created`: Triggers when a new user registers in the app or is created via the Clerk Dashboard or Backend API. Listening to this event allows the initial insertion of user information in your database.
- `user.updated`: Triggers when user information is updated via Clerk components, the Clerk Dashboard, or Backend API. Listening to this event keeps data synced between Clerk and your external database. It is recommended to only sync what you need to simplify this process.
- `user.deleted`: Triggers when a user deletes their account, or their account is removed via the Clerk Dashboard or Backend API. Listening to this event allows you to delete the user from your database or add a `deleted: true` flag.

These steps apply to any Clerk event. To make the setup process easier, it's recommended to keep two browser tabs open: one for your Clerk [**Webhooks**](https://dashboard.clerk.com/last-active?path=webhooks) page and one for your [ngrok dashboard](https://dashboard.ngrok.com).

<Steps>
  ## Set up ngrok

  To test a webhook locally, you need to expose your local server to the internet. This guide uses [ngrok](https://ngrok.com/) which creates a **forwarding URL** that sends the webhook payload to your local server.

  1. Navigate to the [ngrok dashboard](https://dashboard.ngrok.com) to create an account.
  1. On the ngrok dashboard homepage, follow the [setup guide](https://dashboard.ngrok.com/get-started/setup) instructions. Under **Deploy your app online**, select **Static domain**. Run the provided command, replacing the port number with your server's port. For example, if your development server runs on port 3000, the command should resemble `ngrok http --url=<YOUR_FORWARDING_URL> 3000`. This creates a free static domain and starts a tunnel.
  1. Save your **Forwarding** URL somewhere secure.

  ## Set up a webhook endpoint

  1. In the Clerk Dashboard, navigate to the [**Webhooks**](https://dashboard.clerk.com/last-active?path=webhooks) page.
  1. Select **Add Endpoint**.
  1. In the **Endpoint URL** field, paste the ngrok **Forwarding** URL you saved earlier, followed by `/api/webhooks`. This is the endpoint that Clerk uses to send the webhook payload. The full URL should resemble `https://fawn-two-nominally.ngrok-free.app/api/webhooks`.
  1. In the **Subscribe to events** section, scroll down and select `user.created`.
  1. Select **Create**. You'll be redirected to your endpoint's settings page. Keep this page open.

  ## Add your Signing Secret to `.env`

  To verify the webhook payload, you'll need your endpoint's **Signing Secret**. Since you don't want this secret exposed in your codebase, store it as an environment variable in your `.env` file during local development.

  1. On the endpoint's settings page in the Clerk Dashboard, copy the **Signing Secret**. You may need to select the eye icon to reveal the secret.
  1. In your project's root directory, open or create an `.env` file, which should already include your Clerk API keys. Assign your **Signing Secret** to `CLERK_WEBHOOK_SIGNING_SECRET`. The file should resemble:

  <If sdk="nuxt">
    > [!IMPORTANT]
    > Prefix `CLERK_WEBHOOK_SIGNING_SECRET` with `NUXT_`.
  </If>

  ```env {{ filename: '.env' }}
  NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
  CLERK_SECRET_KEY={{secret}}
  CLERK_WEBHOOK_SIGNING_SECRET=whsec_123
  ```

  ## Make sure the webhook route is public

  Incoming webhook events don't contain auth information. They come from an external source and aren't signed in or out, so the route must be public to allow access. If you're using `clerkMiddleware()`, ensure that the `/api/webhooks(.*)` route is set as public. For information on configuring routes, see the [`clerkMiddleware()` guide](/docs/references/nextjs/clerk-middleware).

  ## Install `svix`

  Clerk uses [`svix`](https://www.npmjs.com/package/svix) to deliver and verify webhooks. Run the following command in your terminal to install the package:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install svix
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add svix
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add svix
    ```

    ```bash {{ filename: 'terminal' }}
    bun add svix
    ```
  </CodeBlockTabs>

  ## Create a route handler to verify the webhook

  Set up a Route Handler that uses Clerk's [`verifyWebhook()`](/docs/references/backend/verify-webhook) function to verify the incoming Clerk webhook and process the payload.

  For this guide, the payload will be logged to the console. In a real app, you'd use the payload to trigger an action. For example, if listening for the `user.created` event, you might perform a database `create` or `upsert` to add the user's Clerk data to your database's user table.

  If the route handler returns a [4xx](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses) or [5xx code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses), or no code at all, the webhook event will be [retried](/docs/webhooks/overview#retry). If the route handler returns a [2xx code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#successful_responses), the event will be marked as successful, and retries will stop.

  > [!NOTE]
  > The following Route Handler can be used for any webhook event you choose to listen to. It is not specific to `user.created`.

  <Tabs items={["Next.js", "Astro", "Express", "Fastify", "Nuxt", "React Router", "TanStack React Start"]}>
    <Tab>
      ```ts {{ filename: 'app/api/webhooks/route.ts' }}
      import { verifyWebhook } from '@clerk/nextjs/webhooks'

      export async function POST(req: Request) {
        try {
          const evt = await verifyWebhook(req)

          // Do something with payload
          // For this guide, log payload to console
          const { id } = evt.data
          const eventType = evt.type
          console.log(`Received webhook with ID ${id} and event type of ${eventType}`)
          console.log('Webhook payload:', evt.data)

          return new Response('Webhook received', { status: 200 })
        } catch (err) {
          console.error('Error verifying webhook:', err)
          return new Response('Error verifying webhook', { status: 400 })
        }
      }
      ```
    </Tab>

    <Tab>
      ```ts {{ filename: 'src/pages/api/webhooks.ts' }}
      import { verifyWebhook } from '@clerk/astro/webhooks'
      import type { APIRoute } from 'astro'

      export const POST: APIRoute = async ({ request }) => {
        try {
          const evt = await verifyWebhook(request, {
            signingSecret: import.meta.env.CLERK_WEBHOOK_SIGNING_SECRET,
          })

          // Do something with payload
          // For this guide, log payload to console
          const { id } = evt.data
          const eventType = evt.type
          console.log(`Received webhook with ID ${id} and event type of ${eventType}`)
          console.log('Webhook payload:', evt.data)

          return new Response('Webhook received', { status: 200 })
        } catch (err) {
          console.error('Error verifying webhook:', err)
          return new Response('Error verifying webhook', { status: 400 })
        }
      }
      ```
    </Tab>

    <Tab>
      ```ts {{ filename: 'index.ts' }}
      import { verifyWebhook } from '@clerk/express/webhooks'
      import express from 'express'

      const app = express()

      app.post('/api/webhooks', express.raw({ type: 'application/json' }), async (req, res) => {
        try {
          const evt = await verifyWebhook(req)

          // Do something with payload
          // For this guide, log payload to console
          const { id } = evt.data
          const eventType = evt.type
          console.log(`Received webhook with ID ${id} and event type of ${eventType}`)
          console.log('Webhook payload:', evt.data)

          return res.send('Webhook received')
        } catch (err) {
          console.error('Error verifying webhook:', err)
          return res.status(400).send('Error verifying webhook')
        }
      })
      ```
    </Tab>

    <Tab>
      ```ts {{ filename: 'index.ts' }}
      import { verifyWebhook } from '@clerk/fastify/webhooks'
      import Fastify from 'fastify'

      const fastify = Fastify()

      fastify.post('/api/webhooks', async (request, reply) => {
        try {
          const evt = await verifyWebhook(request)

          // Do something with payload
          // For this guide, log payload to console
          const { id } = evt.data
          const eventType = evt.type
          console.log(`Received webhook with ID ${id} and event type of ${eventType}`)
          console.log('Webhook payload:', evt.data)

          return 'Webhook received'
        } catch (err) {
          console.error('Error verifying webhook:', err)
          return reply.code(400).send('Error verifying webhook')
        }
      })
      ```
    </Tab>

    <Tab>
      First, configure Vite to allow the ngrok host in your `nuxt.config.ts`. You only need to do this in development when tunneling your local server (e.g. `localhost:3000/api/webhooks`) to a public URL (e.g. `https://fawn-two-nominally.ngrok-free.app/api/webhooks`). In production, you won't need this configuration because your webhook endpoint will be hosted on your app's production domain (e.g. `https://your-app.com/api/webhooks`).

      ```ts {{ filename: 'nuxt.config.ts' }}
      export default defineNuxtConfig({
        // ... other config
        vite: {
          server: {
            // Replace with your ngrok host
            allowedHosts: ['fawn-two-nominally.ngrok-free.app'],
          },
        },
      })
      ```

      Then create your webhook handler:

      ```ts {{ filename: 'server/api/webhooks.post.ts' }}
      import { verifyWebhook } from '@clerk/nuxt/webhooks'

      export default defineEventHandler(async (event) => {
        try {
          const evt = await verifyWebhook(event)

          // Do something with payload
          // For this guide, log payload to console
          const { id } = evt.data
          const eventType = evt.type
          console.log(`Received webhook with ID ${id} and event type of ${eventType}`)
          console.log('Webhook payload:', evt.data)

          return 'Webhook received'
        } catch (err) {
          console.error('Error verifying webhook:', err)
          setResponseStatus(event, 400)
          return 'Error verifying webhook'
        }
      })
      ```
    </Tab>

    <Tab>
      First, configure Vite to allow the ngrok host in your `vite.config.ts`. You only need to do this in development when tunneling your local server (e.g. `localhost:3000/api/webhooks`) to a public URL (e.g. `https://fawn-two-nominally.ngrok-free.app/api/webhooks`). In production, you won't need this configuration because your webhook endpoint will be hosted on your app's production domain (e.g. `https://your-app.com/api/webhooks`).

      ```ts {{ filename: 'vite.config.ts' }}
      export default defineConfig({
        // ... other config
        server: {
          // Replace with your ngrok host
          allowedHosts: ['fawn-two-nominally.ngrok-free.app'],
        },
      })
      ```

      Then create your webhook handler:

      ```ts {{ filename: 'app/routes/webhooks.ts' }}
      import { verifyWebhook } from '@clerk/react-router/webhooks'
      import type { Route } from './+types/webhooks'

      export const action = async ({ request }: Route.ActionArgs) => {
        try {
          const evt = await verifyWebhook(request)

          // Do something with payload
          // For this guide, log payload to console
          const { id } = evt.data
          const eventType = evt.type
          console.log(`Received webhook with ID ${id} and event type of ${eventType}`)
          console.log('Webhook payload:', evt.data)

          return new Response('Webhook received', { status: 200 })
        } catch (err) {
          console.error('Error verifying webhook:', err)
          return new Response('Error verifying webhook', { status: 400 })
        }
      }
      ```

      Don't forget to add the route to your `router.ts` file:

      ```ts {{ filename: 'router.ts', mark: [5] }}
      import { type RouteConfig, route, index } from '@react-router/dev/routes'

      export default [
        index('routes/home.tsx'),
        route('api/webhooks', 'routes/webhooks.ts'),
      ] satisfies RouteConfig
      ```
    </Tab>

    <Tab>
      First, configure Vite to allow the ngrok host in your `app.config.ts`. You only need to do this in development when tunneling your local server (e.g. `localhost:3000/api/webhooks`) to a public URL (e.g. `https://fawn-two-nominally.ngrok-free.app/api/webhooks`). In production, you won't need this configuration because your webhook endpoint will be hosted on your app's production domain (e.g. `https://your-app.com/api/webhooks`).

      {/* TODO: `vite` has to be typed as `InlineConfig` in order to support the type for `server` as vinxi currently doesn't expose it. Tanstack Start is in the process of movingaway from vinxi, and this type issue will be resolved. */}

      ```ts {{ filename: 'app.config.ts' }}
      import { defineConfig } from '@tanstack/react-start/config'
      import tsConfigPaths from 'vite-tsconfig-paths'
      import type { InlineConfig } from 'vite'

      // `vite` must be typed as `InlineConfig` in order
      // to support the type for `server`
      // as vinxi currently doesn't expose it
      const vite: InlineConfig = {
        server: {
          // Replace with your ngrok host
          allowedHosts: ['fawn-two-nominally.ngrok-free.app'],
        },
        plugins: [
          tsConfigPaths({
            projects: ['./tsconfig.json'],
          }),
        ],
      }

      export default defineConfig({
        vite,
      })
      ```

      Then create your webhook handler:

      ```ts {{ filename: 'app/routes/api/webhooks.ts' }}
      import { verifyWebhook } from '@clerk/tanstack-react-start/webhooks'
      import { createAPIFileRoute } from '@tanstack/react-start/api'

      export const APIRoute = createAPIFileRoute('/api/webhooks')({
        POST: async ({ request }) => {
          try {
            const evt = await verifyWebhook(request)

            // Do something with payload
            // For this guide, log payload to console
            const { id } = evt.data
            const eventType = evt.type
            console.log(`Received webhook with ID ${id} and event type of ${eventType}`)
            console.log('Webhook payload:', evt.data)

            return new Response('Webhook received', { status: 200 })
          } catch (err) {
            console.error('Error verifying webhook:', err)
            return new Response('Error verifying webhook', { status: 400 })
          }
        },
      })
      ```
    </Tab>
  </Tabs>

  ## Narrow to a webhook event for type inference

  `WebhookEvent` encompasses all possible webhook types. Narrow down the event type for accurate typing for specific events.

  In the following example, the `if` statement narrows the type to `user.created`, enabling type-safe access to evt.data with autocompletion.

  ```ts {{ filename: 'app/api/webhooks/route.ts', del: [1, 2], ins: [[4, 6]] }}
  console.log(`Received webhook with ID ${id} and event type of ${eventType}`)
  console.log('Webhook payload:', body)

  if (evt.type === 'user.created') {
    console.log('userId:', evt.data.id)
  }
  ```

  To handle types manually, import the following types from your backend SDK (e.g., `@clerk/nextjs/webhooks`):

  - `DeletedObjectJSON`
  - `EmailJSON`
  - `OrganizationInvitationJSON`
  - `OrganizationJSON`
  - `OrganizationMembershipJSON`
  - `SessionJSON`
  - `SMSMessageJSON`
  - `UserJSON`

  ## Test the webhook

  1. Start your Next.js server.
  1. In your endpoint's settings page in the Clerk Dashboard, select the **Testing** tab.
  1. In the **Select event** dropdown, select `user.created`.
  1. Select **Send Example**.
  1. In the **Message Attempts** section, confirm that the event's **Status** is labeled with **Succeeded**. In your server's terminal where your app is running, you should see the webhook's payload.

  ### Handling failed messages

  1. In the **Message Attempts** section, select the event whose **Status** is labeled with **Failed**.
  1. Scroll down to the **Webhook Attempts** section.
  1. Toggle the arrow next to the **Status** column.
  1. Review the error. Solutions vary by error type. For more information, refer to the [guide on debugging your webhooks](/docs/webhooks/debug-your-webhooks).

  ## Trigger the webhook

  To trigger the `user.created` event, create a new user in your app.

  In the terminal where your app is running, you should see the webhook's payload logged. You can also check the Clerk Dashboard to see the webhook attempt, the same way you did when [testing the webhook](#test-the-webhook).
</Steps>

## Configure your production instance

1. When you're ready to deploy your app to production, follow [the guide on deploying your Clerk app to production](/docs/deployments/overview).
1. Create your production webhook by following the steps in the previous [Set up a webhook endpoint](#set-up-a-webhook-endpoint) section. In the **Endpoint URL** field, instead of pasting the ngrok URL, paste your production app URL.
1. After you've set up your webhook endpoint, you'll be redirected to your endpoint's settings page. Copy the **Signing Secret**.
1. On your hosting platform, update your environment variables on your hosting platform by adding **Signing Secret** with the key of `CLERK_WEBHOOK_SIGNING_SECRET`.
1. Redeploy your app.

---
title: TanStack React Start Quickstart (beta)
description: Learn how to use Clerk to quickly and easily add secure authentication and user management to your TanStack React Start application.
---

> [!WARNING]
> The TanStack React Start SDK is currently in beta. **It is not yet recommended for production use**.

<TutorialHero
  exampleRepo={[
    {
      title: "TanStack React Start Quickstart Repo",
      link: "https://github.com/clerk/clerk-tanstack-react-start-quickstart"

    }
  ]}
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    }
  ]}
/>

<Steps>
  ## Install `@clerk/tanstack-react-start`

  The [Clerk TanStack React Start SDK](/docs/references/tanstack-react-start/overview) gives you access to prebuilt components, React hooks, and helpers to make user authentication easier.

  Run the following command to install the SDK:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/tanstack-react-start
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/tanstack-react-start
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/tanstack-react-start
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @clerk/tanstack-react-start
    ```
  </CodeBlockTabs>

  ## Set your Clerk API keys

  <SignedIn>
    Add the following keys to your `.env` file. These keys can always be retrieved from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
  </SignedIn>

  <SignedOut>
    1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
    1. In the **Quick Copy** section, copy your Clerk Publishable and Secret Keys.
    1. Paste your keys into your `.env` file.

    The final result should resemble the following:
  </SignedOut>

  ```env {{ filename: '.env' }}
  VITE_CLERK_PUBLISHABLE_KEY={{pub_key}}
  CLERK_SECRET_KEY={{secret}}
  ```

  ## Add `createClerkHandler()`

  TanStack's [`createStartHandler()`](https://tanstack.com/router/latest/docs/framework/react/start/getting-started#the-server-entry-point) creates a server-side handler that determines which routes and loaders need to be executed when the user hits a given route.

  Clerk's [`createClerkHandler()`](/docs/references/tanstack-react-start/create-clerk-handler) configures Clerk to handle authentication state for TanStack routes, allowing you to easily access user session information within your app.

  Update your app's SSR entrypoint by wrapping `createStartHandler()` in `createClerkHandler()`, as shown in the following example:

  ```tsx {{ filename: 'app/ssr.tsx' }}
  import { createStartHandler, defaultStreamHandler } from '@tanstack/react-start/server'
  import { getRouterManifest } from '@tanstack/react-start/router-manifest'
  import { createRouter } from './router'
  import { createClerkHandler } from '@clerk/tanstack-react-start/server'

  export default createClerkHandler(
    createStartHandler({
      createRouter,
      getRouterManifest,
    }),
  )(defaultStreamHandler)
  ```

  ## Add `<ClerkProvider>` to your app

  <Include src="_partials/clerk-provider/explanation" />

  Add the `<ClerkProvider>` component to your app's root route, as shown in the following example:

  ```tsx {{ filename: 'app/routes/__root.tsx', ins: [4, 18, 28] }}
  import { Outlet, createRootRoute } from '@tanstack/react-router'
  import { Meta, Scripts } from '@tanstack/react-start'
  import * as React from 'react'
  import { ClerkProvider } from '@clerk/tanstack-react-start'

  export const Route = createRootRoute({
    component: () => {
      return (
        <RootDocument>
          <Outlet />
        </RootDocument>
      )
    },
  })

  function RootDocument({ children }: { children: React.ReactNode }) {
    return (
      <ClerkProvider>
        <html>
          <head>
            <Meta />
          </head>
          <body>
            {children}
            <Scripts />
          </body>
        </html>
      </ClerkProvider>
    )
  }
  ```

  ## Protect your pages

  ### Client-side

  To protect your pages on the client-side, you can use Clerk's [prebuilt control components](/docs/components/overview#control-components) that control the visibility of content based on the user's authentication state.

  The following example uses the following components:

  - [`<SignedIn>`](/docs/components/control/signed-in): Children of this component can only be seen while **signed in**.
  - [`<SignedOut>`](/docs/components/control/signed-out): Children of this component can only be seen while **signed out**.
  - [`<UserButton />`](/docs/components/user/user-button): Shows the signed-in user's avatar. Selecting it opens a dropdown menu with account management options.
  - [`<SignInButton />`](/docs/components/unstyled/sign-in-button): An unstyled component that links to the sign-in page. In this example, since no props or [environment variables](/docs/deployments/clerk-environment-variables) are set for the sign-in URL, this component links to the [Account Portal sign-in page](/docs/account-portal/overview#sign-in).

  ```tsx {{ filename: 'app/routes/index.tsx' }}
  import {
    SignedIn,
    UserButton,
    SignOutButton,
    SignedOut,
    SignInButton,
    SignUpButton,
  } from '@clerk/tanstack-react-start'
  import { createFileRoute } from '@tanstack/react-router'

  export const Route = createFileRoute('/')({
    component: Home,
  })

  function Home() {
    return (
      <div>
        <h1>Index Route</h1>
        <SignedIn>
          <p>You are signed in</p>
          <UserButton />
        </SignedIn>
        <SignedOut>
          <p>You are signed out</p>
          <SignInButton />
        </SignedOut>
      </div>
    )
  }
  ```

  ### Server-side

  To protect your routes, create a [server function](https://tanstack.com/router/latest/docs/framework/react/start/server-functions) that checks the user's authentication state via the [`getAuth()`](/docs/references/tanstack-react-start/get-auth) method. If the user is not authenticated, they are redirected to a sign-in page. If authenticated, the user's `userId` is passed to the route, allowing access to the `<Home />` component, which welcomes the user and displays their `userId`. The [`beforeLoad()`](https://tanstack.com/router/latest/docs/framework/react/api/router/RouteOptionsType#beforeload-method) method ensures authentication is checked before loading the page, and the [`loader()`](https://tanstack.com/router/latest/docs/framework/react/api/router/RouteOptionsType#loader-method) method returns the user data for use in the component.

  > [!TIP]
  > Ensure that your app has the [TanStack Start API entry handler](https://tanstack.com/router/latest/docs/framework/react/start/api-routes#setting-up-the-entry-handler) configured in order for your API routes to work.

  ```tsx {{ filename: 'app/routes/index.tsx' }}
  import { createFileRoute, redirect } from '@tanstack/react-router'
  import { createServerFn } from '@tanstack/react-start'
  import { getAuth } from '@clerk/tanstack-react-start/server'
  import { getWebRequest } from '@tanstack/react-start/server'

  const authStateFn = createServerFn({ method: 'GET' }).handler(async () => {
    const request = getWebRequest()
    if (!request) throw new Error('No request found')
    const { userId } = await getAuth(request)

    if (!userId) {
      // This will error because you're redirecting to a path that doesn't exist yet
      // You can create a sign-in route to handle this
      // See https://clerk.com/docs/references/tanstack-start/custom-sign-in-or-up-page
      throw redirect({
        to: '/sign-in/$',
      })
    }

    return { userId }
  })

  export const Route = createFileRoute('/')({
    component: Home,
    beforeLoad: async () => await authStateFn(),
    loader: async ({ context }) => {
      return { userId: context.userId }
    },
  })

  function Home() {
    const state = Route.useLoaderData()

    return <h1>Welcome! Your ID is {state.userId}!</h1>
  }
  ```

  ## Create your first user

  Run your project with the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun dev
    ```
  </CodeBlockTabs>

  Visit your app's homepage at [http://localhost:3000](http://localhost:3000). Sign up to create your first user.
</Steps>

## Next steps

<Cards>
  - [Create a custom sign-in-or-up page](/docs/references/tanstack-react-start/custom-sign-in-or-up-page)
  - Learn how add custom sign-in-or-up page with Clerk components.

  ---

  - [Read user and session data](/docs/references/tanstack-react-start/read-session-data)
  - Learn how to use Clerk's hooks and helpers to access the active session and user data in your TanStack React Start app.

  ---

  - [Customization & localization](/docs/customization/overview)
  - Learn how to customize and localize the Clerk components.

  ---

  - [Clerk components](/docs/components/overview)
  - Learn more about Clerk's prebuilt components.
</Cards>

---
title: Terminology
description: A list of common terms and their explanations used inside Clerk's SDKs.
---

A consistent terminology should be used across all user interactions with Clerk's services (e.g., SDKs, documentation, dashboard, error messages, support). The following list includes the most common terms and their explanations. Use these terms in your SDKs, documentation, and support materials.

| Name | Description |
| - | - |
| Client | A [client](/docs/references/javascript/client){{ target: '_blank' }} represents the current device or software accessing an application such as your web browser, native application, Chrome Extension, or Electron app. |
| Session | A [session](/docs/references/javascript/session){{ target: '_blank' }} is a secure representation of the authentication state of the current user. Each client can hold multiple sessions on the same device. This is identical to how Gmail works in a browser. |
| User | A user represents the current user of the session. The [`User`](/docs/references/javascript/user){{ target: '_blank' }} object holds all the basic user information e.g. name, email addresses, phone numbers, etc including their public, private, and unsafe metadata. |
| Organization | An [organization](/docs/references/javascript/organization){{ target: '_blank' }} represents the current organization of the session. Users can belong to many organizations. One of them will be the [active organization](/docs/organizations/overview#active-organization) of the session. |
| FAPI | [Frontend API of Clerk](/docs/reference/frontend-api){{ target: '_blank' }}. Example: `https://random-name.clerk.accounts.dev` (Production example: `https://clerk.yourdomain.com`). FAPI is the primary API for Clerks UI components. Every Clerk development/production instance has a dedicated FAPI. This is the authentication, session, user & organization management API you or your users will interact with. |
| BAPI | [Backend API of Clerk](/docs/reference/backend-api){{ target: '_blank' }}. Currently set to `https://api.clerk.com`. A restful CRUD API for the server-side. |
| Secret Key | Your apps Secret Key for use in the backend. Do not expose this on the frontend with a public environment variable. Allows for CRUD operations. |
| Publishable Key | Your apps Publishable Key for use in the frontend. |
| Instances | When creating an app, youre provided with two instances: Development and Production. [Learn more](/docs/deployments/environments). |
| Hotloading ClerkJS | `@clerk/clerk-js`, or ClerkJS, is the foundational JavaScript library for all frontend JS SDKs, e.g. used in `@clerk/clerk-react`. When you install `@clerk/clerk-react` through npm, you dont install `@clerk/clerk-js`. Instead, once the React code is executed in the browser, the React SDK adds a `<script>` tag to load ClerkJS from a CDN. Clerk internally calls this hotloading. |
| UI components | All components displayed in the [component reference](/docs/components/overview) and available through the [`Clerk`](/docs/references/javascript/clerk) class. |
| Authorization header verification | This refers to the HTTP Authorization request header. Clerk uses this HTTP header instead of the `__client` cookie for secure communication with the FAPI in non-standard web browser environments. For example, in React Native apps, Chrome extensions, and hybrid apps like Electron, the `__client` JWT will be stored in a secure storage provided by the platform and injected into the HTTP header of each FAPI request. |
| Handshake | The client handshake is a mechanism that is used to resolve a requests authentication state from unknown to definitively signed in or signed out. Clerks session management architecture relies on a short-lived session JWT to validate requests, along with a long-lived session that is used to keep the session JWT fresh by interacting with the FAPI. The long-lived session token is stored in an `HttpOnly` cookie associated with the FAPI domain. If a short-lived session JWT is expired on a request to an applications backend, the SDK doesnt know if the session has ended, or if a new short-lived JWT needs to be issued. When an SDK gets into this state, it triggers the handshake. |

## Cookies

Clerk is using cookies in order to keep user sessions alive. It's useful to know about these when debugging issues.

### Development instance cookies

| Cookie Name | Description |
| - | - |
| `__clerk_db_jwt` | The **Development Browser JWT**. Helps Clerk sync the session between the development instance domain, `localhost`, and the Clerk FAPI and Account Portal domain, `https://name.accounts.dev`. |
| `__client_uat` | `uat` stands for **Updated At** and helps Clerk to check if the user session is still valid. It is set by `clerk-js` on the client-side. |
| `__session` | A short-lived session JWT to validate requests in your application or your API. |

### Production instance cookies

| Cookie Name | Description |
| - | - |
| `__client` | This is a long-lived `HttpOnly` cookie that is used to issue short-lived session JWTs. It is set by the Clerk FAPI. |
| `__client_uat` | `uat` stands for **Updated At** and helps Clerk to check if the user session is still valid. It is set by the Clerk FAPI. |
| `__session` | A short-lived session JWT to validate requests in your application or your API. |

Clerk is using other non-persistent cookies (e.g. `__clerk_handshake`) for internal mechanisms but for the sake of creating a new SDK from scratch, you don't need to worry about those.

---
title: Test Account Portal flows
description: Learn how to test the Account Portal flow with Cypress.
---

Testing navigation flows with Cypress can be challenging, especially when redirects to external URLs are involved. This guide demonstrates how to use Cypress to test the Account Portal flow, including the redirect to the Account Portal and back to your app.

> [!IMPORTANT]
> Check out the [demo repo](https://github.com/clerk/clerk-cypress-nextjs) that demonstrates testing a Clerk-powered application using [Testing Tokens](/docs/testing/overview#testing-tokens). To run the tests, you'll need dev instance Clerk API keys, a test user with username and password, and have username and password authentication enabled in the Clerk Dashboard.

## Get your Account Portal domain

To get your Account Portal domain, navigate to the [**Account Portal**](https://dashboard.clerk.com/last-active?path=account-portal) page in the Clerk Dashboard. The domain format should resemble: `https://verb-noun-00.accounts.dev`

## The test format

Cypress's `cy.origin()` function lets you visit multiple domains of different origins in the same test. For more information, see the [Cypress documentation](https://docs.cypress.io/api/commands/origin).

By passing your Account Portal domain to `cy.origin()`, your test can navigate to the Account Portal domain and then return to your app.

Structure tests that include Account Portal redirects as follows:

```ts
it('sign in with Account Portal redirects', () => {
  setupClerkTestingToken()

  // Set the origin to the Account Portal domain
  cy.origin('https://verb-noun-00.accounts.dev', () => {
    // Visit a protected page that redirects to the Account Portal when not signed in
    cy.visit('http://localhost:3000/protected')
    // Fill the form to sign in
    // Add any other actions to test
  })

  // The user should be redirected back to the protected page
  cy.url().should('include', '/protected')
})
```

## Example

The following example creates a test that:

- visits a protected page, which redirects to the Account Portal when not signed in
- completes the form to sign in
- redirects back to the protected page

```ts
import { setupClerkTestingToken } from '@clerk/testing/cypress'

describe('Testing Tokens', () => {
  it('sign in with Account Portal redirects', () => {
    setupClerkTestingToken()

    cy.origin('https://verb-noun-00.accounts.dev', () => {
      cy.visit('http://localhost:3000/protected')
      cy.contains('h1', 'Sign in')
      cy.get('.cl-signIn-root').should('exist')
      cy.get('input[name=identifier]').type(Cypress.env('test_user'))

      cy.get('.cl-formButtonPrimary').contains('button', 'Continue').click()
      cy.get('input[name=password]').type(Cypress.env('test_password'))

      cy.get('.cl-formButtonPrimary').contains('button', 'Continue').click()
    })

    cy.url().should('include', '/protected')
    // Ensure the user has successfully accessed the protected page
    // by checking an element on the page that only the authenticated user can access
    cy.contains('h1', 'This is a PROTECTED page')
  })
})
```

---
title: Test authenticated flows
description: Learn how to test authenticated flows with Playwright.
---

Playwright executes tests in isolated environments called browser contexts. Because each test case runs in a new browser context, the user session is not shared between test cases by default. However, tests can load existing authenticated state.

This guide demonstrates how to save the auth state globally and load it in your test cases, eliminating the need to authenticate in every test and speeding up test execution. Visit the [Playwright docs about authentication](https://playwright.dev/docs/auth) for more information.

> [!IMPORTANT]
> See the [demo repo](https://github.com/clerk/clerk-playwright-nextjs) that demonstrates testing a Clerk-powered application using [Testing Tokens](/docs/testing/overview#testing-tokens). To run the tests, you'll need dev instance Clerk API keys, a test user with username and password, and have username and password authentication enabled in the Clerk Dashboard.

<Steps>
  ## Create a storage directory

  Create a `playwright/.clerk` directory and add it to your `.gitignore`. Once the auth state is generated, it will be stored to a file in this directory. Later on, tests will reuse this state and start already authenticated.

  ```sh {{ filename: 'terminal' }}
  mkdir -p playwright/.clerk
  echo $'\nplaywright/.clerk' >> .gitignore
  ```

  ## Prepare auth state for your tests

  Authenticate and save the auth state in your [global setup file](https://playwright.dev/docs/test-global-setup-teardown).

  This file:

  - Is executed before all projects.
  - Calls [`clerkSetup()`](/docs/testing/playwright/overview#configure-playwright-with-clerk) to configure Playwright with Clerk.
  - Calls `clerk.signIn()` to sign in a test user using credentials stored in environment variables. See the [reference](/docs/testing/playwright/test-helpers#clerk-sign-in) for more information about the different parameters you can pass.
  - Checks if the user can access a protected page to ensure the user is successfully authenticated.
  - Stores the auth state in the storage file.

  ```tsx {{ filename: 'global.setup.ts' }}
  import { clerk, clerkSetup } from '@clerk/testing/playwright'
  import { test as setup } from '@playwright/test'
  import path from 'path'

  // Configure Playwright with Clerk
  setup('global setup', async ({}) => {
    await clerkSetup()
  })

  // Define the path to the storage file, which is `user.json`
  const authFile = path.join(__dirname, '../playwright/.clerk/user.json')

  setup('authenticate and save state to storage', async ({ page }) => {
    // Perform authentication steps.
    // This example uses a Clerk helper to authenticate
    await page.goto('/')
    await clerk.signIn({
      page,
      signInParams: {
        strategy: 'password',
        identifier: process.env.E2E_CLERK_USER_USERNAME!,
        password: process.env.E2E_CLERK_USER_PASSWORD!,
      },
    })
    await page.goto('/protected')
    // Ensure the user has successfully accessed the protected page
    // by checking an element on the page that only the authenticated user can access
    await page.waitForSelector("h1:has-text('This is a PROTECTED page')")

    await page.context().storageState({ path: authFile })
  })
  ```

  ## Load the stored auth state in your tests

  You can either load the stored auth state [in the config](#in-the-config) or directly [in a test file](#in-a-test-file). Loading in the config is useful if you want to authenticate once and reuse the same auth state for all tests or groups of tests. Loading in a test file is useful if you want to authenticate for a specific test case.

  ### In the config

  In your `playwright.config.ts`, create a `global setup` project and declare it as a [dependency](https://playwright.dev/docs/test-projects#dependencies) for all your testing projects. This means that the `global setup` project will always run before all the tests, and because it's where you prepared auth state, it will authenticate before all the tests. All testing projects should use the authenticated state as `storageState`.

  ```tsx {{ filename: 'playwright.config.ts' }}
  // ...
  projects: [
    {
      name: 'global setup',
      testMatch: /global\.setup\.ts/,
    },
    {
      name: 'Main tests',
      testMatch: /.*app.spec.ts/,
      use: {
        ...devices['Desktop Chrome'],
      },
      dependencies: ['global setup'],
    },
    {
      name: 'Authenticated tests',
      testMatch: /.*authenticated.spec.ts/,
      use: {
        ...devices['Desktop Chrome'],

        // Use prepared Clerk auth state
        storageState: 'playwright/.clerk/user.json',
      },
      dependencies: ['global setup'],
    },
  ]
  ```

  ### In a test file

  To use the stored auth state in a test file, see the following example:

  ```tsx {{ filename: 'authenticated.spec.ts', mark: [4, 5] }}
  import { test } from '@playwright/test'

  // Use prepared Clerk auth state
  test.use({ storageState: 'playwright/.clerk/user.json' })

  test('user test', async ({ page }) => {
    // page is authenticated
  })
  ```
</Steps>

For more information, feedback, or issues, visit the [`@clerk/testing`](https://github.com/clerk/javascript/tree/main/packages/testing) package.

---
title: Test emails and phones
description: Write end to end tests by simulating OTP verifications.
---

Most of Clerk's sign-in and sign-up flows involve verifying ownership of an email address or phone number via a [one time passcode (OTP)](/docs/custom-flows/email-sms-otp). To confirm that your integration works correctly, you can simulate verification flows without sending an email or SMS, by using reserved values in test mode.

Verification messages are used during sign-up, sign-in, and when adding an email address or phone number to an existing account.

## Limitations

If Clerk is used to deliver SMS messages for your development instance, a maximum of 20 SMS messages can be delivered per calendar month.

After that, requests resulting in OTP SMS messages will be rejected.
Other SMS notifications will still produce a webhook but won't be sent to the target number.

The following cases do not count toward the limit:

- SMS messages sent to US numbers
- SMS messages sent to test numbers
- Self-delivered SMS messages (i.e. not delivered by Clerk)
- SMS messages for apps with a paid subscription

If your development instance requires a higher allowance of monthly SMS messages, contact support to request a limit increase.

## Setup test mode

Every development instance has "test mode" enabled by default. If you need to use "test mode" on a production instance, you can enable it via the Clerk Dashboard or via the Backend API.

> [!WARNING]
> You should not be using "test mode" on any instance that manages actual customers.

### Test mode via the Clerk Dashboard

To enable test mode via the Clerk Dashboard, navigate to the **Settings** page in the Clerk Dashboard. In the **Enable test mode** section, ensure the toggle is toggled on.

![The 'Enable test mode' section of the Settings page in the Clerk Dashboard. There is a red arrow pointing to the toggled, which is toggled on](/docs/images/testing/enable-test-mode.webp)

## How to use test mode

Once test mode is enabled, all you need to do is use the following test numbers as part of your standard flow.

### Email addresses

Any email with the `+clerk_test` subaddress is a test email address. No emails will be sent, and they can be verified with the code `424242`.

For example:

`jane+clerk_test@example.com`

`doe+clerk_test@example.com`

### Phone numbers

Any [fictional phone number](https://en.wikipedia.org/wiki/555_\(telephone_number\)) is a test phone number. No SMS will be sent, and they can all be verified with the code `424242`.

Fictional phone numbers have the following structure:

`+1 (XXX) 555-0100` to `+1 (XXX) 555-0199`

For example:

`+12015550100`

`+19735550133`

### Email links

Testing email links in E2E suites is an uphill task. We recommend turning on [email verification codes](/docs/authentication/configuration/sign-up-sign-in-options#verification-methods), and using that flow to authenticate your tests. The flows are very similar.

## Code examples

### Testing sign in via email code

```tsx
const testSignInWithEmailCode = async () => {
  const { signIn } = useSignIn()

  const emailAddress = 'john+clerk_test@example.com'
  const signInResp = await signIn.create({ identifier: emailAddress })
  const { emailAddressId } = signInResp.supportedFirstFactors.find(
    (ff) => ff.strategy === 'email_code' && ff.safeIdentifier === emailAddress,
  )! as EmailCodeFactor

  await signIn.prepareFirstFactor({
    strategy: 'email_code',
    emailAddressId: emailAddressId,
  })

  const attemptResponse = await signIn.attemptFirstFactor({
    strategy: 'email_code',
    code: '424242',
  })

  if (attemptResponse.status == 'complete') {
    console.log('success')
  } else {
    console.log('error')
  }
}
```

### Testing sign up with phone number

```jsx
const testSignUpWithPhoneNumber = async () => {
  const { signUp } = useSignUp()

  await signUp.create({
    phoneNumber: '+12015550100',
  })
  await signUp.preparePhoneNumberVerification()

  const res = await signUp.attemptPhoneNumberVerification({
    code: '424242',
  })
  if (res.verifications.phoneNumber.status == 'verified') {
    console.log('success')
  } else {
    console.log('error')
  }
}
```

---
title: Test helpers
description: Use test helpers to sign in/sign out with Clerk in your Playwright tests.
---

The `@clerk/testing` package also provides some helper functions to sign in/sign out with Clerk in your Playwright tests without having to interact with the UI.
To use these commands, import the `clerk` object from the `@clerk/testing/playwright` package.

### `clerk.signIn()`

The `clerk.signIn()` function is used to sign in a user using Clerk. This helper only supports the following first factor strategies: password, phone code, and email code. Multi-factor authentication is not supported.

Before calling `clerk.signIn()`, it is required to call `page.goto()` and navigate to an unprotected page that loads Clerk. For example, the index (`/`) page.

> [!NOTE]
> `clerk.signIn()` internally uses the `setupClerkTestingToken()` helper, so you don't need to call it separately.

#### Parameters

`clerk.signIn()` accepts an object with the following properties:

<Properties>
  - `page`
  - [`Page`](https://playwright.dev/docs/pom)

  [The Playwright `Page` object](https://playwright.dev/docs/pom) to use for the sign-in operation.

  ---

  - `signInParams`
  - [`ClerkSignInParams`](#clerk-sign-in-params)

  The parameters to use for the sign-in operation. See [`ClerkSignInParams`](#clerk-sign-in-params).

  ---

  - `setupClerkTestingTokenOptions?`
  - [`SetupClerkTestingTokenOptions`](#setup-clerk-testing-token-options)

  Options to pass to `setupClerkTestingToken()`. See [`SetupClerkTestingTokenOptions`](#setup-clerk-testing-token-options).
</Properties>

#### `ClerkSignInParams`

The `ClerkSignInParams` type is used to define the object that is passed to the `signInParams` parameter of the `clerk.signIn()` function. It has the following properties:

<Properties>
  - `strategy`
  - `'password' | 'phone_code' | 'email_code'`

  The sign-in strategy. Supported strategies are:

  - `password`: The command will sign in the user using the provided password and identifier.
  - `phone_code`: You must have a user with a test phone number as an identifier (e.g., `+15555550100`).
  - `email_code`: You must have a user with a test email as an identifier (e.g., `your_email+clerk_test@example.com`).

  ---

  - `identifier`
  - `string`

  The user's identifier. This could be a username, a phone number, or an email.

  ---

  - `password`
  - `string`

  The user's password. This is required only if the `strategy` is set to `'password'`.
</Properties>

#### `SetupClerkTestingTokenOptions`

The `SetupClerkTestingTokenOptions` type is used to define the object that is passed to the `setupClerkTestingTokenOptions` parameter of the `clerk.signIn()` function. It has the following properties:

<Properties>
  - `frontendApiUrl?`
  - `string`

  The Frontend API URL for your Clerk dev instance, without the protocol. If provided, it overrides the Frontend API URL parsed from the Publishable Key. To retrieve your Frontend API URL, navigate to the [**Domains**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
</Properties>

#### Example

The following example demonstrates how to use `clerk.signIn()` in a test to sign in a user.

```ts {{ filename: 'e2e/app.spec.ts' }}
import { clerk } from '@clerk/testing/playwright'

test('sign in', async ({ page }) => {
  // Navigate to an unprotected page that loads Clerk
  await page.goto('/')

  await clerk.signIn({
    page,
    signInParams: { strategy: 'phone_code', identifier: '+15555550100' },
  })

  // Navigate to a protected page
  await page.goto('/protected')
})
```

### `clerk.signOut()`

`clerk.signOut()` is used to sign out the current user using Clerk.

Before calling `clerk.signOut()`, it is required to call `page.goto()` and navigate to an unprotected page that loads Clerk. For example, the index (`/`) page.

#### Parameters

`clerk.signOut()` accepts an object with the following properties:

<Properties>
  - `page`
  - [`Page`](https://playwright.dev/docs/pom)

  [The Playwright `Page` object](https://playwright.dev/docs/pom) to use for the sign-in operation.

  ---

  - `signOutOptions?`
  - `SignOutOptions`

  Options to pass to `clerk.signOut()`. See [`SignOutOptions`](#sign-out-options).
</Properties>

#### `SignOutOptions`

The `SignOutOptions` type is used to define the object that is passed to the `signOutOptions` parameter of the `clerk.signOut()` function. It has the following properties:

<Properties>
  - `sessionId?`
  - `string`

  The ID of a specific session to sign out of. Useful for multi-session applications.

  ---

  - `redirectUrl?`
  - `string`

  The full URL or path to navigate after sign-out is complete.
</Properties>

#### Example

The following example demonstrates how to use `clerk.signOut()` in a test to sign out a user.

```ts {{ filename: 'e2e/app.spec.ts' }}
import { clerk } from '@clerk/testing/playwright'

test('sign out', async ({ page }) => {
  // Navigate to an unprotected page that loads Clerk
  await page.goto('/')

  await clerk.signIn({
    page,
    signInParams: { strategy: 'phone_code', identifier: '+15555550100' },
  })

  await page.goto('/protected')
  await clerk.signOut({ page })
  await page.goto('/protected')
  // should redirect to sign in page
})
```

### `clerk.loaded()`

`clerk.loaded()` asserts that Clerk has been loaded.

Before calling `clerk.loaded()`, it is required to call `page.goto()` and navigate to an unprotected page that loads Clerk. For example, the index (`/`) page.

#### Parameters

`clerk.loaded()` accepts an object with the following properties:

<Properties>
  - `page`
  - [`Page`](https://playwright.dev/docs/pom)

  [The Playwright `Page` object](https://playwright.dev/docs/pom) to use for the sign-in operation.
</Properties>

#### Example

The following example demonstrates how to use `clerk.loaded()` in a test to assert that Clerk has been loaded.

```ts {{ filename: 'e2e/app.spec.ts' }}
import { clerk } from '@clerk/testing/playwright'

test('ensure that clerk has loaded', async ({ page }) => {
  // Navigate to an unprotected page that loads Clerk
  await page.goto('/')

  await clerk.loaded({ page })
  // clerk has loaded
})
```

---
title: Testing
description: Learn about testing with Clerk.
---

Testing is an important part of every application. Each framework may require a slightly different setup. If you're having trouble getting testing to work properly, [contact support](/contact/support){{ target: '_blank' }}.

## Test with one time passcodes

To avoid sending an email or SMS message with a one time passcode (OTP) during testing, you can use a fake email address or phone number that has a fixed code. Read the complete documentation [here](/docs/testing/test-emails-and-phones).

## Get a valid session token

When writing tests using Clerk, if you need to get a valid session token, use the following flow:

1. If you have not already, [create a new user](https://clerk.com/docs/reference/backend-api/tag/Users#operation/CreateUser).
1. [Create a new session](https://clerk.com/docs/reference/backend-api/tag/Sessions#operation/createSession) for the user.
1. [Create a session token](https://clerk.com/docs/reference/backend-api/tag/Sessions#operation/CreateSessionToken) using the session ID returned in the previous step.
1. Pass the returned session token as the value of an Authorization header to any other requests you're making, as such: `Authorization: Bearer <session_token>`.

Note that Clerk's session tokens are short-lived and are valid only for 60 seconds. Read more [here](/docs/how-clerk-works/overview).

If the session token expires, you will need to refresh it with the same [create session token endpoint](https://clerk.com/docs/reference/backend-api/tag/Sessions#operation/CreateSessionToken). The most common ways to do this are to either hit this endpoint before every test to ensure you have a valid session token, or to run an interval timer that refreshes the token before it expires.

For more information, feedback or issues, visit the [`@clerk/testing`](https://github.com/clerk/javascript/tree/main/packages/testing) package.

## Testing Tokens

Testing Tokens allow you to bypass bot detection mechanisms that protect Clerk applications from malicious bots, ensuring your test suites run smoothly. Without Testing Tokens, you may encounter "Bot traffic detected" errors in your requests.

> [!NOTE]
> While you can manually implement the following logic in your test suite, Clerk provides [Playwright](/docs/testing/playwright/overview) and [Cypress](/docs/testing/cypress/overview) integrations that handle this automatically.

Obtained via the [Backend API](/docs/reference/backend-api/tag/Testing-Tokens){{ target: '_blank' }}, Testing Tokens are short-lived and valid only for the specific instance for which they are issued.

Once retrieved, include the token value in the `__clerk_testing_token` query parameter in your Frontend API requests. For example, a sign-up request using a Testing Token would look like this:

```shell
POST https://happy-hippo-1.clerk.accounts.dev/v1/client/sign_ups?__clerk_testing_token=1713877200-c_2J2MvPu9PnXcuhbPZNao0LOXqK9A7YrnBn0HmIWxy
```

---
title: Testing with Cypress
description: Use Cypress to write end-to-end tests with Clerk.
---

> [!WARNING]
> Our `@clerk/testing` package only supports end-to-end testing. Unit tests are not supported.

Testing with Cypress requires the use of [Testing Tokens](/docs/testing/overview#testing-tokens) to bypass various bot detection mechanisms that typically safeguard Clerk apps against malicious bots. Without Testing Tokens, you might encounter "Bot traffic detected" errors in your requests.

This guide will help you set up your environment for creating Clerk-authenticated tests with Cypress.

> [!IMPORTANT]
> Check out the [demo repo](https://github.com/clerk/clerk-cypress-nextjs) that tests a Clerk-powered application using [Testing Tokens](/docs/testing/overview#testing-tokens).

<Steps>
  ## Install `@clerk/testing`

  Clerk's testing package provides integration helpers for popular testing frameworks. Run the following command to install it:

  <CodeBlockTabs options={['npm', 'yarn', 'pnpm']}>
    ```sh {{ filename: 'terminal' }}
    npm install @clerk/testing --save-dev
    ```

    ```sh {{ filename: 'terminal' }}
    yarn add -D @clerk/testing
    ```

    ```sh {{ filename: 'terminal' }}
    pnpm add @clerk/testing -D
    ```
  </CodeBlockTabs>

  ## Set your API keys

  In your test runner, set your Publishable and Secret Keys as the `CLERK_PUBLISHABLE_KEY` and `CLERK_SECRET_KEY` environment variables, respectively.

  To find your keys:

  1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
  1. In the **Quick Copy** section, copy your Clerk Publishable and Secret Keys.
  1. Paste your keys into your `.env` file.

  > [!WARNING]
  > Ensure you provide the Secret Key in a secure manner, to avoid leaking it to third parties. For example, if you are using GitHub Actions, refer to [_Using secrets in GitHub Actions_](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).

  ## Global setup

  To set up Clerk with Cypress, call the `clerkSetup()` function in your [`cypress.config.ts`](https://docs.cypress.io/guides/references/configuration) file.

  ```tsx {{ filename: 'cypress.config.ts' }}
  import { clerkSetup } from '@clerk/testing/cypress'
  import { defineConfig } from 'cypress'

  export default defineConfig({
    e2e: {
      setupNodeEvents(on, config) {
        return clerkSetup({ config })
      },
      baseUrl: 'http://localhost:3000', // your app's URL
    },
  })
  ```

  `clerkSetup()` will retrieve a [Testing Token](/docs/testing/overview#testing-tokens) once the test suite starts, making it available for all subsequent tests.

  ## Use Clerk Testing Tokens

  Now that Cypress is configured with Clerk, use the `setupClerkTestingToken()` function in your tests to integrate the Testing Token. See the following example:

  ```tsx {{ filename: 'testing-tokens.cy.ts' }}
  import { setupClerkTestingToken } from '@clerk/testing/cypress'

  it('sign up', () => {
    setupClerkTestingToken()

    cy.visit('/sign-up')
    // Add any other actions to test
  })
  ```
</Steps>

---
title: Testing with Playwright
description: Use Playwright to write end-to-end tests with Clerk.
---

[Playwright](https://playwright.dev) is an open-source, end-to-end testing framework that automates web application testing across multiple browsers. This guide will help you set up your environment for creating authenticated tests with Clerk, assuming you have some familiarity with both Clerk and Playwright.

> [!IMPORTANT]
> See the [demo repo](https://github.com/clerk/clerk-playwright-nextjs) that demonstrates testing a Clerk-powered application using [Testing Tokens](/docs/testing/overview#testing-tokens). To run the tests, you'll need dev instance Clerk API keys, a test user with username and password, and have username and password authentication enabled in the Clerk Dashboard.

<Steps>
  ## Install `@clerk/testing`

  Clerk's testing package provides integration helpers for popular testing frameworks. Run the following command to install it:

  <CodeBlockTabs options={['npm', 'yarn', 'pnpm']}>
    ```sh {{ filename: 'terminal' }}
    npm i @clerk/testing --save-dev
    ```

    ```sh {{ filename: 'terminal' }}
    yarn add -D @clerk/testing
    ```

    ```sh {{ filename: 'terminal' }}
    pnpm add @clerk/testing -D
    ```
  </CodeBlockTabs>

  ## Set your API keys

  In your test runner, set your Publishable and Secret Keys as the `CLERK_PUBLISHABLE_KEY` and `CLERK_SECRET_KEY` environment variables, respectively.

  To find your keys:

  1. In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
  1. In the **Quick Copy** section, copy your Clerk Publishable and Secret Keys.

  > [!WARNING]
  > Ensure that the Secret Key is provided securely to prevent exposure to third parties. For example, if you are using GitHub Actions, refer to [_Using secrets in GitHub Actions_](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).

  ## Configure Playwright with Clerk

  The `clerkSetup()` function obtains a Testing Token when your test suite starts, making it available for all subsequent tests to use. This ensures that you don't have to manually generate a Testing Token for each test.

  To configure Playwright with Clerk, call the `clerkSetup()` function in your [global setup file](https://playwright.dev/docs/test-global-setup-teardown), as shown in the following example:

  ```tsx {{ filename: 'global.setup.ts' }}
  import { clerkSetup } from '@clerk/testing/playwright'
  import { test as setup } from '@playwright/test'

  // Setup must be run serially, this is necessary if Playwright is configured to run fully parallel: https://playwright.dev/docs/test-parallel
  setup.describe.configure({ mode: 'serial' })

  setup('global setup', async ({}) => {
    await clerkSetup()
  })
  ```

  > [!NOTE]
  > Instead of calling `clerkSetup()`, you can manually set the Testing Token by setting the `CLERK_TESTING_TOKEN` environment variable to the [Testing Token](/docs/testing/overview#testing-tokens) that you create through the Backend API.

  ## Use `setupClerkTestingToken()`

  Now that Playwright is configured with Clerk, you can use the `setupClerkTestingToken()` function to include the Testing Token in individual test cases. This function injects the Testing Token for the specific test, ensuring the test can bypass Clerk's bot detection mechanisms. See the following example:

  ```tsx {{ filename: 'my-test.spec.ts' }}
  import { setupClerkTestingToken } from '@clerk/testing/playwright'
  import { test } from '@playwright/test'

  test('sign up', async ({ page }) => {
    await setupClerkTestingToken({ page })

    await page.goto('/sign-up')
    // Add additional test logic here
  })
  ```
</Steps>

---
title: Testing with Postman or Insomnia
description: Learn about generating and using a long-lived JWT Token with Postman or Insomnia.
---

Postman and Insomnia are powerful tools used to test API's, validate their behavior, and automate testing tasks. Basic testing with these tools is similar, and this guide will help you get started with either option.

## Generate long-lived JWT template

The standard token issued by Clerk expires after 60 seconds. Clerk SDKs handle refreshing the token regularly so that the authentication state is kept up to date. Because this token expires quickly, it isn't very useful when trying to test with Postman or Insomnia.

You will want to create a long-lived [JWT Template](/docs/backend-requests/jwt-templates) to be used in Postman or Insomnia. To do so, navigate to the [**JWT templates**](https://dashboard.clerk.com/last-active?path=jwt-templates) page in the Clerk Dashboard. Select **New template** then choose the **Blank** template.

![The JWT templates page in the Clerk Dashboard. The 'New template' button was clicked, in the modal that opened, the 'Blank' template is hovered over](/docs/images/testing/blank-jwt-template.webp)

Give your template a unique name, such as _'testing-template'_. Set the **Token Lifetime** to a value that suits your needs, or use the maximum of 315360000 seconds (10 years). If you added custom claims to the normal session token, then you should add the same claims to your JWT template.

![Creating a JWT template in the Clerk Dashboard](/docs/images/testing/testing-template.webp)

## Fetch long-lived token

Visit your frontend that is using the same Clerk Application and instance that you want to test. Sign in as a user. The user that you sign in as will be the user you test with in Postman or Insomnia. You can create several tokens for several different users. Once you have signed in, open your Dev Tools and go to the **Console** tab. Enter the following command:

```js
await window.Clerk.session.getToken({ template: '<the template name you chose above>' })
```

![The Dev Tools Console with the command 'await window.Clerk.session.getToken()' entered. The token is logged to the console](/docs/images/testing/get-token-from-console.webp)

## Using Postman or Insomnia

<Tabs items={["Postman", "Insomnia"]}>
  <Tab>
    Open Postman and create a new request.

    ![The Postman app with a red arrow pointing at the plus icon in the top-left corner](/docs/images/testing/postman-new-request.webp)

    Configure Postman with the method and URL for the API Route you want to test. This example uses the `POST` method and the `/api/protected-route` route.

    ![The Postman app with a red box around the method and URL field](/docs/images/testing/postman-configure-request.webp)

    Navigate to the **Authorization** tab and for token type, select **Bearer Token**. Paste the token you copied from the console as the Bearer Token. Your request will now authenticate as the user you created the token with.

    ![The Postman app with the first red arrow pointing at the Authorization tab, the second red arrow pointing at the token type with 'Bearer token' chosen, and a third red arrow pointing at the token field with the token pasted in](/docs/images/testing/postman-bearer-token.webp)
  </Tab>

  <Tab>
    Open Insomnia and create a new request.

    ![The Insomnia app with a red arrow pointing at the 'New HTTP Request' button](/docs/images/testing/insomnia-new-request.webp)

    Configure Insomnia with the method and URL for the API Route you want to test. This example uses the `POST` method and the `/api/protected-route` route.

    ![The Insomnia app with a red box around the method and URL field](/docs/images/testing/insomnia-configure-request.webp)

    Navigate to the **Auth** tab and select **Auth** again to show a menu of auth types. Choose the **Bearer token** option. Paste the token you copied from the console. Your request will now authenticate as the user you created the token with.

    ![The Insomnia app with the first red arrow pointing at the Auth tab which has been switched to the 'Bearer token' option. The second red arrow points at the token field with the token pasted in](/docs/images/testing/insomnia-bearer-token.webp)
  </Tab>
</Tabs>

## Grouping requests

Postman and Insomnia both provide a **Collections** feature, which allows you to group requests together. Inside that collection, you can add **[Variables](https://learning.postman.com/docs/sending-requests/variables/)** (Postman) or **[Environment Variables](https://docs.insomnia.rest/insomnia/environment-variables)** (Insomnia). These features enable you to use a single token across multiple requests and also allow you to store tokens for multiple users. This is great for testing different features in your application by conveniently changing the token/user you are testing with. You can read more about Postman **Variables** [here](https://learning.postman.com/docs/sending-requests/variables/) and Insomnia **Environment Variables** [here](https://docs.insomnia.rest/insomnia/environment-variables).

---
title: The Backend `AllowlistIdentifier` object
description: The Backend AllowlistIdentifier object holds information about a AllowlistIdentifier of your application. However, the Backend AllowlistIdentifier object is different from the AllowlistIdentifier object in that it is used in the Backend API.
---

The Backend `AllowlistIdentifier` object represents an identifier that has been added to the allowlist of your application. The Backend `AllowlistIdentifier` object is used in the [Backend API](/docs/reference/backend-api/tag/Allow-list-Block-list#operation/ListAllowlistIdentifiers){{ target: '_blank' }} and is not directly accessible from the Frontend API.

## Properties

<Properties>
  - `id`
  - `string`

  A unique ID for the allowlist identifier.

  ---

  - `identifier`
  - `string`

  The [identifier](/docs/authentication/configuration/sign-up-sign-in-options#identifiers) that was added to the allowlist.

  ---

  - `createdAt`
  - `number`

  The date when the allowlist identifier was first created.

  ---

  - `updatedAt`
  - `number`

  The date when the allowlist identifier was last updated.

  ---

  - `invitationId?`
  - `string`

  The ID of the invitation sent to the identifier.
</Properties>

---
title: 'The Backend `Client` object'
description: The Backend Client object holds information about the authenticated sessions in the current device. However, the Backend Client object is different from the Client object in that it is used in the Backend API.
---

The Backend `Client` object is similar to the [`Client`](/docs/references/javascript/client) object as it holds information about the authenticated sessions in the current device. However, the Backend `Client` object is different from the `Client` object in that it is used in the [Backend API](/docs/reference/backend-api/tag/Clients#operation/GetClient) and is not directly accessible from the Frontend API.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for the `Client`.

  ---

  - `sessionIds`
  - `string[]`

  An array of [Session](/docs/references/javascript/session){{ target: '_blank' }} IDs associated with the `Client`.

  ---

  - `sessions`
  - <code>[Session](/docs/references/javascript/session){{ target: '_blank' }}\[]</code>

  An array of [Session](/docs/references/javascript/session){{ target: '_blank' }} objects associated with the `Client`.

  ---

  - `signInId`
  - `string`

  The ID of the [`SignIn`](/docs/references/javascript/sign-in){{ target: '_blank' }}.

  ---

  - `signUpId`
  - `string`

  The ID of the [`SignUp`](/docs/references/javascript/sign-up){{ target: '_blank' }}

  ---

  - `lastActiveSessionId`
  - `string`

  The ID of the last active [Session](/docs/references/javascript/session){{ target: '_blank' }}.

  ---

  - `createdAt`
  - `number`

  The date when the `Client` was first created.

  ---

  - `updatedAt`
  - `number`

  The date when the `Client` was last updated.
</Properties>

---
title: The Backend `Invitation` object
description: The Backend Invitation object represents an invitation to join your application.
---

The Backend `Invitation` object represents an invitation to join your application.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for the `Invitation`.

  ---

  - `emailAddress`
  - `string`

  The email address that the invitation was sent to.

  ---

  - `publicMetadata`
  - [`UserPublicMetadata`](/docs/references/javascript/types/metadata#user-public-metadata)

  Metadata that can be read from the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }} and can be set only from the Backend API. Once the user accepts the invitation and signs up, these metadata will end up in the user's public metadata.

  ---

  - `createdAt`
  - `number`

  The date when the `Invitation` was first created.

  ---

  - `updatedAt`
  - `number`

  The date when the `Invitation` was last updated.

  ---

  - `status`
  - `'pending' | 'accepted' | 'revoked'`

  The status of the `Invitation`.

  ---

  - `revoked?`
  - `boolean`

  Whether the `Invitation` has been revoked.
</Properties>

---
title: The Backend `Organization` object
description: The Backend Organization object holds information about an organization, as well as methods for managing it. However, the it is different from the Organization object in that it is used in the Backend API and is not directly accessible from the Frontend API.
---

The Backend `Organization` object is similar to the [`Organization`](/docs/references/javascript/organization) object as it holds information about an organization, as well as methods for managing it. However, the Backend `Organization` object is different in that it is used in the [Backend API](/docs/reference/backend-api/tag/Organizations#operation/ListOrganizations){{ target: '_blank' }} and is not directly accessible from the Frontend API.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for the organization.

  ---

  - `name`
  - `string`

  The name of the organization.

  ---

  - `slug`
  - `string`

  The URL-friendly identifier of the user's active organization. If supplied, it must be unique for the instance.

  ---

  - `createdBy?`
  - `string`

  The ID of the user who created the organization.

  ---

  - `createdAt`
  - `number`

  The date when the organization was first created.

  ---

  - `updatedAt`
  - `number`

  The date when the organization was last updated.

  ---

  - `imageUrl`
  - `string`

  Holds the organization's logo. Compatible with Clerk's [Image Optimization](/docs/guides/image-optimization).

  ---

  - `hasImage`
  - `boolean`

  Whether the organization has an image.

  ---

  - `publicMetadata`
  - [`OrganizationPublicMetadata`](/docs/references/javascript/types/metadata#organization-public-metadata)

  Metadata that can be read from the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }} and can be set only from the Backend API.

  ---

  - `privateMetadata`
  - [`OrganizationPrivateMetadata`](/docs/references/javascript/types/metadata#organization-private-metadata)

  Metadata that can be read and set only from the [Backend API](/docs/reference/backend-api){{ target: '_blank' }}.

  ---

  - `maxAllowedMemberships`
  - `number`

  The maximum number of memberships allowed in the organization.

  ---

  - `adminDeleteEnabled`
  - `boolean`

  Whether the organization allows admins to delete users.

  ---

  - `membersCount?`
  - `number`

  The number of members in the organization.
</Properties>

---
title: The Backend `OrganizationInvitation` object
description: The Backend OrganizationInvitation object is the model around an organization invitation.
---

The Backend `OrganizationInvitation` object is similar to the [`OrganizationInvitation`](/docs/references/javascript/types/organization-invitation) object as it's the model around an organization invitation. However, the Backend `OrganizationInvitation` object is different in that it's used in the [Backend API](/docs/reference/backend-api/tag/Organization-Invitations#operation/CreateOrganizationInvitation){{ target: '_blank' }} and is not directly accessible from the Frontend API.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for the `OrganizationInvitation`.

  ---

  - `emailAddress`
  - `string`

  The email address of the user who is invited to the [`Organization`](/docs/references/backend/types/backend-organization).

  ---

  - `role`
  - `string`

  The role of the invited user.

  ---

  - `organizationId`
  - `string`

  The ID of the [`Organization`](/docs/references/backend/types/backend-organization) that the user is invited to.

  ---

  - `createdAt`
  - `number`

  The date when the invitation was first created.

  ---

  - `updatedAt`
  - `number`

  The date when the invitation was last updated.

  ---

  - `status?`
  - `'pending' | 'accepted' | 'revoked'`

  The status of the invitation.

  ---

  - `publicMetadata`
  - [`OrganizationInvitationPublicMetadata`](/docs/references/javascript/types/metadata#organization-invitation-public-metadata)

  Metadata that can be read from the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }} and can be set only from the Backend API.

  ---

  - `privateMetadata`
  - [`OrganizationInvitationPrivateMetadata`](/docs/references/javascript/types/metadata#organization-invitation-private-metadata)

  Metadata that can be read and set only from the [Backend API](/docs/reference/backend-api){{ target: '_blank' }}.
</Properties>

---
title: The Backend `OrganizationMembership` object
description: The Backend OrganizationMembership object is the model around an organization membership entity and describes the relationship between users and organizations.
---

The Backend `OrganizationMembership` object is similar to the [`OrganizationMembership`](/docs/references/javascript/types/organization-membership) object as it's the model around an organization membership entity and describes the relationship between users and organizations. However, the Backend `OrganizationMembership` object is different in that it's used in the [Backend API](/docs/reference/backend-api/tag/Organization-Memberships#operation/CreateOrganizationMembership){{ target: '_blank' }} and is not directly accessible from the Frontend API.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for the membership.

  ---

  - `role`
  - `OrganizationMembershipRole`

  The role of the user.

  ---

  - `publicMetadata`
  - [`OrganizationMembershipPublicMetadata`](/docs/references/javascript/types/metadata#organization-membership-public-metadata)

  Metadata that can be read from the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }} and can be set only from the Backend API.

  ---

  - `privateMetadata`
  - [`OrganizationMembershipPrivateMetadata`](/docs/references/javascript/types/metadata#organization-membership-private-metadata)

  Metadata that can be read and set only from the [Backend API](/docs/reference/backend-api){{ target: '_blank' }}.

  ---

  - `createdAt`
  - `number`

  The date when the membership was first created.

  ---

  - `updatedAt`
  - `number`

  The date when the membership was last updated.

  ---

  - `organization`
  - [`Organization`](/docs/references/backend/types/backend-organization)

  The organization that the user is a member of.

  ---

  - `publicUserData?`
  - [`OrganizationMembershipPublicUserData`](#organization-membership-public-user-data)

  Public information about the user that this membership belongs to.
</Properties>

### `OrganizationMembershipPublicUserData`

<Properties>
  - `identifier`
  - `string`

  The [identifier](/docs/authentication/configuration/sign-up-sign-in-options#identifiers) of the user.

  ---

  - `firstName`
  - `string`

  The first name of the user.

  ---

  - `lastName`
  - `string`

  The last name of the user.

  ---

  - `imageUrl`
  - `string`

  Holds the default avatar or user's uploaded profile image. Compatible with Clerk's [Image Optimization](/docs/guides/image-optimization).

  ---

  - `hasImage`
  - `boolean`

  Whether the user has a profile picture.

  ---

  - `userId`
  - `string`

  The ID of the user that this public data belongs to.
</Properties>

---
title: The Backend `RedirectUrl` object
description: The Backend RedirectUrl object represents a redirect URL in your application. This object is used in the Backend API.
---

Redirect URLs are whitelisted URLs that facilitate secure authentication flows in native applications (e.g. React Native, Expo). In these contexts, Clerk ensures that security-critical nonces are passed only to the whitelisted URLs.

The Backend `RedirectUrl` object represents a redirect URL in your application. This object is used in the Backend API.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for the redirect URL.

  ---

  - `url`
  - `string`

  The full URL value prefixed with `https://` or a custom scheme. For example, `https://my-app.com/oauth-callback` or `my-app://oauth-callback`.

  ---

  - `createdAt`
  - `number`

  The date when the redirect URL was first created.

  ---

  - `updatedAt`
  - `number`

  The date when the redirect URL was last updated.
</Properties>

---
title: The Backend `SamlConnection` object
description: The Backend SamlConnection object holds information about a SAML connection for an organization.
---

The Backend `SamlConnection` object holds information about a SAML connection for an organization.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for the connection.

  ---

  - `acsUrl`
  - `string`

  The Assertion Consumer Service (ACS) URL of the connection.

  ---

  - `active`
  - `boolean`

  Indicates whether the connection is active or not.

  ---

  - `allowIdpInitiated`
  - `boolean`

  Indicates whether the connection allows Identity Provider (IdP) initiated flows or not.

  ---

  - `allowSubdomains`
  - `boolean`

  Indicates whether users with an email address subdomain are allowed to use this connection in order to authenticate or not.

  ---

  - `attributeMapping`
  - `{ userId: string, emailAddress: string, firstName: string, lastName: string }`

  Defines the attribute name mapping between the Identity Provider (IdP) and Clerk's [`User`](/docs/references/javascript/user) properties.

  ---

  - `createdAt`
  - `number`

  The date when the connection was first created.

  ---

  - `domain`
  - `string`

  The domain of your organization. Sign in flows using an email with this domain will use the connection.

  ---

  - `idpEntityId`
  - `string`

  The Entity ID as provided by the Identity Provider (IdP)

  ---

  - `idpSsoUrl`
  - `string`

  The Single-Sign On URL as provided by the Identity Provider (IdP).

  ---

  - `idpCertificate`
  - `string`

  The X.509 certificate as provided by the Identity Provider (IdP)

  ---

  - `idpMetadataUrl`
  - `string`

  The URL which serves the Identity Provider (IdP) metadata. If present, it takes priority over the corresponding individual properties.

  ---

  - `idpMetadata`
  - `string`

  The XML content of the Identity Provider (IdP) metadata file. If present, it takes priority over the corresponding individual properties.

  ---

  - `name`
  - `string`

  The name to use as a label for the connection.

  ---

  - `spEntityId`
  - `string`

  The Entity ID as provided by the Service Provider (Clerk).

  ---

  - `spMetadataUrl`
  - `string`

  The metadata URL as provided by the Service Provider (Clerk).

  ---

  - `provider`
  - `string`

  The Identity Provider (IdP) of the connection.

  ---

  - `syncUserAttributes`
  - `boolean`

  Indicates whether the connection syncs user attributes between the Service Provider (SP) and Identity Provider (IdP) or not.

  ---

  - `updatedAt`
  - `number`

  The date when the SAML connection was last updated.

  ---

  - `userCount`
  - `number`

  The number of users associated with the connection.
</Properties>

---
title: The Backend `Session` object
description: The Backend Session object holds information about a Session of your application. However, the Backend Session object is different from the Session object in that it is used in the Backend API.
---

The Backend `Session` object is similar to the [`Session`](/docs/references/javascript/session) object as it is an abstraction over an HTTP session and models the period of information exchange between a user and the server. However, the Backend `Session` object is different as it is used in the [Backend API](/docs/reference/backend-api/tag/Sessions#operation/GetSessionList) and is not directly accessible from the Frontend API.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for the `Session`.

  ---

  - `clientId`
  - `string`

  The ID of the client associated with the `Session`.

  ---

  - `userId`
  - `string`

  The ID of the user associated with the `Session`.

  ---

  - `status`
  - `string`

  The current state of the `Session`.

  ---

  - `lastActiveAt`
  - `number`

  The time the session was last active on the [`Client`](/docs/references/backend/types/backend-client).

  ---

  - `lastActiveOrganizationId`
  - `string | undefined`

  The ID of the last active organization.

  ---

  - `actor`
  - `ActJWTClaim | null`

  The JWT actor for the session. Holds identifier for the user that is impersonating the current user. Read more about [impersonation](/docs/users/user-impersonation).

  ---

  - `latestActivity`
  - [`SessionActivity`](/docs/references/javascript/types/session-with-activities#session-activity)

  An object that provides additional information about this session, focused around user activity data.

  ---

  - `expireAt`
  - `number`

  The date when the `Session` will expire.

  ---

  - `abandonAt`
  - `number`

  The date when the `Session` will be abandoned.

  ---

  - `createdAt`
  - `number`

  The date when the `Session` was first created.

  ---

  - `updatedAt`
  - `number`

  The date when the `Session` was last updated.
</Properties>

---
title: The Backend `User` object
description: The Backend User object holds information about a user of your application. However, the Backend User object is different from the User object in that it is used in the Backend API.
---

The Backend `User` object is similar to the `User` object as it holds information about a user of your application, such as their unique identifier, name, email addresses, phone numbers, and more. However, the Backend `User` object is different from the `User` object in that it is used in the [Backend API](/docs/reference/backend-api/tag/Users#operation/GetUser){{ target: '_blank' }} and is not directly accessible from the Frontend API.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for the user.

  ---

  - `passwordEnabled`
  - `boolean`

  A boolean indicating whether the user has a password on their account.

  ---

  - `totpEnabled`
  - `boolean`

  A boolean indicating whether the user has enabled TOTP by generating a TOTP secret and verifying it via an authenticator app

  ---

  - `backupCodeEnabled`
  - `boolean`

  A boolean indicating whether the user has enabled Backup codes.

  ---

  - `twoFactorEnabled`
  - `boolean`

  A boolean indicating whether the user has enabled two-factor authentication.

  ---

  - `banned`
  - `boolean`

  A boolean indicating whether the user is banned or not.

  ---

  - `createdAt`
  - `number`

  The date when the user was first created.

  ---

  - `updatedAt`
  - `number`

  The date when the user was last updated.

  ---

  - `imageUrl`
  - `string`

  The URL of the user's profile image.

  ---

  - `hasImage`
  - `boolean`

  A getter boolean to check if the user has uploaded an image or one was copied from OAuth. Returns `false` if Clerk is displaying an avatar for the user.

  ---

  - `primaryEmailAddressId`
  - `string`

  The ID for the `EmailAddress` that the user has set as primary.

  ---

  - `primaryPhoneNumberId`
  - `string`

  The ID for the `PhoneNumber` that the user has set as primary.

  ---

  - `primaryWeb3WalletId`
  - `string`

  The ID for the [`Web3Wallet`][web3-ref] that the user signed up with.

  ---

  - `lastSignInAt`
  - `number`

  The date when the user last signed in. May be empty if the user has never signed in.

  ---

  - `externalId`
  - `string`

  The ID of the user as used in your external systems. Must be unique across your instance.

  ---

  - `username`
  - `string`

  The user's username.

  ---

  - `firstName`
  - `string`

  The user's first name.

  ---

  - `lastName`
  - `string`

  The user's last name.

  ---

  - `publicMetadata`
  - [`UserPublicMetadata`](/docs/references/javascript/types/metadata#user-public-metadata)

  Metadata that can be read from the Frontend API and [Backend API](/docs/reference/backend-api){{ target: '_blank' }} and can be set only from the Backend API.

  ---

  - `privateMetadata`
  - [`UserPrivateMetadata`](/docs/references/javascript/types/metadata#user-private-metadata)

  Metadata that can be read and set only from the [Backend API](/docs/reference/backend-api){{ target: '_blank' }}.

  ---

  - `unsafeMetadata`
  - [`UserUnsafeMetadata`](/docs/references/javascript/types/metadata#user-unsafe-metadata)

  Metadata that can be read and set from the Frontend API. It's considered unsafe because it can be modified from the frontend.

  ---

  - `emailAddresses`
  - [`EmailAddress[]`][email-ref]

  An array of all the `EmailAddress` objects associated with the user. Includes the primary.

  ---

  - `phoneNumbers`
  - [`PhoneNumber[]`][phone-ref]

  An array of all the `PhoneNumber` objects associated with the user. Includes the primary.

  ---

  - `hasVerifiedPhoneNumber`
  - `boolean`

  A getter boolean to check if the user has verified a phone number.

  ---

  - `web3Wallets`
  - [`Web3Wallet[]`][web3-ref]

  An array of all the `Web3Wallet` objects associated with the user. Includes the primary.

  ---

  - `externalAccounts`
  - [`ExternalAccount[]`][exacc-ref]

  An array of all the `ExternalAccount` objects associated with the user via OAuth. **Note**: This includes both verified & unverified external accounts.

  ---

  - `lastActiveAt`
  - `number`

  Date when the user was last active.

  ---

  - `createOrganizationEnabled`
  - `boolean`

  A boolean indicating whether the organization creation is enabled for the user or not.

  ---

  - `createOrganizationsLimit?`
  - `number`

  An integer indicating the number of organizations that can be created by the user. If the value is `0`, then the user can create unlimited organizations. Default is `null`.

  ---

  - `legalAcceptedAt?`
  - `number | null`

  The unix timestamp of when the user accepted the legal requirements. `null` if [**Require express consent to legal documents**](/docs/authentication/configuration/legal-compliance) is not enabled.
</Properties>

[web3-ref]: /docs/references/javascript/web3-wallet/web3-wallet

[exacc-ref]: /docs/references/javascript/types/external-account

[email-ref]: /docs/references/javascript/types/email-address

[phone-ref]: /docs/references/javascript/phone-number

---
title: Themes
description: Clerk currently offers four prebuilt themes for you to customize the overall appearance of your Clerk app.
---

Clerk currently offers four prebuilt themes:

- [The default theme](#default-theme)
- [The "Dark" theme](#dark-theme)
- [The "Shades of Purple" theme](#shades-of-purple-theme)
- [The "Neobrutalism" theme](#neobrutalism-theme)

## Default theme

Applied by default when no other theme is provided.

<div style={{padding: "1rem 0", filter: "drop-shadow(rgba(0, 0, 0, 0.16) 0px 12px 24px)"}}>
  ![A sign-in form with a light theme](/docs/images/themes/default.svg)
</div>

## "Dark" theme

<div style={{padding: "1rem 0", filter: "drop-shadow(rgba(0, 0, 0, 0.16) 0px 12px 24px)"}}>
  ![A sign-in form with a dark theme](/docs/images/themes/dark.svg)
</div>

## "Shades of purple" theme

<div style={{padding: "1rem 0", filter: "drop-shadow(rgba(0, 0, 0, 0.16) 0px 12px 24px)"}}>
  ![A sign-in form with a purple and yellow theme](/docs/images/themes/shades_of_purple.png){{ style: { maxWidth: '400px' } }}
</div>

## "Neobrutalism" theme

<div style={{padding: "1rem 0", filter: "drop-shadow(rgba(0, 0, 0, 0.16) 0px 12px 24px)"}}>
  ![A sign-in form with a neobrutalist red theme](/docs/images/themes/neobrutalism.png){{ style: { maxWidth: '400px' } }}
</div>

## Usage

1. To get started, install the `@clerk/themes` package.

   <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
     ```bash {{ filename: 'terminal' }}
     npm install @clerk/themes
     ```

     ```bash {{ filename: 'terminal' }}
     yarn add @clerk/themes
     ```

     ```bash {{ filename: 'terminal' }}
     pnpm add @clerk/themes
     ```

     ```bash {{ filename: 'terminal' }}
     bun add @clerk/themes
     ```
   </CodeBlockTabs>
1. To use a theme, import it from `@clerk/themes` and pass it to the `appearance` prop of a Clerk component.

### Apply a theme to all Clerk components

To apply a theme to all Clerk components, pass the `appearance` prop to the [`<ClerkProvider>`](/docs/components/clerk-provider) component. The `appearance` prop accepts the property `baseTheme`, which can be set to a theme.

In the following example, the "Dark" theme is applied to all Clerk components.

<Tabs items={["Next.js", "React", "Remix", "Astro", "Vue", "Nuxt"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: '/src/app/layout.tsx', mark: [2, [7, 9]] }}
      import { ClerkProvider } from '@clerk/nextjs'
      import { dark } from '@clerk/themes'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <ClerkProvider
            appearance={{
              baseTheme: dark,
            }}
          >
            <html lang="en">
              <body>{children}</body>
            </html>
          </ClerkProvider>
        )
      }
      ```

      ```tsx {{ filename: '_app.tsx', mark: [2, 8, 9, 10] }}
      import { ClerkProvider } from '@clerk/nextjs'
      import { dark } from '@clerk/themes'
      import type { AppProps } from 'next/app'

      function MyApp({ Component, pageProps }: AppProps) {
        return (
          <ClerkProvider
            appearance={{
              baseTheme: dark,
            }}
          >
            <Component {...pageProps} />
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app.tsx', mark: [3, [14, 16]] }}
    import React from 'react'
    import './App.css'
    import { dark } from '@clerk/themes'
    import { ClerkProvider } from '@clerk/clerk-react'

    if (!process.env.REACT_APP_CLERK_PUBLISHABLE_KEY) {
      throw new Error('Missing Publishable Key')
    }
    const clerkPubKey = process.env.REACT_APP_CLERK_PUBLISHABLE_KEY

    function App() {
      return (
        <ClerkProvider
          appearance={{
            baseTheme: dark,
          }}
          publishableKey={clerkPubKey}
        >
          <div>Hello from clerk</div>
        </ClerkProvider>
      )
    }

    export default App
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/root.tsx', mark: [3, [36, 38]] }}
    // Import ClerkApp
    import { ClerkApp } from '@clerk/remix'
    import { dark } from '@clerk/themes'
    import type { MetaFunction, LoaderFunction } from '@remix-run/node'

    import { Links, LiveReload, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react'

    import { rootAuthLoader } from '@clerk/remix/ssr.server'

    export const meta: MetaFunction = () => ({
      charset: 'utf-8',
      title: 'New Remix App',
      viewport: 'width=device-width,initial-scale=1',
    })

    export const loader: LoaderFunction = (args) => rootAuthLoader(args)

    function App() {
      return (
        <html lang="en">
          <head>
            <Meta />
            <Links />
          </head>
          <body>
            <Outlet />
            <ScrollRestoration />
            <Scripts />
            <LiveReload />
          </body>
        </html>
      )
    }

    export default ClerkApp(App, {
      appearance: {
        baseTheme: dark,
      },
    })
    ```
  </Tab>

  <Tab>
    ```js {{ filename: 'astro.config.mjs', mark: [2, [7, 9]] }}
    import clerk from '@clerk/astro'
    import { dark } from '@clerk/themes'

    export default defineConfig({
      integrations: [
        clerk({
          appearance: {
            baseTheme: dark,
          },
        }),
      ],
    })
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'src/main.ts', mark: [4, [8, 10]] }}
    import { createApp } from 'vue'
    import App from './App.vue'
    import { clerkPlugin } from '@clerk/vue'
    import { dark } from '@clerk/themes'

    const app = createApp(App)
    app.use(clerkPlugin, {
      appearance: {
        baseTheme: dark,
      },
    })
    app.mount('#app')
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'nuxt.config.ts', mark: [1, [6, 8]] }}
    import { dark } from '@clerk/themes'

    export default defineNuxtConfig({
      modules: ['@clerk/nuxt'],
      clerk: {
        appearance: {
          baseTheme: dark,
        },
      },
    })
    ```
  </Tab>
</Tabs>

### Apply multiple themes

You can also stack themes by passing an array of themes to the `baseTheme` property of the `appearance` prop. The themes will be applied in the order they are listed. If styles overlap, the last defined theme will take precedence.

In the following example, the "Dark" theme is applied first, then the "Neobrutalism" theme is applied on top of it.

<Tabs items={["Next.js", "React", "Remix", "Astro", "Vue", "Nuxt"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: '/src/app/layout.tsx', mark: [2, [7, 9]] }}
      import { ClerkProvider } from '@clerk/nextjs'
      import { dark, neobrutalism } from '@clerk/themes'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <ClerkProvider
            appearance={{
              baseTheme: [dark, neobrutalism],
            }}
          >
            <html lang="en">
              <body>{children}</body>
            </html>
          </ClerkProvider>
        )
      }
      ```

      ```tsx {{ filename: '_app.tsx', mark: [2, [8, 10]] }}
      import { ClerkProvider, SignIn } from '@clerk/nextjs'
      import { dark, neobrutalism } from '@clerk/themes'
      import type { AppProps } from 'next/app'

      function MyApp({ Component, pageProps }: AppProps) {
        return (
          <ClerkProvider
            appearance={{
              baseTheme: [dark, neobrutalism],
            }}
          >
            <Component {...pageProps} />
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app.tsx', mark: [3, [14, 16]] }}
    import React from 'react'
    import './App.css'
    import { dark, neobrutalism } from '@clerk/themes'
    import { ClerkProvider } from '@clerk/clerk-react'

    if (!process.env.REACT_APP_CLERK_PUBLISHABLE_KEY) {
      throw new Error('Missing Publishable Key')
    }
    const clerkPubKey = process.env.REACT_APP_CLERK_PUBLISHABLE_KEY

    function App() {
      return (
        <ClerkProvider
          appearance={{
            baseTheme: [dark, neobrutalism],
          }}
          publishableKey={clerkPubKey}
        >
          <div>Hello from clerk</div>
        </ClerkProvider>
      )
    }

    export default App
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/root.tsx', mark: [3, [36, 38]] }}
    // Import ClerkApp
    import { ClerkApp } from '@clerk/remix'
    import { dark, neobrutalism } from '@clerk/themes'
    import type { MetaFunction, LoaderFunction } from '@remix-run/node'

    import { Links, LiveReload, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react'

    import { rootAuthLoader } from '@clerk/remix/ssr.server'

    export const meta: MetaFunction = () => ({
      charset: 'utf-8',
      title: 'New Remix App',
      viewport: 'width=device-width,initial-scale=1',
    })

    export const loader: LoaderFunction = (args) => rootAuthLoader(args)

    function App() {
      return (
        <html lang="en">
          <head>
            <Meta />
            <Links />
          </head>
          <body>
            <Outlet />
            <ScrollRestoration />
            <Scripts />
            <LiveReload />
          </body>
        </html>
      )
    }

    export default ClerkApp(App, {
      appearance: {
        baseTheme: [dark, neobrutalism],
      },
    })
    ```
  </Tab>

  <Tab>
    ```js {{ filename: 'astro.config.mjs', mark: [2, [7, 9]] }}
    import clerk from '@clerk/astro'
    import { dark, neobrutalism } from '@clerk/themes'

    export default defineConfig({
      integrations: [
        clerk({
          appearance: {
            baseTheme: [dark, neobrutalism],
          },
        }),
      ],
    })
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'src/main.ts', mark: [4, [8, 10]] }}
    import { createApp } from 'vue'
    import App from './App.vue'
    import { clerkPlugin } from '@clerk/vue'
    import { dark, neobrutalism } from '@clerk/themes'

    const app = createApp(App)
    app.use(clerkPlugin, {
      appearance: {
        baseTheme: [dark, neobrutalism],
      },
    })
    app.mount('#app')
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'nuxt.config.ts', mark: [1, [6, 8]] }}
    import { dark, neobrutalism } from '@clerk/themes'

    export default defineNuxtConfig({
      modules: ['@clerk/nuxt'],
      clerk: {
        appearance: {
          baseTheme: [dark, neobrutalism],
        },
      },
    })
    ```
  </Tab>
</Tabs>

### Apply a theme to all instances of a Clerk component

You can apply a theme to all instances of a Clerk component by passing the component to the `appearance` prop of the `<ClerkProvider>`. The `appearance` prop accepts the name of the Clerk component you want to style as a key.

In the following example, the "Neobrutalism" theme is applied to all instances of the [`<SignIn />`](/docs/components/authentication/sign-in) component.

<Tabs items={["Next.js", "React", "Remix", "Astro", "Vue", "Nuxt"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: '/src/app/layout.tsx', mark: [2, [7, 10]] }}
      import { ClerkProvider } from '@clerk/nextjs'
      import { dark, neobrutalism } from '@clerk/themes'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <ClerkProvider
            appearance={{
              baseTheme: dark,
              signIn: { baseTheme: neobrutalism },
            }}
          >
            <html lang="en">
              <body>{children}</body>
            </html>
          </ClerkProvider>
        )
      }
      ```

      ```tsx {{ filename: '_app.tsx', mark: [2, [8, 11]] }}
      import { ClerkProvider, SignIn } from '@clerk/nextjs'
      import { dark } from '@clerk/themes'
      import type { AppProps } from 'next/app'

      function MyApp({ Component, pageProps }: AppProps) {
        return (
          <ClerkProvider
            appearance={{
              baseTheme: dark,
              signIn: { baseTheme: neobrutalism },
            }}
          >
            <Component {...pageProps} />
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app.tsx', mark: [3, [14, 17]] }}
    import React from 'react'
    import './App.css'
    import { dark } from '@clerk/themes'
    import { ClerkProvider } from '@clerk/clerk-react'

    if (!process.env.REACT_APP_CLERK_PUBLISHABLE_KEY) {
      throw new Error('Missing Publishable Key')
    }
    const clerkPubKey = process.env.REACT_APP_CLERK_PUBLISHABLE_KEY

    function App() {
      return (
        <ClerkProvider
          appearance={{
            baseTheme: dark,
            signIn: { baseTheme: neobrutalism },
          }}
          publishableKey={clerkPubKey}
        >
          <div>Hello from clerk</div>
        </ClerkProvider>
      )
    }

    export default App
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/root.tsx', mark: [3, [36, 39]] }}
    // Import ClerkApp
    import { ClerkApp } from '@clerk/remix'
    import { dark } from '@clerk/themes'
    import type { MetaFunction, LoaderFunction } from '@remix-run/node'

    import { Links, LiveReload, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react'

    import { rootAuthLoader } from '@clerk/remix/ssr.server'

    export const meta: MetaFunction = () => ({
      charset: 'utf-8',
      title: 'New Remix App',
      viewport: 'width=device-width,initial-scale=1',
    })

    export const loader: LoaderFunction = (args) => rootAuthLoader(args)

    function App() {
      return (
        <html lang="en">
          <head>
            <Meta />
            <Links />
          </head>
          <body>
            <Outlet />
            <ScrollRestoration />
            <Scripts />
            <LiveReload />
          </body>
        </html>
      )
    }

    export default ClerkApp(App, {
      appearance: {
        baseTheme: dark,
        signIn: { baseTheme: neobrutalism },
      },
    })
    ```
  </Tab>

  <Tab>
    ```js {{ filename: 'astro.config.mjs', mark: [2, [7, 10]] }}
    import clerk from '@clerk/astro'
    import { dark } from '@clerk/themes'

    export default defineConfig({
      integrations: [
        clerk({
          appearance: {
            baseTheme: dark,
            signIn: { baseTheme: neobrutalism },
          },
        }),
      ],
    })
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'src/main.ts', mark: [4, [8, 11]] }}
    import { createApp } from 'vue'
    import App from './App.vue'
    import { clerkPlugin } from '@clerk/vue'
    import { dark, neobrutalism } from '@clerk/themes'

    const app = createApp(App)
    app.use(clerkPlugin, {
      appearance: {
        baseTheme: dark,
        signIn: { baseTheme: neobrutalism },
      },
    })
    app.mount('#app')
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'nuxt.config.ts', mark: [1, [6, 9]] }}
    import { dark, neobrutalism } from '@clerk/themes'

    export default defineNuxtConfig({
      modules: ['@clerk/nuxt'],
      clerk: {
        appearance: {
          baseTheme: dark,
          signIn: { baseTheme: neobrutalism },
        },
      },
    })
    ```
  </Tab>
</Tabs>

### Apply a theme to a single Clerk component

To apply a theme to a single Clerk component, pass the `appearance` prop to the component. The `appearance` prop accepts the property `baseTheme`, which can be set to a theme.

<Tabs items={["Next.js", "React", "Remix", "Astro", "Vue", "Nuxt"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: 'app/sign-in/[[...sign-in]]/page.tsx', mark: [2, [7, 9]] }}
      import { SignIn } from '@clerk/nextjs'
      import { dark } from '@clerk/themes'

      export default function Page() {
        return (
          <SignIn
            appearance={{
              baseTheme: dark,
            }}
          />
        )
      }
      ```

      ```tsx {{ filename: '/pages/sign-in/[[...index]].tsx', mark: [2, [6, 8]] }}
      import { SignIn } from '@clerk/nextjs'
      import { dark } from '@clerk/themes'

      const SignInPage = () => (
        <SignIn
          appearance={{
            baseTheme: dark,
          }}
        />
      )

      export default SignInPage
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    ```tsx {{ filename: '/src/sign-in/[[...index]].tsx', mark: [2, [6, 8]] }}
    import { SignIn } from '@clerk/clerk-react'
    import { dark } from '@clerk/themes'

    const SignInPage = () => (
      <SignIn
        appearance={{
          baseTheme: dark,
        }}
      />
    )

    export default SignInPage
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/routes/sign-in/$.tsx', mark: [2, [9, 11]] }}
    import { SignIn } from '@clerk/remix'
    import { dark } from '@clerk/themes'

    export default function SignInPage() {
      return (
        <div style={{ border: '2px solid blue', padding: '2rem' }}>
          <h1>Sign In route</h1>
          <SignIn
            appearance={{
              baseTheme: dark,
            }}
          />
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    ```astro {{ filename: 'pages/sign-in.astro', mark: [3, [9, 11]] }}
    ---
    import { SignIn } from '@clerk/astro/components'
    import { dark } from '@clerk/themes'
    ---

    <SignIn
      appearance={{
        baseTheme: dark,
      }}
    />
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'src/pages/sign-in.vue' }}
    <script setup lang="ts">
    import { SignIn } from '@clerk/vue'
    import { dark } from '@clerk/themes'
    </script>

    <template>
      <SignIn :appearance="{ baseTheme: dark }" />
    </template>
    ```
  </Tab>

  <Tab>
    ```vue {{ filename: 'pages/sign-in.vue' }}
    <script setup lang="ts">
    // Components are automatically imported
    import { dark } from '@clerk/themes'
    </script>

    <template>
      <SignIn :appearance="{ baseTheme: dark }" />
    </template>
    ```
  </Tab>
</Tabs>

## Customize a theme using variables

You can customize a theme by passing an object of variables to the `variables` property of the `appearance` prop. The `variables` property is used to adjust the general styles of the component's base theme, like colors, backgrounds, typography.

In the following example, the primary color of the themes are customized.

> [!IMPORTANT]
> For a list of all of the variables you can customize, and for more examples on how to use the `variables` property, see the [Variables](/docs/customization/variables) docs.

<Tabs items={["Next.js", "React", "Remix", "Astro", "Vue", "Nuxt"]}>
  <Tab>
    <CodeBlockTabs options={["App Router", "Pages Router"]}>
      ```tsx {{ filename: '/src/app/layout.tsx', mark: [2, [7, 14]] }}
      import { ClerkProvider } from '@clerk/nextjs'
      import { dark, neobrutalism, shadesOfPurple } from '@clerk/themes'

      export default function RootLayout({ children }: { children: React.ReactNode }) {
        return (
          <ClerkProvider
            appearance={{
              baseTheme: [dark, neobrutalism],
              variables: { colorPrimary: 'blue' },
              signIn: {
                baseTheme: [shadesOfPurple],
                variables: { colorPrimary: 'green' },
              },
            }}
          >
            <html lang="en">
              <body>{children}</body>
            </html>
          </ClerkProvider>
        )
      }
      ```

      ```tsx {{ filename: '_app.tsx', mark: [2, [8, 15]] }}
      import { ClerkProvider } from '@clerk/nextjs'
      import { dark, neobrutalism, shadesOfPurple } from '@clerk/themes'
      import type { AppProps } from 'next/app'

      function MyApp({ Component, pageProps }: AppProps) {
        return (
          <ClerkProvider
            appearance={{
              baseTheme: [dark, neobrutalism],
              variables: { colorPrimary: 'blue' },
              signIn: {
                baseTheme: [shadesOfPurple],
                variables: { colorPrimary: 'blue' },
              },
            }}
          >
            <Component {...pageProps} />
          </ClerkProvider>
        )
      }

      export default MyApp
      ```
    </CodeBlockTabs>
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app.tsx', mark: [3, [14, 21]] }}
    import React from 'react'
    import './App.css'
    import { dark, neobrutalism, shadesOfPurple } from '@clerk/themes'
    import { ClerkProvider } from '@clerk/clerk-react'

    if (!process.env.REACT_APP_CLERK_PUBLISHABLE_KEY) {
      throw new Error('Missing Publishable Key')
    }
    const clerkPubKey = process.env.REACT_APP_CLERK_PUBLISHABLE_KEY

    function App() {
      return (
        <ClerkProvider
          appearance={{
            baseTheme: [dark, neobrutalism],
            variables: { colorPrimary: 'blue' },
            signIn: {
              baseTheme: [shadesOfPurple],
              variables: { colorPrimary: 'blue' },
            },
          }}
          publishableKey={clerkPubKey}
        >
          <div>Hello from clerk</div>
        </ClerkProvider>
      )
    }

    export default App
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/root.tsx', mark: [3, [36, 43]] }}
    // Import ClerkApp
    import { ClerkApp } from '@clerk/remix'
    import { dark, neobrutalism, shadesOfPurple } from '@clerk/themes'
    import type { MetaFunction, LoaderFunction } from '@remix-run/node'

    import { Links, LiveReload, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react'

    import { rootAuthLoader } from '@clerk/remix/ssr.server'

    export const meta: MetaFunction = () => ({
      charset: 'utf-8',
      title: 'New Remix App',
      viewport: 'width=device-width,initial-scale=1',
    })

    export const loader: LoaderFunction = (args) => rootAuthLoader(args)

    function App() {
      return (
        <html lang="en">
          <head>
            <Meta />
            <Links />
          </head>
          <body>
            <Outlet />
            <ScrollRestoration />
            <Scripts />
            <LiveReload />
          </body>
        </html>
      )
    }

    export default ClerkApp(App, {
      appearance: {
        baseTheme: [dark, neobrutalism],
        variables: { colorPrimary: 'blue' },
        signIn: {
          baseTheme: [shadesOfPurple],
          variables: { colorPrimary: 'blue' },
        },
      },
    })
    ```
  </Tab>

  <Tab>
    ```js {{ filename: 'astro.config.mjs', mark: [2, [7, 14]] }}
    import clerk from '@clerk/astro'
    import { dark, neobrutalism, shadesOfPurple } from '@clerk/themes'

    export default defineConfig({
      integrations: [
        clerk({
          appearance: {
            baseTheme: [dark, neobrutalism],
            variables: { colorPrimary: 'blue' },
            signIn: {
              baseTheme: [shadesOfPurple],
              variables: { colorPrimary: 'blue' },
            },
          },
        }),
      ],
    })
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'src/main.ts', mark: [4, [8, 15]] }}
    import { createApp } from 'vue'
    import App from './App.vue'
    import { clerkPlugin } from '@clerk/vue'
    import { dark, neobrutalism, shadesOfPurple } from '@clerk/themes'

    const app = createApp(App)
    app.use(clerkPlugin, {
      appearance: {
        baseTheme: [dark, neobrutalism],
        variables: { colorPrimary: 'blue' },
        signIn: {
          baseTheme: [shadesOfPurple],
          variables: { colorPrimary: 'blue' },
        },
      },
    })
    app.mount('#app')
    ```
  </Tab>

  <Tab>
    ```ts {{ filename: 'nuxt.config.ts', mark: [1, [6, 13]] }}
    import { dark, neobrutalism, shadesOfPurple } from '@clerk/themes'

    export default defineNuxtConfig({
      modules: ['@clerk/nuxt'],
      clerk: {
        appearance: {
          baseTheme: [dark, neobrutalism],
          variables: { colorPrimary: 'blue' },
          signIn: {
            baseTheme: [shadesOfPurple],
            variables: { colorPrimary: 'blue' },
          },
        },
      },
    })
    ```
  </Tab>
</Tabs>

---
title: Tokens and signatures
description: Learn about JWTs, digital signatures, and how Clerk uses them to securely authenticate users.
---

## Digital signatures

Digital signatures are a cryptographic technique that ensures the authenticity and integrity of messages. They guarantee that:

1. The message originates from a specific sender (authenticity).
1. The message's content hasn't been modified from how it was written by the sender (integrity).

However, digital signatures do **not** encrypt the messageanyone can read its contents.

### How digital signatures work

Digital signatures use **public key cryptography**, which involves a key pair: a private key (kept secret) and a public key (shared openly). Here's the process:

1. A private key is used to create a **signature**:
   1. The message is [hashed](https://www.techtarget.com/searchdatamanagement/definition/hashing) (a unique, fixed-length representation of the message).
   1. The hash is encrypted using the sender's private key, creating the signature.
1. The message and signature are sent to the recipient.
1. The recipient verifies the signature using the sender's public key by:
   1. Decrypting the signature to retrieve the hash.
   1. Independently hashing the message and comparing the two hashes. If they match, the message is authentic and has not been changed.

So for example, imagine you get a publicly readable message, like `hello world`, and the message is signed with the signature `j2e80w8dj9f8`. If you'd like to be sure that the message is genuine, and you have a copy of the sender's public key, you can use this key to decrypt the signature and make sure that it is valid. If it is, you know two things for sure: who sent the message, and that nobody intercepted the message and messed with it in the middle, since part of the verification process involves hashing the message and comparing it to the decrypted signature.

### Key Terminology

- **Sign**: The process of generating a digital signature with a private key and attaching it to a message.
- **Verify**: The process of using a public key to confirm the signature's validity and the message's integrity.

Clerk leverages digital signatures in **JSON Web Tokens (JWTs)** to securely authenticate users.

## JSON Web Tokens (JWTs)

JSON Web Tokens (JWTs) are a lightweight format for transmitting digitally signed data over the internet. They are commonly used for authentication and information exchange.

### Structure of a JWT

A JWT's format is three [base64-encoded](https://builtin.com/software-engineering-perspectives/base64-encoding) parts, separated by dots:

```plaintext
<Header>.<Payload>.<Signature>
```

Here's an example of a JWT:

```plaintext
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.Eci61G6w4zh_u9oOCk_v1M_sKcgk0svOmW4ZsL-rt4ojGUH2QY110bQTYNwbEVlowW7phCg7vluX_MCKVwJkxJT6tMk2Ij3Plad96Jf2G2mMsKbxkC-prvjvQkBFYWrYnKWClPBRCyIcG0dVfBvqZ8Mro3t5bX59IKwQ3WZ7AtGBYz5BSiBlrKkp6J1UmP_bFV3eEzIHEFgzRa3pbr4ol4TK6SnAoF88rLr2NhEz9vpdHglUMlOBQiqcZwqrI-Z4XDyDzvnrpujIToiepq9bCimPgVkP54VoZzy-mMSGbthYpLqsL_4MQXaI1Uf_wKFAUuAtzVn4-ebgsKOpvKNzVA
```

Let's decode and break down each part:

**Header**: The header specifies metadata about the token, such as the hashing algorithm used for the signature. There are several different hashing algorithms that can be used to digitally sign a JWT. This example's header tells us that the signature's hash was created using the `RS256` algorithm:

```json
{
  "alg": "RS256",
  "typ": "JWT"
}
```

**Payload**: The payload contains the actual information that you want to send. In Clerk's case, this includes information about the authenticated user. [Read more about Clerk's session JWT payload](/docs/backend-requests/resources/session-tokens).

```json
{
  "sub": "user_123",
  "iat": 1516239022
}
```

**Signature**: The signature is created by hashing the header and payload, and then encrypting the hash with the private key.

```
Error: The string is not correctly encoded
```

When decoding the signature from base64, an error is thrown because the signature is not base64-encoded. This is expected behavior. The recipient must use the JWT issuer's public key and the algorithm specified in the header (e.g., RS256) to verify the signature. Clerk's SDKs all ship with a method for verifying the signature of a Clerk JWT: [`authenticateRequest()`](/docs/references/backend/authenticate-request). But if you'd like to verify the signature yourself, see the [guide on manual JWT verification](/docs/backend-requests/manual-jwt).

### How Clerk uses JWTs

To learn more about how Clerk uses JWTs, read the [guide on how Clerk works](/docs/how-clerk-works/overview).

---
title: Troubleshooting
description: Learn how to troubleshoot common issues with Clerk and contact support for additional assistance.
---

We hope that our documentation is thorough and transparent enough that you won't run into any issues. If you can't find what you're looking for in the navigation sidenav, use the search function of the docs to track down the information you need.

Refer to the [Backend API](/docs/reference/backend-api){{ target: '_blank' }} and [Frontend API](/docs/reference/frontend-api){{ target: '_blank' }} reference docs for questions about object structures, requests, and responses.

Are you looking for a place to get started? See the [quickstarts](/docs/quickstarts/overview).

## Discord community

Need help? Have a suggestion? Join our [Discord community](https://clerk.com/discord) and never miss a thing.

## Support

Can't find what you need? [Contact us](/contact/support){{ target: '_blank' }} to receive answers to your questions and learn more about Clerk.

---
title: Twitter v1 (deprecated)
description: Learn how to set up social connection with Twitter v1.
---

> [!CAUTION]
> [X/Twitter](https://twitter.com/XDevelopers/status/1641222782594990080) considers this method deprecated. We strongly recommend using the [latest version (v2)](/docs/authentication/social-connections/x-twitter) for future-proofing your application.

How to set up social connection with Twitter v1

## Overview

Adding social connection with Twitter to your app with Clerk is done in a few steps - you only need to set the **Client ID**, **Client Secret** and **Redirect URI** in your instance settings.

Clerk does not currently support preconfigured shared OAuth credentials for Twitter on development instances. You will have to provide custom credentials for both development _and_ production instances, which includes generating your own Client ID and Client Secret using your Twitter Developer account. Don't worry, this guide will walk you through that process in just a few simple steps.

> [!NOTE]
> The purpose of this guide is to help you create a Twitter account and a Twitter OAuth app - if you're looking for step-by-step instructions using Clerk to add social connection (OAuth) to your application, follow the [Social connection (OAuth) guide](/docs/authentication/social-connections/overview).

## Before you start

- You need to create a Clerk Application in the [Clerk Dashboard](https://dashboard.clerk.com/). For more information, see the [setup guide](/docs/quickstarts/setup-clerk).
- You need to have a Twitter Application set up so it can be used as a social connection. If you don't have a Twitter Application, click [here](https://developer.twitter.com/en/docs/apps/overview) for instructions on how to create one. If you already have one, go to your [Twitter app settings](https://developer.twitter.com/en/portal/projects-and-apps) and ensure that the _"Allow this app to be used to Sign in with Twitter?_ option is enabled.

## Configuring Twitter social connection

If you don't have an existing Twitter Application you've set up for social connection, you need to register a new one at the [Twitter Developer Portal](https://developer.twitter.com/en/portal/dashboard). Note that the process requires approval from Twitter before your new application can be used.

To do so, go to "[Projects & Apps](https://developer.twitter.com/en/portal/projects-and-apps)" and click "**+ Add App**" to create a new application. After entering a name, you'll be presented with your app's credentials: **API Key** and **API Secret**. Copy those values as you will be needing those shortly.

> [!NOTE]
> You will need your application to be approved for elevated status to be able to use it with Clerk. You can apply for the status in [Twitter developer dashboard](https://developer.twitter.com/en/portal/products/elevated)

In the Clerk Dashboard, navigate to the [**SSO connections**](https://dashboard.clerk.com/last-active?path=user-authentication/sso-connections) page. Select the **Add connection** button, and select **For all users**. In the **Choose provider** dropdown, select **Twitter**. Toggle on **Use custom credentials** and paste the **API Key** and **API Secret** values which you copied in the previous step. Then, copy the **Authorized Redirect URI**.

Navigate to your application settings screen and scroll down to the **User authentication settings** section and select **Set up**.

![Setting up User Authentication settings of a Twitter app](/docs/images/authentication-providers/twitter/a5b63a206cc6a04fd8b143dd191483c4f6e81d66-979x618.png)

In the next screen you'll be presented with the user authentication settings. Make sure that both **OAuth 1.0a** and **Request email address from users** are enabled.

Also, enter the **Authorized Redirect URI** that you grabbed in the previous step from your Clerk instance's settings and insert it in the **Callback URI** setting. Your app's settings should like similar to the ones below.  Fill any other required fields and click save. Your Twitter App is now ready.

![Fill in the Callback URI](/docs/images/authentication-providers/twitter/89fc23c0ac843ba74831c669e17c44a31896a8d7-1196x954.png)

Finally, select **Add connection** so that the settings are applied. Congratulations! Social connection with Twitter is now configured for your instance.

---
title: Unauthorized sign-in
description: Notify users of unauthorized sign-ins to their accounts
---

Clerk detects sign-in attempts from unrecognized devices to protect users from unauthorized access to their accounts. This security feature helps identify potentially malicious sign-in activity.

## Email notification for unauthorized access

When a sign-in attempt is made from an unfamiliar device, Clerk notifies the account owner by email with details about the newly created session. The email notification varies depending on the instance's configuration and the application's billing plan.

By default, the email includes information about the unauthorized sign-in attempt, such as device type, operating system, IP address, location, and the sign-in method used. If you've set a support email for your app, Clerk will add instructions for the user to contact the app administrator.

For supported instances, the email might also include a button that allows users to sign out from the unrecognized device. Selecting this button immediately revokes the session.

To customize the unauthorized sign-in email notification:

1. In the Clerk Dashboard, navigate to the [**Emails**](https://dashboard.clerk.com/last-active?path=customization/email) page.
1. Select **Sign in from new device**. You'll be redirected to the template settings page.
1. Edit the email template.
1. Select **Apply changes**.

## Revoke sessions for unauthorized sign-ins

> [!WARNING]
> This feature isn't available in production for free plans but can be tested for free in development mode. For more information, see the [pricing](/pricing){{ target: '_blank' }} page.

For apps that support this feature, users can immediately revoke unauthorized sign-ins directly from the email notification. With a single click, the suspicious session is revoked and the user is redirected to a confirmation page.

The confirmation page depends on the instance configuration:

- [Account Portal](/docs/account-portal/overview) enabled: The user is redirected to the [unauthorized sign-in](/docs/account-portal/overview#unauthorized-sign-in) page, where content can be customized based on the app's theme.
- Account Portal disabled: The user sees a plain text confirmation of the successful session revocation.

In either case, after revoking the session, users must sign in again unless they have an active session on their device.

To customize the URL path of the unauthorized sign-in page:

1. In the Clerk Dashboard, navigate to the [**Paths**](https://dashboard.clerk.com/last-active?path=paths) page.
1. Under **Application paths**, enter the **Unauthorized sign in URL** path.
1. Select **Save**.

---
title: Unlock user accounts from the Clerk Dashboard
description: Use the Clerk Dashboard to unlock user accounts.
---

> [!NOTE]
> This feature is applicable to a subset of actions. Find a [full list here](/docs/security/user-lock-guide#actions)

Users with admin roles can override lockouts through the Clerk Dashboard.

1. In the top in the Clerk Dashboard, select [**Users**](https://dashboard.clerk.com/last-active?path=users).
1. Locate the locked user by looking for a "locked" badge next to their username/email.
1. Open the admin menu by selecting the icon that looks like three stacked dots.
1. Select **Unlock** to unlock the user account.

![](/docs/images/security/userlock_dashboard.webp)

Alternatively, you can unlock a user's account on their profile page.

1. In the top in the Clerk Dashboard, select [**Users**](https://dashboard.clerk.com/last-active?path=users).
1. Locate the locked user by looking for a "locked" badge next to their username/email.
1. Select the user's row to be taken to their profile page.
1. Scroll to the **Unlock user** section, and select **Unlock user**.

![](/docs/images/security/userlock_profile.webp)

---
title: Upgrade to `clerk-sdk-ruby` v4
description: Learn how to upgrade your application to use Clerk Ruby SDK v4.
---

In January 2025, version 4.0 of the Clerk Ruby SDK was released. This guide covers the breaking changes that were introduced.

## `Clerk.configure` updates

Previously, `Clerk.configure` accepted `api_key` as a parameter. Now, it accepts `secret_key` instead.

```ruby {{ del: [4], ins: [5] }}
require 'clerk'

Clerk.configure do |c|
  c.api_key = `{{secret}}`
  c.secret_key = `{{secret}}`
end
```

## `middleware_cache_store` updates

Previously, if Rails was detected, the `middleware_cache_store` was set to `Rails.cache`. Otherwise, it was set to `nil`.

Now, if Rails is not detected, the `middleware_cache_store` attempts to use `ActiveSupport::Cache::MemoryStore` before defaulting to `nil`.

## Available methods updates

With the introduction of our generated Ruby HTTP Client, the `Clerk::SDK` class methods have all been overhauled to align with the [Clerk OpenAPI specification](https://github.com/clerk/openapi-specs){{ target: '_blank' }}.

Refer to the [Ruby HTTP Client documentation](https://github.com/clerk/clerk-http-client-ruby/tree/main/.generated#documentation-for-api-endpoints){{ target: '_blank' }} for more information on what methods are available via the `Clerk::SDK` class or the `clerk.sdk` helper method.

---
title: Use Clerk Go for Backend API Operations
description: Explore different examples of how to utilize Clerk with Go.
---

The following example demonstrates how to use the Clerk Go SDK to execute [Clerk Backend API](/docs/references/backend/overview) operations.

By executing the code in the snippet below, you will:

- Create an organization and update its slug.
- Fetch all organization memberships and loop through them to get the first one.
- Get more details about the organization's user.

> [!NOTE]
> Your Clerk Secret Key is required. If you're signed into the Clerk Dashboard, your Secret Key should become visible by selecting the eye icon. Otherwise, you can retrieve your Clerk Secret Key on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.

```go {{ filename: 'main.go' }}
import (
    "github.com/clerk/clerk-sdk-go/v2"
    "github.com/clerk/clerk-sdk-go/v2/organization"
    "github.com/clerk/clerk-sdk-go/v2/organizationmembership"
    "github.com/clerk/clerk-sdk-go/v2/user"
)

func main() {
  // Each API operation requires a context.Context as the first argument.
  ctx := context.Background()

  // Set the API key
  clerk.SetKey("{{secret}}")

  // Create an organization
  org, err := organization.Create(ctx, &organization.CreateParams{
      Name: clerk.String("Clerk Inc"),
  })
  if err != nil {
    // You can get additional information on the error, if it can
    // be type-cast to clerk.APIErrorResponse.
    if apiErr, ok := err.(*clerk.APIErrorResponse); ok {
      apiErr.TraceID
      apiErr.Error()
      apiErr.Response.RawJSON
    }
    // handle the error
    panic(err)
  }

  // Update the organization
  org, err = organization.Update(ctx, org.ID, &organization.UpdateParams{
      Slug: clerk.String("clerk"),
  })
  if err != nil {
    // handle the error
    panic(err)
  }

  // List organization memberships
  listParams := organizationmembership.ListParams{}
  listParams.Limit = clerk.Int64(10)
  memberships, err := organizationmembership.List(ctx, params)
  if err != nil {
    // handle the error
    panic(err)
  }
  if memberships.TotalCount < 0 {
      return
  }
  membership := memberships[0]

  // Get a user
  usr, err := user.Get(ctx, membership.UserID)
  if err != nil {
    // handle the error
    panic(err)
  }
}
```

---
title: Use Clerk with Astro and React
description: Learn how to user Clerk inside an Astro app with React
---

Astro provides an [integration](https://docs.astro.build/en/guides/integrations-guide/react/) that enables server-side rendering and client-side hydration for your React components. This guide demonstrates how to use Clerk with Astro and React.

If you have not set up your Astro application to work with Clerk, see the [quickstart guide](/docs/quickstarts/astro).

<Steps>
  ## Install `@astrojs/react`

  Add the [Astro React integration](https://docs.astro.build/en/guides/integrations-guide/react/) to your project:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npx astro add react
    ```

    ```bash {{ filename: 'terminal' }}
    yarn astro add react
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm astro add react
    ```

    ```bash {{ filename: 'terminal' }}
    bun astro add react
    ```
  </CodeBlockTabs>

  ## Update `astro.config.mjs`

  Add Clerk and React integrations to your Astro configuration:

  ```ts {{ filename: 'astro.config.mjs' }}
  import { defineConfig } from 'astro/config'
  import node from '@astrojs/node'
  import react from '@astrojs/react'
  import clerk from '@clerk/astro'

  export default defineConfig({
    integrations: [clerk(), react()],
    output: 'server',
    adapter: node({ mode: 'standalone' }),
  })
  ```

  ## Use Clerk components

  You can use the [prebuilt components](/docs/components/overview) in your Astro pages or regular React components.

  ### Astro pages

  The following example demonstrates how to use Clerk components in Astro pages.

  ```astro {{ filename: 'src/layouts/SiteLayout.astro' }}
  ---
  import { SignedIn, SignedOut, UserButton, SignInButton } from '@clerk/astro/react'
  ---

  <html lang="en">
    <head>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
      <meta name="generator" content={Astro.generator} />
    </head>
    <body>
      <header>
        <nav>
          <SignedOut client:load>
            <SignInButton client:load mode="modal" />
          </SignedOut>
          <SignedIn client:load>
            <UserButton client:load />
          </SignedIn>
        </nav>
      </header>
      <article>
        <slot />
      </article>
    </body>
  </html>
  ```

  ### React components

  The following example demonstrates how to use Clerk components in React components.

  ```tsx {{ filename: 'src/components/Header.tsx' }}
  import { SignInButton, SignedIn, SignedOut, UserButton } from '@clerk/astro/react'

  export default function Header() {
    return (
      <>
        <p>My App</p>
        <SignedOut>
          <SignInButton />
        </SignedOut>
        <SignedIn>
          <UserButton />
        </SignedIn>
      </>
    )
  }
  ```

  ## Use stores in your React components

  Clerk Astro provides a set of useful [stores](/docs/references/astro/overview#client-side-helpers) that give you access to the [`Clerk`](/docs/references/javascript/clerk){{ target: '_blank' }} object, and helper methods for signing in and signing up.

  The following example demonstrates how to use a Clerk Astro store.

  ```tsx {{ filename: 'src/components/Header.tsx' }}
  import { $userStore } from '@clerk/astro/client'

  export default function Username() {
    const user = useSyncExternalStore($userStore.listen, $userStore.get, $userStore.get)
    return <>{user?.firstName}</>
  }
  ```
</Steps>

## Next steps

<Cards>
  - [Read user and session data](/docs/references/astro/read-session-data)
  - Learn how to use Clerk's hooks and helpers to access the active session and user data in your Astro application.

  ---

  - [Client-side helpers](/docs/references/astro/overview#client-side-helpers)
  - Learn more about Astro client-side helpers and how to use them.
</Cards>

---
title: Use Clerk with Next.js 12 and older
description: Learn how to use Clerk with older versions of Next.js.
---

Clerk's [prebuilt components](/docs/components/overview) are exported from the `@clerk/nextjs` package and leverage APIs from Next.js itself. These APIs often change between major Next.js releases. While Clerk tries to offer the highest compatibility for any supported Next.js version, for Next.js 12 and older, you need to modify your setup.

> [!WARNING]
> Clerk highly recommends updating your Next.js version as older versions won't receive any updates in the future. Read [their upgrade guides](https://nextjs.org/docs/pages/building-your-application/upgrading) to learn more.

<Steps>
  ## Install `@clerk/nextjs` v4

  Install `^4.0.0` of `@clerk/nextjs`. Newer major versions of `@clerk/nextjs` only support Next.js 13+.

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/nextjs@^4.0.0
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/nextjs@^4.0.0
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/nextjs@^4.0.0
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @clerk/nextjs@^4.0.0
    ```
  </CodeBlockTabs>

  ## Change your `next.config.js`

  As mentioned previously, the `@clerk/nextjs` components contain code for multiple Next.js versions, but depending on your version, only certain components will be used. Update your `next.config.js` to instruct webpack to ignore modules on code paths that won't be used.

  ```js {{ filename: 'next.config.js', mark: [1, [5, 12]] }}
  const webpack = require('webpack')

  /** @type {import('next').NextConfig} */
  const nextConfig = {
    webpack(config) {
      config.plugins.push(
        new webpack.IgnorePlugin({
          resourceRegExp: /^next\/(navigation|headers|compat\/router)$/,
        }),
      )
      return config
    },
  }

  module.exports = nextConfig
  ```
</Steps>

---
title: Use image optimization to improve app performance
description: Learn how to use image optimization when fetching user images from Clerk.
---

When displaying your users' profile images, you should use query parameters to specify a maximum size and minimum quality. Doing so can allow you to improve your app's overall page load times by reducing the file sizes of the images you're fetching.

## Add query parameters to `imageUrl`

Some types in Clerk's JavaScript SDK, such as [`User`](/docs/references/javascript/user), [`PublicUserData`](/docs/references/javascript/types/public-user-data#properties), and [`Organization`](/docs/references/javascript/organization#properties), have an `imageUrl`. The URL returned from this property can be scaled down with the following image optimization options:

- `"width"`: Sets the minimum width of the image in pixels.
- `"height"`: Sets the minimum height of the image in pixels.
- `"fit"`: Describes how the image should fit its container. It can take the following values:
  - `"scale-down"`: The image will scale down to fit the sizes specified in `"width"` and `"height"` if it's bigger, but will not scale up if it's smaller.
  - `"crop"`: The image will scale down and be cropped to fit within the area specified in `"width"` and `"height"`.
- `"quality"`: Specifies the image quality for JPEG, WebP, PNG, and AVIF files. Accepts values from `1` to `100`. Defaults to `85`.

## Example

The following example demonstrates how you can get the `imageUrl` from the currently active user in a session, and display their profile picture using Clerk's image optimization options:

<CodeBlockTabs options={["Next.js", "React"]}>
  ```tsx {{ filename: 'app/image-optimization/page.tsx' }}
  import { currentUser } from '@clerk/nextjs/server'

  export default async function ImageOptimization() {
    const user = await currentUser()
    if (!user) return <p>No Image URL found</p>

    const { imageUrl } = user
    const params = new URLSearchParams()

    params.set('height', '200')
    params.set('width', '200')
    params.set('quality', '100')
    params.set('fit', 'crop')

    const imageSrc = `${imageUrl}?${params.toString()}`

    return (
      <div>
        <h1>Image source:</h1>
        <p>{imageSrc}</p>
        <h2>Image:</h2>
        <img src={imageSrc} alt="User image" />
      </div>
    )
  }
  ```

  ```tsx {{ filename: 'components/image-optimization.tsx' }}
  import { useClerk } from '@clerk/clerk-react'
  import React from 'react'

  export default function ImageOptimization() {
    const clerk = useClerk()
    const { user } = clerk
    if (!user) return <p>No Image URL found</p>

    const { imageUrl } = user
    const params = new URLSearchParams()

    params.set('height', '200')
    params.set('width', '200')
    params.set('quality', '100')
    params.set('fit', 'crop')

    const imageSrc = `${imageUrl}?${params.toString()}`

    return (
      <div>
        <h1>Image source:</h1>
        <p>{imageSrc}</p>
        <h2>Image:</h2>
        <img src={imageSrc} alt="User image" />
      </div>
    )
  }
  ```
</CodeBlockTabs>

---
title: Use organization slugs in URLs
description: Learn how to use organization slugs in your application URLs to manage and switch between active Clerk organizations.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Next.js + Clerk app",
      link: "/docs/quickstarts/nextjs",
      icon: "nextjs",
    },
    {
      title: "Enable organizations for your instance",
      link: "/docs/organizations/overview",
      icon: "globe",
    }
  ]}
  exampleRepo={[
    {
      title: "Demo app",
      link: "https://github.com/clerk/orgs/tree/main/examples/sync-org-with-url"
    }
  ]}
/>

Organization slugs are human-readable URL identifiers that help users reference which organization they're working in. A common pattern for organization-scoped areas in an application is to include the organization slug in the URL path.

For example, a B2B application named "Petstore" has two customer organizations: **Acmecorp** and **Widgetco**. Each organization uses its name as a slug in the URL:

- **Acmecorp**: `https://petstore.example.com/orgs/`**`acmecorp`**`/dashboard`
- **Widgetco**: `https://petstore.example.com/orgs/`**`widgetco`**`/dashboard`

Alternatively, [organization IDs](/docs/references/javascript/organization#properties) can be used to identify organizations in URLs:

- **Acmecorp**: `https://petstore.example.com/orgs/`**`org_1a2b3c4d5e6f7g8e`**`/dashboard`
- **Widgetco**: `https://petstore.example.com/orgs/`**`org_1a2b3c4d5e6f7g8f`**`/dashboard`

### When to use organization slugs

This feature is intended for apps that **require** organization slugs in URLs. **Adding slugs to URLs isn't recommended unless necessary.**

Use organization slugs if:

- Users frequently share links for public-facing content (e.g., documentation, marketing materials, and third-party blogs)
- Users regularly switch between multiple organizations
- Organization-specific URLs provide meaningful context

**Don't** use organization slugs if:

- Most users belong to only one organization
- You want to keep URLs simple and consistent
- You're primarily using the Clerk session for organization context

This guide shows you how to add organization slugs to your app's URLs, configure Clerk components to handle slug-based navigation, and access organization data based on the URL slug at runtime.

<Steps>
  ## Configure your app's URL structure

  Your application URLs should be structured to indicate which sections of your app are scoped to organizations versus [personal accounts](/docs/organizations/organization-workspaces).

  The following example uses the following URL structure:

  - `/orgs/` indicates the **active organization**, followed by the **organization slug**
  - `/me/` indicates the **active personal account**

  | URL | What should be active? | What should be displayed? |
  | - | - | - |
  | `/orgs/acmecorp` | Organization Acmecorp | Acmecorp's home page |
  | `/orgs/acmecorp/settings` | Organization Acmecorp | Acmecorp's settings page |
  | `/me` | Personal account | Personal home page |
  | `/me/settings` | Personal account | Personal settings page |

  ## Configure `<OrganizationSwitcher />` and `<OrganizationList />`

  The [`<OrganizationSwitcher />`](/docs/components/organization/organization-switcher) and [`<OrganizationList />`](/docs/components/organization/organization-list) components provide a robust set of options to manage organization slugs and IDs in your application's URLs.

  Set the following properties to configure the components to handle slug-based navigation:

  - Set `hideSlug` to `false` to allow users to customize the organization's URL slug when creating an organization.
  - Set `hidePersonal` to `false` to allow users to select their personal account.
  - Set `afterCreateOrganizationUrl` to `/orgs/:slug` to navigate the user to the organization's slug after creating an organization.
  - Set `afterSelectOrganizationUrl` to `/orgs/:slug` to navigate the user to the organization's slug after selecting it.
  - Set `afterSelectPersonalUrl` to `/me` to navigate the user to their personal account after selecting it.

  For example, if the organization has the slug `acmecorp`:

  - When a user creates or selects that organization using either component, they'll be redirected to `/orgs/acmecorp`.
  - When a user selects their personal account using either component, they'll be redirected to `/me`.

  <Tabs items={["<OrganizationSwitcher />", "<OrganizationList />"]}>
    <Tab>
      ```tsx {{ filename: 'components/Header.tsx', mark: [[6, 10]] }}
      import { OrganizationSwitcher } from '@clerk/nextjs'

      export default function Header() {
        return (
          <OrganizationSwitcher
            hideSlug={false} // Allow users to customize the org's URL slug
            hidePersonal={false} // Allow users to select their personal account
            afterCreateOrganizationUrl="/orgs/:slug" // Navigate to the org's slug after creating an org
            afterSelectOrganizationUrl="/orgs/:slug" // Navigate to the org's slug after selecting  it
            afterSelectPersonalUrl="/me" // Navigate to the personal account after selecting it
          />
        )
      }
      ```
    </Tab>

    <Tab>
      ```tsx {{ filename: 'app/organization-list/[[...organization-list]]/page.tsx', mark: [[6, 10]] }}
      import { OrganizationList } from '@clerk/nextjs'

      export default function OrganizationListPage() {
        return (
          <OrganizationList
            hideSlug={false} // Allow users to customize the org's URL slug
            hidePersonal={false} // Allow users to select their personal account
            afterCreateOrganizationUrl="/orgs/:slug" // Navigate to the org's slug after creating an org
            afterSelectOrganizationUrl="/orgs/:slug" // Navigate to the org's slug after selecting it
            afterSelectPersonalUrl="/me" // Navigate to the personal account after selecting it
          />
        )
      }
      ```
    </Tab>
  </Tabs>

  ## Configure `clerkMiddleware()` to set the active organization

  > [!TIP]
  > If your app doesn't use `clerkMiddleware()`, or you prefer to manually set the active organization, use the [`setActive()`](/docs/references/javascript/clerk) method to control the active organization on the client-side. See [this guide](/docs/organizations/force-organizations#set-an-active-organization-based-on-the-url) to learn how to manually activate a specific organization based on the URL.

  With [`clerkMiddleware()`](/docs/references/nextjs/clerk-middleware), you can use the [`organizationSyncOptions`](/docs/references/nextjs/clerk-middleware#organization-sync-options) property to declare URL patterns that determine whether a specific organization or user's personal account should be activated.

  If the middleware detects one of these patterns in the URL and finds that a different organization is active in the session, it'll attempt to set the specified organization as the active one.

  In the following example, two `organizationPatterns` are defined: one for the root (e.g., `/orgs/acmecorp`) and one as the wildcard matcher `(.*)` to match `/orgs/acmecorp/any/other/resource`. This configuration ensures that the path `/orgs/:slug` with any optional trailing path segments will set the organization indicated by the slug as the active one.

  The same pattern is used with `personalAccountPatterns` to match the user's personal account.

  > [!WARNING]
  > If no organization with the specified slug exists, or if the user isn't a member of the organization, then `clerkMiddleware()` **won't** modify the active organization. Instead, it will leave the previously active organization unchanged on the Clerk session.

  ```tsx {{ filename: 'middleware.ts', mark: [[7, 18]] }}
  import { clerkMiddleware } from '@clerk/nextjs/server'

  export default clerkMiddleware(
    (auth, req) => {
      // Add your middleware checks
    },
    {
      organizationSyncOptions: {
        organizationPatterns: [
          '/orgs/:slug', // Match the org slug
          '/orgs/:slug/(.*)', // Wildcard match for optional trailing path segments
        ],
        personalAccountPatterns: [
          '/me', // Match the personal account
          '/me/(.*)', // Wildcard match for optional trailing path segments
        ],
      },
    },
  )

  export const config = {
    matcher: [
      // Skip Next.js internals and all static files, unless found in search params
      '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
      // Always run for API routes
      '/(api|trpc)(.*)',
    ],
  }
  ```

  ### Handle failed activation

  Now that `clerkMiddleware()` is configured to activate organizations, you can build an organization-specific page while handling cases where the organization  can't be activated.

  Failed activation occurs if no organization with the specified slug exists, or if the given user isn't a member of the organization. When this happens, the middleware won't change the active organization, leaving the previously active one unchanged.

  For troubleshooting, a message will also be logged on the server:

  > Clerk: Organization activation handshake loop detected. This is likely due to an invalid organization ID or slug. Skipping organization activation.

  It's ultimately the responsibility of the page to ensure that it renders the appropriate content for a given URL, and to handle the case where the expected organization **isn't** active.

  In the following example, the organization slug is detected as a Next.js [Dynamic Route](https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes) param and passed as a parameter to the page. If the slug doesn't match the active organization slug, an error message is rendered and the [`<OrganizationList />`](/docs/components/organization/organization-list) component allows the user to select a valid organization.

  ```tsx {{ filename: 'app/orgs/[slug]/page.tsx' }}
  import { auth } from '@clerk/nextjs/server'
  import { OrganizationList } from '@clerk/nextjs'

  export default async function Home({ params }: { params: { slug: string } }) {
    const { orgSlug } = await auth()

    // Check if the organization slug from the URL params doesn't match
    // the active organization slug from the user's session.
    // If they don't match, show an error message and the list of valid organizations.
    if (params.slug != orgSlug) {
      return (
        <>
          <p>Sorry, organization {params.slug} is not valid.</p>
          <OrganizationList
            hideSlug={false}
            hidePersonal={false}
            afterCreateOrganizationUrl="/orgs/:slug"
            afterSelectOrganizationUrl="/orgs/:slug"
            afterSelectPersonalUrl="/me"
          />
        </>
      )
    }

    return <div>Welcome to organization {orgSlug}</div>
  }
  ```

  ## Render organization-specific content

  Use the following tabs to learn how to access organization information on the server-side and client-side.

  <Tabs items={["Server-side","Client-side"]}>
    <Tab>
      To get organization information on the server-side, access the [`Auth`](/docs/references/backend/types/auth-object) object. In Next.js apps, this object is returned by [`auth()`](/docs/references/nextjs/auth). In other frameworks, use the [`getAuth()`](/docs/references/nextjs/get-auth) helper to get the `Auth` object.

      To access additional organization information like the organization name, you'll need to [customize the Clerk session token](/docs/backend-requests/custom-session-token) to include these details:

      1. In the Clerk Dashboard, navigate to the [**Sessions**](https://dashboard.clerk.com/last-active?path=sessions) page.
      1. In the **Customize session token** section, select **Edit**.
      1. In the modal that opens, add any claim you need to your session token. For this guide, add the following:
         ```json
         {
           "org_name": "{{org.name}}"
         }
         ```
      1. Select **Save**.

      Then, access the [`sessionClaims`](/docs/references/backend/types/auth-object)
      on the `Auth` object.

      ```tsx {{ filename: 'app/orgs/[slug]/page.tsx', mark: [[23, 24]] }}
      import { auth } from '@clerk/nextjs/server'
      import { OrganizationList } from '@clerk/nextjs'

      export default async function Home({ params }: { params: { slug: string } }) {
        const { orgSlug, sessionClaims } = await auth()
        const { slug } = await params

        if (slug != orgSlug) {
          return (
            <>
              <p>Sorry, organization {slug} is not valid.</p>
              <OrganizationList
                hideSlug={false}
                hidePersonal={false}
                afterCreateOrganizationUrl="/orgs/:slug"
                afterSelectOrganizationUrl="/orgs/:slug"
                afterSelectPersonalUrl="/me"
              />
            </>
          )
        }

        // Access the organization name from the session claims
        let orgId = sessionClaims['org_id'] as string

        return <div>{orgId && `Welcome to organization ${orgId}`}</div>
      }
      ```
    </Tab>

    <Tab>
      To get organization information on the client-side, use the [`useOrganization()`](/docs/hooks/use-organization) hook to access the [`organization`](/docs/references/javascript/organization) object.

      ```tsx {{ filename: 'app/orgs/[slug]/page.tsx', mark: [24] }}
      'use client'

      import { OrganizationList, useOrganization } from '@clerk/nextjs'

      export default function Home({ params }: { params: { slug: string } }) {
        const { organization } = useOrganization()

        if (!organization || organization.slug != params.slug) {
          return (
            <>
              <p>Sorry, organization {params.slug} is not valid.</p>
              <OrganizationList
                hidePersonal={false}
                hideSlug={false}
                afterCreateOrganizationUrl="/orgs/:slug"
                afterSelectOrganizationUrl="/orgs/:slug"
                afterSelectPersonalUrl="/me"
              />
            </>
          )
        }

        // Access the organization name from the organization object
        return <div>{organization && `Welcome to organization ${organization.name}`}</div>
      }
      ```
    </Tab>
  </Tabs>
</Steps>

---
title: useAuth()
description: Access and manage authentication state in your application with Clerk's useAuth() hook.
---

The `useAuth()` hook provides access to the current user's authentication state and methods to manage the active session.

> [!NOTE]
> To access auth data server-side, see the [`Auth` object reference doc](/docs/references/backend/types/auth-object).

## Returns

<Properties>
  - `isLoaded`
  - `boolean`

  A boolean that indicates whether Clerk has completed initialization. Initially `false`, becomes `true` once Clerk loads.

  ---

  - `isSignedIn`
  - `boolean`

  A boolean that indicates whether a user is currently signed in.

  ---

  - `userId`
  - `string`

  The ID of the current user.

  ---

  - `sessionId`
  - `string`

  The ID for the current session.

  ---

  - `orgId`
  - `string`

  The ID of the user's active organization.

  ---

  - `orgRole`
  - `string`

  The current user's role in their active organization.

  ---

  - `orgSlug`
  - `string`

  The URL-friendly identifier of the user's active organization.

  ---

  - `signOut()`
  - `(options?: SignOutOptions) => Promise<void>`

  A function that signs out the current user. Returns a promise that resolves when complete. See the [reference doc](/docs/references/javascript/clerk#sign-out).

  ---

  - `sessionClaims`
  - `JwtPayload`

  The current user's [session claims](/docs/backend-requests/resources/session-tokens).

  ---

  - `getToken()`
  - `(options?: GetTokenOptions) => Promise<string | null>`

  A function that retrieves the current user's session token or a custom JWT template. Returns a promise that resolves to the token. See the [reference doc](/docs/references/javascript/session#get-token).

  ---

  - `has()`
  - `(isAuthorizedParams: CheckAuthorizationParamsWithCustomPermissions) => boolean`

  A function that checks if the user has specific permissions or roles. See the [reference doc](/docs/references/backend/types/auth-object#has).
</Properties>

## How to use the `useAuth()` hook

> [!NOTE]
> For Next.js applications, it's recommended to use the [`auth()`](/docs/references/nextjs/auth) helper instead of `useAuth()`. Since `auth()` must be used in Server Components, you'll need to pass auth data to Client Components as needed. If you prefer `useAuth()`, you must pass the `dynamic` prop to `<ClerkProvider>`, but be aware this switches the app to dynamic rendering. Learn more [here](/docs/references/nextjs/rendering-modes).

The following example demonstrates how to use the `useAuth()` hook to access the current auth state, like whether the user is signed in or not. It also includes a basic example for using the `getToken()` method to retrieve a session token for fetching data from an external resource.

<Tabs items={['React', 'Next.js']}>
  <Tab>
    ```tsx {{ filename: 'src/pages/ExternalDataPage.tsx' }}
    import { useAuth } from '@clerk/clerk-react'

    export default function ExternalDataPage() {
      const { userId, sessionId, getToken, isLoaded, isSignedIn } = useAuth()

      const fetchExternalData = async () => {
        const token = await getToken()

        // Fetch data from an external API
        const response = await fetch('https://api.example.com/data', {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        })

        return response.json()
      }

      if (!isLoaded) {
        return <div>Loading...</div>
      }

      if (!isSignedIn) {
        return <div>Sign in to view this page</div>
      }

      return (
        <div>
          <p>
            Hello, {userId}! Your current active session is {sessionId}.
          </p>
          <button onClick={fetchExternalData}>Fetch Data</button>
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/external-data/page.tsx' }}
    'use client'

    import { useAuth } from '@clerk/nextjs'

    export default function ExternalDataPage() {
      const { userId, sessionId, getToken, isLoaded, isSignedIn } = useAuth()

      const fetchExternalData = async () => {
        const token = await getToken()

        // Fetch data from an external API
        const response = await fetch('https://api.example.com/data', {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        })

        return response.json()
      }

      if (!isLoaded) {
        return <div>Loading...</div>
      }

      if (!isSignedIn) {
        return <div>Sign in to view this page</div>
      }

      return (
        <div>
          <p>
            Hello, {userId}! Your current active session is {sessionId}.
          </p>
          <button onClick={fetchExternalData}>Fetch Data</button>
        </div>
      )
    }
    ```
  </Tab>
</Tabs>

---
title: useAuth() | Vue
description: Access and manage authentication state in your Vue application with Clerk's useAuth() composable.
---

The `useAuth()` composable provides access to the current user's authentication state and methods to manage the active session in your Vue application.

## Returns

<Properties>
  - `isLoaded`
  - `Ref<boolean>`

  A boolean that indicates whether Clerk has completed initialization. Initially `false`, becomes `true` once Clerk loads.

  ---

  - `isSignedIn`
  - `Ref<boolean>`

  A boolean that indicates whether a user is currently signed in.

  ---

  - `userId`
  - `Ref<string>`

  The ID of the current user.

  ---

  - `sessionId`
  - `Ref<string>`

  The ID of the current session.

  ---

  - `orgId`
  - `Ref<string>`

  The ID of the user's active organization.

  ---

  - `orgRole`
  - `Ref<string>`

  The current user's role in their active organization.

  ---

  - `orgSlug`
  - `Ref<string>`

  The URL-friendly identifier of the user's active organization.

  ---

  - `signOut()`
  - `Ref<(options?: SignOutOptions) => Promise<void>>`

  A function that signs out the current user. Returns a promise that resolves when complete. See the [reference doc](/docs/references/javascript/clerk#sign-out).

  ---

  - `getToken()`
  - `Ref<(options?: GetTokenOptions) => Promise<string | null>>`

  A function that retrieves the current user's session token or a custom JWT template. Returns a promise that resolves to the token. See the [reference doc](/docs/references/javascript/session#get-token).

  ---

  - `has()`
  - `Ref<(isAuthorizedParams: CheckAuthorizationParamsWithCustomPermissions) => boolean>`

  A function that checks if the user has specific permissions or roles. See the [reference doc](/docs/references/backend/types/auth-object#has).
</Properties>

## How to use the `useAuth()` composable

The following example demonstrates how to use the `useAuth()` composable to access the current auth state, like whether the user is signed in or not. It also includes a basic example for using the `getToken()` method to retrieve a session token for fetching data from an external resource.

```vue {{ filename: 'App.vue' }}
<script setup>
import { useAuth } from '@clerk/vue'

const { getToken, isLoaded, isSignedIn } = useAuth()

const fetchProtectedData = async () => {
  const token = await getToken.value()

  // Fetch data from an external API
  const response = await fetch('https://api.example.com/data', {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  })

  return response.json()
}
</script>

<template>
  <div v-if="!isLoaded">Loading...</div>
  <div v-else-if="!isSignedIn">Sign in to view this page</div>
  <div v-else>
    <!-- Your protected content here -->
  </div>
</template>
```

---
title: useClerk()
description: Access and manage the Clerk object in your React application with Clerk's useClerk() hook.
---

> [!WARNING]
> This hook should only be used for advanced use cases, such as building a completely custom OAuth flow or as an escape hatch to access to the `Clerk` object.

The `useClerk()` hook provides access to the [`Clerk`](/docs/references/javascript/clerk) object, allowing you to build alternatives to any Clerk Component.

## Returns

The `useClerk()` hook returns the `Clerk` object, which includes all the methods and properties listed in the [`Clerk` reference](/docs/references/javascript/clerk).

## How to use the `useClerk()` hook

The following example uses the `useClerk()` hook to access the `clerk` object. The `clerk` object is used to call the [`openSignIn()`](/docs/references/javascript/clerk#sign-in) method to open the sign-in modal.

<Tabs items={['React', 'Next.js']}>
  <Tab>
    ```tsx {{ filename: 'src/Home.tsx' }}
    import { useClerk } from '@clerk/clerk-react'

    export default function Home() {
      const clerk = useClerk()

      return <button onClick={() => clerk.openSignIn({})}>Sign in</button>
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/page.tsx' }}
    'use client'

    import { useClerk } from '@clerk/nextjs'

    export default function HomePage() {
      const clerk = useClerk()

      return <button onClick={() => clerk.openSignIn({})}>Sign in</button>
    }
    ```
  </Tab>
</Tabs>

---
title: useClerk() | Vue
description: Access and manage the Clerk instance in your Vue application with Clerk's useClerk() composable.
---

> [!WARNING]
> This composable should only be used for advanced use cases, such as building a completely custom OAuth flow or as an escape hatch to access to the `Clerk` object.

The `useClerk()` composable provides access to the [`Clerk`](/docs/references/javascript/clerk) object, giving you the ability to build alternatives to any [Clerk component](/docs/components/overview).

## Returns

The `useClerk()` composable returns the `Clerk` object, which includes all the methods and properties listed in the [`Clerk` reference](/docs/references/javascript/clerk).

## How to use the `useClerk()` composable

The following example uses the `useClerk()` composable to access the `clerk` object. The `clerk` object is used to call the [`openSignIn()`](/docs/references/javascript/clerk#sign-in) method to open the sign-in modal.

```vue
<script setup>
import { useClerk } from '@clerk/vue'

const clerk = useClerk()
</script>

<template>
  <button @click="clerk.openSignIn">Sign in</button>
</template>
```

---
title: useOAuth() (deprecated)
description: Clerk's useOAuth() hook is used to create a new OAuth flow.
---

> [!WARNING]
> This feature is deprecated. Use [`useSSO()`](/docs/references/expo/use-sso) instead.

The `useOAuth()` hook is used to create a new OAuth flow. It can be used in both web and native apps.

## Parameters

<Properties>
  - `strategy`
  - [`OAuthStrategy`](/docs/references/javascript/types/sso#o-auth-strategy)

  The strategy corresponding to the OAuth provider. For example: `oauth_facebook`, `oauth_github`, etc.

  ---

  - `redirectUrl?`
  - `string`

  The full URL or path to redirect to after the OAuth flow is complete.

  ---

  - `unsafeMetadata?`
  - [`SignUpUnsafeMetadata`](/docs/references/javascript/types/metadata#sign-up-unsafe-metadata)

  Unsafe metadata to be passed to the OAuth provider.
</Properties>

## Returns

The `useOAuth()` hook returns the `startOAuthFlow()` method, which you can use to initiate the OAuth flow.

The `startOAuthFlow()` method has the following signature:

```ts
const startOAuthFlow: (
  startOAuthFlowParams?: StartOAuthFlowParams,
) => Promise<StartOAuthFlowReturnType>
```

It accepts the following parameters (`StartOAuthFlowParams`):

<Properties>
  - `redirectUrl?`
  - `string`

  The URL or path to redirect to after the OAuth flow is complete.

  ---

  - `unsafeMetadata?`
  - [`SignUpUnsafeMetadata`](/docs/references/javascript/types/metadata#sign-up-unsafe-metadata)

  Unsafe metadata to be passed to the OAuth provider.
</Properties>

## How to use the `useOAuth()` hook

The following example demonstrates how to create a custom OAuth sign-in flow for [Google accounts](/docs/authentication/social-connections/google).

```tsx {{ filename: 'app/(auth)/sign-in.tsx', collapsible: true }}
import React from 'react'
import * as WebBrowser from 'expo-web-browser'
import { Text, View, Button } from 'react-native'
import { Link } from 'expo-router'
import { useOAuth } from '@clerk/clerk-expo'
import * as Linking from 'expo-linking'

export const useWarmUpBrowser = () => {
  React.useEffect(() => {
    // Warm up the android browser to improve UX
    // https://docs.expo.dev/guides/authentication/#improving-user-experience
    void WebBrowser.warmUpAsync()
    return () => {
      void WebBrowser.coolDownAsync()
    }
  }, [])
}

WebBrowser.maybeCompleteAuthSession()

export default function Page() {
  useWarmUpBrowser()

  const { startOAuthFlow } = useOAuth({ strategy: 'oauth_google' })

  const onPress = React.useCallback(async () => {
    try {
      const { createdSessionId, signIn, signUp, setActive } = await startOAuthFlow({
        redirectUrl: Linking.createURL('/dashboard', { scheme: 'myapp' }),
      })

      // If sign in was successful, set the active session
      if (createdSessionId) {
        setActive!({ session: createdSessionId })
      } else {
        // Use signIn or signUp returned from startOAuthFlow
        // for next steps, such as MFA
      }
    } catch (err) {
      // See https://clerk.com/docs/custom-flows/error-handling
      // for more info on error handling
      console.error(JSON.stringify(err, null, 2))
    }
  }, [])

  return (
    <View>
      <Link href="/">
        <Text>Home</Text>
      </Link>
      <Button title="Sign in with Google" onPress={onPress} />
    </View>
  )
}
```

---
title: useOrganization()
description: Access and manage the currently active organization in your React application with Clerk's useOrganization() hook.
search:
  rank: 1
---

The `useOrganization()` hook retrieves attributes of the currently active organization.

## Parameters

`useOrganization()` accepts a single object with the following optional properties:

<Properties>
  - `invitations`
  - `true | { status?: 'pending' | 'accepted' | 'revoked' } & { SharedProperties }`

  If set to `true`, all default properties will be used.

  Otherwise, accepts an object with the following optional properties:

  - `status`: A string that filters the invitations by the provided status.
  - Any of the properties described in [Shared properties](#shared-properties).

  ---

  - `membershipRequests`
  - `true | { status?: 'pending' | 'accepted' | 'revoked' } & { SharedProperties }`

  If set to `true`, all default properties will be used. Otherwise, accepts an object with the following optional properties:

  - `status`: A string that filters the membership requests by the provided status.
  - Any of the properties described in [Shared properties](#shared-properties).

  ---

  - `memberships`
  - `true | { role?: OrganizationCustomRoleKey[]; query?: string } & { SharedProperties }`

  If set to `true`, all default properties will be used.

  Otherwise, accepts an object with the following optional properties:

  - `role`: An array of [`OrganizationCustomRoleKey`](/docs/references/javascript/types/organization-custom-role-key).
  - `query`: A string that filters the memberships by the provided string.
  - Any of the properties described in [Shared properties](#shared-properties).

  ---

  - `domains`
  - `true | { enrollmentMode?: 'manual_invitation' | 'automatic_invitation' | 'automatic_suggestion' } & { SharedProperties }`

  If set to `true`, all default properties will be used.

  Otherwise, accepts an object with the following optional properties:

  - `enrollmentMode`: A string that filters the domains by the provided enrollment mode.
  - Any of the properties described in [Shared properties](#shared-properties).
</Properties>

> [!WARNING]
> By default, the `memberships`, `invitations`, `membershipRequests`, and `domains` attributes aren't populated. To fetch and paginate the data, you must pass `true` or an object with the desired properties.

### Shared properties

Optional properties that are shared across the `invitations`, `membershipRequests`, `memberships`, and `domains` properties.

<Include src="_partials/hooks/shared-properties" />

> [!NOTE]
> These attributes are updating automatically and will re-render their respective components whenever you set a different organization using the [`setActive({ organization })`](/docs/references/javascript/clerk#set-active) method or update any of the memberships or invitations. No need for you to manage updating anything manually.

## Returns

<Properties>
  - `isLoaded`
  - `boolean`

  A boolean that indicates whether Clerk has completed initialization. Initially `false`, becomes `true` once Clerk loads.

  ---

  - `organization`
  - [`Organization`](/docs/references/javascript/organization)

  The currently active organization.

  ---

  - `membership`
  - [`OrganizationMembership`](/docs/references/javascript/types/organization-membership)

  The current organization membership.

  ---

  - `memberships`
  - <code>[PaginatedResources](#paginated-resources)[\<OrganizationMembership>](/docs/references/javascript/types/organization-membership)</code>

  Includes a paginated list of the organization's memberships.

  ---

  - `invitations`
  - <code>[PaginatedResources](#paginated-resources)[\<OrganizationInvitation>](/docs/references/javascript/types/organization-invitation)</code>

  Includes a paginated list of the organization's invitations.

  ---

  - `membershipRequests`
  - <code>[PaginatedResources](#paginated-resources)[\<OrganizationMembershipRequest>](/docs/references/javascript/types/organization-membership-request)</code>

  Includes a paginated list of the organization's membership requests.

  ---

  - `domains`
  - <code>[PaginatedResources](#paginated-resources)[\<OrganizationDomain>](/docs/references/javascript/types/organization-domain)</code>

  Includes a paginated list of the organization's domains.
</Properties>

### `PaginatedResources`

<Include src="_partials/hooks/paginated-resources" />

## How to use the `useOrganization()` hook

### Expand and paginate attributes

To keep network usage to a minimum, developers are required to opt-in by specifying which resource they need to fetch and paginate through. By default, the `memberships`, `invitations`, `membershipRequests`, and `domains` attributes are not populated. You must pass `true` or an object with the desired [properties](#shared-properties) to fetch and paginate the data.

```jsx
// invitations.data will never be populated.
const { invitations } = useOrganization()

// Use default values to fetch invitations, such as initialPage = 1 and pageSize = 10
const { invitations } = useOrganization({
  invitations: true,
})

// Pass your own values to fetch invitations
const { invitations } = useOrganization({
  invitations: {
    pageSize: 20,
    initialPage: 2, // skips the first page
  },
})

// Aggregate pages in order to render an infinite list
const { invitations } = useOrganization({
  invitations: {
    infinite: true,
  },
})
```

### Infinite pagination

The following example demonstrates how to use the `infinite` property to fetch and append new data to the existing list. The `memberships` attribute will be populated with the first page of the organization's memberships. When the "Load more" button is clicked, the `fetchNext` helper function will be called to append the next page of memberships to the list.

<Tabs items={['React', 'Next.js']}>
  <Tab>
    ```jsx
    import { useOrganization } from '@clerk/clerk-react'

    export default function MemberList() {
      const { memberships } = useOrganization({
        memberships: {
          infinite: true, // Append new data to the existing list
          keepPreviousData: true, // Persist the cached data until the new data has been fetched
        },
      })

      if (!memberships) {
        // Handle loading state
        return null
      }

      return (
        <div>
          <h2>Organization members</h2>
          <ul>
            {memberships.data?.map((membership) => (
              <li key={membership.id}>
                {membership.publicUserData.firstName} {membership.publicUserData.lastName} &lt;
                {membership.publicUserData.identifier}&gt; :: {membership.role}
              </li>
            ))}
          </ul>

          <button
            disabled={!memberships.hasNextPage} // Disable the button if there are no more available pages to be fetched
            onClick={memberships.fetchNext}
          >
            Load more
          </button>
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/users/page.tsx' }}
    'use client'

    import { useOrganization } from '@clerk/nextjs'

    export default function MemberListPage() {
      const { memberships } = useOrganization({
        memberships: {
          infinite: true, // Append new data to the existing list
          keepPreviousData: true, // Persist the cached data until the new data has been fetched
        },
      })

      if (!memberships) {
        // Handle loading state
        return null
      }

      return (
        <div>
          <h2>Organization members</h2>
          <ul>
            {memberships.data?.map((membership) => (
              <li key={membership.id}>
                {membership.publicUserData.firstName} {membership.publicUserData.lastName} &lt;
                {membership.publicUserData.identifier}&gt; :: {membership.role}
              </li>
            ))}
          </ul>

          <button
            disabled={!memberships.hasNextPage} // Disable the button if there are no more available pages to be fetched
            onClick={memberships.fetchNext}
          >
            Load more
          </button>
        </div>
      )
    }
    ```
  </Tab>
</Tabs>

### Simple pagination

The following example demonstrates how to use the `fetchPrevious` and `fetchNext` helper functions to paginate through the data. The `memberships` attribute will be populated with the first page of the organization's memberships. When the "Previous page" or "Next page" button is clicked, the `fetchPrevious` or `fetchNext` helper function will be called to fetch the previous or next page of memberships.

Notice the difference between this example's pagination and the infinite pagination example above.

<Tabs items={['React', 'Next.js']}>
  <Tab>
    ```jsx
    import { useOrganization } from '@clerk/clerk-react'

    export default function MemberList() {
      const { memberships } = useOrganization({
        memberships: {
          keepPreviousData: true, // Persist the cached data until the new data has been fetched
        },
      })

      if (!memberships) {
        // Handle loading state
        return null
      }

      return (
        <div>
          <h2>Organization members</h2>
          <ul>
            {memberships.data?.map((membership) => (
              <li key={membership.id}>
                {membership.publicUserData.firstName} {membership.publicUserData.lastName} &lt;
                {membership.publicUserData.identifier}&gt; :: {membership.role}
              </li>
            ))}
          </ul>

          <button disabled={!memberships.hasPreviousPage} onClick={memberships.fetchPrevious}>
            Previous page
          </button>

          <button disabled={!memberships.hasNextPage} onClick={memberships.fetchNext}>
            Next page
          </button>
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/users/page.tsx' }}
    'use client'

    import { useOrganization } from '@clerk/nextjs'

    export default function MemberListPage() {
      const { memberships } = useOrganization({
        memberships: {
          keepPreviousData: true, // Persist the cached data until the new data has been fetched
        },
      })

      if (!memberships) {
        // Handle loading state
        return null
      }

      return (
        <div>
          <h2>Organization members</h2>
          <ul>
            {memberships.data?.map((membership) => (
              <li key={membership.id}>
                {membership.publicUserData.firstName} {membership.publicUserData.lastName} &lt;
                {membership.publicUserData.identifier}&gt; :: {membership.role}
              </li>
            ))}
          </ul>

          <button disabled={!memberships.hasPreviousPage} onClick={memberships.fetchPrevious}>
            Previous page
          </button>

          <button disabled={!memberships.hasNextPage} onClick={memberships.fetchNext}>
            Next page
          </button>
        </div>
      )
    }
    ```
  </Tab>
</Tabs>

To see the different organization features integrated into one application, take a look at our [organizations demo repository](https://github.com/clerk/organizations-demo).

---
title: useOrganization() | Vue
description: Access and manage the currently active organization in your Vue application with Clerk's useOrganization() composable.
---

The `useOrganization()` composable retrieves attributes of the currently active organization.

## Returns

<Properties>
  - `isLoaded`
  - `Ref<boolean>`

  A boolean that indicates whether Clerk has completed initialization. Initially `false`, becomes `true` once Clerk loads.

  ---

  - `organization`
  - <code>Ref\<[Organization](/docs/references/javascript/organization)></code>

  The currently active organization.

  ---

  - `membership`
  - <code>Ref\<[OrganizationMembership](/docs/references/javascript/types/organization-membership)></code>

  The current organization membership.
</Properties>

## How to use the `useOrganization()` composable

### Retrieve the current active organization

Use `useOrganization()` to access the current active [`Organization`](/docs/references/javascript/organization) object.

```vue {{ filename: 'OrganizationStatus.vue' }}
<script setup>
import { OrganizationSwitcher, useOrganization } from '@clerk/vue'

const { organization, isLoaded } = useOrganization()
</script>

<template>
  <div v-if="!organization">
    <OrganizationSwitcher />
  </div>
  <div v-if="isLoaded">
    <p>This current organization is {{ organization?.name }}</p>
  </div>

  <div v-else>
    <p>Loading...</p>
  </div>
</template>
```

### Paginate organization memberships

The following example demonstrates how to use `useOrganization()` to access the organization's memberships. Pagination is implemented by fetching pages of memberships when the "Previous page" or "Next page" buttons are clicked.

```vue {{ filename: 'MembershipList.vue', collapsible: true }}
<script setup>
import { ref, watchEffect } from 'vue'
import { OrganizationSwitcher, useOrganization } from '@clerk/vue'

const memberships = ref([])
const currentPage = ref(1)
const { organization, isLoaded } = useOrganization()

const pageSize = 5

async function fetchMemberships() {
  if (!organization.value) {
    return
  }

  // Use the `getMemberships()` method on the `organization` object to fetch the organization's memberships.
  const { data } = await organization.value.getMemberships({
    initialPage: currentPage.value,
    pageSize: pageSize,
  })
  memberships.value = data
}

watchEffect(() => {
  if (!organization.value) {
    return
  }

  fetchMemberships()
})

const fetchPrevious = () => currentPage.value--
const fetchNext = () => currentPage.value++
</script>

<template>
  <div v-if="!organization">
    <OrganizationSwitcher />
  </div>

  <div v-else-if="isLoaded">
    <h2>Organization members</h2>

    <ul>
      <li v-for="membership in memberships" :key="membership.id">
        {{ membership.publicUserData.firstName }} {{ membership.publicUserData.lastName }} &lt;{{
          membership.publicUserData.identifier
        }}&gt; :: {{ membership.role }}
      </li>
    </ul>

    <div>
      <button :disabled="currentPage === 1" @click="fetchPrevious">Previous</button>
      <button :disabled="memberships.length < pageSize" @click="fetchNext">Next</button>
    </div>
  </div>

  <div v-else>
    <p>Loading...</p>
  </div>
</template>
```

---
title: User impersonation
description: Clerk's user impersonation feature allows you to sign in as different users to offer customer support or debug issues.
---

Clerk's user impersonation feature allows you to sign in to your application as one of your users, enabling you to directly reproduce and remedy any issues they're experiencing. It's a helpful feature for customer support and debugging.

## Impersonate a user

The easiest way to impersonate a user is from the [**Users**](https://dashboard.clerk.com/last-active?path=users) page in the Clerk Dashboard.

To impersonate a user, on the right side of a user's row, select on the menu icon (three stacked dots). A dropdown menu will appear. When you select the **Impersonate user** option, your application instance should open in a new tab with the impersonated user signed in.

To add user impersonation functionality to your application, see the [custom flow for user impersonation](/docs/custom-flows/user-impersonation).

## How user impersonation works

Clerk allows developers or admins of an application to sign in as different users. The feature involves two parts:

1. Get an actor token that can be used to sign in as a different user.
1. Detect an impersonated session as soon as you're signed in.

## Actor tokens

Actor tokens are similar to [sign-in tokens](/docs/reference/backend-api/tag/Sign-in-Tokens#operation/CreateSignInToken){{ target: '_blank' }}. They can be used for one-time sign-ins, but they result in impersonated sessions.

### Create an actor token

To create an actor token, you can use the [Backend API](/docs/reference/backend-api/tag/Actor-Tokens#operation/CreateActorToken){{ target: '_blank' }}.

The following example demonstrates how to create an actor token that is valid for 600 seconds (10 minutes). Using the generated token will result in user with ID `user_21Ufcy98STcA11s3QckIwtwHIES` (the actor/impersonator) signing in as user with ID `user_1o4qfak5AdI2qlXSXENGL05iei6` (the subject/impersonated).

```bash
curl -X POST https://api.clerk.com/v1/actor_tokens -d '{ \
  "user_id": "user_1o4qfak5AdI2qlXSXENGL05iei6", \
  "expires_in_seconds": 600 \
  "actor": { \
    "sub": "user_21Ufcy98STcA11s3QckIwtwHIES", \
  } \
}'
```

When creating actor tokens, the object that you pass as the `actor` parameter will end up in the authentication token's `act` claim. You can read more details in the [guide on session tokens](/docs/backend-requests/resources/session-tokens#default-claims).

### Revoke an actor token

To revoke an actor token, you can use the [Backend API](/docs/reference/backend-api/tag/Actor-Tokens#operation/RevokeActorToken){{ target: '_blank' }}.

Despite it's expiration date, you can revoke a token at any time. Revoked actor tokens can no longer be used for signing in.

The following example demonstrates how to revoke an actor token, even if it's not expired yet.

```bash
curl -X POST https://api.clerk.com/v1/actor_tokens/act_2EL6mQKzeUtoRwGuLZsznyfkIsH/revoke
```

### Sign in with an actor token

Actor tokens are consumed the same way as sign in tokens.

Once you've successfully created an actor token, you can use the `url` attribute of the response to consume the token and impersonate a user.

The `url` attribute is a Clerk Frontend API URL that will use the token to sign out existing users and prepare the [`SignIn`](/docs/references/javascript/sign-in) object for impersonation. You can directly visit the `url` provided in the response to consume the actor token.

The [Frontend API](/docs/reference/frontend-api/){{ target: '_blank' }} will redirect you to the `/sign-in` page of your application, where the flow will continue by consuming the `__clerk_ticket` parameter.

## How to detect impersonated sessions

Once a user is signed in as a different user, Clerk provides APIs and helper methods to distinguish an impersonated session from a regular session.

Clerk also adds an `act` claim on the [Clerk session token](/docs/backend-requests/resources/session-tokens), which contains information like the impersonated session ID and the actor/impersonator's user ID.

> [!NOTE]
> When using a custom JWT template, the `{{session.actor}}` will need to be added as a claim in order to expose it.

### Detect impersonated sessions in the frontend

To detect impersonated sessions in the frontend, the `actor` object contains the `sub` claim of the impersonator. You can use this information to detect impersonated sessions.

<Tabs items={["React-based SDKs", "JavaScript"]}>
  <Tab>
    You can use the [`useAuth()`](/docs/hooks/use-auth) hook to get access to the authentication context, which includes the `actor` object.

    ```jsx
    const { userId, actor } = useAuth()

    return (
      <div>
        Server-side info:
        <p>
          {actor && (
            <span>
              User {actor.sub} has signed in as user {userId}
            </span>
          )}
        </p>
      </div>
    )
    ```
  </Tab>

  <Tab>
    You can use the [`Clerk`](/docs/references/javascript/clerk) object to get access to the `session` object, which includes the `actor` object.

    ```js {{ filename: 'main.js' }}
    import { Clerk } from '@clerk/clerk-js'

    // Initialize Clerk with your Clerk Publishable Key
    const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

    const clerk = new Clerk(pubKey)
    await clerk.load()

    const { session } = clerk

    if (session.actor) {
      const { actor, user } = session

      console.log(`User ${actor.sub} is signed in as user ${user.id}.`)
    }
    ```
  </Tab>
</Tabs>

### Detect impersonated sessions in the backend

The [`Auth`](/docs/references/backend/types/auth-object) object is a server-side object that contains the `actor` object, as well as important information like the current user's session ID and user ID. Accessing the `Auth` object differs depending on the SDK you're using. Here are some examples:

<Tabs items={["Next.js", "Express"]}>
  <Tab>
    The Next.js SDK provides the [`auth()`](/docs/references/nextjs/auth) helper to App Router apps to access the `Auth` object.

    ```jsx
    import { auth } from '@clerk/nextjs/server'

    export default async function Page() {
      // Use Clerk's `auth()` helper to access the `Auth` object
      const { userId, actor } = await auth()

      return (
        <div>
          {actor && (
            <span>
              user {actor.sub} has signed in as user {userId}
            </span>
          )}
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    The Express SDK provides a [middleware](/docs/references/express/overview#clerk-middleware) that attaches the [`Auth`](/docs/references/backend/types/auth-object) object to the `request` object.

    ```js
    import express from 'express'
    import { clerkMiddleware } from '@clerk/express'

    const app = express()
    // Apply the Express SDK middleware
    app.use(clerkMiddleware())

    app.get('/protected-endpoint', (req, res) => {
      // Clerk's authentication context can be accessed from the request object
      const { userId, actor } = req.auth

      res.json({ userId, actor })
    })

    app.listen(3000, () => {
      console.log('Booted.')
    })
    ```
  </Tab>
</Tabs>

---
title: User metadata
description: Metadata allows for custom data to be saved on the User object.
---

Metadata allows for custom data to be saved on the [`User` object](/docs/users/overview). There are three types of metadata: "unsafe", "public", and "private".

| Metadata | Frontend API | Backend API |
| - | - | - |
| Private | No read or write access | Read & write access |
| Public | Read access | Read & write access |
| Unsafe | Read & write access | Read & write access |

> [!WARNING]
> Metadata is limited to **8kb** maximum.

## Private metadata

Private metadata is only accessible by the backend, which makes this useful for storing sensitive data that you don't want to expose to the frontend. For example, you could store a user's Stripe customer ID.

### Set private metadata

<Tabs items={["Fullstack SDKs", "Express", "Go", "Ruby", "cURL"]}>
  <Tab>
    ```ts {{ filename: 'route.ts' }}
    export async function POST(req) {
      const { stripeId, userId } = await req.json()

      await clerkClient.users.updateUserMetadata(userId, {
        privateMetadata: {
          stripeId: stripeId,
        },
      })

      return Response.json({ success: true })
    }
    ```

    <If sdk="nextjs">
      If you're using Next.js, you must `await` the instantiation of the `clerkClient` instance, like so:

      ```ts
      const client = await clerkClient()

      const response = await client.users.updateUserMetadata()
      ```
    </If>
  </Tab>

  <Tab>
    ```ts {{ filename: 'private.ts' }}
    import { clerkClient } from '@clerk/express'

    app.post('/updateStripe', async (req, res) => {
      const { stripeId, userId } = req.body

      await clerkClient.users.updateUserMetadata(userId, {
        privateMetadata: {
          stripeId: stripeId,
        },
      })

      res.status(200).json({ success: true })
    })
    ```
  </Tab>

  <Tab>
    ```go {{ filename: 'private.go' }}
    var client clerk.Client

    func addStripeCustomerID(user *clerk.User, stripeCustomerID string) error {
        stripeID := map[string]interface{}{
            "stripeID": stripeCustomerID,
        }
    	user, err := s.clerkClient.Users().UpdateMetadata(sess.UserID, &clerk.updateMetadataRequest{
    		PrivateMetadata: stripeID,
    	})

    	if err != nil {
    		panic(err)
    	}
    }
    ```
  </Tab>

  <Tab>
    ```ruby {{ filename: 'private.rb' }}
    # ruby json example with a private metadata and stripe id
    require 'clerk'
    require 'json'

    privateMetadata = {
      "stripeID": stripeCustomerID
    }


    clerk = Clerk::SDK.new(api_key: "your_clerk_secret_key")
    clerk.users.updateMetadata("user_xyz", private_metadata: privateMetadata)
    ```
  </Tab>

  <Tab>
    ```bash {{ filename: 'curl.sh' }}
    curl -XPATCH -H 'Authorization: Bearer CLERK_SECRET_KEY' -H "Content-type: application/json" -d '{
      "private_metadata": {
        "stripeId": "12356"
      }
    }' 'https://api.clerk.com/v1/users/{user_id}/metadata'
    ```
  </Tab>
</Tabs>

### Retrieve private metadata

You can retrieve the private metadata for a user by using the JavaScript Backend SDK's [`getUser()`](/docs/references/backend/user/get-user) method. This method will return the `User` object which contains the private metadata.

<Tabs items={["Fullstack SDKs", "Express", "Go", "Ruby", "cURL"]}>
  <Tab>
    ```ts {{ filename: 'route.ts' }}
    export async function GET(req) {
      const { userId } = await req.json()

      const user = await clerkClient.users.getUser(userId)

      return Response.json(user.privateMetadata)
    }
    ```

    <If sdk="nextjs">
      If you're using Next.js, you must `await` the instantiation of the `clerkClient` instance, like so:

      ```ts
      const client = await clerkClient()

      const response = await client.users.getUser()
      ```
    </If>
  </Tab>

  <Tab>
    ```ts {{ filename: 'private.ts' }}
    import { clerkClient } from '@clerk/express'

    app.post('/updateStripe', async (req, res) => {
      const { userId } = req.body

      const user = await clerkClient.users.getUser(userId)

      res.status(200).json(user.privateMetadata)
    })
    ```
  </Tab>

  <Tab>
    ```go {{ filename: 'private.go' }}
    var client clerk.Client

    func GetUserMetadata(user *clerk.User, stripeCustomerID string) error {
      user, err := s.clerkClient.Users().Read(sess.UserID)

      if err != nil {
        panic(err)
      }
    }
    ```
  </Tab>

  <Tab>
    ```ruby {{ filename: 'private.rb' }}
    # ruby json example with a private metadata and stripe id
    require 'clerk'
    clerk = Clerk::SDK.new(api_key: "your_clerk_secret_key")
    clerk.users.getUser("user_xyz")
    ```
  </Tab>

  <Tab>
    ```bash {{ filename: 'curl.sh' }}
    curl -XGET -H 'Authorization: CLERK_SECRET_KEY' -H "Content-type: application/json" 'https://api.clerk.com/v1/users/{user_id}'
    ```
  </Tab>
</Tabs>

## Public metadata

Public metadata is accessible by both the frontend and the backend, but can only be set on the backend. This is useful for storing data that you want to expose to the frontend, but don't want the user to be able to modify. For example, you could store a custom role for a user.

### Set public metadata

<Tabs items={["Fullstack SDKs", "Express", "Go", "Ruby", "cURL"]}>
  <Tab>
    ```ts {{ filename: 'route.ts' }}
    export async function POST(req) {
      const { role, userId } = await req.json()

      await clerkClient.users.updateUserMetadata(userId, {
        publicMetadata: {
          role,
        },
      })

      return Response.json({ success: true })
    }
    ```

    <If sdk="nextjs">
      If you're using Next.js, you must `await` the instantiation of the `clerkClient` instance, like so:

      ```ts
      const client = await clerkClient()

      const response = await client.users.updateUserMetadata()
      ```
    </If>
  </Tab>

  <Tab>
    ```ts {{ filename: 'public.ts' }}
    import { clerkClient } from '@clerk/express'

    app.post('/updateRole', async (req, res) => {
      const { role, userId } = req.body

      await clerkClient.users.updateUserMetadata(userId, {
        publicMetadata: {
          role,
        },
      })
      res.status(200).json({ success: true })
    })
    ```
  </Tab>

  <Tab>
    ```go {{ filename: 'public.go' }}
    var client clerk.Client

    func addStripeCustomerID(user *clerk.User, role string) error {
        Role := map[string]interface{}{
            "role": role,
        }
      user, err := s.clerkClient.Users().UpdateMetadata(sess.UserID, &clerk.updateMetadataRequest{
        PublicMetadata: role,
      })

      if err != nil {
        panic(err)
      }
    }
    ```
  </Tab>

  <Tab>
    ```ruby {{ filename: 'public.rb' }}
    # ruby json example with a private metadata and stripe id
    require 'clerk'
    require 'json'

    publicMetadata = {
      "role": "awesome-user",
    }

    clerk = Clerk::SDK.new(api_key: "your_clerk_secret_key")
    clerk.users.updateMetadata("user_xyz", public_metadata: publicMetadata)
    ```
  </Tab>

  <Tab>
    ```bash {{ filename: 'curl.sh' }}
    curl -XPATCH -H 'Authorization: Bearer CLERK_SECRET_KEY' -H "Content-type: application/json" -d '{
      "public_metadata": {
        "role": "shopper"
      }
    }' 'https://api.clerk.com/v1/users/{user_id}/metadata'
    ```
  </Tab>
</Tabs>

### Retrieve public metadata

There are multiple ways to retrieve public metadata.

On the frontend, it's available on the [`User`](/docs/references/javascript/user) object which can be accessed using the [`useUser()`](/docs/hooks/use-user) hook.

On the backend, it's available on the [Backend `User`](/docs/references/backend/types/backend-user) object which can be accessed using the JavaScript Backend SDK's [`getUser()`](/docs/references/backend/user/get-user) method. It can also be attached to a session token, and the `sessionClaims` of the session token can be retrieved on the [`Auth`](/docs/references/backend/types/auth-object) object. If you need to retrieve public metadata frequently in the backend, the best option is to attach it to the session token and retrieve it from the session token. See the [guide on customizing your session token](/docs/backend-requests/custom-session-token).

## Unsafe metadata

Unsafe metadata can be both read and set from the frontend and the backend. It's called "unsafe" metadata because it can be modified directly from the frontend, which means malicious users could potentially tamper with these values.

Unsafe metadata is the only metadata property that can be set during sign-up, so a common use case is to use it in [custom onboarding flows](/docs/references/nextjs/add-onboarding-flow). Custom data collected during the onboarding (sign-up) flow can be stored in the [`SignUp`](/docs/references/javascript/sign-up) object. After a successful sign-up, `SignUp.unsafeMetadata` is copied to the `User` object as `User.unsafeMetadata`. From that point on, the unsafe metadata is accessible as a direct attribute of the `User` object.

### Set unsafe metadata

The following examples demonstrate how to update unsafe metadata for an existing user. Updating `unsafeMetadata` replaces the previous value; it doesn't perform a merge. To merge data, you can pass a combined object such as `{ user.unsafeMetadata, newData }` to the `unsafeMetadata` parameter.

The following examples demonstrate how to update `unsafeMetadata` using [the Backend API](#using-the-backend-api) or [the Frontend SDKs](#using-the-frontend-sdks).

#### Using the Backend API

<Tabs items={["Fullstack SDKs", "Express", "Go", "Ruby", "cURL"]}>
  <Tab>
    ```ts {{ filename: 'route.ts' }}
    export async function POST(req) {
      const { userId } = await req.json()

      await clerkClient.users.updateUserMetadata(userId, {
        unsafeMetadata: {
          birthday: '11-30-1969',
        },
      })

      return Response.json({ success: true })
    }
    ```

    <If sdk="nextjs">
      If you're using Next.js, you must `await` the instantiation of the `clerkClient` instance, like so:

      ```ts
      const client = await clerkClient()

      const response = await client.users.updateUserMetadata()
      ```
    </If>
  </Tab>

  <Tab>
    ```ts {{ filename: 'private.ts' }}
    import { clerkClient } from '@clerk/express'

    app.post('/updateStripe', async (req, res) => {
      const { stripeId, userId } = await req.body

      await clerkClient.users.updateUserMetadata(userId, {
        unsafeMetadata: {
          birthday: '11-30-1969',
        },
      })

      res.status(200).json({ success: true })
    })
    ```
  </Tab>

  <Tab>
    ```go {{ filename: 'private.go' }}
    var client clerk.Client

    func addStripeCustomerID(user *clerk.User, stripeCustomerID string) error {
        birthday := map[string]interface{}{
            "birthday": "04-20-1969",
        }
      user, err := s.clerkClient.Users().UpdateMetadata(sess.UserID, &clerk.updateMetadataRequest{
        UnsafeMetadata: birthday,
      })

      if err != nil {
        panic(err)
      }
    }
    ```
  </Tab>

  <Tab>
    ```ruby {{ filename: 'private.rb' }}
    require 'clerk'
    require 'json'

    unsafeMetadata = {
      "birthday": "04-20-1969"
    }

    clerk = Clerk::SDK.new(api_key: "your_clerk_secret_key")
    clerk.users.updateMetadata("user_123", unsafe_metadata: unsafeMetadata)
    ```
  </Tab>

  <Tab>
    ```bash {{ filename: 'curl.sh' }}
    curl -XPATCH -H 'Authorization: Bearer CLERK_SECRET_KEY' -H "Content-type: application/json" -d '{
      "unsafe_metadata": {
        "birthday": "11-30-1969"
      }
    }' 'https://api.clerk.com/v1/users/{user_id}/metadata'
    ```
  </Tab>
</Tabs>

#### Using the Frontend SDKs

<Tabs items={["React-based SDKs", "JavaScript"]}>
  <Tab>
    ```tsx {{ filename: 'page.tsx' }}
    export default function Page() {
      const { user } = useUser()
      const [birthday, setBirthday] = useState('')

      return (
        <div>
          <input type="text" value={birthday} onChange={(e) => setBirthday(e.target.value)} />

          <button
            onClick={() => {
              user?.update({
                unsafeMetadata: { birthday },
              })
            }}
          >
            Update birthday
          </button>
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    ```js {{ filename: 'main.js' }}
    import { Clerk } from '@clerk/clerk-js'

    // Initialize Clerk with your Clerk Publishable Key
    const pubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

    const clerk = new Clerk(pubKey)
    await clerk.load()

    if (clerk.user) {
      await clerk.user
        .update({
          unsafeMetadata: {
            birthday: '01-01-2000',
          },
        })
        .then((res) => console.log(res))
        .catch((error) => console.log('An error occurred:', error.errors))
    } else {
      document.getElementById('app').innerHTML = `
        <div id="sign-in"></div>
      `

      const signInDiv = document.getElementById('sign-in')

      clerk.mountSignIn(signInDiv)
    }
    ```
  </Tab>
</Tabs>

### Retrieve unsafe metadata

There are multiple ways to retrieve unsafe metadata.

On the frontend, it is available on the [`User`](/docs/references/javascript/user) object, which you can access by using the [`useUser()`](/docs/hooks/use-user) hook.

On the backend, it's available on the [Backend `User`](/docs/references/backend/types/backend-user) object which can be accessed using the JavaScript Backend SDK's [`getUser()`](/docs/references/backend/user/get-user) method. It can also be attached to a session token, and the `sessionClaims` of the session token can be retrieved on the [`Auth`](/docs/references/backend/types/auth-object) object. If you need to retrieve unsafe metadata frequently in the backend, the best option is to attach it to the session token and retrieve it from the session token. See the [guide on customizing your session token](/docs/backend-requests/custom-session-token).

---
title: useReverification()
description: Clerk's useReverification() hook enhances a fetcher function to handle a session's reverification flow.
---

> [!WARNING]
>
> Depending on the SDK you're using, this feature requires `@clerk/nextjs@6.12.7` or later, `@clerk/clerk-react@5.25.1` or later, and `@clerk/clerk-js@5.57.1` or later.

Reverification allows you to prompt a user to verify their credentials before performing sensitive actions, even if they're already authenticated. For example, in a banking application, transferring money is considered a "sensitive action." Reverification can be used to confirm the user's identity.

The `useReverification()` hook is used to handle a session's reverification flow. If a request requires reverification, a modal will display, prompting the user to verify their credentials. Upon successful verification, the original request will automatically retry. If you'd like to build a custom UI, you can use the [`onNeedsReverification`](#use-reverification-options) option.

When using reverification, a user's credentials are valid for 10 minutes. Once stale, a user will need to reverify their credentials. This time duration can be customized by using the `has()` helper on the server-side. See the [guide on reverification](/docs/guides/reverification) for more information.

## Parameters

<Properties>
  - `fetcher`
  - `Fetcher extends (...args: any[]) => Promise<any>`

  A function that returns a promise.

  ---

  - `options?`
  - [`UseReverificationOptions`](#use-reverification-options)

  The optional options object.
</Properties>

### `UseReverificationOptions`

<Properties>
  - `onNeedsReverification?`
  - <code>(\{ complete, cancel, level }: [NeedsReverificationParameters](#needs-reverification-parameters)) => void</code>

  Handler for the reverification process. Opts out of using the default UI. Use this to build a custom UI.
</Properties>

### `NeedsReverificationParameters`

<Properties>
  - `complete`
  - `() => void`

  Marks the reverification process as complete and retries the original request.

  ---

  - `cancel`
  - `() => void`

  Marks the reverification process as cancelled and rejects the original request.

  ---

  - `level`
  - `"first_factor" | "second_factor" | "multi_factor" | undefined`

  The verification level required for the reverification process.
</Properties>

## Returns

<Properties>
  - `(...args: any[]) => Promise<any>`

  The action returns the response from the fetcher function.
</Properties>

## Examples

> [!TIP]
> For more dedicated examples, such as handling reverification on the server-side, see the [guide on reverification](/docs/guides/reverification).

The `useReverification()` hook displays a prebuilt UI when the user needs to reverify their credentials. You can also build a custom UI to handle the reverification process yourself. Use the following tabs to see examples of either option.

<Tabs items={["Prebuilt UI", "Custom UI"]}>
  <Tab>
    ### Handle reverification for an action

    The following example demonstrates how to use the `useReverification()` hook to require a user to reverify their credentials before being able to update their primary email address. It also demonstrates how to handle the cancellation of the reverification process.

    This example uses React, but can be adapted for other React-based frameworks, like Next.js.

    ```tsx {{ filename: 'src/components/UpdateUserEmail.tsx', collapsible: true }}
    import { useReverification, useUser } from '@clerk/clerk-react'
    import { isClerkRuntimeError, isReverificationCancelledError } from '@clerk/clerk-react/errors'

    export function UpdateUserEmail() {
      // Use `useUser()` to get the current user's `User` object
      // `User` includes the `update()` method to update the user's primary email address
      const { user } = useUser()

      // Use `useReverification()` to enhance the `update()` method
      // to handle the reverification process
      const changePrimaryEmail = useReverification((emailAddressId: string) =>
        user?.update({ primaryEmailAddressId: emailAddressId }),
      )

      const handleClick = async (emailAddressId: string) => {
        try {
          await changePrimaryEmail(emailAddressId)
        } catch (e) {
          // Handle if user cancels the reverification process
          if (isClerkRuntimeError(e) && isReverificationCancelledError(e)) {
            console.error('User cancelled reverification', e.code)
          }

          // Handle other errors
          // See https://clerk.com/docs/custom-flows/error-handling
          // for more info on error handling
          console.error(JSON.stringify(e, null, 2))
        }
      }

      return (
        <div>
          <span>Your primary email address is {user?.primaryEmailAddress?.emailAddress}</span>

          <ul>
            {user?.emailAddresses.map((email) => (
              <li key={email.id}>
                <span>{email.emailAddress}</span>
                {email.emailAddress !== user?.primaryEmailAddress?.emailAddress && (
                  <button onClick={() => handleClick(email.id)}>Make primary</button>
                )}
              </li>
            ))}
          </ul>
        </div>
      )
    }
    ```

    ### Handle reverification for a fetcher function

    The following example demonstrates how to use the `useReverification()` hook to enhance a fetcher function that fetches data from a route that requires reverification. For examples on how to set up a route that requires reverification, see the [guide on reverification](/docs/guides/reverification).

    This example uses React, but can be adapted for other React-based frameworks, like Next.js.

    ```tsx {{ filename: 'src/components/AccountBalance.tsx' }}
    import { useReverification, useUser } from '@clerk/clerk-react'
    import { isClerkRuntimeError, isReverificationCancelledError } from '@clerk/clerk-react/errors'
    import { useState } from 'react'

    export function UpdateUserEmail() {
      const [balance, setBalance] = useState<number | null>(null)
      const accountBalance = useReverification(() => fetch('/api/balance'))

      const handleClick = async () => {
        try {
          const accountBalanceResponse = await accountBalance()

          setBalance(accountBalanceResponse.amount)
        } catch (e) {
          // Handle if user cancels the reverification process
          if (isClerkRuntimeError(e) && isReverificationCancelledError(e)) {
            console.error('User cancelled reverification', e.code)
          }

          // Handle other errors
          // See https://clerk.com/docs/custom-flows/error-handling
          // for more info on error handling
          console.error(JSON.stringify(e, null, 2))
        }
      }

      return (
        <div>
          <span>Your account balance is {balance ? `$${balance}` : '$******'}</span>
          <button onClick={() => handleClick()}>See account balance</button>
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    The following example demonstrates how to build a custom UI when using the `useReverification()` hook. In the example, the `useReverification()` hook is used to require a user to reverify their credentials before being able to update their primary email address. It requires two components: the `<UpdateUserEmail />` component displays the list of email addresses to choose from and it renders the second component, `<VerificationComponent />`, which handles the reverification process.

    The example handles first factor verification using an email code, so you will need to have the [email code verification method](/docs/authentication/configuration/sign-up-sign-in-options#verification-methods) enabled for your application. But you can adapt this example to handle any type of verification level or strategy.

    This example uses React, but can be adapted for other React-based frameworks, like Next.js.

    <Tabs items={["UpdateUserEmail", "VerificationComponent"]}>
      <Tab>
        The `<UpdateUserEmail />` component uses `useReverification()` to enhance the `update()` method, requiring the user to reverify their credentials before being able to update their primary email address.

        The `useReverification()` hook provides the `onNeedsReverification` option, which is a handler for building a custom UI. It provides four properties: `level`, `complete`, `cancel`, and `inProgress`. The example tracks these using the `verificationState` state variable.

        - The `level` property determines the verification level required for the reverification process. This example only handles first factor verification, which is done in the `<VerificationComponent>` component.
        - The `complete` and `cancel` properties are the steps of the reverification process, which is also done in the `<VerificationComponent>` component.
        - The `inProgress` property is used to track the state of the reverification process. When the user selects the "Make primary" button, it triggers the reverification process and sets the `inProgress` property is `true`, which displays the `<VerificationComponent>` component.

        ```tsx {{ filename: 'src/components/UpdateUserEmail.tsx', collapsible: true }}
        import { useReverification, useUser } from '@clerk/clerk-react'
        import { isClerkRuntimeError, isReverificationCancelledError } from '@clerk/clerk-react/errors'
        import { useState } from 'react'
        import { SessionVerificationLevel } from '@clerk/types'
        import { VerificationComponent } from './VerificationComponent'

        export function UpdateUserEmail() {
          // Use `useUser()` to get the current user's `User` object
          // `User` includes the `update()` method to update the user's primary email address
          const { user } = useUser()

          // TODO: Update to use exported type once available
          const [verificationState, setVerificationState] = useState<
            | {
                complete: () => void
                cancel: () => void
                level: SessionVerificationLevel | undefined
                inProgress: boolean
              }
            | undefined
          >(undefined)

          // Use `useReverification()` to enhance the `update()` method
          // to handle the reverification process
          const changePrimaryEmail = useReverification(
            (emailAddressId: string) => user?.update({ primaryEmailAddressId: emailAddressId }),
            {
              onNeedsReverification: ({ complete, cancel, level }) => {
                setVerificationState({
                  complete,
                  cancel,
                  level,
                  inProgress: true,
                })
              },
            },
          )

          const handleClick = async (emailAddressId: string) => {
            try {
              await changePrimaryEmail(emailAddressId)
            } catch (e) {
              // Handle if user cancels the reverification process
              if (isClerkRuntimeError(e) && isReverificationCancelledError(e)) {
                console.error('User cancelled reverification', e.code)
              }

              // Handle other errors
              // See https://clerk.com/docs/custom-flows/error-handling
              // for more info on error handling
              console.error(JSON.stringify(e, null, 2))
            }
          }

          return (
            <div>
              <span>Your primary email address is {user?.primaryEmailAddress?.emailAddress}</span>

              <ul>
                {user?.emailAddresses.map((email) => (
                  <li key={email.id}>
                    <span>{email.emailAddress}</span>
                    {user?.primaryEmailAddressId !== email.id && (
                      <button onClick={() => handleClick(email.id)}>Make primary</button>
                    )}
                  </li>
                ))}
              </ul>

              {verificationState?.inProgress && (
                <VerificationComponent
                  level={verificationState?.level}
                  onComplete={() => {
                    verificationState.complete()
                    setVerificationState(undefined)
                  }}
                  onCancel={() => {
                    verificationState.cancel()
                    setVerificationState(undefined)
                  }}
                />
              )}
            </div>
          )
        }
        ```
      </Tab>

      <Tab>
        The `<VerificationComponent />` component handles the reverification process. It uses the `level` property to determine the verification level, which is set to `first_factor`. First, it finds the determined starting first factor from the supported first factors. Then, it prepares the first factor verification using the `strategy` (`email_code` in this case) and `emailAddressId` properties. Finally, it attempts to verify the session with email code provided by the user. If the verification is successful, the `onComplete()` handler is called to complete the reverification process.

        ```tsx {{ filename: 'src/components/VerificationComponent.tsx', collapsible: true }}
        import { useEffect, useRef, useState } from 'react'
        import { useSession } from '@clerk/clerk-react'
        import {
          EmailCodeFactor,
          SessionVerificationLevel,
          SessionVerificationResource,
        } from '@clerk/types'

        export function VerificationComponent({
          level = 'first_factor',
          onComplete,
          onCancel,
        }: {
          level: SessionVerificationLevel | undefined
          onComplete: () => void
          onCancel: () => void
        }) {
          const { session } = useSession()
          const [code, setCode] = useState<string>('')
          const reverificationRef = useRef<SessionVerificationResource | undefined>(undefined)
          const [determinedStartingFirstFactor, setDeterminedStartingFirstFactor] = useState<
            EmailCodeFactor | undefined
          >()

          useEffect(() => {
            if (reverificationRef.current) {
              return
            }

            session?.startVerification({ level }).then(async (response) => {
              reverificationRef.current = response
              await prepareEmailVerification(response)
            })
          }, [])

          const prepareEmailVerification = async (verificationResource: SessionVerificationResource) => {
            // To simplify the example we will only handle the first factor verification
            if (verificationResource.status === 'needs_first_factor') {
              // Determine the starting first factor from the supported first factors
              const determinedStartingFirstFactor = verificationResource.supportedFirstFactors?.filter(
                (factor) => factor.strategy === 'email_code',
              )[0]

              if (determinedStartingFirstFactor) {
                setDeterminedStartingFirstFactor(determinedStartingFirstFactor)
                // Prepare the first factor verification with the determined starting first factor
                await session?.prepareFirstFactorVerification({
                  strategy: determinedStartingFirstFactor.strategy,
                  emailAddressId: determinedStartingFirstFactor?.emailAddressId,
                })
              }
            }
          }

          const handleVerificationAttempt = async () => {
            try {
              // Attempt to verify the session with the provided code
              await session?.attemptFirstFactorVerification({
                strategy: 'email_code',
                code,
              })
              onComplete()
            } catch (e) {
              // Any error from the attempt to verify the session can be handled here
              console.error('Error verifying session', e)
            }
          }

          if (!determinedStartingFirstFactor) {
            return null
          }

          return (
            <div>
              <p>Enter verification code sent to {determinedStartingFirstFactor.safeIdentifier || ''}</p>
              <input type="number" name="code" onChange={(e) => setCode(e.target.value)} />
              <button onClick={async () => handleVerificationAttempt()}>Complete</button>
              <button onClick={() => onCancel()}>Cancel</button>
            </div>
          )
        }
        ```
      </Tab>
    </Tabs>
  </Tab>
</Tabs>

---
title: UserOrganizationInvitation
description: The UserOrganizationInvitation object is the model around a user's invitation to an organization.
---

The `UserOrganizationInvitation` object is the model around a user's invitation to an organization.

## Properties

<Properties>
  - `id`
  - `string`

  The unique identifier for this organization invitation.

  ---

  - `emailAddress`
  - `string`

  The email address the invitation has been sent to.

  ---

  - `publicOrganizationData`
  - `{ hasImage: boolean; imageUrl: string; name: string; id: string; slug: string | null; }`

  The public data of the organization.

  - `hasImage`: Whether the organization has an image.
  - `imageUrl`: Holds the organization logo. Compatible with Clerk's [Image Optimization](/docs/guides/image-optimization).
  - `name`: The name of the organization.
  - `id`: The ID of the organization.
  - `slug`: The slug of the organization.

  ---

  - `publicMetadata`
  - [`UserOrganizationInvitationPublicMetadata`](/docs/references/javascript/types/metadata#user-organization-invitation-public-metadata)

  The public metadata of the organization invitation.

  ---

  - `role`
  - [`OrganizationCustomRoleKey`](/docs/references/javascript/types/organization-custom-role-key)

  The [role](/docs/organizations/roles-permissions) of the current user in the organization.

  ---

  - `status`
  - `'pending' | 'accepted' | 'revoked'`

  The status of the invitation.

  ---

  - `createdAt`
  - `Date`

  The date when the invitation was created.

  ---

  - `updatedAt`
  - `Date`

  The date when the invitation was last updated.
</Properties>

## Methods

### `accept()`

Accepts the invitation to the organization.

```typescript
function accept(): Promise<UserOrganizationInvitation>
```

### Example

To see an example of how to use the `accept()` method, see the [custom flow guide for managing invitations](/docs/custom-flows/manage-user-org-invitations).

---
title: Users
description: Learn how to manage your users in your Clerk application.
---

You can manage your users [in the Clerk Dashboard](#manage-users-in-the-clerk-dashboard), or [in your app](#manage-users-in-your-app).

## Manage users in the Clerk Dashboard

To manage users in the Clerk Dashboard, navigate to the [**Users**](https://dashboard.clerk.com/last-active?path=users) page.

## Manage users in your app

You can manage users in your app either through the frontend or backend. But first, it's important to understand the [`User` object](/docs/references/javascript/user).

<Include src="_partials/user-object" />

For more information on the `User` object, such as helper methods for retrieving and updating user information and authentication status, see the [reference docs](/docs/references/javascript/user). The `User` object is also available in the backend, but it looks slightly different. For more information, see the [Backend `User` object reference docs](/docs/references/backend/types/backend-user).

### Manage users in the frontend

Depending on the level of abstraction you need, you can manage users in the frontend using Clerk's prebuilt components, React hooks, or lower-level JavaScript methods.

- Prebuilt components: Clerk provides the prebuilt components [`<UserButton />`](/docs/components/user/user-button) and [`<UserProfile />`](/docs/components/user/user-profile) to help your users manage their profile data.
- Hooks: Because Clerk's React-based SDKs are built on top of the Clerk React SDK, you can use the [hooks](/docs/references/react/overview#custom-hooks) that the React SDK provides. These hooks include access to the `User` object and helpful methods for managing user authentication and profile data.
- JavaScript methods: If Clerk's prebuilt components don't meet your specific needs or if you require more control over the logic, you can rebuild the existing Clerk flows using the Clerk API. For more information, see the [custom flow guides](/docs/custom-flows/overview).

### Manage users in the backend

The [JavaScript Backend SDK](/docs/references/backend/overview) exposes the [Backend API](/docs/reference/backend-api){{ target: '_blank' }} resources and low-level authentication utilities for JavaScript environments.

There are many operations available for managing users, such as `getUser()`, `createUser()`, and `deleteUser()`. For more information, see the [Backend SDK reference docs](/docs/references/backend/overview).

---
title: useSession()
description: Access and manage the current user's session in your React application with Clerk's useSession() hook.
---

The `useSession()` hook provides access to the current user's [`Session`](/docs/references/javascript/session) object, as well as helpers for setting the active session.

## Returns

<Properties>
  - `isLoaded`
  - `boolean`

  A boolean that indicates whether Clerk has completed initialization. Initially `false`, becomes `true` once Clerk loads.

  ---

  - `isSignedIn`
  - `boolean`

  A boolean that indicates whether a user is currently signed in.

  ---

  - `session`
  - [`Session`](/docs/references/javascript/session)

  Holds the current active session for the user.
</Properties>

## How to use the `useSession()` hook

### Access the `Session` object

The following example uses the `useSession()` hook to access the `Session` object, which has the `lastActiveAt` property. The `lastActiveAt` property is a `Date` object used to show the time the session was last active.

<Tabs items={['React', 'Next.js']}>
  <Tab>
    ```tsx {{ filename: 'src/Home.tsx' }}
    import { useSession } from '@clerk/clerk-react'

    export default function Home() {
      const { isLoaded, session, isSignedIn } = useSession()

      if (!isLoaded) {
        // Handle loading state
        return null
      }
      if (!isSignedIn) {
        // Handle signed out state
        return null
      }

      return (
        <div>
          <p>This session has been active since {session.lastActiveAt.toLocaleString()}</p>
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/page.tsx' }}
    'use client'

    import { useSession } from '@clerk/nextjs'

    export default function HomePage() {
      const { isLoaded, session, isSignedIn } = useSession()

      if (!isLoaded) {
        // Handle loading state
        return null
      }
      if (!isSignedIn) {
        // Handle signed out state
        return null
      }

      return (
        <div>
          <p>This session has been active since {session.lastActiveAt.toLocaleString()}</p>
        </div>
      )
    }
    ```
  </Tab>
</Tabs>

---
title: useSession() | Vue
description: Access and manage the current user's session in your Vue application with Clerk's useSession() composable.
---

The `useSession()` composable provides access to the current user's [`Session`](/docs/references/javascript/session) object, as well as helpers for setting the active session.

## Returns

<Properties>
  - `isLoaded`
  - `Ref<boolean>`

  A boolean that indicates whether Clerk has finished loading and initializing. Returns `false` during initialization.

  ---

  - `isSignedIn`
  - `Ref<boolean>`

  A boolean that indicates whether a user is currently signed in.

  ---

  - `session`
  - <code>Ref\<[Session](/docs/references/javascript/session)></code>

  Holds the current active session for the user.
</Properties>

## How to use the `useSession()` composable

### Access the `Session` object

The following example uses `useSession()` to access the `Session` object, which has the `lastActiveAt` property. The `lastActiveAt` property is a `Date` object used to show the time the session was last active.

```vue {{ filename: 'SessionStatus.vue' }}
<script setup>
import { useSession } from '@clerk/vue'

const { isLoaded, session, isSignedIn } = useSession()
</script>

<template>
  <div v-if="!isLoaded">
    <!-- Handle loading state -->
  </div>

  <div v-else-if="!isSignedIn">
    <!-- Handle signed out state -->
  </div>

  <div v-else>
    <p>This session has been active since {{ session.lastActiveAt.toLocaleString() }}</p>
  </div>
</template>
```

---
title: useSessionList()
description: Access and manage the current user's session list in your React application with Clerk's useSessionList() hook.
---

The `useSessionList()` hook returns an array of [`Session`](/docs/references/javascript/session) objects that have been registered on the client device.

## Returns

<Properties>
  - `isLoaded`
  - `boolean`

  A boolean that indicates whether Clerk has completed initialization. Initially `false`, becomes `true` once Clerk loads.

  ---

  - `setActive()`
  - <code>(params: [SetActiveParams](/docs/references/javascript/types/set-active-params)) => Promise\<void></code>

  A function that sets the active session and/or organization.

  ---

  - `sessions`
  - <code>[Session](/docs/references/javascript/session)\[]</code>

  A list of sessions that have been registered on the client device.
</Properties>

## How to use the `useSessionList()` hook

### Get a list of sessions

The following example uses `useSessionList()` to get a list of sessions that have been registered on the client device. The `sessions` property is used to show the number of times the user has visited the page.

<Tabs items={['React', 'Next.js']}>
  <Tab>
    ```tsx {{ filename: 'src/Home.tsx' }}
    import { useSessionList } from '@clerk/clerk-react'

    export default function Home() {
      const { isLoaded, sessions } = useSessionList()

      if (!isLoaded) {
        // Handle loading state
        return null
      }

      return (
        <div>
          <p>Welcome back. You've been here {sessions.length} times before.</p>
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/page.tsx' }}
    'use client'

    import { useSessionList } from '@clerk/nextjs'

    export default function HomePage() {
      const { isLoaded, sessions } = useSessionList()

      if (!isLoaded) {
        // Handle loading state
        return null
      }

      return (
        <div>
          <p>Welcome back. You've been here {sessions.length} times before.</p>
        </div>
      )
    }
    ```
  </Tab>
</Tabs>

---
title: useSessionList() | Vue
description: Access and manage a list of sessions registered on the client device in your Vue application with Clerk's useSessionList() composable.
---

The `useSessionList()` composable returns an array of [`Session`](/docs/references/javascript/session) objects that have been registered on the client device.

## Returns

<Properties>
  - `isLoaded`
  - `Ref<boolean>`

  A boolean that indicates whether Clerk has completed initialization. Initially `false`, becomes `true` once Clerk loads.

  ---

  - `setActive()`
  - <code>Ref\<(params: [SetActiveParams](/docs/references/javascript/types/set-active-params)) => Promise\<void>></code>

  A function that sets the active session and/or organization.

  ---

  - `sessions`
  - <code>Ref\<[Session](/docs/references/javascript/session)></code>

  A list of sessions that have been registered on the client device.
</Properties>

## How to use the `useSessionList()` composable

### Get a list of sessions

The following example uses `useSessionList()` to get a list of sessions that have been registered on the client device. The `sessions` property is used to show the number of times the user has visited the page.

```vue {{ filename: 'SessionList.vue' }}
<script setup>
import { useSessionList } from '@clerk/vue'

const { isLoaded, sessions } = useSessionList()
</script>

<template>
  <div v-if="!isLoaded">
    <!-- Handle loading state -->
  </div>

  <div v-else>
    <p>Welcome back. You've been here {{ sessions.length }} times before.</p>
  </div>
</template>
```

---
title: useSignIn()
description: Access and manage the current user's sign-in state in your React application with Clerk's useSignIn() hook.
---

The `useSignIn()` hook provides access to the [`SignIn`](/docs/references/javascript/sign-in) object, which allows you to check the current state of a sign-in attempt and manage the sign-in flow. You can use this to create a [custom sign-in flow](/docs/custom-flows/overview#sign-in-flow).

## Returns

<Properties>
  - `isLoaded`
  - `boolean`

  A boolean that indicates whether Clerk has completed initialization. Initially `false`, becomes `true` once Clerk loads.

  ---

  - `setActive()`
  - <code>(params: [SetActiveParams](/docs/references/javascript/types/set-active-params)) => Promise\<void></code>

  A function that sets the active session.

  ---

  - `signIn`
  - [`SignIn`](/docs/references/javascript/sign-in)

  An object that contains the current sign-in attempt status and methods to create a new sign-in attempt.
</Properties>

## How to use the `useSignIn()` hook

### Check the current state of a sign-in

The following example uses the `useSignIn()` hook to access the [`SignIn`](/docs/references/javascript/sign-in) object, which contains the current sign-in attempt status and methods to create a new sign-in attempt. The `isLoaded` property is used to handle the loading state.

<Tabs items={['React', 'Next.js']}>
  <Tab>
    ```tsx {{ filename: 'src/pages/SignInPage.tsx' }}
    import { useSignIn } from '@clerk/clerk-react'

    export default function SignInPage() {
      const { isLoaded, signIn } = useSignIn()

      if (!isLoaded) {
        // Handle loading state
        return null
      }

      return <div>The current sign-in attempt status is {signIn?.status}.</div>
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/sign-in/page.tsx' }}
    'use client'

    import { useSignIn } from '@clerk/nextjs'

    export default function SignInPage() {
      const { isLoaded, signIn } = useSignIn()

      if (!isLoaded) {
        // Handle loading state
        return null
      }

      return <div>The current sign-in attempt status is {signIn?.status}.</div>
    }
    ```
  </Tab>
</Tabs>

### Create a custom sign-in flow with `useSignIn()`

The `useSignIn()` hook can also be used to build fully custom sign-in flows, if Clerk's prebuilt components don't meet your specific needs or if you require more control over the authentication flow. Different sign-in flows include email and password, email and phone codes, email links, and multifactor (MFA). To learn more about using the `useSignIn()` hook to create custom flows, see the [custom flow guides](/docs/custom-flows/overview).

---
title: useSignIn() | Vue
description: Access and manage sign-in state in your Vue application with Clerk's useSignIn() composable.
---

The `useSignIn()` composable provides access to the [`SignIn`](/docs/references/javascript/sign-in) object, which allows you to check the current state of a sign-in attempt and manage the sign-in flow. You can use this to create a [custom sign-in flow](/docs/custom-flows/overview#sign-in-flow).

## Returns

<Properties>
  - `isLoaded`
  - `Ref<boolean>`

  A boolean that indicates whether Clerk has completed initialization. Initially `false`, becomes `true` once Clerk loads.

  ---

  - `setActive()`
  - <code>Ref\<(params: [SetActiveParams](/docs/references/javascript/types/set-active-params)) => Promise\<void>></code>

  A function that sets the active session.

  ---

  - `signIn`
  - <code>Ref\<[SignIn](/docs/references/javascript/sign-in)></code>

  An object that contains the current sign-in attempt status and methods to create a new sign-in attempt.
</Properties>

## How to use the `useSignIn()` composable

The following example uses `useSignIn()` to access the [`SignIn`](/docs/references/javascript/sign-in) object, which contains the current sign-in attempt status and methods to create a new sign-in attempt. The `isLoaded` property is used to handle the loading state.

```vue {{ filename: 'SignInPage.vue' }}
<script setup>
import { useSignIn } from '@clerk/vue'

const { isLoaded, signIn } = useSignIn()
</script>

<template>
  <div v-if="!isLoaded">
    <!-- Add logic to handle loading state -->
  </div>

  <div v-else>The current sign in attempt status is {{ signIn?.status }}.</div>
</template>
```

---
title: useSignUp()
description: Access and manage the current user's sign-up state in your React application with Clerk's useSignUp() hook.
---

The `useSignUp()` hook provides access to the [`SignUp`](/docs/references/javascript/sign-up) object, which allows you to check the current state of a sign-up attempt and manage the sign-up flow. You can use this to create a [custom sign-up flow](/docs/custom-flows/overview#sign-up-flow).

## Returns

<Properties>
  - `isLoaded`
  - `boolean`

  A boolean that indicates whether Clerk has completed initialization. Initially `false`, becomes `true` once Clerk loads.

  ---

  - `setActive()`
  - <code>(params: [SetActiveParams](/docs/references/javascript/types/set-active-params)) => Promise\<void></code>

  A function that sets the active session.

  ---

  - `signUp`
  - [`SignUp`](/docs/references/javascript/sign-up)

  An object that contains the current sign-up attempt status and methods to create a new sign-up attempt.
</Properties>

## How to use the `useSignUp()` hook

### Check the current state of a sign-up

The following example uses the `useSignUp()` hook to access the [`SignUp`](/docs/references/javascript/sign-up) object, which contains the current sign-up attempt status and methods to create a new sign-up attempt. The `isLoaded` property is used to handle the loading state.

<Tabs items={['React', 'Next.js']}>
  <Tab>
    ```tsx {{ filename: 'src/pages/SignUpPage.tsx' }}
    import { useSignUp } from '@clerk/clerk-react'

    export default function SignUpPage() {
      const { isLoaded, signUp } = useSignUp()

      if (!isLoaded) {
        // Handle loading state
        return null
      }

      return <div>The current sign-up attempt status is {signUp?.status}.</div>
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/sign-up/page.tsx' }}
    'use client'

    import { useSignUp } from '@clerk/nextjs'

    export default function SignUpPage() {
      const { isLoaded, signUp } = useSignUp()

      if (!isLoaded) {
        // Handle loading state
        return null
      }

      return <div>The current sign-up attempt status is {signUp?.status}.</div>
    }
    ```
  </Tab>
</Tabs>

### Create a custom sign-up flow with `useSignUp()`

The `useSignUp()` hook can also be used to build fully custom sign-up flows, if Clerk's prebuilt components don't meet your specific needs or if you require more control over the authentication flow. Different sign-up flows include email and password, email and phone codes, email links, and multifactor (MFA). To learn more about using the `useSignUp()` hook to create custom flows, see the [custom flow guides](/docs/custom-flows/overview).

---
title: useSignUp() | Vue
description: Access and manage sign-up state in your Vue application with Clerk's useSignUp() composable.
---

The `useSignUp()` composable provides access to the [`SignUp`](/docs/references/javascript/sign-up) object, which allows you to check the current state of a sign-up attempt and manage the sign-up flow. You can use this to create a [custom sign-up flow](/docs/custom-flows/overview#sign-up-flow).

## Returns

<Properties>
  - `isLoaded`
  - `Ref<boolean>`

  A boolean that indicates whether Clerk has completed initialization. Initially `false`, becomes `true` once Clerk loads.

  ---

  - `setActive()`
  - <code>Ref\<(params: [SetActiveParams](/docs/references/javascript/types/set-active-params)) => Promise\<void>></code>

  A function that sets the active session.

  ---

  - `signUp`
  - <code>Ref\<[SignUp](/docs/references/javascript/sign-up)></code>

  An object that contains the current sign-up attempt status and methods to create a new sign-up attempt.
</Properties>

## How to use the `useSignUp()` composable

### Check the current state of a sign-up

The following example uses the `useSignUp()` hook to access the [`SignUp`](/docs/references/javascript/sign-up) object, which contains the current sign-up attempt status and methods to create a new sign-up attempt. The `isLoaded` property is used to handle the loading state.

```vue {{ filename: 'SignUpStep.vue' }}
<script setup>
import { useSignUp } from '@clerk/vue'

const { isLoaded, signUp } = useSignUp()
</script>

<template>
  <div v-if="!isLoaded">
    <!-- Handle loading state -->
  </div>

  <div v-else>The current sign-up attempt status is {{ signUp?.status }}.</div>
</template>
```

---
title: useSSO()
description: Clerk's useSSO() hook is used to create a new SSO flow.
---

The `useSSO()` hook is used to create a new SSO flow. It can be used in both web and native apps.

## Returns

The `useSSO()` hook returns the `startSSOFlow()` method, which you can use to initiate the SSO flow.

### `startSSOFlow()`

`startSSOFlow()` has the following function signature:

```ts
function startSSOFlow(startSSOFlowParams: StartSSOFlowParams): Promise<StartSSOFlowReturnType>
```

#### Parameters

`startSSOFlow()` accepts the following parameters (`StartSSOFlowParams`):

<Properties>
  - `strategy`
  - [`OAuthStrategy`](/docs/references/javascript/types/sso#o-auth-strategy) | [`EnterpriseSSOStrategy`](/docs/references/javascript/types/sso#enterprise-sso-strategy)

  The strategy to use for authentication. The following strategies are supported:

  - `'oauth_<provider>'`: The user will be authenticated with their [social connection account](/docs/authentication/social-connections/oauth). [See a list of supported values for `<provider>`](/docs/references/javascript/types/sso#o-auth-provider).
  - `'enterprise_sso'`: The user will be authenticated either through SAML, EASIE, or OIDC depending on the configuration of their [enterprise SSO account](/docs/authentication/enterprise-connections/overview).

  ---

  - `identifier?`
  - string

  **Required** if `strategy` is set to `'enterprise_sso'`. The [identifier](/docs/authentication/configuration/sign-up-sign-in-options#identifiers) of the user.

  ---

  - `redirectUrl?`
  - `string`

  The full URL or path to redirect to after the SSO flow is complete. If not specified, defaults to `sso-callback` path.

  ---

  - `unsafeMetadata?`
  - [`SignUpUnsafeMetadata`](/docs/references/javascript/types/metadata#sign-up-unsafe-metadata)

  Metadata that can be read and set from the frontend and the backend. Once the authentication process is complete, the value of this field will be automatically copied to the created user's unsafe metadata (`User.unsafeMetadata`). One common use case is to collect custom information about the user during the authentication process and store it in this property. Read more about [unsafe metadata](/docs/users/metadata#unsafe-metadata).
</Properties>

#### Returns

`startSSOFlow()` returns the following:

<Properties>
  - `createdSessionId`
  - `string | null`

  The ID of the session that was created.

  ---

  - `authSessionResult?`
  - `WebBrowser.WebBrowserAuthSessionResult | undefined`

  The result of the web browser session. See the [Expo WebBrowser documentation](https://docs.expo.dev/versions/latest/sdk/webbrowser/#webbrowserauthsessionresult) for more details.

  ---

  - `setActive?`
  - `(params: SetActiveParams) => Promise<void>`

  A method used to set the active session and/or organization. Accepts a [`SetActiveParams`](/docs/references/javascript/types/set-active-params) object.

  ---

  - `signIn?`
  - <code>[SignIn](/docs/references/javascript/sign-in) | undefined</code>

  The [`SignIn`](/docs/references/javascript/sign-in) object that was created, which holds the state of the current sign-in and provides helper methods to navigate and complete the sign-in process.

  ---

  - `signUp?`
  - <code>[SignUp](/docs/references/javascript/sign-up) | undefined</code>

  The [`SignUp`](/docs/references/javascript/sign-up) object that was created, which holds the state of the current sign-up and provides helper methods to navigate and complete the sign-up process.
</Properties>

## How to use the `useSSO()` hook

For detailed examples of how to use the `useSSO()` hook, see the following guides:

- [OAuth custom flow](/docs/custom-flows/oauth-connections)
- [Enterprise SSO custom flow](/docs/custom-flows/enterprise-connections)

---
title: useUser()
description: Access and manage the current user's data in your React application with Clerk's useUser() hook.
---

The `useUser()` hook provides access to the current user's [`User`](/docs/references/javascript/user) object, which contains all the data for a single user in your application and provides methods to manage their account. This hook also allows you to check if the user is signed in and if Clerk has loaded and initialized.

## Returns

<Properties>
  - `isLoaded`
  - `boolean`

  A boolean that indicates whether Clerk has completed initialization. Initially `false`, becomes `true` once Clerk loads.

  ---

  - `isSignedIn`
  - `boolean`

  A boolean that returns `true` if the user is signed in.

  ---

  - `user`
  - <code>[User](/docs/references/javascript/user) | null</code>

  The `User` object for the current user. If the user isn't signed in, `user` will be `null`.
</Properties>

## How to use the `useUser()` hook

### Get the current user

<Include src="_partials/hooks/use-user" />

### Update user data

The following example uses the `useUser()` hook to access the [`User`](/docs/references/javascript/user) object, which calls the [`update()`](/docs/references/javascript/user#update) method to update the current user's information.

<Tabs items={['React', 'Next.js']}>
  <Tab>
    ```tsx {{ filename: 'src/Home.tsx' }}
    import { useUser } from '@clerk/clerk-react'

    export default function Home() {
      const { isLoaded, user } = useUser()

      if (!isLoaded) {
        // Handle loading state
        return null
      }

      if (!user) return null

      const updateUser = async () => {
        await user.update({
          firstName: 'John',
          lastName: 'Doe',
        })
      }

      return (
        <>
          <button onClick={updateUser}>Update your name</button>
          <p>user.firstName: {user?.firstName}</p>
          <p>user.lastName: {user?.lastName}</p>
        </>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/page.tsx' }}
    'use client'

    import { useUser } from '@clerk/nextjs'

    export default function HomePage() {
      const { isLoaded, user } = useUser()

      if (!isLoaded) {
        // Handle loading state
        return null
      }

      if (!user) return null

      const updateUser = async () => {
        await user.update({
          firstName: 'John',
          lastName: 'Doe',
        })
      }

      return (
        <>
          <button onClick={updateUser}>Update your name</button>
          <p>user.firstName: {user?.firstName}</p>
          <p>user.lastName: {user?.lastName}</p>
        </>
      )
    }
    ```
  </Tab>
</Tabs>

### Reload user data

The following example uses the `useUser()` hook to access the [`User`](/docs/references/javascript/user) object, which calls the [`reload()`](/docs/references/javascript/user#reload) method to get the latest user's information.

<Tabs items={['React', 'Next.js']}>
  <Tab>
    ```tsx {{ filename: 'src/Home.tsx' }}
    import { useUser } from '@clerk/clerk-react'

    export default function Home() {
      const { isLoaded, user } = useUser()

      if (!isLoaded) {
        // Handle loading state
        return null
      }

      if (!user) return null

      const updateUser = async () => {
        // Update data via an API endpoint
        const updateMetadata = await fetch('/api/updateMetadata')

        // Check if the update was successful
        if (updateMetadata.message !== 'success') {
          throw new Error('Error updating')
        }

        // If the update was successful, reload the user data
        await user.reload()
      }

      return (
        <>
          <button onClick={updateUser}>Update your metadata</button>
          <p>user role: {user?.publicMetadata.role}</p>
        </>
      )
    }
    ```
  </Tab>

  <Tab>
    ```tsx {{ filename: 'app/page.tsx' }}
    'use client'

    import { useUser } from '@clerk/nextjs'

    export default function HomePage() {
      const { isLoaded, user } = useUser()

      if (!isLoaded) {
        // Handle loading state
        return null
      }

      if (!user) return null

      const updateUser = async () => {
        // Update data via an API endpoint
        const updateMetadata = await fetch('/api/updateMetadata')

        // Check if the update was successful
        if (updateMetadata.message !== 'success') {
          throw new Error('Error updating')
        }

        // If the update was successful, reload the user data
        await user.reload()
      }

      return (
        <>
          <button onClick={updateUser}>Update your metadata</button>
          <p>user role: {user?.publicMetadata.role}</p>
        </>
      )
    }
    ```
  </Tab>
</Tabs>

---
title: useUser() | Vue
description: Access and manage the current user's data in your Vue application with Clerk's useUser() composable.
---

The `useUser()` composable provides access to the current user's [`User`](/docs/references/javascript/user) object, which contains all the data for a single user in your application and provides methods to manage their account. This composable also allows you to check if the user is signed in and if Clerk has loaded and initialized.

## Returns

<Properties>
  - `isLoaded`
  - `Ref<boolean>`

  A boolean that indicates whether Clerk has completed initialization. Initially `false`, becomes `true` once Clerk loads.

  ---

  - `user`
  - <code>Ref\<[User](/docs/references/javascript/user)></code>

  The `User` object for the current active user. If the user isn't signed in, `user` will be `null`.

  ---

  - `isSignedIn`
  - `Ref<boolean>`

  Indicates whether a user is currently signed in.
</Properties>

## How to use the `useUser()` composable

### Get the current user

The following example uses the `useUser()` composable to access the [`User`](/docs/references/javascript/user) object, which contains the current user's data such as their full name. The `isLoaded` and `isSignedIn` properties are used to handle the loading state and to check if the user is signed in, respectively.

```vue {{ filename: 'GetCurrentUser.vue' }}
<script setup>
import { useUser } from '@clerk/vue'

const { isSignedIn, user, isLoaded } = useUser()
</script>

<template>
  <div v-if="!isLoaded">
    <!-- Handle loading state -->
  </div>

  <div v-else-if="isSignedIn">Hello {{ user?.fullName }}!</div>

  <div v-else>Not signed in</div>
</template>
```

### Update user data

The following example uses the `useUser()` composable to access the [`User`](/docs/references/javascript/user) object, which calls the [`update()`](/docs/references/javascript/user#update) method to update the current user's information.

```vue {{ filename: 'UpdateUser.vue' }}
<script setup>
import { useUser } from '@clerk/vue'

const { isLoaded, user } = useUser()

const updateUser = async () => {
  await user.value?.update({
    firstName: 'John',
    lastName: 'Doe',
  })
}
</script>

<template>
  <div v-if="!isLoaded">
    <!-- Handle loading state -->
  </div>

  <div v-else-if="user">
    <button @click="updateUser">Update your name</button>
    <p>user.firstName: {{ user?.firstName }}</p>
    <p>user.lastName: {{ user?.lastName }}</p>
  </div>
</template>
```

### Reload user data

The following example uses the `useUser()` composable to access the [`User`](/docs/references/javascript/user) object, which calls the [`reload()`](/docs/references/javascript/user#reload) method to get the latest user's information.

```vue {{ filename: 'ReloadUser.vue' }}
<script setup>
import { useUser } from '@clerk/vue'

const { isLoaded, user } = useUser()

const updateUser = async () => {
  // Update user data via an API endpoint
  const updateMetadata = await fetch('/api/updateMetadata')

  // Check if the update was successful
  if (updateMetadata.message !== 'success') {
    throw new Error('Error updating')
  }

  // If the update was successful, reload the user data
  await user.value?.reload()
}
</script>

<template>
  <div v-if="!isLoaded">
    <!-- Handle loading state -->
  </div>

  <div v-else-if="user">
    <button @click="updateUser">Update your metadata</button>
    <p>user role: {{ user.publicMetadata?.role }}</p>
  </div>
</template>
```

---
title: Verified domains
description: Learn about how to use verified domains for organizations.
---

Verified domains can be used to streamline enrollment into an organization. For example, if the domain `@clerk.com` is verified, any user with an email address ending in `@clerk.com` can be automatically invited or be suggested to join an organization with that domain. The role assigned to this user will be the role set as the [**Default** role](/docs/organizations/roles-permissions#the-default-role-for-members) in the organization settings page. The verified domains feature is useful for organizations that want to restrict membership to users with specific email domains.

A verified domain cannot be a disposable domain or common email provider. For example, you cannot create a verified domain for `@gmail.com`.

> [!WARNING]
> A verified domain can't be added if it's already in use for the [organization's SSO](/docs/organizations/manage-sso).

The easiest way to add and verify domains, and manage all settings related to verified domains is to use Clerk's [`<OrganizationSwitcher />`](/docs/components/organization/organization-switcher) component.

## Enable verified domains

Enabling verified domains applies to all organizations and cannot currently be managed on a per-organization basis.

In order to enable this feature:

1. In the Clerk Dashboard, navigate to the [**Organizations Settings**](https://dashboard.clerk.com/last-active?path=organizations-settings) page.
1. In the **Verified domains** section, enable **Enable verified domains**.
1. The following setting will appear:
   - [**Enrollment mode**](#enrollment-mode) - **Automatic invitation** and **Automatic suggestion**.

### Enrollment mode

You can enable the following enrollment modes to be available for your application:

- [**Automatic invitation**](#automatic-invitations) - Users are automatically invited to join the organization when they sign-up and can join anytime.
- [**Automatic suggestion**](#automatic-suggestions) - Users receive a suggestion to request to join, but must be approved by an admin before they are able to join the organization.

Then, in your application, when a user with the `org:sys_domains:manage` permission has added and verified a domain, they can enable an enrollment mode. Only one enrollment mode can be enabled for a verified domain at a time.

### Automatic invitations

After sign-up, a user will receive an **invitation** for the organization if their email's domain matches the verified domain. If your app uses the `<OrganizationSwitcher />` component, the user will see a notification on the component. When they open the component, they will see a **Join** button next to the organization they were invited to. Selecting the button will accept the invitation and the user will instantly be added as a member of the organization.

### Automatic suggestions

After sign-up, a user will receive a **suggestion** for the organization if their email's domain matches the verified domain. If your app uses the `<OrganizationSwitcher />` component, the user will see a **Request to join** button next to the organization. Selecting the button will send a [membership request](#membership-requests) to the organization.

### Membership requests

Membership requests are requests from users who saw an organization suggestion and requested to join an organization. Membership requests are only available for organizations that have the **Verified domains** feature enabled and the **Automatic suggestions** feature enabled in both the Dashboard and for the specific domain.

When a user sends an organization membership request, users with the `org:sys_memberships:manage` permission (by default, admins) will see a notification on their `<OrganizationSwitcher />` component. They will need to accept the request before the user can join the organization.

## Add and verify domains

Domains can be added and verified under an organization by any user with the `org:sys_domains:manage` permission. By default, admins have this permission. To add and verify domains in the [`<OrganizationSwitcher />`](/docs/components/organization/organization-switcher) component, select the **General** tab. There will be a **Verified domains** section.

Domains can be verified through an email verification code sent to an email that matches the domain. If the user adding the domain already has a verified email using that domain in their account, the domain will be automatically verified.

An application instance may only have one verified domain of the same name, and an organization may only have one domain of the same name (verified or unverified).

You can create up to 10 domains per organization to meet your needs. If you need more than 10 domains, [contact support](/contact/support){{ target: '_blank' }}.

### Custom flow

If Clerk's [`<OrganizationSwitcher />`](/docs/components/organization/organization-switcher) does not meet your specific needs or if you require more control over the logic, you can use the Clerk API to add and verify a domain and update the domain's enrollment mode. Here's an example of how you can do this:

```tsx
const { organization, domains } = useOrganization()

// create domain
const domain = await organization.createDomain('example.com')

// prepare email verification
domain.prepareAffiliationVerification({ affiliationEmailAddress: 'foo@example.com' })

// attempt email verification
domain.attemptAffiliationVerification({ code: '123456' })

// update domain enrollment mode
domain.updateEnrollmentMode({ enrollmentMode: 'automatic_invitation' })
```

---
title: Verify a Clerk session in Go
description: Learn how to verify a session with Clerk in your Go application.
---

There are two ways to verify a session with Clerk in your Go application:

- [Using Clerk middleware](#use-clerk-middleware-to-verify-a-session)
  <br />If you want to verify a session in an HTTP context, it is recommended to use Clerk middleware. Clerk middleware guarantees better performance and efficiency by making the minimum necessary requests to the Clerk Backend API.

- [Manually verifying the session token](#manually-verify-a-session-token)
  <br />If you want to verify a session in a non-HTTP context, or if you would like total control over the verification process, you can verify the session token on your own.

## Use Clerk middleware to verify a session

Go enables you to create a simple HTTP server, and Clerk enables you to authenticate any request. Together, you can create a secure server that only allows authenticated users to access certain routes.

Clerk Go SDK provides two functions for adding authentication to HTTP handlers:

- [`WithHeaderAuthorization()`](https://pkg.go.dev/github.com/clerk/clerk-sdk-go/v2/http#WithHeaderAuthorization)
- [`RequireHeaderAuthorization()`](https://pkg.go.dev/github.com/clerk/clerk-sdk-go/v2/http#RequireHeaderAuthorization), which calls `WithHeaderAuthorization()` under the hood, but responds with `HTTP 403 Forbidden` if it fails to detect valid session claims.

Both middleware functions support header based authentication with a bearer token. The token will be parsed, verified, and its claims will be extracted as [`SessionClaims`](https://pkg.go.dev/github.com/clerk/clerk-sdk-go/v2#SessionClaims).

The claims will then be made available in the `http.Request.Context` for the next handler in the chain. Clerk Go SDK provides the [`SessionClaimsFromContext()`](https://pkg.go.dev/github.com/clerk/clerk-sdk-go/v2#SessionClaimsFromContext) helper for accessing the claims from the context.

The following example demonstrates how to use the `WithHeaderAuthorization()` middleware to protect a route. If the user tries accessing the route and their session token is valid, the user's ID and banned status will be returned in the response.

> [!NOTE]
> Your Clerk Secret Key is required. If you are signed into the Clerk Dashboard, your Secret Key should become visible by selecting the eye icon. Otherwise, you can retrieve your Clerk Secret Key on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.

```go {{ filename: 'main.go' }}
package main

import (
  "fmt"
  "net/http"

  "github.com/clerk/clerk-sdk-go/v2"
  clerkhttp "github.com/clerk/clerk-sdk-go/v2/http"
  "github.com/clerk/clerk-sdk-go/v2/user"
)

func main() {
  clerk.SetKey("{{secret}}")

  mux := http.NewServeMux()
  mux.HandleFunc("/", publicRoute)
  protectedHandler := http.HandlerFunc(protectedRoute)
  mux.Handle(
    "/protected",
    clerkhttp.WithHeaderAuthorization()(protectedHandler),
  )

  http.ListenAndServe(":3000", mux)
}

func publicRoute(w http.ResponseWriter, r *http.Request) {
  w.Write([]byte(`{"access": "public"}`))
}

func protectedRoute(w http.ResponseWriter, r *http.Request) {
  claims, ok := clerk.SessionClaimsFromContext(r.Context())
  if !ok {
    w.WriteHeader(http.StatusUnauthorized)
    w.Write([]byte(`{"access": "unauthorized"}`))
    return
  }

  usr, err := user.Get(r.Context(), claims.Subject)
  if err != nil {
    // handle the error
  }
  fmt.Fprintf(w, `{"user_id": "%s", "user_banned": "%t"}`, usr.ID, usr.Banned)
}
```

## Manually verify a session token

Verifying a Clerk session manually is useful when you want to verify a session in a non-HTTP context, or if you would like total control over the verification process. With the solution above, Clerk middleware makes the minimum necessary requests to the Clerk Backend API. With this solution, you must be mindful of API rate limits.

Verifying a session token requires providing a JSON Web Key. When using Clerk middleware to verify a session, it fetches the JSON Web Key once and caches it for you. However, when manually verifying a session, there's no caching layer for the JSON Web Key.

Clerk Go SDK provides a set of functions for decoding and verifying JWTs, as well as fetching JSON Web Keys. It is recommended to cache your JSON Web Key and invalidate the cache only when a replacement key is generated.

The following example demonstrates how to manually verify a session token. If the user tries accessing the route and their session token is valid, the user's ID and banned status will be returned in the response.

```go {{ filename: 'main.go' }}
package main

import (
	"fmt"
	"net/http"
	"strings"

	"github.com/clerk/clerk-sdk-go/v2"
	"github.com/clerk/clerk-sdk-go/v2/jwt"
	"github.com/clerk/clerk-sdk-go/v2/user"
)

func main() {
  clerk.SetKey("{{secret}}")

	mux := http.NewServeMux()
	mux.HandleFunc("/", publicRoute)
	mux.HandleFunc("/protected", protectedRoute)

	http.ListenAndServe(":3000", mux)
}

func publicRoute(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte(`{"access": "public"}`))
}

func protectedRoute(w http.ResponseWriter, r *http.Request) {
	// Get the session JWT from the Authorization header
	sessionToken := strings.TrimPrefix(r.Header.Get("Authorization"), "Bearer ")

	// Verify the session
	claims, err := jwt.Verify(r.Context(), &jwt.VerifyParams{
		Token: sessionToken,
	})
	if err != nil {
		// handle the error
		w.WriteHeader(http.StatusUnauthorized)
		w.Write([]byte(`{"access": "unauthorized"}`))
		return
	}

	usr, err := user.Get(r.Context(), claims.Subject)
	if err != nil {
		// handle the error
	}
	fmt.Fprintf(w, `{"user_id": "%s", "user_banned": "%t"}`, usr.ID, usr.Banned)
}
```

If you need to verify session tokens frequently, it's recommended to cache the JSON Web Key for your instance in order to avoid making too many requests to the Clerk Backend API.

The following example includes the same code as above, with the addition of demonstrating a possible way to store your JSON Web Key. The example is meant to serve as a guide; implementation may vary depending on your needs.

```go {{ filename: 'main.go' }}
package main

import (
	"fmt"
	"net/http"
	"strings"

	"github.com/clerk/clerk-sdk-go/v2"
	"github.com/clerk/clerk-sdk-go/v2/jwks"
	"github.com/clerk/clerk-sdk-go/v2/jwt"
	"github.com/clerk/clerk-sdk-go/v2/user"
)

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", publicRoute)

	// Initialize storage for JSON Web Keys. You can cache/store
	// the key for as long as it's valid, and pass it to jwt.Verify.
	// This way jwt.Verify won't make requests to the Clerk
	// Backend API to refetch the JSON Web Key.
	// Make sure you refetch the JSON Web Key whenever your
	// Clerk Secret Key changes.
	jwkStore := NewJWKStore()

	config := &clerk.ClientConfig{}
	config.Key = clerk.String("{{secret}}")
	jwksClient := jwks.NewClient(config)
	mux.HandleFunc("/protected", protectedRoute(jwksClient, jwkStore))

	http.ListenAndServe(":3000", mux)
}

func publicRoute(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte(`{"access": "public"}`))
}

func protectedRoute(jwksClient *jwks.Client, store JWKStore) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		// Get the session JWT from the Authorization header
		sessionToken := strings.TrimPrefix(r.Header.Get("Authorization"), "Bearer ")

		// Attempt to get the JSON Web Key from your store.
		jwk := store.GetJWK()
		if jwk == nil {
			// Decode the session JWT so that we can find the key ID.
			unsafeClaims, err := jwt.Decode(r.Context(), &jwt.DecodeParams{
				Token: sessionToken,
			})
			if err != nil {
				// handle the error
				w.WriteHeader(http.StatusUnauthorized)
				w.Write([]byte(`{"access": "unauthorized"}`))
				return
			}

			// Fetch the JSON Web Key
			jwk, err = jwt.GetJSONWebKey(r.Context(), &jwt.GetJSONWebKeyParams{
				KeyID:      unsafeClaims.KeyID,
				JWKSClient: jwksClient,
			})
			if err != nil {
				// handle the error
				w.WriteHeader(http.StatusUnauthorized)
				w.Write([]byte(`{"access": "unauthorized"}`))
				return
			}
		}
		// Write the JSON Web Key to your store, so that next time
		// you can use the cached value.
		store.SetJWK(jwk)

		// Verify the session
		claims, err := jwt.Verify(r.Context(), &jwt.VerifyParams{
			Token: sessionToken,
			JWK:   jwk,
		})
		if err != nil {
			// handle the error
			w.WriteHeader(http.StatusUnauthorized)
			w.Write([]byte(`{"access": "unauthorized"}`))
			return
		}

		usr, err := user.Get(r.Context(), claims.Subject)
		if err != nil {
			// handle the error
		}
		fmt.Fprintf(w, `{"user_id": "%s", "user_banned": "%t"}`, usr.ID, usr.Banned)
	}
}

// Sample interface for JSON Web Key storage.
// Implementation may vary.
type JWKStore interface {
	GetJWK() *clerk.JSONWebKey
	SetJWK(*clerk.JSONWebKey)
}

func NewJWKStore() JWKStore {
	// Implementation may vary. This can be an
	// in-memory store, database, caching layer,...
	return nil
}
```

---
title: Verify the active user's permissions in an organization
description: A collection of utility functions and components in order to allow developers to perform authorization checks.
---

> [!IMPORTANT]
> The following authorization checks are predicated on a user having an active organization. Without this, they will likely always evaluate to false by default. Learn more about [active organizations](/docs/organizations/overview#active-organization). If you would like to perform authorization checks without using Clerk's organizations feature, see [the Role Based Access Control (RBAC) guide](/docs/references/nextjs/basic-rbac).

In general, you should always verify whether or not a user is authorized to access sensitive information, important content, or exclusive features. The most secure way to implement authorization is by checking the active user's [role or permissions](/docs/organizations/roles-permissions#permissions). It's recommended to use permission-based authorization over role-based authorization, as it's more flexible, easier to manage, and more secure.

Clerk enables two broad approaches to role and permissions-based authorization:

1. If you would like to immediately prevent unauthorized users from accessing content, you can:
   - Use the [`<Protect>`](/docs/components/protect) component to prevent content from rendering if the active user is unauthorized.
   - Call [`auth.protect()`](/docs/references/nextjs/auth#auth-protect) to throw a `404` error if the active user is unauthorized.
1. If you would like more control over the response when a user is unauthorized, you can:
   - Call the [`has()`](/docs/references/backend/types/auth-object#has) helper, which returns `false` if the active user lacks the role or permissions you're checking for. You can _choose_ how your app responds instead of immediately preventing content from rendering or throwing an error.

## Authorization in Client Components

The following examples work for both SSR and CSR.

<Tabs items={["<Protect>", "has()"]}>
  <Tab>
    The following example uses the `<Protect>` component to only render the form for users with the correct permission. The example uses the `fallback` prop to render a different UI if the user is not authorized.

    ```tsx {{ filename: 'app/dashboard/settings/form.tsx' }}
    'use client'
    import { Protect } from '@clerk/nextjs'

    export default function SettingsForm() {
      return (
        <Protect
          permission="org:team_settings:manage"
          fallback={<p>You are not allowed to see this section.</p>}
        >
          <form>{/* Add UI for managing team settings */}</form>
        </Protect>
      )
    }
    ```
  </Tab>

  <Tab>
    The following example uses `has()` to inspect a user's permissions granularly. If the user doesn't have the permission, `has()` returns `false`, causing the component to return `null` instead of rendering its children.

    ```tsx {{ filename: 'app/dashboard/settings/form.tsx' }}
    'use client'
    import { useAuth } from '@clerk/nextjs'

    export default function SettingsForm() {
      const { has } = useAuth()

      if (!has) return null

      // Check if the user is authorized
      const canManageSettings = has({ permission: 'org:team_settings:manage' })

      // If has() returns false, the user does not have the correct permissions
      // You can choose how your app responds. This example returns null.
      if (!canManageSettings) return null

      // If the user is both authenticated and authorized, move forward with your logic
      return <form>{/* Add UI for managing team settings */}</form>
    }
    ```
  </Tab>
</Tabs>

## Authorization in React Server Components

<Tabs items={["<Protect>", "has()", "auth.protect()"]}>
  <Tab>
    The following example uses the `<Protect>` component to only render the layout for users with the correct permission. If the user is not authorized, the component will not render its children.

    > [!WARNING]
    > Be cautious when doing authorization checks in layouts, as these don't re-render on navigation, meaning the user session won't be checked on every route change. [Read more in the Next.js docs](https://nextjs.org/docs/app/building-your-application/authentication#layouts-and-auth-checks).

    ```tsx {{ filename: 'app/dashboard/settings/layout.tsx' }}
    import type { PropsWithChildren } from 'react'
    import { Protect } from '@clerk/nextjs'

    export default function SettingsLayout(props: PropsWithChildren) {
      return <Protect permission="org:team_settings:read">{props.children}</Protect>
    }
    ```
  </Tab>

  <Tab>
    The following example uses `has()` to inspect a user's permissions granularly. If the user doesn't have the correct permission, `has()` returns `false`, causing the component to return `null` instead of rendering its children.

    > [!WARNING]
    > Be cautious when doing authorization checks in layouts, as these don't re-render on navigation, meaning the user session won't be checked on every route change. [Read more in the Next.js docs](https://nextjs.org/docs/app/building-your-application/authentication#layouts-and-auth-checks).

    ```tsx {{ filename: 'app/dashboard/settings/layout.tsx' }}
    import type { PropsWithChildren } from 'react'
    import { auth } from '@clerk/nextjs/server'

    export default async function SettingsLayout(props: PropsWithChildren) {
      const { has } = await auth()

      // Check if the user is authorized
      const canAccessSettings = has({ permission: 'org:team_settings:read' })

      // If has() returns false, the user does not have the correct permissions
      // You can choose how your app responds. This example returns null.
      if (!canAccessSettings) return null

      return props.children
    }
    ```
  </Tab>

  <Tab>
    > [!WARNING]
    > [`auth.protect()`](/docs/references/nextjs/auth#auth-protect) is only available for App Router, and only works on the server-side.

    The following example uses [`auth.protect()`](/docs/references/nextjs/auth#auth-protect) to protect a RSC from unauthenticated and unauthorized access.

    - If the user is not authenticated, `auth.protect()` will redirect the user to the sign-in route.
    - If the user is authenticated but is not authorized (as in, does not have the `org:team_settings:read` permission), `auth.protect()` will throw a `404` error.
    - If the user is both authenticated and authorized, `auth.protect()` will return the user's `userId`.

    ```tsx {{ filename: 'app/dashboard/settings/page.tsx' }}
    import { auth } from '@clerk/nextjs/server'

    export default async function Page() {
      const { userId } = await auth.protect({ permission: 'org:team_settings:read' })

      return <p>{userId} is authorized to access this page.</p>
    }
    ```
  </Tab>
</Tabs>

## Authorization in endpoints

<Tabs items={["Next.js Server Actions", "Next.js Route Handlers", "Next.js Pages Router"]}>
  <Tab>
    The following example uses `has()` to inspect a user's permissions granularly in a Next.js Server Action. If the user doesn't have the correct permission, `has()` returns `false`, causing the Server Action to return a `403` error.

    ```tsx {{ filename: 'app/components/ExampleServerComponent.tsx' }}
    import { auth } from '@clerk/nextjs/server'

    export default async function ExampleServerComponent() {
      async function myServerAction(formData: FormData) {
        'use server'
        const { has } = await auth()

        // Check if the user is authorized
        const canManage = has({ permission: 'org:team_settings:manage' })

        // If has() returns false, the user does not have the correct permissions
        // You can choose how your app responds. This example returns a 403 error.
        if (!canManage)
          return Response.json({ error: 'User does not have the correct permissions' }, { status: 403 })

        // If the user is both authenticated and authorized, move forward with your logic
        return users.getTeams(userId)
      }

      return (
        <form action={myServerAction}>
          {/* Add UI for managing team settings */}
          <button type="submit">Submit</button>
        </form>
      )
    }
    ```
  </Tab>

  <Tab>
    <Tabs items={["has()", "auth.protect()"]}>
      <Tab>
        The following example demonstrates how to use `has()` in a Next.js Route Handler.

        The example:

        - uses the `userId` returned from [`auth()`](/docs/references/nextjs/auth) to check if the user is signed in. If the user is not **authenticated**, the Route Handler will return a `401` error.
        - uses `has()` to check if the user has the correct permission. If the user is not **authorized**, `has()` will return false, causing the Route Handler to return a `403` error.

        ```tsx {{ filename: 'app/api/get-teams/route.tsx' }}
        import { auth } from '@clerk/nextjs/server'

        export const GET = async () => {
          const { userId, has } = await auth()

          // Check if the user is authenticated
          if (!userId) {
            return Response.json({ error: 'User is not signed in' }, { status: 401 })
          }

          // Check if the user is authorized
          const canRead = has({ permission: 'org:team_settings:read' })

          // If has() returns false, the user does not have the correct permissions
          // You can choose how your app responds. This example returns a 403 error.
          if (!canRead)
            return Response.json({ error: 'User does not have the correct permissions' }, { status: 403 })

          // If the user is both authenticated and authorized, move forward with your logic
          return users.getTeams(userId)
        }
        ```
      </Tab>

      <Tab>
        > [!WARNING]
        > [`auth.protect()`](/docs/references/nextjs/auth#auth-protect) is only available for App Router, and only works on the server-side.

        The following example uses [`auth.protect()`](/docs/references/nextjs/auth#auth-protect) to protect a Next.js Route Handler from unauthenticated and unauthorized access.

        - If the user is not authenticated nor authorized (as in, does not have the `org:team_settings:manage` permission), `auth.protect()` will throw a `404` error.
        - If the user is both authenticated and authorized, `auth.protect()` will return the user's `userId`.

        ```tsx {{ filename: 'app/api/create-team/route.tsx' }}
        import { auth } from '@clerk/nextjs/server'

        export const GET = async () => {
          const { userId } = await auth.protect({
            permission: 'org:team_settings:manage',
          })

          return Response.json({ userId })
        }
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab>
    Use the [`getAuth()`](/docs/references/nextjs/get-auth) helper to access the `has()` helper in a Next.js Pages Router application.

    The following example:

    - uses the `userId` returned from `getAuth()` to check if the user is signed in. If the user is not **authenticated**, the route will return a `401` error.
    - uses `has()` to check if the user has the correct permission. If the user is not **authorized**, `has()` will return false, causing the route to return a `403` error.

    ```tsx {{ filename: 'src/pages/api/get-teams.ts' }}
    import { getAuth } from '@clerk/nextjs/server'

    export default async function handler(req: NextApiRequest) {
      const { userId, has } = await getAuth(req)

      // Check if the user is authenticated
      if (!userId) return res.status(401)

      // Check if the user is authorized
      const canRead = has({ permission: 'org:team_settings:read' })

      // If has() returns false, the user does not have the correct permissions
      // You can choose how your app responds. This example returns a 403 error.
      if (!canRead) return res.status(403)

      // If the user is both authenticated and authorized, move forward with your logic
      return users.getTeams(userId)
    }
    ```
  </Tab>
</Tabs>

## Authorization in Remix Loaders

The following example uses the [`has()`](/docs/references/backend/types/auth-object#has) helper to check if the user has the correct permission. If the user is not authorized, `has()` will return false, causing the loader to redirect the user to the `/request-access` route.

<Tabs items={["Remix"]}>
  <Tab>
    ```tsx
    export const loader: LoaderFunction = async (args) => {
      const { has } = await getAuth(args)

      if (has({ permission: 'org:team_settings:manage' }) === false) {
        return redirect('/request-access')
      }

      return {}
    }

    export default function Settings() {
      return (
        <div>
          <h1>Settings Page</h1>
        </div>
      )
    }
    ```
  </Tab>
</Tabs>

## Authorization in JavaScript

If you are not using React or any of the meta-frameworks we support, you can use the [Clerk JavaScript SDK](/docs/references/javascript/overview). The following example demonstrates how to use the [`checkAuthorization()`](/docs/references/javascript/session#check-authorization) method to check if a user is authorized.

<Tabs items={["JavaScript"]}>
  <Tab>
    ```tsx {{ filename: 'main.js' }}
    import { Clerk } from '@clerk/clerk-js'

    const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

    const clerk = new Clerk(clerkPubKey)
    await clerk.load()

    // Check if the user is authenticated
    if (clerk.user) {
      // Check if the user is authorized
      const canManageSettings = clerk.session.checkAuthorization({
        permission: 'org:team_settings:manage',
      })
    }
    ```
  </Tab>
</Tabs>

## Authorize with roles

> [!WARNING]
> It's best practice to use permission-based authorization over role-based authorization, as it's more flexible and easier to manage. Usually, complex role checks can be refactored with a single permission check.

You can pass a `role` the same way you can pass a `permission` in all the examples above.

<Tabs items={[ "RSC with <Protect>", "RSC with auth.protect()", "Client Component with has()", ]}>
  <Tab>
    The following example uses `<Protect>`'s `condition` prop to conditionally render its children if the user has the correct role.

    ```tsx {{ filename: 'app/dashboard/settings/Page.tsx' }}
    import { Protect } from '@clerk/nextjs'

    export default function Page() {
      return (
        <Protect
          condition={(has) => has({ role: 'org:admin' }) || has({ role: 'org:billing_manager' })}
        >
          <p>Admin settings</p>
        </Protect>
      )
    }
    ```
  </Tab>

  <Tab>
    > [!WARNING]
    > [`auth.protect()`](/docs/references/nextjs/auth#auth-protect) is only available for App Router, and only works on the server-side.

    The following example uses [`auth.protect()`](/docs/references/nextjs/auth#auth-protect) to protect a RSC from unauthenticated and unauthorized access.

    - If the user is not authenticated, `auth.protect()` will redirect the user to the sign-in route.
    - If the user is authenticated but is not authorized (as in, does not have the `org:admin` or `org:billing_manager` role), `auth.protect()` will throw a `404` error.
    - If the user is both authenticated and authorized, `auth.protect()` will return the user's `userId`.

    ```tsx {{ filename: 'app/dashboard/settings/page.tsx' }}
    import { auth } from '@clerk/nextjs/server'

    export default async function Page() {
      const { userId } = await auth.protect(
        (has) => has({ role: 'org:admin' }) || has({ role: 'org:billing_manager' }),
      )

      return <p>{userId} is authorized to access this page.</p>
    }
    ```
  </Tab>

  <Tab>
    The following example uses `has()` to inspect a user's roles granularly. If the user doesn't have the correct role, `has()` returns `false`, causing the component to return `null` instead of rendering its children.

    ```tsx {{ filename: 'app/dashboard/settings/form.tsx' }}
    'use client'
    import { useAuth } from '@clerk/nextjs'

    export function SettingsForm() {
      const { has } = useAuth()

      // Check if the user is authorized
      const canAccessSettings = has({ role: 'org:admin' }) || has({ role: 'org:billing_manager' })

      // If has() returns false, the user does not have the correct permissions
      // You can choose how your app responds. This example returns null.
      if (!canAccessSettings) return null

      // If the user is both authenticated and authorized, move forward with your logic
      return <form>{/* Add UI for team settings */}</form>
    }
    ```
  </Tab>
</Tabs>

## Add custom types for roles and permissions

In order to enhance typesafety in your project, you can define a global `ClerkAuthorization` interface, which defines the acceptable values for roles and permissions.

> [!NOTE]
> By default, roles and permission types, such as `OrganizationCustomRoleKey` and `OrganizationCustomPermissionKey`, are assigned `string`. However, if a `ClerkAuthorization` type is defined, it will be utilized instead.

In the example below, `ClerkAuthorization` is defined with the default roles that Clerk provides.

```tsx {{ filename: 'types/globals.d.ts' }}
export {}

declare global {
  interface ClerkAuthorization {
    permission: ''
    role: 'org:admin' | 'org:member'
  }
}
```

Because Clerk supports custom roles and permissions, you can modify `ClerkAuthorization` to align with the roles and permissions configured in your Clerk application. See how in the example below, the default Clerk roles `org:admin` and `org:member` are replaced with custom roles `org:super_admin`, `org:teacher`, and `org:student`.

```tsx {{ filename: 'types/globals.d.ts' }}
export {}

declare global {
  interface ClerkAuthorization {
    permission: 'org:quiz:create' | 'org:quiz:grade' | 'org:quiz:read' | 'org:quiz:fill'
    role: 'org:super_admin' | 'org:teacher' | 'org:student'
  }
}
```

---
title: Versioning overview
description: A brief guide on how versioning works in Clerk.
---

When backwards incompatible changes are necessary for an API, new versions are released to prevent disruption to existing applications. These versions are identified by their release date, such as 2021-02-05. Both the frontend and backend APIs follow the same version.

A complete list of all the available versions with their changes can be found on the [API versions](/docs/versioning/available-versions) page.

## What constitutes a breaking change

A breaking change is any modification that would require users to alter their existing setups. These include:

- **Change in property type**: Altering the data type of a property in either requests or responses.
- **Removal of a property**: Deleting a property or parameter from a request or response.
- **Change in property name**: Renaming a property in request or response payloads.
- **Backwards incompatible endpoint changes**: Implementing changes in an endpoint's functionality that older client versions cannot support. For instance, adding a new status to the sign-in process.
- **Endpoint removal**: Discontinuing access to an existing endpoint, which remains accessible in earlier versions.

## When using an SDK

Each Clerk SDK version corresponds to a specific API version, so by updating the SDK, you're also updating to the latest compatible API version.

### Choosing an API version

When making direct API calls to an endpoint, there are two options to specify the version:

1. **Query parameter**: Set the `__clerk_api_version` query parameter in your request URL.
1. **Clerk-API-Version header**: Include a `Clerk-API-Version` header in your requests.

> [!NOTE]
> You must choose only one method to specify a version. Using both the query parameter and the header simultaneously will lead to an invalid request.
> The same is also true when the version is invalid.

---
title: Vue Quickstart
description: Add authentication and user management to your Vue app with Clerk.
---

<TutorialHero
  exampleRepo={[
    {
      title: "Vue Quickstart Repo",
      link: "https://github.com/clerk/clerk-vue-quickstart"

    }
  ]}
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
      icon: "clerk",
    }
  ]}
/>

This tutorial assumes that you're using [Vue 3](https://vuejs.org/) with [TypeScript](https://www.typescriptlang.org/).

<Steps>
  ### Create a Vue app using Vite

  Run the following commands to create a new Vue app using [Vite](https://vitejs.dev/guide/#scaffolding-your-first-vite-project):

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm create vite@latest clerk-vue -- --template vue-ts
    cd clerk-vue
    npm install
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn create vite clerk-vue --template vue-ts
    cd clerk-vue
    yarn install
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm create vite clerk-vue --template vue-ts
    cd clerk-vue
    pnpm install
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun create vite clerk-vue --template vue-ts
    cd clerk-vue
    bun install
    bun dev
    ```
  </CodeBlockTabs>

  ### Install `@clerk/vue`

  The [Clerk Vue SDK](/docs/references/vue/overview) gives you access to prebuilt components, composables, and helpers to make user authentication easier.

  Run the following command to install the SDK:

  <CodeBlockTabs options={["npm", "yarn",  "pnpm" ]}>
    ```bash {{ filename: 'terminal' }}
    npm install @clerk/vue
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @clerk/vue
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @clerk/vue
    ```
  </CodeBlockTabs>

  ### Set your Clerk API keys

  <SignedIn>
    Add your Clerk Publishable Key to your `.env` file. This key can always be retrieved from the [**API Keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.
  </SignedIn>

  <SignedOut>
    1. In the Clerk Dashboard, navigate to the [**API Keys**](https://dashboard.clerk.com/last-active?path=api-keys) page.
    1. In the **Quick Copy** section, copy your Clerk Publishable Key.
    1. Paste your key into your `.env` file.

    The final result should resemble the following:
  </SignedOut>

  ```env {{ filename: '.env' }}
  VITE_CLERK_PUBLISHABLE_KEY={{pub_key}}
  ```

  ### Import the Clerk Publishable Key

  In your `main.ts` file, import your Clerk Publishable Key. You can add an `if` statement to check that the key is imported properly. This prevents the app from running without the Publishable Key and catches TypeScript errors.

  ```tsx {{ filename: 'src/main.ts', mark: [5, [7, 9]] }}
  import { createApp } from 'vue'
  import './style.css'
  import App from './App.vue'

  const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  if (!PUBLISHABLE_KEY) {
    throw new Error('Add your Clerk Publishable Key to the .env file')
  }

  createApp(App).mount('#app')
  ```

  ### Add `clerkPlugin` to your app

  `clerkPlugin` provides active session and user context to Clerk's components and composables. It's required to pass your Publishable Key as an option.

  ```ts {{ filename: 'src/main.ts', mark: [4, [12, 14]] }}
  import { createApp } from 'vue'
  import './style.css'
  import App from './App.vue'
  import { clerkPlugin } from '@clerk/vue'

  const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

  if (!PUBLISHABLE_KEY) {
    throw new Error('Add your Clerk Publishable Key to the .env file')
  }

  const app = createApp(App)
  app.use(clerkPlugin, { publishableKey: PUBLISHABLE_KEY })
  app.mount('#app')
  ```

  ### Create a header with Clerk components

  You can control which content signed-in and signed-out users can see with Clerk's [prebuilt control components](/docs/components/overview#control-components). The following example creates a header using the following components:

  - [`<SignedIn>`](/docs/components/control/signed-in): Children of this component can only be seen while **signed in**.
  - [`<SignedOut>`](/docs/components/control/signed-out): Children of this component can only be seen while **signed out**.
  - [`<UserButton />`](/docs/components/user/user-button): Shows the signed-in user's avatar. Selecting it opens a dropdown menu with account management options.
  - [`<SignInButton />`](/docs/components/unstyled/sign-in-button): An unstyled component that links to the sign-in page or displays the sign-in modal.

  ```vue {{ filename: 'src/App.vue', mark: [2, [6, 13]] }}
  <script setup lang="ts">
  import { SignedIn, SignedOut, SignInButton, UserButton } from '@clerk/vue'
  </script>

  <template>
    <header>
      <SignedOut>
        <SignInButton />
      </SignedOut>
      <SignedIn>
        <UserButton />
      </SignedIn>
    </header>
  </template>
  ```

  ### Create your first user

  Run your project with the following command:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm run dev
    ```

    ```bash {{ filename: 'terminal' }}
    yarn dev
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm dev
    ```

    ```bash {{ filename: 'terminal' }}
    bun dev
    ```
  </CodeBlockTabs>

  Visit your app's homepage at [`http://localhost:5173`](http://localhost:5173). Sign up to create your first user.
</Steps>

## More resources

Learn more about Clerk components, how to customize them, and how to use Clerk's client-side helpers using the following guides.

<Cards>
  - [Prebuilt components](/docs/components/overview)
  - Learn more about Clerk's suite of components that let you quickly add authentication to your app.

  ---

  - [Customization & localization](/docs/customization/overview)
  - Learn how to customize and localize Clerk components.

  ---

  - [Client-side helpers (composables)](/docs/references/vue/use-user)
  - Learn more about Clerk's client-side helpers and how to use them.
</Cards>

---
title: Vulnerability disclosure policy
description: Clerk's vulnerability disclosure policy.
---

## Guidelines

We require that all researchers:

1. Make every effort to avoid privacy violations, degradation of user experience, disruption to production systems, and destruction of data during security testing.
1. Perform research only within the scope set out below.
1. Use the identified communication channels to report vulnerability information to us.
1. Keep information about any vulnerabilities you've discovered confidential between yourself and Clerk, Inc. until we've had 90 days to resolve the issue.

If you follow these guidelines when reporting an issue to us, we commit to:

- Not pursue or support any legal action related to your research;
- Work with you to understand and resolve the issue quickly (including an initial confirmation of your report within 72 hours of submission);

## Scope

- `https://dashboard.clerk.com`
- `https://accounts.clerk.com`
- `https://api.clerk.com`
- `https://clerk.clerk.com`
- Production instances created on `https://dashboard.clerk.com`

## Out of scope

Any services hosted by 3rd party providers and services are excluded from scope. These services include:

- `https://clerk.com`

In the interest of the safety of our users, staff, the Internet at large and you as a security researcher, the following test types are excluded from scope:

- Findings in Development or Staging instances created on `https://dashboard.clerk.com`
- Findings from physical testing such as office access (e.g. open doors, tailgating)
- Findings derived primarily from social engineering (e.g. phishing, vishing)
- Findings from applications or systems not listed in the Scope section
- UI and UX bugs and spelling mistakes
- Network level Denial of Service (DoS/DDoS) vulnerabilities

## Things we do not want to receive

- Personally identifiable information (PII)
- Credit card holder data

## How to report a security vulnerability

If you believe you've found a security vulnerability in one of our products or platforms send it to us by emailing [security@clerk.dev](mailto:security@clerk.dev). Include the following details with your report:

Description of the location and potential impact of the vulnerability; and
A detailed description of the steps required to reproduce the vulnerability (POC scripts, screenshots, and compressed screen captures are all helpful to us).

---
title: Web support
description: Add web support to your Expo project with Clerk.
---

Expo provides a way to [develop web applications](https://docs.expo.dev/workflow/web/) using the same codebase as your iOS and Android apps. Though Clerk prebuilt components cannot be used in native apps, they can be used in web applications built with Expo.

## Create a new project with web support

If you're starting from scratch, you can follow the [Expo quickstart](/docs/quickstarts/expo), which showcases how to create a sign-in and sign-up page with the same code for all platforms Expo supports.

## Add web support to an existing project

If you already have an Expo project and want to add web support, you must first ensure that your existing Clerk [custom flows](/docs/custom-flows/overview) do not have any native-specific code. If you have any native-specific code you will have to either adjust your custom flows to also work on web by leveraging [platform-specific code](https://reactnative.dev/docs/platform-specific-code#platform-specific-extensions), if you are using Expo Router you can also take a look at the [platform-specific modules](https://docs.expo.dev/router/advanced/platform-specific-modules/) guide.

> [!WARNING]
> Clerk prebuilt components are only available on the web platform. If you're using Expo for iOS or Android, you'll need to build components using [custom flows](/docs/custom-flows/overview).

## More resources

Use the following guides to learn more about Clerk components, how to build custom flows for your native apps, and how to use Clerk's client-side helpers.

<Cards>
  - [Prebuilt components](/docs/components/overview)
  - Learn more about Clerk's suite of components that let you quickly add authentication to your app.

  ---

  - [Customization & localization](/docs/customization/overview)
  - Learn how to customize and localize Clerk components.

  ---

  - [Client-side helpers](/docs/references/expo/overview#hooks)
  - Learn more about Clerk's client-side helpers and how to use them.
</Cards>

---
title: Web3Wallet
description: The Web3Wallet object describes a Web3 wallet address. The address can be used as a proof of identification for users.
---

The `Web3Wallet` object describes a Web3 wallet address. The address can be used as a proof of identification for users.

Web3 addresses must be verified to ensure that they can be assigned to their rightful owners. The verification is completed via Web3 wallet browser extensions, such as [Metamask](https://metamask.io/), [Coinbase Wallet](https://www.coinbase.com/wallet), and [OKX Wallet](https://www.okx.com/help/section/faq-web3-wallet). The `Web3Wallet3` object holds all the necessary state around the verification process.

The verification process always starts with the [`Web3Wallet.prepareVerification()`](/docs/references/javascript/types/web3-wallet#prepare-verification) or [`signIn.prepareFirstFactor()`](/docs/references/javascript/sign-in#prepare-first-factor) method, which will send the wallet address to the [Frontend API](/docs/reference/frontend-api){{ target: '_blank' }} and will receive a nonce that needs to be signed by the Web3 wallet browser extension.

The second and final step involves an attempt to complete the verification by calling [`Web3Wallet.attemptVerification()`](/docs/references/javascript/types/web3-wallet#attempt-verification) method, passing the generated signature as a parameter.

## Properties

<Properties>
  - `id`
  - `string`

  The unique ID for the Web3 wallet.

  ---

  - `web3Wallet`
  - `string`

  The Web3 wallet address, made up of 0x + 40 hexadecimal characters.

  ---

  - `verification`
  - [`Verification`](/docs/references/javascript/types/verification)

  An object holding information on the verification of this Web3 wallet.
</Properties>

## Methods

### `create()`

Creates a new Web3 wallet.

```typescript
function create(): Promise<Web3Wallet>
```

### `destroy()`

Deletes this Web3 wallet.

```typescript
function destroy(): Promise<void>
```

### `toString()`

Returns the `web3Wallet` hexadecimal string.

```typescript
function toString(): string
```

## `prepareVerification()`

Kick off the verification process for this Web3 wallet. The user will be prompted to sign a generated nonce by the browser extension e.g MetaMask. Returns a `Web3Wallet` object.

```typescript
function prepareVerification(params: PrepareWeb3WalletVerificationParams): Promise<Web3Wallet>
```

### `PrepareWeb3WalletVerificationParams`

<Properties>
  - `strategy`
  - `'web3_metamask_signature'` | `'web3_coinbase_wallet_signature'` | `'web3_okx_wallet_signature'`

  The verification strategy to validate the user's sign-up request. The following strategies are supported:

  - `'web3_metamask_signature'`: User will need to sign a message and generate a signature using MetaMask browser extension.
  - `'web3_coinbase_wallet_signature'`: User will need to sign a message and generate a signature using Coinbase Wallet.
  - `'web3_okx_wallet_signature'`: User will need to sign a message and generate a signature using OKX Wallet.
</Properties>

## `attemptVerification()`

Attempts to verify this Web3 wallet, by passing the generated signature. Returns a `Web3Wallet` object.

```typescript
function attemptVerification(params: AttemptWeb3WalletVerificationParams): Promise<Web3Wallet>
```

### `AttemptWeb3WalletVerificationParams`

<Properties>
  - `signature`
  - `string`

  The signature that was generated after [`prepareVerification`](#prepare-verification) was called.
</Properties>

---
title: Webhooks overview
description: Clerk webhooks allow you to receive event notifications from Clerk.
---

A webhook is an _event-driven_ method of communication between applications.

Unlike typical APIs where you would need to poll for data very frequently to get it "real-time", webhooks only send data when there is an event to trigger the webhook. This makes webhooks seem "real-time", but it's important to note that they are asynchronous.

For example, if you are onboarding a new user, you can't rely on the webhook delivery as part of that flow. Typically the delivery will happen quickly, but it's not guaranteed to be delivered immediately or at all. Webhooks are best used for things like sending a notification or updating a database, but not for synchronous flows where you need to know the webhook was delivered before moving on to the next step. If you need a synchronous flow, see the [onboarding guide](/docs/references/nextjs/add-onboarding-flow) for an example.

## Clerk webhooks

Clerk webhooks allow you to receive event notifications from Clerk, such as when a user is created or updated. When an event occurs, Clerk will send an HTTP `POST` request to your webhook endpoint configured for the event type. The payload carries a JSON object. You can then use the information from the request's JSON payload to trigger actions in your app, such as sending a notification or updating a database.

Clerk uses [Svix](https://svix.com/) to send our webhooks.

You can find the Webhook signing secret when you select the endpoint you created on the [**Webhooks**](https://dashboard.clerk.com/last-active?path=webhooks) page in the Clerk Dashboard.

## Supported webhook events

To find a list of all the events Clerk supports:

1. In the Clerk Dashboard, navigate to the [**Webhooks**](https://dashboard.clerk.com/last-active?path=webhooks) page.
1. Select the **Event Catalog** tab.

## Payload structure

The payload of a webhook is a JSON object that contains the following properties:

- `data`: contains the actual payload sent by Clerk. The payload can be a different object depending on the `event` type. For example, for `user.*` events, the payload will always be the [User](/docs/references/javascript/user) object.
- `object`: always set to `event`.
- `type`: the type of event that triggered the webhook.
- `timestamp`: timestamp in milliseconds of when the event occurred.
- `instance_id`: the identifier of your Clerk instance.

The following example shows the payload of a `user.created` event:

```json
{
  "data": {
    "birthday": "",
    "created_at": 1654012591514,
    "email_addresses": [
      {
        "email_address": "example@example.org",
        "id": "idn_29w83yL7CwVlJXylYLxcslromF1",
        "linked_to": [],
        "object": "email_address",
        "verification": {
          "status": "verified",
          "strategy": "ticket"
        }
      }
    ],
    "external_accounts": [],
    "external_id": "567772",
    "first_name": "Example",
    "gender": "",
    "id": "user_29w83sxmDNGwOuEthce5gg56FcC",
    "image_url": "https://img.clerk.com/xxxxxx",
    "last_name": "Example",
    "last_sign_in_at": 1654012591514,
    "object": "user",
    "password_enabled": true,
    "phone_numbers": [],
    "primary_email_address_id": "idn_29w83yL7CwVlJXylYLxcslromF1",
    "primary_phone_number_id": null,
    "primary_web3_wallet_id": null,
    "private_metadata": {},
    "profile_image_url": "https://www.gravatar.com/avatar?d=mp",
    "public_metadata": {},
    "two_factor_enabled": false,
    "unsafe_metadata": {},
    "updated_at": 1654012591835,
    "username": null,
    "web3_wallets": []
  },
  "instance_id": "ins_123",
  "object": "event",
  "timestamp": 1654012591835,
  "type": "user.created"
}
```

The payload should always be treated as unsafe until you validate the incoming webhook. Webhooks will originate from another server and be sent to your application as a POST request. A bad actor would fake a webhook event to try and gain access to your application or data.

## How Clerk handles delivery issues

### Retry

Svix will use a set schedule and retry any webhooks that fail. To see the up-to-date schedule, see the [Svix Retry Schedule](https://docs.svix.com/retries).

If Svix is attempting and failing to send a webhook, and that endpoint is removed or disabled from the [**Webhooks**](https://dashboard.clerk.com/last-active?path=webhooks) page in the Clerk Dashboard, then the attempts will also be disabled.

### Replay

If a webhook message or multiple webhook messages fail to send, you have the option to replay the webhook messages. This protects against your service having downtime or against a misconfigured endpoint.

To replay webhook messages:

1. In the Clerk Dashboard, navigate to the [**Webhooks**](https://dashboard.clerk.com/last-active?path=webhooks) page.
1. Select the affected endpoint.
1. In the **Message Attempts** section, next to the message you want to replay, select the menu icon on the right side, and then select **Replay**.
1. The **Replay Messages** menu will appear. You can choose to:

- Resend the specific message you selected.
- Resend all failed messages since the first failed message in that date range.
- Resend all missing messages since the first failed message in that date range.

## Sync data to your database

You can find a guide on how to use webhooks to sync your data to your database [here](/docs/webhooks/sync-data).

## Protect your webhooks from abuse

To ensure that the API route receiving the webhook can only be hit by your app, there are a few protections you can put in place:

- **Verify the request signature**: Svix webhook requests are [signed](https://www.wikiwand.com/en/Digital_signature) and can be verified to ensure the request is not malicious. To learn more, see Svix's guide on [how to verify webhooks with the svix libraries](https://docs.svix.com/receiving/verifying-payloads/how) or [how to verify webhooks manually](https://docs.svix.com/receiving/verifying-payloads/how-manual).

- **Only accept requests coming from [Svix's webhook IPs](https://docs.svix.com/webhook-ips.json)**:  To further prevent attackers from flooding your servers or wasting your compute, you can ensure that your webhook-receiving api routes only accept requests coming from [Svix's webhook IPs](https://docs.svix.com/webhook-ips.json), rejecting all other requests.

---
title: Welcome to Clerk Docs
description: Add complete user management to your application in minutes.
template: wide
---

Find all the guides and resources you need to develop with Clerk.

<Cards cols={4} level={2}>
  - [Quickstarts & Tutorials](/docs/quickstarts/overview)
  - Explore our end-to-end tutorials and getting started guides for different application stacks using Clerk.
  - {<svg viewBox="0 0 32 32" fill="none"><g fill="currentColor"><path fillOpacity=".15" fillRule="evenodd" d="M16 31.25c8.422 0 15.25-6.828 15.25-15.25S24.422.75 16 .75.75 7.578.75 16 7.578 31.25 16 31.25Zm-5.25-21.5L23.25 16l-12.5 6.25V9.75Z" clipRule="evenodd"/><path d="m23.25 16 .335.67a.75.75 0 0 0 0-1.34l-.335.67Zm-12.5-6.25.335-.67A.75.75 0 0 0 10 9.75h.75Zm0 12.5H10a.75.75 0 0 0 1.085.67l-.335-.67ZM30.5 16c0 8.008-6.492 14.5-14.5 14.5V32c8.837 0 16-7.163 16-16h-1.5ZM16 1.5c8.008 0 14.5 6.492 14.5 14.5H32c0-8.837-7.163-16-16-16v1.5ZM1.5 16C1.5 7.992 7.992 1.5 16 1.5V0C7.163 0 0 7.163 0 16h1.5ZM16 30.5C7.992 30.5 1.5 24.008 1.5 16H0c0 8.837 7.163 16 16 16v-1.5Zm7.585-15.17-12.5-6.25-.67 1.34 12.5 6.25.67-1.34Zm-12.5 7.59 12.5-6.25-.67-1.34-12.5 6.25.67 1.34ZM10 9.75v12.5h1.5V9.75H10Z"/></g></svg>}

  ---

  - [UI Components](/docs/components/overview)
  - Clerk's prebuilt UI components give you a beautiful, fully-functional user management experience in minutes.
  - {<svg viewBox="0 0 32 32" fill="none"><path fill="currentColor" fillOpacity=".15" d="M16 31.25 1.962 25.234A2 2 0 0 1 .75 23.395V7.285l14.462-6.197a2 2 0 0 1 1.576 0L31.25 7.286 16 13.896V31.25Z"/><path fill="currentColor" d="m16 31.25-.295.69a.75.75 0 0 0 1.045-.69H16ZM1.962 25.234l-.295.69.295-.69ZM.75 7.286l-.295-.69a.75.75 0 0 0-.455.69h.75Zm30.5 0 .298.688a.75.75 0 0 0-.003-1.378l-.295.69ZM16.788 1.088l-.296.689.296-.69Zm-1.576 0 .296.689-.296-.69Zm1.083 29.473L2.258 24.544l-.591 1.38 14.038 6.015.59-1.378ZM1.5 23.395V7.285H0v16.11h1.5ZM31.545 6.596 17.083.398l-.59 1.379 14.462 6.198.59-1.379ZM14.917.398.455 6.596l.59 1.38 14.463-6.199-.591-1.379ZM.452 7.974l15.25 6.61.596-1.376-15.25-6.61-.596 1.376Zm15.846 6.61 15.25-6.61-.596-1.376-15.25 6.61.596 1.377Zm-1.048-.688V31.25h1.5V13.896h-1.5ZM17.083.399a2.75 2.75 0 0 0-2.166 0l.59 1.379a1.25 1.25 0 0 1 .985 0l.591-1.379ZM2.258 24.544a1.25 1.25 0 0 1-.758-1.149H0c0 1.1.656 2.095 1.667 2.528l.59-1.379Z"/><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M31.25 7.281v16.11a2 2 0 0 1-1.212 1.838L16 31.246"/></svg>}

  ---

  - [API Reference](/docs/references/overview)
  - Dig into our API reference documentation and SDKs. We have everything you need to get started setting up authentication with Clerk.
  - {<svg viewBox="0 0 32 32" fill="none"><path fill="currentColor" fillOpacity=".15" d="M1.25 10.25a1 1 0 0 1 1-1h29v21h-26a4 4 0 0 1-4-4v-16Z"/><rect width="30.5" height="28.5" x=".75" y="1.75" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" rx="4"/><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="m19.75 16.75 3.5 3.25-3.5 3.25M12.25 16.75 8.75 20l3.5 3.25M4.75 8.75h22.5"/></svg>}

  ---

  - [Security](/docs/security/overview)
  - Account security is the top concern of every feature we build. This documentation lists some of the many protections included with Clerk.
  - {<svg viewBox="0 0 32 32" fill="none"><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M23.382 20.897c0-4.45-3.753-8.059-8.382-8.059-4.63 0-8.382 3.608-8.382 8.059 0 3.045 1.098 5.843 2.933 8.05a13.248 13.248 0 0 0 2.106 2.023M29.25 12.402C26.292 7.826 21.016 4.78 15 4.78S3.708 7.826.75 12.402m24.309-9.184A21.525 21.525 0 0 0 15 .75c-3.645 0-7.073.895-10.059 2.468M20.03 31.25c-5.222-.775-9.22-5.115-9.22-10.353 0-2.225 1.876-4.03 4.191-4.03s4.191 1.805 4.191 4.03c0 2.225 1.877 4.03 4.191 4.03 2.315 0 4.191-1.805 4.191-4.03 0-6.676-5.629-12.088-12.573-12.088-6.944 0-12.574 5.412-12.574 12.088 0 2.037.525 3.957 1.45 5.641M15 20.091c0 4.45 3.753 8.059 8.382 8.059.574 0 1.135-.056 1.677-.162"/></svg>}
</Cards>

## Explore by frontend framework

{/* TODO: Keep aligned with /references/overview */}

<Cards variant="plain" cols={3}>
  - [Next.js](/docs/quickstarts/nextjs)
  - Easily add secure, beautiful, and fast authentication to Next.js with Clerk.
  - {<Include src="_partials/icons/nextjs" />}

  ---

  - [React](/docs/quickstarts/react)
  - Get started installing and initializing Clerk in a new React + Vite app.
  - {<Include src="_partials/icons/react" />}

  ---

  - [Astro](/docs/quickstarts/astro)
  - Easily add secure and SSR-friendly authentication to your Astro application with Clerk.
  - {<Include src="_partials/icons/astro" />}

  ---

  - [Chrome Extension](/docs/quickstarts/chrome-extension)
  - Use the Chrome Extension SDK to authenticate users in your Chrome extension.
  - {<Include src="_partials/icons/chrome-extension" />}

  ---

  - [Expo](/docs/quickstarts/expo)
  - Use Clerk with Expo to authenticate users in your React Native application.
  - {<Include src="_partials/icons/expo" />}

  ---

  - [iOS](/docs/quickstarts/ios)
  - Use the Clerk iOS SDK to authenticate users in your native Apple applications.
  - {<Include src="_partials/icons/ios" />}

  ---

  - [JavaScript](/docs/quickstarts/javascript)
  - The Clerk JavaScript SDK gives you access to prebuilt components and helpers to make user authentication easier.
  - {<Include src="_partials/icons/javascript" />}

  ---

  - [Nuxt](/docs/quickstarts/nuxt)
  - Easily add secure, beautiful, and fast authentication to Nuxt with Clerk.
  - {<Include src="_partials/icons/nuxt" />}

  ---

  - [React Router](/docs/quickstarts/react-router)
  - Easily add secure, edge- and SSR-friendly authentication to React Router with Clerk.
  - {<Include src="_partials/icons/react-router" />}

  ---

  - [Remix](/docs/quickstarts/remix)
  - Easily add secure, edge- and SSR-friendly authentication to Remix with Clerk.
  - {<Include src="_partials/icons/remix" />}

  ---

  - [TanStack React Start (beta)](/docs/quickstarts/tanstack-react-start)
  - Easily add secure and SSR-friendly authentication to your TanStack React Start application with Clerk.
  - {<Include src="_partials/icons/tanstack-start" />}

  ---

  - [Vue](/docs/quickstarts/vue)
  - Get started installing and initializing Clerk in a new Vue + Vite app.
  - {<Include src="_partials/icons/vue" />}
</Cards>

## Explore by backend framework

{/* TODO: Keep aligned with /references/overview */}

<Cards variant="plain" cols={3}>
  - [JS Backend SDK](/docs/references/backend/overview)
  - The Clerk Backend SDK exposes our Backend API resources and low-level authentication utilities for JavaScript environments.
  - {<Include src="_partials/icons/backend-sdk" />}

  ---

  - [C#](https://github.com/clerk/clerk-sdk-csharp/blob/main/README.md)
  - The Clerk C# SDK is a wrapper around our Backend API to make it easier to integrate Clerk into your backend.
  - {<Include src="_partials/icons/c-sharp" />}

  ---

  - [Express](/docs/quickstarts/express)
  - Quickly add authentication and user management to your Express application.
  - {<Include src="_partials/icons/express" />}

  ---

  - [Go](/docs/references/go/overview)
  - The Clerk Go SDK is a wrapper around the Backend API written in Golang to make it easier to integrate Clerk into your backend.
  - {<Include src="_partials/icons/go" />}

  ---

  - [Fastify](/docs/quickstarts/fastify)
  - Build secure authentication and user management flows for your Fastify server.
  - {<Include src="_partials/icons/fastify" />}

  ---

  - [Python](https://github.com/clerk/clerk-sdk-python/blob/main/README.md)
  - The Clerk Python SDK is a wrapper around the Backend API written in Python to make it easier to integrate Clerk into your backend.
  - {<Include src="_partials/icons/python" />}

  ---

  - [Ruby on Rails](/docs/quickstarts/ruby)
  - Integrate authentication and user management into your Ruby application.
  - {<Include src="_partials/icons/ruby.mdx" />}
</Cards>

## Explore by feature

<Cards variant="plain">
  - [Authentication](/docs/authentication/overview)
  - Clerk supports multiple authentication strategies so you can implement the strategy that makes sense for your users.
  - {<svg viewBox="0 0 32 32" fill="none"><path fill="currentColor" fillOpacity=".15" fillRule="evenodd" d="M1.75 30.25v-6.88l11.178-11.178c.456-.455.648-1.102.622-1.745a8.353 8.353 0 1 1 7.252 7.94c-.679-.09-1.383.065-1.887.528L12.56 24.75H8.75v1.5a4 4 0 0 1-4 4h-3Zm20.75-19a1.75 1.75 0 1 0 0-3.5 1.75 1.75 0 0 0 0 3.5Z" clipRule="evenodd"/><path fill="currentColor" d="m1.75 23.37-.53-.53a.75.75 0 0 0-.22.53h.75Zm0 6.88H1c0 .414.336.75.75.75v-.75Zm11.178-18.057.53.53-.53-.53Zm.622-1.746-.75.03.75-.03Zm7.252 7.939.097-.744-.097.744Zm-1.887.53.507.552-.507-.553ZM12.56 24.75v.75a.75.75 0 0 0 .508-.198l-.508-.552Zm-3.81 0V24a.75.75 0 0 0-.75.75h.75ZM1 23.37v6.88h1.5v-6.88H1Zm11.398-11.708L1.22 22.84l1.06 1.061L13.46 12.723l-1.061-1.06Zm.403-1.185c.02.485-.128.91-.403 1.185l1.06 1.06c.637-.635.874-1.504.841-2.306l-1.498.06Zm-.008-.374c0 .126.003.25.008.374l1.498-.06a7.731 7.731 0 0 1-.006-.314h-1.5ZM21.897 1a9.103 9.103 0 0 0-9.104 9.103h1.5c0-4.199 3.404-7.603 7.604-7.603V1ZM31 10.103A9.103 9.103 0 0 0 21.897 1v1.5c4.199 0 7.603 3.404 7.603 7.603H31Zm-9.103 9.104A9.104 9.104 0 0 0 31 10.103h-1.5c0 4.2-3.404 7.604-7.603 7.604v1.5Zm-1.192-.078c.39.052.788.078 1.192.078v-1.5c-.339 0-.672-.022-.998-.065l-.194 1.488Zm-1.283.339c.304-.28.769-.406 1.283-.338l.194-1.488c-.843-.11-1.787.074-2.491.72l1.014 1.106Zm-6.354 5.834 6.354-5.834-1.014-1.105-6.355 5.835 1.015 1.104ZM8.75 25.5h3.81V24H8.75v1.5Zm.75.75v-1.5H8v1.5h1.5ZM4.75 31a4.75 4.75 0 0 0 4.75-4.75H8a3.25 3.25 0 0 1-3.25 3.25V31Zm-3 0h3v-1.5h-3V31ZM23.5 9.5a1 1 0 0 1-1 1V12A2.5 2.5 0 0 0 25 9.5h-1.5Zm-1-1a1 1 0 0 1 1 1H25A2.5 2.5 0 0 0 22.5 7v1.5Zm-1 1a1 1 0 0 1 1-1V7A2.5 2.5 0 0 0 20 9.5h1.5Zm1 1a1 1 0 0 1-1-1H20a2.5 2.5 0 0 0 2.5 2.5v-1.5Z"/></svg>}

  ---

  - [User management](/docs/users/overview)
  - Complete user management. Add sign up, sign in, and profile management to your application in minutes.
  - {<svg viewBox="0 0 32 32" fill="none"><g fill="currentColor"><path fillOpacity=".15" fillRule="evenodd" d="M16.016 31.25C24.431 31.241 31.25 24.417 31.25 16 31.25 7.578 24.422.75 16 .75S.75 7.578.75 16 7.578 31.25 16 31.25a15.101 15.101 0 0 1-9.25-3.152l2.665-3.339a8 8 0 0 1 6.253-3.009h.664a8 8 0 0 1 6.252 3.01l2.666 3.339a15.102 15.102 0 0 1-9.234 3.151Zm-.016-13a5.25 5.25 0 1 0 0-10.5 5.25 5.25 0 0 0 0 10.5Z" clipRule="evenodd"/><path d="M16.016 30.5a.75.75 0 0 0 .001 1.5l-.001-1.5ZM16 32a.75.75 0 0 0 0-1.5V32Zm-9.25-3.902-.586-.467a.75.75 0 0 0 .128 1.062l.458-.595Zm2.665-3.339.587.468-.587-.468Zm13.17 0 .586-.468-.587.468Zm2.665 3.34.458.594a.75.75 0 0 0 .128-1.062l-.586.468ZM30.5 16c0 8.003-6.483 14.492-14.484 14.5l.001 1.5C24.846 31.99 32 24.83 32 16h-1.5ZM16 1.5c8.008 0 14.5 6.492 14.5 14.5H32c0-8.837-7.163-16-16-16v1.5ZM1.5 16C1.5 7.992 7.992 1.5 16 1.5V0C7.163 0 0 7.163 0 16h1.5ZM16 30.5C7.992 30.5 1.5 24.008 1.5 16H0c0 8.837 7.163 16 16 16v-1.5Zm0 0a14.352 14.352 0 0 1-8.792-2.996l-.916 1.189A15.852 15.852 0 0 0 16 32v-1.5Zm-8.664-1.934 2.665-3.339-1.172-.936-2.665 3.34 1.172.935Zm2.665-3.339a7.25 7.25 0 0 1 5.667-2.727V21a8.75 8.75 0 0 0-6.839 3.291l1.172.936Zm5.667-2.727h.664V21h-.664v1.5Zm.664 0a7.25 7.25 0 0 1 5.666 2.727l1.173-.936A8.75 8.75 0 0 0 16.332 21v1.5Zm5.666 2.727 2.666 3.34 1.172-.936-2.665-3.34-1.173.936Zm2.794 2.277a14.352 14.352 0 0 1-8.776 2.996l.001 1.5a15.851 15.851 0 0 0 9.69-3.307l-.915-1.189ZM20.5 13a4.5 4.5 0 0 1-4.5 4.5V19a6 6 0 0 0 6-6h-1.5ZM16 8.5a4.5 4.5 0 0 1 4.5 4.5H22a6 6 0 0 0-6-6v1.5ZM11.5 13A4.5 4.5 0 0 1 16 8.5V7a6 6 0 0 0-6 6h1.5Zm4.5 4.5a4.5 4.5 0 0 1-4.5-4.5H10a6 6 0 0 0 6 6v-1.5Z"/></g></svg>}

  ---

  - [Database integrations](/docs/integrations/overview)
  - Enable Clerk-managed users to authenticate and interact directly with your database with Clerk's integrations.
  - {<svg viewBox="0 0 32 32" fill="none"><path fill="currentColor" fillOpacity=".15" d="M28.25 27.173c0 2.252-5.485 4.077-12.25 4.077S3.75 29.425 3.75 27.173V4.827c0 2.252 5.485 4.077 12.25 4.077s12.25-1.825 12.25-4.077v22.346Z"/><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M28.25 16c0 2.252-5.485 4.077-12.25 4.077S3.75 18.252 3.75 16m24.5 0v11.173c0 2.252-5.485 4.077-12.25 4.077S3.75 29.425 3.75 27.173V16m24.5 0V4.827c0 2.252-5.485 4.077-12.25 4.077S3.75 7.079 3.75 4.827V16M3.75 4.827C3.75 2.575 9.235.75 16 .75s12.25 1.825 12.25 4.077"/></svg>}

  ---

  - [Customization](/docs/customization/overview)
  - Clerk's components can be customized to match the look and feel of your application.
  - {<svg viewBox="0 0 32 32" fill="none"><path fill="currentColor" fillOpacity=".15" fillRule="evenodd" d="M3.75 1.75a2 2 0 0 0-2 2V24a6.25 6.25 0 1 0 12.5 0V3.75a2 2 0 0 0-2-2h-8.5ZM8 25.25a1.75 1.75 0 1 0 0-3.5 1.75 1.75 0 0 0 0 3.5Z" clipRule="evenodd"/><path fill="currentColor" d="M8 29.5A.75.75 0 0 0 8 31v-1.5ZM20.948 5.164l-.53.53.53-.53Zm5.888 5.888.53-.53-.53.53ZM12.27 28.445l-.53-.53.53.53Zm-8.186-.53a.75.75 0 0 0-1.06 1.06l1.06-1.06Zm22.75-14.035-.53-.53.53.53Zm-3.87 3.87-.53-.53.53.53ZM18.12 5.164l.53.53-.53-.53Zm-4.4 3.34a.75.75 0 0 0 1.06 1.06l-1.06-1.06ZM2.5 3.75c0-.69.56-1.25 1.25-1.25V1A2.75 2.75 0 0 0 1 3.75h1.5ZM2.5 24V3.75H1V24h1.5ZM8 29.5A5.5 5.5 0 0 1 2.5 24H1a7 7 0 0 0 7 7v-1.5Zm5.5-5.5A5.5 5.5 0 0 1 8 29.5V31a7 7 0 0 0 7-7h-1.5Zm0-14.966V24H15V9.034h-1.5Zm0-5.284v5.284H15V3.75h-1.5ZM12.25 2.5c.69 0 1.25.56 1.25 1.25H15A2.75 2.75 0 0 0 12.25 1v1.5Zm-8.5 0h8.5V1h-8.5v1.5ZM9 23.5a1 1 0 0 1-1 1V26a2.5 2.5 0 0 0 2.5-2.5H9Zm-1-1a1 1 0 0 1 1 1h1.5A2.5 2.5 0 0 0 8 21v1.5Zm-1 1a1 1 0 0 1 1-1V21a2.5 2.5 0 0 0-2.5 2.5H7Zm1 1a1 1 0 0 1-1-1H5.5A2.5 2.5 0 0 0 8 26v-1.5Zm21.5-4.75v8.5H31v-8.5h-1.5Zm-1.25 9.75H8V31h20.25v-1.5ZM20.418 5.695l5.887 5.887 1.061-1.06-5.887-5.888-1.061 1.06Zm-8.677 22.22a5.413 5.413 0 0 1-7.656 0l-1.06 1.06c2.7 2.7 7.077 2.7 9.776 0l-1.06-1.06ZM26.305 13.35l-3.87 3.87 1.061 1.06 3.87-3.87-1.06-1.06Zm-3.87 3.87L11.742 27.915l1.06 1.06L23.496 18.28l-1.06-1.06ZM28.25 17h-5.284v1.5h5.284V17ZM21.479 4.634a2.75 2.75 0 0 0-3.89 0l1.061 1.06a1.25 1.25 0 0 1 1.768 0l1.06-1.06ZM29.5 28.25c0 .69-.56 1.25-1.25 1.25V31A2.75 2.75 0 0 0 31 28.25h-1.5Zm-3.195-16.668a1.25 1.25 0 0 1 0 1.768l1.061 1.06a2.75 2.75 0 0 0 0-3.889l-1.06 1.061ZM31 19.75A2.75 2.75 0 0 0 28.25 17v1.5c.69 0 1.25.56 1.25 1.25H31ZM14.78 9.564l3.87-3.87-1.06-1.06-3.87 3.87 1.06 1.06Z"/></svg>}

  ---

  - [Organizations](/docs/organizations/overview)
  - Organizations are shared accounts, useful for project and team leaders. Members with elevated privileges can manage member access to the organization's data and resources.
  - {<svg viewBox="0 0 32 32" fill="none"><g stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5"><circle cx="16" cy="16" r="15.25" fill="currentColor" fillOpacity=".15"/><path d="M1 16h30M16 1v30M14 1S7.75 5.978 7.75 16 14 31 14 31M18 1s6.25 4.978 6.25 15S18 31 18 31"/></g></svg>}

  ---

  - [SDKs](/docs/references/overview)
  - Clerk's SDKs allow you to call the Clerk server API without having to implement the calls yourself.
  - {<svg viewBox="0 0 32 32" fill="none"><path fill="currentColor" fillOpacity=".15" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M16 31.25 29.25 25l-9.54-4.5L16 22.25l-3.71-1.75L2.75 25 16 31.25Z"/><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M16 22.25 29.25 16l-9.54-4.5L16 13.25l-3.71-1.75L2.75 16 16 22.25Z"/><path fill="currentColor" fillOpacity=".15" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M2.75 7 16 .75 29.25 7 16 13.25 2.75 7Z"/></svg>}
</Cards>

## Learn the concepts

<Cards cols={3} variant="image">
  - [What is Clerk authentication?](/docs/authentication/overview)
  - Clerk offers multiple authentication strategies to identify legitimate users of your application, and to allow them to make authenticated requests to your backend.
  - ![](/docs/images/home/what-is-clerk.png){{ dark: '/docs/images/home/what-is-clerk-dark.png' }}

  ---

  - [What is the "User" object?](/docs/users/overview)
  - The User object contains all account information that describes a user of your app in Clerk. Users can authenticate and manage their accounts, update their personal and contact info, or set up security features for their accounts.
  - ![](/docs/images/home/user-object.png){{ dark: '/docs/images/home/user-object-dark.png' }}

  ---

  - [How do organizations work?](/docs/organizations/overview)
  - Organizations allow members to collaborate across shared resources. Each member of an organization needs to have a user account in your application. All organization members have access to most of the organization resources, but some members can take advantage of administrative features.
  - ![](/docs/images/home/organizations.png){{ dark: '/docs/images/home/organizations-dark.png' }}
</Cards>

<Include src="_partials/help" />

---
title: XSS leak protection
description: Learn how Clerk prevents and mitigates XSS attacks.
---

Cross-Site Scripting (XSS) attacks are a type of injection, in which malicious scripts are injected into otherwise benign and trusted websites. XSS vulnerabilities are incredibly serious and we recommend you reference the [OWASP Foundation's Cross Site Scripting (XSS) Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html) to learn how you can prevent an attack.

Prevention is just one aspect of an effective security model. To prepare for the worst case scenario where an attack is successful, you should ensure your application is configured to minimize the attack's surface area.

Clerk works to minimize the surface area by using `HttpOnly` cookies for authenticated requests to our [Frontend API](/docs/reference/frontend-api){{ target: '_blank' }}, so that credentials cannot be leaked during XSS attacks.

## What is a `HttpOnly` cookie?

`HttpOnly` is a flag on the [`Set-Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) header that is issued by a server to set a cookie in the browser.

By default, cookies can be accessed via `document.cookie` in JavaScript. When the `HttpOnly` flag is set on a cookie, the cookie is only accessible server-side through HTTP requests. The cookie cannot be accessed by client-side JavaScript code, including attempts to read it via `document.cookie`. This provides an important security boundary between client and server-side cookie access.

## How do `HttpOnly` cookies minimize XSS attacks?

During an XSS attack, malicious JavaScript can execute in users' browsers. If session tokens are stored in JavaScript-accessible locations like `localStorage` or non-HttpOnly cookies, the attacker can steal these tokens and impersonate users even after the XSS vulnerability is fixed. If this happens, it is recommended you invalidate existing tokens and force users to sign in again.

By using `HttpOnly` cookies, Clerk ensures session tokens cannot be accessed by JavaScript, protecting them from XSS attacks.

For maximum security, avoid storing session tokens in JavaScript-accessible locations like:

- Cookies without the `HttpOnly` flag
- [Window.localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)
- [Window.sessionStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage)
- [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)

## Why is the `__session` cookie on my application domain not `HttpOnly`?

The `__session` cookie contains the session token and it is dropped by Clerk to your application's root domain (e.g. `example.com`). It is not `HttpOnly` because it needs to be accessible by Clerk's client-side SDKs. However, for this reason, the token contained in this cookie is short-lived (1 minute lifetime), so as to mitigate any potential XSS attacks. Read more about the `__session` and `__client` cookies in the [guide on how Clerk works](/docs/how-clerk-works/overview#clerks-cookies-and-tokens-in-detail).
