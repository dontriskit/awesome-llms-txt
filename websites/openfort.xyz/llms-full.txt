# Custom Generic Auth Token
Configure a custom auth token

Generic authentication serves as an alternative for those utilizing their own authentication server. This method accommodates various authentication types not currently supported, such as `Discord`, `Twitter`, `GitHub`, or bespoke systems.

Essential steps and requirements for generic authentication through an endpoint include:

- Post-login, generate a public identifier to recognize the user.
- Relay this identifier to the embedded signer to initiate wallet creation.
- An endpoint you provide will be contacted to confirm the user's identity, upon which we'll create a wallet if the information is valid.

You'll need to supply an endpoint for identity verification.

Additional headers for request authentication can be passed and will accompany every verification request to your endpoint.

## Authenticating Users with Generic Authentication

### Configure your server

Within the server that handles auhentication requests, you'll need to implement an endpoint responsible for verifying the user's identity. This endpoint should accept a `POST` request with a JSON body containing the `payload` field, which corresponds to the user's public identifier.

```json
{
  "payload": "public_identifier" // you can put any data you want here (as long as it's a string)
}
```

After returning a JSON response, the SDK will create a wallet for the user if the response is valid. The response should contain the following fields:

```json
{
  "userId": "unique_user_id", // A unique identifier for the user, used for wallet identification if no email is provided
  "email": "user_email" // optional
}
```

### Set up your provider

To set up your Custom Authentication with Openfort, visit your [dashboard provider settings](https://dashboard.openfort.xyz/players/auth/providers).

<div align="center">
  <img
    width="70%"
    height="70%"
    src="https://blog-cms.openfort.xyz/uploads/custom_auth_25d003b91c.png?updated_at=2024-03-20T23:54:40.898Z"
    alt='custom auth'
  />
</div>


# Custom OIDC compatible Auth
Configure a custom OIDC compatible auth

OIDC authentication setup is a viable choice when leveraging an external authentication provider such as `Auth0`, `Cognito`, etc., that offers JWK publication for token authenticity verification.

An OIDC authentication framework employs a public-private key pair, utilizing the private key to sign authentication tokens. The public key is made accessible via a public URL in JWKS format, typically found at `https://{domain}.com/.well-known/jwks.json`. When a user logs in, an idToken, a JWT, is produced and signed with the private key, following OIDC specifications for token field requirements. This JWT is then used within the embedded signer to create a user wallet.

The verification of the JWT against the public key confirms its authenticity, allowing wallet generation based on the subject (user identifier) within the idToken.

Input Requirements:

- JWKS File URL (public key): Validates the token's authentic signature.
- idToken's `aud` value: Confirms that the intended recipient of the token is correct.

## Authenticating Users with OIDC-Compatible Authentication

### Set up your provider

To set up your OIDC Authentication with Openfort, visit your [dashboard provider settings](https://dashboard.openfort.xyz/players/auth/providers).

<div align="center">
  <img
    width="70%"
    height="70%"
    src="https://blog-cms.openfort.xyz/uploads/oidc_auth_314e50f269.png?updated_at=2024-03-20T23:54:03.814Z"
    alt='oidc auth'
  />
</div>


# Seamless login with Telegram mini-app
Learn how you can integrate EVM wallet in your Telegam mini-app

You can integrate Openfort to enable login directly from within a Telegram bot or Telegram mini-app.

## Configuration

Follow [this guide](https://core.telegram.org/bots/tutorial#obtain-your-bot-token) to create a telegram bot. After creating a Telegram bot, you must set your domain using the `/setdomain` command in the `@BotFather` chat. You will need to provide the following to Openfort via the Openfort Dashboard upon completion:
- Bot token

<div align="center">
    <img
      width="70%"
      height="70%"
      src="https://blog-cms.openfort.xyz/uploads/telegram_mini_app_cf6c97fb24.png"
      alt='Telegram mini-app'
    />
</div>

The `telegramMiniApp`, uses the signed `initDataRaw` from the `telegramSDK` available in the mini app as third party authentication. It does not have any kind of refresh token since Telegram is in charge of issuing new authentications. This method can be used directly from the mini app without requiring interaction with the user as he is already authenticated with the mini app.

<Admonition type='note'>
Since you need to set your bot's allowed domain you'll need to use a tunneling tool for local development such as [ngrok](https://ngrok.com/).
</Admonition>

## Samples

<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href={``}
    key={'iframe'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Telegram mini-app'>
        {'Learn how integrate with our mini-app sample'}
      </GlassPanel>
  </Link>
</div>


# AccelByte Auth
Integrate with AccelByte.

AccelByte offers robust backend services for building and operating online games, featuring scalable cloud infrastructure, matchmaking, and cross-platform player accounts.
Their solutions focus on enhancing multiplayer experiences while providing developers with the flexibility to customize game services.

## Set up your provider

To set up Accelbyte to authenticate players with Openfort, visit your [dashboard provider settings](https://dashboard.openfort.xyz/players/auth/providers).

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/accelbye_auth_c2acb72c15.png?updated_at=2023-11-09T20:01:56.592Z"
    alt='accelbyte auth'
  />
</div>


# Firebase Auth
Integrate with Firebase.

Firebase is a development platform from Google that provides a variety of tools and services to help developers build, improve, and grow their apps, with features such as databases, analytics, messaging, and crash reporting.
It emphasizes easy integration and real-time updates, enabling developers to create rich, collaborative experiences.

## Prerequisites

Head to your Project Settings in the Firebase Console and grab your Firebase Project ID.

## Set up your provider

To set up Firebase to authenticate players with Openfort, visit your [dashboard provider settings](https://dashboard.openfort.xyz/players/auth/providers).

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_auth_8ccee72abf.png?updated_at=2023-11-09T19:56:44.398Z"
    alt='firebase auth'
  />
</div>


# LootLocker Auth
Integrate with LootLocker.

LootLocker offers robust backend services for building and operating online games, featuring scalable cloud infrastructure, matchmaking, and cross-platform player accounts.
Their solutions focus on enhancing multiplayer experiences while providing developers with the flexibility to customize game services.

## Set up your provider

To set up LootLocker to authenticate players with Openfort, visit your [dashboard provider settings](https://dashboard.openfort.xyz/players/auth/providers).

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/lootlocker_auth_49c09f0ca8.png?updated_at=2023-11-30T11:02:05.677Z"
    alt='lootlocker auth'
  />
</div>


# PlayFab Auth
Integrate with PlayFab

PlayFab provides a comprehensive suite of live game management services, including server hosting, data analytics, and liveOps utilities to streamline game development and monetization.
It is designed to empower developers with the tools needed to engage players and drive revenue, all while minimizing overhead and time to market.

## Prerequisites

To set up your PlayFab authentication with Openfort, you'll need to get the `Project ID`.

1. Visit the [PlayFab developer dashboard](https://developer.playfab.com/), select your title, and navigate to **_Settings wheel --> Title settings_**:

  <div align="center">
    <img
      src="https://blog-cms.openfort.xyz/uploads/image_24_da6eb344c3.png?updated_at=2023-10-26T12:11:33.581Z"
      width="50%"
      alt="playfab title settings"
      height="50%"
    />
  </div>

2. In the **_API Features_** section, copy your **_Title ID_**:

  <div align="center">
    <img
      src="https://blog-cms.openfort.xyz/uploads/image_29_62480d0f61.png?updated_at=2023-10-26T12:11:34.085Z"
      width="50%"
      alt="get playfab title id"
      height="50%"
    />
  </div>


# Supabase Auth
Integrate with Supabase.

Supabase is an open-source alternative to Firebase. It provides a variety of tools and services to help with Postgres database, Authentication, instant APIs, Realtime, Functions, Storage and Vector embeddings.

## Prerequisites

Head to your Project Settings in the Supabase Console and grab your Project URL and anon API Key.

## Set up your provider

To set up Supabase to authenticate players with Openfort, visit your [dashboard provider settings](https://dashboard.openfort.xyz/players/auth/providers).

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/supabase_auth_5c920d5dd0.png?updated_at=2024-04-12T18:09:08.937Z"
    alt='supabase auth'
  />
</div>


# Password Security
How to work with passwords in Openfort Auth

## Custom SMTP

At present, you can trial the Openfort platform by sending up to **3** emails per hour via the built-in service. The default email service as a whole is offered on a best effort basis: we will do our best to maintain it and will review usage of the service on a regular basis to see if the email service should be continued.

As you progress toward production, you may find yourself wanting for a custom SMTP service in order to increase your limits. A custom SMTP server will allow you to set your own cap on the number of emails sent per hour.

Beyond rate limits, an SMTP server might also help with:

- Deliverability and Reputation Management
- Scalability
- Analytics and Tracking
- Compliance and Anti Spam measures

## How to set up SMTP

Head over to [Settings Page](https://dashboard.openfort.xyz/settings/configuration/auth) and hit "Enable Custom SMTP" under the SMTP Provider section.

Fill in fields below with the relevant details obtained from your custom SMTP provider:

<div align="center">
  <img
    width="100%"
    height="100%"
    src="https://blog-cms.openfort.xyz/uploads/SMPT_setting_509fec2568.png"
    alt='authenticated players'
  />
</div>

### SMTP providers

You can use Openfort Auth with any major SMTP provider of your choosing. Some SMTP providers you could consider using are:

- [Twilio SendGrid](https://docs.sendgrid.com/for-developers/sending-email/integrating-with-the-smtp-api)
- [AWS SES](https://docs.aws.amazon.com/ses/latest/dg/send-email-smtp.html)

## Email templates

You can customize the email messages used for the authentication flows. You can edit the following email templates:

- Confirm signup
- Reset Password

<div align="center">
  <img
    width="100%"
    height="100%"
    src="https://blog-cms.openfort.xyz/uploads/email_templates_85f06db035.png"
    alt='email templates'
  />
</div>

## Terminology

The templating system provides the following variables for use:

| Name                     | Description                                                                                                                                                                                                                                                                           |
| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `{{ .state }}`           | Contains a 6-digit One-Time-Password (OTP).                                                                                                                                                                                 |
| `{{ .email }}`           | The user's email address.                                                                                                                                |
| `{{ .redirectUrl }}`     | Contains the redirect URL to confirm the email address to a new account. |

## Editing email templates

Edit your email templates on the [Email Templates](https://dashboard.openfort.xyz/settings/configuration/templates) page. Below is an example for a verification of a sign up:

```
Subject: Confirm Reauthentication

Body:
<h2>Confirm reauthentication</h2> 
    <p>Enter the code: {{ .state }}</p>
```


# Password-based Auth
How to work with passwords in Openfort Auth

<Admonition type='note' label='Email authentication with ecosystem wallets'>
You only need to enable this togle if you're developing an ecosystem wallets.
<div align="center">
    <img
      width="70%"
      height="70%"
      src="https://blog-cms.openfort.xyz/uploads/email_ecosystem_0f56b82ca0.png"
      alt='email setup'
    />
</div></Admonition>

## Password security

A password is more secure if it is harder to guess or brute-force. In theory, a password is harder to guess if it is longer. It is also harder to guess if it uses a larger set of characters (for example, digits, lowercase and uppercase letters, and symbols).

This table shows the _minimum_ number of guesses that need to be tried to access a user's account:

| Required characters                          | Length | Guesses          |
| -------------------------------------------- | ------ | ---------------- |
| Digits only                                  | 8      | ~ 2<sup>27</sup> |
| Digits and letters                           | 8      | ~ 2<sup>41</sup> |
| Digits, lower and uppercase letters          | 8      | ~ 2<sup>48</sup> |
| Digits, lower and uppercase letters, symbols | 8      | ~ 2<sup>52</sup> |

In reality though, passwords are not always generated at random. They often contain variations of names, words, dates, and common phrases. Malicious actors can use these properties to guess a password in fewer attempts.

There are hundreds of millions (and growing!) known passwords out there. Malicious actors can use these lists of leaked passwords to automate login attempts (known as credential stuffing) and steal or access sensitive user data.

### Password strength and leaked password protection

To help protect your users, Openfort Auth sets strength constrains of the passwords used on your project.

- Set a large minimum password length. Anything less than 8 characters is not recommended.
- Set the required characters that must appear at least once in a user's password. Use the strongest option of requiring digits, lowercase and uppercase letters, and symbols.
- Prevent the use of leaked passwords. Openfort Auth uses the open-source [HaveIBeenPwned.org Pwned Passwords API](https://haveibeenpwned.com/Passwords) to reject passwords that have been leaked and are known by malicious actors.


# Discord Login
Integrate with Discord Login

To enable Discord Auth for your project, you need to set up a Discord OAuth application and add the application credentials in the Openfort Dashboard.

## Overview
Setting up Discord logins for your application consists of 3 parts:

- Create and configure a Discord Project and App on the [Discord Developer Dashboard](https://discord.com/developers).
- Add your Discord API Key and API Secret Key to your [Openfort Project](https://dashboard.openfort.xyz/players/auth/providers).
- Add the login code to your [Openfort JS Client App](https://github.com/openfort-xyz/openfort-js).

### Configuration

**Access your Discord account**

- Go to [discord.com](https://discord.com/).
- Click on `Login` at the top right to log in.

- Once logged in, go to [discord.com/developers](https://discord.com/developers).

- callback URL: `https://api.openfort.xyz/iam/v1/oauth/callback/discord`

**Create a Discord application**

- Click on `New Application` at the top right.
- Enter the name of your application and click `Create`.
- Click on `OAuth2` under `Settings` in the left side panel.
- Click `Add Redirect` under `Redirects`.
- Type or paste your `callback URL` into the `Redirects` box.
- Click `Save Changes` at the bottom.
- Copy your `Client ID` and `Client Secret` under `Client information`.

**Add your Discord credentials into your Supabase project**

<div align="center">
    <img
      width="70%"
      height="70%"
      src="https://blog-cms.openfort.xyz/uploads/discordauth_72052f416b.png?updated_at=2024-06-25T13:37:20.731Z"
      alt='Discord Auth'
    />
</div>


# Epic Games Login
Integrate with Epic Games Login

To enable Epic Games Auth for your project, you need to set up a Epic Games OAuth application and add the application credentials in the Openfort Dashboard.

## Overview
Setting up Epic Games login for your application consists of 3 parts:

- Create and configure a Epic Project and App on the [Epic Developer Dashboard](https://dev.epicgames.com/portal/en-US/).
- Add your Epic API Key and API Secret Key to your [Openfort Project](https://dashboard.openfort.xyz/players/auth/providers).
- Add the login code to your [Openfort JS Client App](https://github.com/openfort-xyz/openfort-js).

<div align="center">
    <img
      width="70%"
      height="70%"
      src="https://blog-cms.openfort.xyz/uploads/epicgamesauth_1a1916d474.png?updated_at=2024-06-25T13:38:28.433Z"
      alt='Epic Auth'
    />
</div>

### Configuration

1. Create an organization on Epic Games portal and create a new project.
2. Click on `Epic Account Services` and add a new applications:
- Verify your application website and privacy policy URL
- Save the API Key (client_id) and API Secret Key (client_secret) for later use.

3. Set up Epic Games in Openfort:
- Go to the [Openfort dashboard](https://dashboard.openfort.xyz/players/auth/providers).
- Click on Epic Enabled to turn it ON.
- Enter the Epic Client ID and Epic Client Secret.


# Facebook Login
Integrate with Facebook Login

To enable Facebook Auth for your project, you need to set up a Facebook OAuth application and add the application credentials to your Openfort Dashboard.

## Overview
Setting up Facebook logins for your application consists of 3 parts:

- Create and configure a Facebook Application on the [Facebook Developers Site](https://developers.facebook.com/).
- Add your Facebook keys to your [Openfort Project](https://dashboard.openfort.xyz/players/auth/providers).
- Add the login code to your [Openfort JS Client App](https://github.com/openfort-xyz/openfort-js).

### Configuration 

- Go to [developers.facebook.com](https://developers.facebook.com).
- Click on `Log In` at the top right to log in.

**Create a Facebook app**

- Click on `My Apps` at the top right.
- Click `Create App` near the top right.
- Select your app type and click `Continue`.
- Fill in your app information, then click `Create App`.
- This should bring you to the screen: `Add Products to Your App`. (Alternatively you can click on `Add Product` in the left sidebar to get to this screen.)

**Set up Facebook login for your Facebook app**

From the `Add Products to your App` screen:

- Click `Setup` under `Facebook Login`
- Skip the Quickstart screen, instead, in the left sidebar, click `Settings` under `Facebook Login`
- Enter your callback URI (`https://api.openfort.xyz/iam/v1/oauth/callback/facebook`) under `Valid OAuth Redirect URIs` on the `Facebook Login Settings` page
- Enter this in the `Valid OAuth Redirect URIs` box
- Click `Save Changes` at the bottom right

Be aware that you have to set the right use case permissions to enable Third party applications to read the email address. To do so:

Under `Build Your App`, click on `Use Cases` screen. From there, do the following steps:

- Click the Edit button in `Authentication and Account Creation` on the right side. This action will lead to the other page.
- `public_profile` is set by default, so make sure it and `email` have status of **Ready for testing** in the redirected page.
- If not, click the **Add** button in email on right side.

**Copy your Facebook app ID and secret**

- Click `Settings / Basic` in the left sidebar
- Copy your App ID from the top of the `Basic Settings` page
- Under `App Secret` click `Show` then copy your secret
- Make sure all required fields are completed on this screen.

**Enter your Facebook app ID and secret into your Supabase project**
<div align="center">
    <img
      width="70%"
      height="70%"
      src="https://blog-cms.openfort.xyz/uploads/facebookauth_da6c619b33.png"
      alt='Facbook Auth'
    />
</div>


# Google Login
Integrate with Google Login

Openfort Auth supports Sign in with Google on the web, native Android applications and Chrome extensions.

## Overview
Setting up Twitter logins for your application consists of 3 parts:

- Create and configure a Google Project and App on the [Google Cloud Platform](https://console.cloud.google.com/home/dashboard).
- Add your Google API Key and API Secret Key to your [Openfort Project](https://dashboard.openfort.xyz/players/auth/providers).
- Add the login code to your [Openfort JS Client App](https://github.com/openfort-xyz/openfort-js).

### Configuration 

1. Go to the [API Credentials page](https://console.cloud.google.com/apis/credentials).
2. Click `Create credentials` and choose `OAuth Client ID`.
3. For application type, choose `Web application`.
4. Under **Authorized redirect URLs**, enter the callback URL from the [Openfort dashboard](https://dashboard.openfort.xyz/players/auth/providers). Expand the Google Auth Provider section to display it.
5. When you finish configuring your credentials, you will be shown your client ID and secret. Add these to the Google Auth Provider section of the Openfort Dashboard.

<div align="center">
    <img
      width="70%"
      height="70%"
      src="https://blog-cms.openfort.xyz/uploads/googleauth_729cabb623.png"
      alt='Google Auth'
    />
</div>


# LINE Login
Integrate with LINE Login

Integrate LINE Login into your web app (website) to make it easier for people to create an account and log in. 

## Overview

Setting up LINE login for your application consists of 3 parts:

- Create and configure a LINE Project and App on the [LINE Dashboard](https://developers.line.biz/console/).
- Add your LINE `Channel ID` and `Channel Secret` to your [Openfort Project](https://dashboard.openfort.xyz/players/auth/providers).
- Add the login code to your [Openfort JS Client App](https://github.com/openfort-xyz/openfort-js).

<div align="center">
    <img
      width="70%"
      height="70%"
      src="https://blog-cms.openfort.xyz/uploads/Line_auth_7891fd38a0.png"
      alt='LINE Auth'
    />
</div>


# Telegram Login
Integrate with Telegram Login

Openfort enables developers to quickly integrate Login with Telegram into their applications. 

## Overview

There are two methods of authentication with Telegram. Telegram Auth requires the botUsername as an OAuth2 authentication flow with telegram, similarly to how you login with Google with an access/refresh token returned. This method goes through the screen you have seen with the [Continue with Telegram](https://core.telegram.org/widgets/login) button. 

<Admonition type='note' label='Telegram mini-app'>
Openfort also enables seamless Telegram login directly from within a Telegram bot or within Telegram Mini-Apps! [Refer to this guide](/docs/guides/dashboard/custom-auth/telegram-mini-app).
</Admonition>

### Configuration 

Start the conversation with [BotFather](https://t.me/botfather) and follow [this guide](https://core.telegram.org/bots/tutorial#obtain-your-bot-token) to create a telegram bot. You will need to provide the following to Openfort via the Openfort Dashboard upon completion:
- Bot token (Paste the token you recive from BotFather)
- Bot name (Paste the bot's username)

After creating a Telegram bot, you must set your domain using the `/setdomain` command in the `@BotFather` chat. Send this link 'https://oauth.openfort.xyz/telegram/callback'. 

<div align="center">
    <img
      width="70%"
      height="70%"
      src="https://blog-cms.openfort.xyz/uploads/telegram_auth_cca4b3a10c.png"
      alt='Epic Auth'
    />
</div>

<Admonition type='caution'>
Telegram login requires developers to create a Telegram bot with a bot secret. This bot secret controls the Telegram bot and is also used as a symmetric key for authentication. Control over this key enables a developer to sign over authentication data, meaning compromise of this key puts your users (and their accounts) at risk.

**Securing this symmetric key is essential for the security of all of your app’s Telegram logins.**
</Admonition>


# X (Twitter) Login
Integrate with X Login

To enable Twitter Auth for your project, you need to set up a Twitter OAuth application and add the application credentials in the Openfort Dashboard.

## Overview
Setting up Twitter logins for your application consists of 3 parts:

- Create and configure a Twitter Project and App on the [Twitter Developer Dashboard](https://developer.twitter.com/en/portal/dashboard).
- Add your Twitter API Key and API Secret Key to your [Openfort Project](https://dashboard.openfort.xyz/players/auth/providers).
- Add the login code to your [Openfort JS Client App](https://github.com/openfort-xyz/openfort-js).

<div align="center">
    <img
      width="70%"
      height="70%"
      src="https://blog-cms.openfort.xyz/uploads/twitterauth_a9219869d5.png"
      alt='Twitter Auth'
    />
</div>

### Configuration

1. Create Project and App:
- Click "+ Create Project", enter project name, and select use case.
- Enter a project description and app name.
- Copy and save your API Key (client_id) and API Secret Key (client_secret).

2. Set Up App Settings:
- Click on "App settings".
- Go to "User authentication settings" and click "Set up".

3. Configure App Permissions:
- Turn ON "Request email from users".
- Select "Web App" as the Type of App.
- Enter Callback URL, Website URL, Terms of service URL, and Privacy policy URL.

4. Set up X in Openfort:
- Go to the [Openfort dashboard](https://dashboard.openfort.xyz/players/auth/providers).
- Click on Twitter Enabled to turn it ON.
- Enter the Twitter Client ID and Twitter Client Secret.


# Backend wallets


) => {
    const pathParts = route.split('/').filter(Boolean);
    return pathParts.map(part => part.charAt(0).toUpperCase() + part.slice(1)).join(' > ');
  },
}

Backend wallets serve as an internal account for games and developers to manage assets and flows. The accounts are EOAs (Externally Owned Account). 

<div align="center">
  <img
    alt="dev-account-dashboard"
    src="https://blog-cms.openfort.xyz/uploads/dev_account_dashboard_f73e699b8b.png"
    width="80%"
    height="80%"
  />
</div>

There are [several use cases](/docs/guides/server/dev) for this:
- **Treasury Account**: Transferring assets on demand. 
- **Minting Account**: Minting assets on demand. 
- **Escrow Account**: Hold assets or tokens in an escrow between users and transferring them afterwards.

## Requisites
Developer account pay for gas using either:
- **Support [ERC-2771](https://eips.ethereum.org/EIPS/eip-2771) transactions**: The assets you want to escrow need to support [ERC-2771](https://eips.ethereum.org/EIPS/eip-2771) transactions (i.e. gasless).
- **Funding a backend wallet**: You need to fund your developer account with the chain's native token.

## Create a backend wallet
Head to the [backend wallet](https://dashboard.openfort.xyz/developers/wallets) page in your dashboard settings and click on `Add account`. By default, the backend wallets created with Openfort are custodial. 

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="dashboard"
>
<TabPanel id="dashboard" label="Dashboard">

<div align="center">
  <img
    alt="addDevAccount"
    src="https://blog-cms.openfort.xyz/uploads/custodial_dev_account_7bf9f3a20a.png"
    width="50%"
    height="50%"
  />
</div>

</TabPanel>
<TabPanel id="api" label="API">
<Tabs
  scrollable
  size="small"
  type="rounded-pills"
  defaultActiveId="node"
>
<TabPanel id="node" label="Node">

```ts server.ts    
// Set your secret key. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.openfort.xyz/developers/api-keys
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);

const settings = await openfort.settings.createDeveloperAccount({
  name: 'Minting Account',
})
```

</TabPanel>
<TabPanel id="bash" label="curl">

```bash command-line
curl https://api.openfort.xyz/v1/settings/developer_accounts \
  -u "$YOUR_SECRET_KEY:" \
  -d name= "Minting Account"
```

  </TabPanel>
  </Tabs>
  </TabPanel>
</Tabs>

### Verify wallet ownership

If you're looking to **sponsor gas with your native tokens** for smart accounts, it's important to verify your deposited funds with the paymaster. 

Head to [backend wallets](https://dashboard.openfort.xyz/accounts) in your dashboard and click on `Add account`. 

1. Click on "Advanced Options" to start the process.
2. Sign the explorer message.
3. Add the wallet address used to deposit native tokens.
4. Add the signed message. 

<div align="center">
  <img
    alt="noncustodial-dev-account"
    src="https://blog-cms.openfort.xyz/uploads/noncustodial_dev_account_01a86b37fa.png"
    width="60%"
    height="60%"
  />
</div>

<div className="video-container">
  <iframe
    src="https://www.youtube-nocookie.com/embed/lWpcJJOcaLs"
    frameBorder="1"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>

### Optional: Custom forwarder contract

By default you can use the [supported forwarder contracts](/docs/addresses) from Openfort if you need. 

Alternatively, you can also use your forward contract in order to sponsor the transaction of your backend wallet. Go to your [Gas policy](https://dashboard.openfort.xyz/policies) section and create a policy by adding the address of your `Forwarder contract address`.


# Ecosystem dashboard configuration


<DashboardCustomization />


# Using a third-party auth provider
Integrate with existing auth providers and backends

Openfort's signer solution enables the user onboarding by integrating with established backend solutions and authentication providers that support JWT-based authentication. This strategy provides a trusted, scalable, and versatile framework that supports an extensive range of authentication options. 

## Third-party auth platforms

With this approach, Openfort is in charge of creating **embedded signers** on the and follow the necessary security steps to make sure the smart wallet created remains non custodial.

<div className="container" style={{ padding: 0 }}>
  <AuthProviders type="backend" />
</div>

## Custom Auth Methods

We offer two options to setup embedded signers with custom auth, one that is based on the OIDC ([Open ID Connect](https://openid.net/developers/how-connect-works/)) standard, and a generic option that lets you bring your own auth server. 

<div className="container" style={{ padding: 0 }}>
  <AuthProviders type="custom-auth" />
</div>


# FAQs
Most frequently asked questions about the Openfort platform.

### Can players use ERC-20 tokens to pay for gas fees?
Yes, you can sponsor fully or partially with the network token or ERC-20.

### Do users need to fund the newly created accounts?
You don't need to. With Openfort you can use policies to sponsor gas fees on behalf of your users.

### How do I pay for the sponsored gas fees?
Openfort handles all the gas payments for you when using policies. While everything is free on `Testnets`, on `Mainnets` you'll need to top up your account.

### What smart contracts can I interact with?
Yes, you're free to use any smart contracts you wish. You will need add contracts using the assets page in your dashboard.

### Is Openfort ERC-4337 compatible?
Yes, Openfort is compatible with Account Abstraction (ERC-4337) among other standards and follows best practices and implementations across other ethereum standards.

### What blockchains do you support?
Checkout the comprehensive list of [supported chains](/docs/chains).

### Can users have the same smart account address on all EVM chains?
Yes, users can have the same address across all EVM chains because the addresses are deterministic. Each chain will have separate smart account.

### Has Openfort been audited?
The Smart Account implementation has been [audited by CertiK](https://drive.google.com/drive/u/0/folders/1aoPgJD_oz1qagWflnO91ASlQo-2upjRL) and the embedded signer is [audited by Cure+53](https://drive.google.com/drive/u/0/folders/1aoPgJD_oz1qagWflnO91ASlQo-2upjRL).

### Do you provide the ability to communicate with players through notifications?
Openfort can notify you of transactions succeeded or reverted with [webhooks](/docs/guides/dashboard/webhooks). You can use that to send push notifications.

### What's Openfort's business model?
At Openfort we work with any size business to connect your backend and product to the blockchain. Our business model adapts to your needs based on volume as well as the revenue and growth model your business has.

### How can I activate "Live Mode"?
Whenever you want to go live with your product, you need to make sure to complete the details on your billing settings. This is necessary on order to top up your Account Funds.

### What options are available for branding and white labeling?
Openfort offers headless smart accounts which means that you can customize your own UI and experience. You can decide to use any popular framework or completely integrate it within you game (zero popups).

## Security and Contingency Planning

### If Openfort were to shut down with a one-month notice, would there be scope to change the signer on the Smart Contract Wallet and use it in connection with a different provider that manages the private keys differently?

**TLDR:** With enough time, transitioning is fairly simple. You’d need to invoke the `transferOwnership` function for users to accept the new signer.

**Detailed Answer:** Yes, if Openfort shuts down with a one-month notice, it's possible to change the signer. Since Openfort wallets are non-custodial, users have control over their private keys. The key migration process would involve using the "recovery share" and "device share" from Shamir's Secret Sharing (SSS) to reconstruct the private key, allowing users to accept a new signer through the `transferOwnership` function. The new provider would need to support compatible key management systems.

### If Openfort were shut down with zero notice, would there be any scope to do a migration? Would that rely on a self-hosted Shield for the recovery share and the device share being intact?

**TLDR:** If there is no self-hosted option, users should rely on on-chain social recovery.

**Detailed Answer:** Migration is still possible, but it depends on the self-hosted Shield for the recovery share and the availability of the device share. If a self-hosted Shield is not in place, users can utilize on-chain social recovery. As long as the device share and recovery share are intact, users can reconstruct their private key and migrate to a new provider. On-chain social recovery can also help recover the wallet if the device share is lost.

### If Openfort's API were compromised, what is the risk there? Can that risk be mitigated? What’s the risk of the auth share on the private key being exposed?

**TLDR:** Both Openfort's server and Shield are encrypted. Even if an attacker obtains the auth share, they would need a secret to decrypt it.

**Detailed Answer:** If Openfort's API were compromised, the risk is limited because both the auth share and Shield service are encrypted. Even if an attacker gains access to the auth share, they would still need to decrypt it using a secret. Furthermore, since the private key is split using Shamir's Secret Sharing, the auth share alone is insufficient to reconstruct the full key without the device or recovery share.


# Charge Gas Fees with ERC20 Tokens
Make your users pay transaction with ERC20.

Gas fees can be a hurdle for many users in blockchain applications. This guide will help you configure gasless transactions where the gas is paid using an ERC20 token. Choose between dynamic or fixed-rate payment strategies.       By the end of this guide, you’ll have a working implementation for charging gas fees with ERC20 tokens and executing transactions seamlessly.

<Accordion
  type="default"
  chevronAlign="left"
  size="medium"
  defaultActiveId='mint-nft'
  className="text-zinc-500 dark:text-white"
  >
    <div className="border-b dark:border-zinc-700 py-3">
      <Accordion.Item
        header={<span className="dark:text-zinc-100 text-zinc-900 font-medium">Charge an ERC20 with dynamic price</span>}
        id="mint-nft"
      >

    <StepHikeCompact>

      {/* Step 1: Select Contract */}
      <StepHikeCompact.Step step={1}>
        <StepHikeCompact.Details title="Select the Contract You Want to Interact With">
          <ul className="list-disc pl-6">
            <li>Add your collectible’s smart contract.</li>
            <li>Define the contract function you want to use (e.g., <code>mint</code>).</li>
          </ul>
        </StepHikeCompact.Details>
        <StepHikeCompact.Code>
          <Tabs scrollable size="small" type="underlined" defaultActiveId="cli">
            <TabPanel id="cli" label="API">
              ```bash command-line
              curl https://api.openfort.xyz/v1/contracts \
                -u "$YOUR_SECRET_KEY:" \
                -d 'name=NFT Contract' \
                -d 'chainId=80002' \
                -d 'address=contract_address'
              ```
            </TabPanel>
            <TabPanel id="dashboard" label="Dashboard">
              <div align="left">
                <img
                  alt="Add Contract"
                  src="https://blog-cms.openfort.xyz/uploads/Add_contract_7634c46ab8.png"
                  width="80%"
                  height="80%"
                />
              </div>
            </TabPanel>
          </Tabs>
        </StepHikeCompact.Code>
      </StepHikeCompact.Step>

      {/* Step 2: Create a Dynamic ERC20 Policy */}
      <StepHikeCompact.Step step={2}>
        <StepHikeCompact.Details title="Set Up a Dynamic ERC20 Policy">
          <ul className="list-disc pl-6">
            <li>Create a new policy and select the strategy <code>charge dynamic amount of ERC20</code>.</li>
            <li>Select the ERC20 token contract and exchange rate.</li>
            <li>Link the imported contract and the function you want to sponsor.</li>
          </ul>
          <p>If you want to update the dynamic rate programmatically, contact us.</p>
        </StepHikeCompact.Details>
        <StepHikeCompact.Code>
          <Tabs scrollable size="small" type="underlined" defaultActiveId="cli">
            <TabPanel id="cli" label="API">

            ```bash command-line
            curl https://api.openfort.xyz/v1/policies \
              -u "$YOUR_SECRET_KEY:" \
              -d 'name=My Policy' \
              -d 'chainId=80002' \
              -d 'strategy[sponsorSchema]=charge_custom_tokens' \
              -d 'strategy[tokenContract]=con_...' \
              -d 'strategy[tokenContractAmount]=1' 

            ```

            ```bash  command-line
            curl https://api.openfort.xyz/v1/policies/:id/policy_rules \
              -H "Authorization: Bearer $YOUR_SECRET_KEY" \
              -d type="contract_functions" \
              -d functionName="All functions" \
              -d contract="con_..."
            ```

            </TabPanel>
            <TabPanel id="dashboard" label="Dashboard">
              <div align="left">
                <img
                  alt="Dynamic Pricing Policy"
                  src="https://blog-cms.openfort.xyz/uploads/gas_payment_erc20_f380972463.png"
                  width="70%"
                  height="70%"
                />
              </div>
            </TabPanel>
          </Tabs>
        </StepHikeCompact.Code>
      </StepHikeCompact.Step>

      {/* Step 3: Create a Gasless Transaction */}
      <StepHikeCompact.Step step={3}>
        <StepHikeCompact.Details title="Create a Gasless Transaction">
          <ul className="list-disc pl-6">
            <li>Add <code>chainId</code>.</li>
            <li>Add the contract.</li>
            <li>Add the policy.</li>
            <li>Add the function you want to interact with.</li>
          </ul>
          <p>
            Note: You can make a transaction without a registered user or account deployed at the time of interaction. Once you make the transaction, a <code>playerId</code> and <code>accountId</code> will be created.
          </p>
        </StepHikeCompact.Details>
        <StepHikeCompact.Code>
          ```bash command-line
          curl https://api.openfort.xyz/v1/transaction_intents \
            -u "$YOUR_SECRET_KEY:" \
            -d 'chainId=80002' \
            -d 'optimistic=true' \
            -d 'policy=policy_id' \
            -d 'interactions[0][contract]=contract_address' \
            -d 'interactions[0][functionName]=mint' \
            -d 'interactions[0][functionArgs][0]=sender_address_or_id'
          ```
        </StepHikeCompact.Code>
      </StepHikeCompact.Step>

      {/* Optional Step 4: Add Account or Player */}
      <StepHikeCompact.Step step={4}>
        <StepHikeCompact.Details title="Optional: Add the Account or Player">
          <ul className="list-disc pl-6">
            <li>Add an account or player to specify the user.</li>
          </ul>
        </StepHikeCompact.Details>
        <StepHikeCompact.Code>
          ```bash command-line
          curl https://api.openfort.xyz/v1/transaction_intents \
            -u "$YOUR_SECRET_KEY:" \
            -d 'chainId=80002' \
            -d 'policy=policy_id' \
            -d 'account=account_id' \
            -d 'optimistic=true' \
            -d 'interactions[0][contract]=contract_address' \
            -d 'interactions[0][functionName]=mint' \
            -d 'interactions[0][functionArgs][0]=sender_address_or_id'
          ```
        </StepHikeCompact.Code>
      </StepHikeCompact.Step>

    </StepHikeCompact>
      </Accordion.Item>
    </div>
    <div className="border-b dark:border-zinc-700 py-3">
    <Accordion.Item
        header={<span className="dark:text-zinc-100 text-zinc-900 font-medium">Charge an ERC20 with fixed prize</span>}
        id="deploy"
      >

    <StepHikeCompact>

      {/* Step 1: Select Contract */}
      <StepHikeCompact.Step step={1}>
        <StepHikeCompact.Details title="Select the Contract You Want to Interact With">
          <ul className="list-disc pl-6">
            <li>Add your collectible’s smart contract.</li>
            <li>Define the contract function you want to use (e.g., <code>mint</code>).</li>
          </ul>
        </StepHikeCompact.Details>
        <StepHikeCompact.Code>
          <Tabs scrollable size="small" type="underlined" defaultActiveId="cli">
            <TabPanel id="cli" label="API">
              ```bash command-line
              curl https://api.openfort.xyz/v1/contracts \
                -u "$YOUR_SECRET_KEY:" \
                -d 'name=NFT Contract' \
                -d 'chainId=80002' \
                -d 'address=contract_address'
              ```
            </TabPanel>
            <TabPanel id="dashboard" label="Dashboard">
              <div align="left">
                <img
                  alt="Add Contract"
                  src="https://blog-cms.openfort.xyz/uploads/Add_contract_7634c46ab8.png"
                  width="80%"
                  height="80%"
                />
              </div>
            </TabPanel>
          </Tabs>
        </StepHikeCompact.Code>
      </StepHikeCompact.Step>

      {/* Step 2: Create a Fixed ERC20 Policy */}
      <StepHikeCompact.Step step={2}>
        <StepHikeCompact.Details title="Set Up a Fixed ERC20 Policy">
          <ul className="list-disc pl-6">
            <li>Create a new policy and select the strategy <code>charge fixed amount of ERC20</code>.</li>
            <li>Specify the ERC20 token contract and the fixed amount to charge.</li>
            <li>Link the imported contract and the function you want to sponsor.</li>
          </ul>
        </StepHikeCompact.Details>
        <StepHikeCompact.Code>
          <Tabs scrollable size="small" type="underlined" defaultActiveId="cli">
            <TabPanel id="cli" label="API">
              ```bash command-line
              curl https://api.openfort.xyz/v1/policies \
                -u "$YOUR_SECRET_KEY:" \
                -d 'name=Fixed Policy' \
                -d 'chainId=80002' \
                -d 'strategy[sponsorSchema]=charge_fixed_rate' \
                -d 'strategy[tokenContract]=contract_address' \
                -d 'strategy[tokenContractAmount]=1'
              ```
            </TabPanel>
            <TabPanel id="dashboard" label="Dashboard">
              <div align="left">
                <img
                  alt="Fixed Pricing Policy"
                  src="https://blog-cms.openfort.xyz/uploads/fixed_gas_policy_example.png"
                  width="70%"
                  height="70%"
                />
              </div>
            </TabPanel>
          </Tabs>
        </StepHikeCompact.Code>
      </StepHikeCompact.Step>

      {/* Step 3: Create a Gasless Transaction */}
      <StepHikeCompact.Step step={3}>
        <StepHikeCompact.Details title="Create a Gasless Transaction">
          <ul className="list-disc pl-6">
            <li>Add <code>chainId</code>.</li>
            <li>Add the contract.</li>
            <li>Add the policy.</li>
            <li>Add the function you want to interact with.</li>
          </ul>
          <p>
            Note: You can make a transaction without a registered user or account deployed at the time of interaction. Once you make the transaction, a <code>playerId</code> and <code>accountId</code> will be created.
          </p>
        </StepHikeCompact.Details>

    <StepHikeCompact.Code>

      ```bash command-line
        curl https://api.openfort.xyz/v1/transaction_intents \
        -u "$YOUR_SECRET_KEY:" \
        -d 'chainId=80002' \
        -d 'optimistic=true' \
        -d 'policy=pol_...'
        -d 'interactions[0][contract]=con_...' \
        -d 'interactions[0][functionName]=mint' \
        -d 'interactions[0][functionArgs][0]=sender address or Id'
      ```

    </StepHikeCompact.Code>

  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={4}>
    <StepHikeCompact.Details title="Optional: Add the Account or Player you're using">

    - Add account or add player

    </StepHikeCompact.Details>

    <StepHikeCompact.Code>

      ```bash command-line
        curl https://api.openfort.xyz/v1/transaction_intents \
        -u "$YOUR_SECRET_KEY:" \
        -d 'chainId=80002' \
        -d 'policy=pol_...' \
        -d 'account=acc...' or 'player=pla...' \
        -d 'optimistic=true' \
        -d 'interactions[0][contract]=con_...' \
        -d 'interactions[0][functionName]=mint' \
        -d 'interactions[0][functionArgs][0]=sender address or Id'
      ```

    </StepHikeCompact.Code>

  </StepHikeCompact.Step>

</StepHikeCompact>

     </Accordion.Item>
  </div>
</Accordion>


# Gas sponsorship
Gas sponsorship offers a flexible way to manage and control gas payments

Whether you're building a game, marketplace, or any web3 application, these policies give you the tools to create seamless user experiences by controlling how transaction fees are handled.

## What's a Gas Manager?

A gas manager is at the heart of how Openfort handles transaction fees. Think of it as your control center for managing how and when your application will sponsor user's gas fees. You might use it to make onboarding smoother by covering gas fees for new users, let players use in-game tokens for transactions, or encourage specific actions in your ecosystem.

<div align="center">
  <img
    alt="control policy spending"
    src="https://blog-cms.openfort.xyz/uploads/Screenshot_2023_06_10_at_16_01_28_016882e0fe.png"
    width="80%"
    height="80%"
  />
</div>

## Getting started

Setting up gas sponsorship is straightforward. Start by visiting the [Gas Policy tab](https://dashboard.openfort.xyz/policies) in your dashboard and clicking `Add Policy`. From there, you'll be able to configure how you want to handle transaction fees.

## Sponsoring gas fees

When it comes to sponsoring gas fees, you have two main approaches available:

### Paying with credit card

The simplest way to get started is by adding [balance credit](https://dashboard.openfort.xyz/settings/project/billing) to your account. When you choose this method, gas costs are automatically deducted from your balance as transactions occur. This is particularly useful when you're ready to go live with your project, as it's required for `livemode` operations.

### Paying with native tokens

For more advanced use cases, you can use network native tokens (like ETH on Base). This method involves depositing tokens to Openfort's Paymaster contract. Here's how to set it up:

Check the [entity addresses](/docs/addresses) page to find the paymaster's address in your network.

<Admonition type="note">

Tokens deposited in this contract can always be withdrawn by the owner and you can control its balance at any time checking the its balance.

</Admonition>

1. First, deposit your tokens using the `depositFor` function:

<div align="center">
  <img
    alt="deposit native tokens"
    src="https://blog-cms.openfort.xyz/uploads/deposit_native_tokens_f96cedc838.png"
    width="80%"
    height="80%"
  />
</div>

2. After depositing, head to the [backend wallets](https://dashboard.openfort.xyz/accounts) page to register your EOA wallet. 

3. Sign and validate your signature by clicking on advanced configuration (see the video below).

<div className="video-container">
  <iframe
    src="https://www.youtube-nocookie.com/embed/lWpcJJOcaLs"
    frameBorder="1"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>

4. Finally, configure your policy to use these deposits by selecting "Sponsor gas with your tokens" when editing or creating a policy:

<div align="center">
  <img
    alt="deposit native tokens"
    src="https://blog-cms.openfort.xyz/uploads/deposit_address_6a7ede434e.png"
    width="40%"
    height="40%"
  />
</div>

<Admonition type="caution">

When using a strategy that supports payment in ERC-20 tokens (i.e. `charge_custom_tokens` or `fixed_rate`), the backend wallet will receive the tokens users pay for gas fees.

</Admonition>

## Optional: Using external paymasters

For those needing custom solutions, Openfort supports integration with external paymasters. This feature is particularly useful when you have specific requirements for gas sponsorship that go beyond the standard options. Note that when using external paymasters, you'll need to use the `pay_for_user` strategy.

<Admonition type="info">

When using an external paymaster, the only supported `strategy` is `pay_for_user`.

</Admonition>

To set up an external paymaster, you can either use the dashboard:

<div align="center">
  <img
    alt="Using external paymasters"
    src="https://blog-cms.openfort.xyz/uploads/policy_addional_options_35e7b3096b.png"
    width="40%"
    height="40%"
  />
</div>

Or configure it through the API:

```bash
# Create the paymaster object
curl https://api.openfort.xyz/v1/paymasters/ \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d address=80002 \
  -d url="YOUR_PAYMASTER_URL"

# Link it to your policy
curl https://api.openfort.xyz/v1/policies/:id \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d paymaster=pay_...
```

With these fundamentals in place, you're ready to start managing gas fees for your users. The next section will dive deeper into the different types of policies and rules you can create.


# API Keys
Use API keys to authenticate API requests.

## Regenerate API keys

<Admonition type="caution" label='Regenerating API keys'>

Regenerating an API key will invalidate the current key and generate a new one. This action cannot be undone. If you have set up webhooks or registered a Shield project with the key, you will need to update them with the new key.

</Admonition>

Openfort supports the ability to regenerate, delete and create API keys. You can do this at any time in the [API keys](https://dashboard.openfort.xyz/developers/api-keys) section of the dashboard.

- **Delete and regenerate API keys**:

<div align="center">
  <img
    alt="generate-delete-api-keys"
    src="https://blog-cms.openfort.xyz/uploads/regenerate_delete_api_keys_f6b94994b0.png"
    width="80%"
    height="80%"
  />
</div>

- **Generate new API keys**: You can create multiple API keys when you're planning to generate a new one to avoid disruption to your integration.

<div align="center">
  <img
    alt="generate-api-keys"
    src="https://blog-cms.openfort.xyz/uploads/generate_api_keys_5807b195fa.png"
    width="80%"
    height="80%"
  />
</div>

### Limit API keys interaction by IP

Openfort supports limiting the IPs that can interact with Openfort services using specific APIn keys.

To enable this, [API keys](https://dashboard.openfort.xyz/developers/api-keys) section of the dashboard and press the three dots next to the **secret key**.

A new page will appear with an option `Whitelist IPs` like so:

<div align="center">
  <img
    alt="generate-delete-api-keys"
    src="https://blog-cms.openfort.xyz/uploads/regenerate_delete_api_keys_f6b94994b0.png"
    width="80%"
    height="80%"
  />
</div>

You can then add multiple IPs per single secret key.

If you try to make a request from an unauthorized IP, you will receive a `Forbidden` error like so:

```json
{
  "error": {
    "type": "invalid_request_error",
    "message": "Access is limited for this address"
  }
}
```


# Events
Get notified about events happening in Openfort and onchain

## Why use events?

When building Openfort integrations, you might want your applications to receive events as they occur in your Openfort accounts, so that your backend systems can execute actions accordingly.

You can configure notifications via the API to be notified about events that happen in your Openfort account or on-chain.

By default, Openfort will send a notification to the specified subscriptions every 24 hours.

## Create an event

Notification objects are the core of the event system. They define the name of the event and encapsulate both the trigger and subscriptions.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="terminal"
>
<TabPanel id="terminal" label="curl">
```bash command-line
curl https://api.openfort.xyz/v1/notifications/ \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d "name=Low balance"
```
</TabPanel>
<TabPanel id="nodejs" label="Node">

```ts server.ts
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);

const notifications = await openfort.notifications.create({ 
  name: "Low balance"
})
```

</TabPanel>
<TabPanel id="csharp" label=".Net">

```csharp Program.cs
using Openfort.SDK;
using Openfort.SDK.Model;
const openfort = new OpenfortClient(YOUR_SECRET_KEY);

const notifications = await openfort.Notifications.Create(
  new CreateNotificationRequest(
    name: "Low balance"
  )
);
```

</TabPanel>
</Tabs>

<Admonition type="note">

You can also configure events directly from your **dashboard**. 

</Admonition>

## Create a trigger

Triggers define the condition that will trigger the notification.

There are 3 available triggers:
- **[Project balance trigger](https://dashboard.openfort.xyz/settings/project/notifications)**: Define a threshold balance of credits in your project. This is useful to control you can continue to sponsor gas fees for your users.
- **[Contract balance trigger](https://dashboard.openfort.xyz/developers/events)**: Check for the returned parameter of a contract call and compare it to a threshold. This is useful to control the deposited amount in a paymaster contract.
- **[Backend wallet balance trigger](https://dashboard.openfort.xyz/developers/events)**: Check for the balance of a backend wallet and compare it to a threshold. This is useful when you're using a backend wallet itself is paying for the gas fees of the transactions it puts onchain.

There can be more than one notification trigger per event.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="terminal"
>
<TabPanel id="terminal" label="curl">
```bash command-line
curl https://api.openfort.xyz/v1/notification_triggers \
  -u "$YOUR_SECRET_KEY:" \
  -d 'notification=not_e0b84653-1741-4a3d-9e91-2b0fd2942f60' \
  -d 'type=project_balance_trigger' \
  -d 'threshold=1000000000'
```
</TabPanel>
<TabPanel id="nodejs" label="Node">

```ts server.ts
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);

const notificationtriggers = await openfort.notificationTriggers.create({ 
  notification: "not_e0b84653-1741-4a3d-9e91-2b0fd2942f60", 
  type: "project_balance_trigger", 
  threshold: "1000000000"
})
```

</TabPanel>
<TabPanel id="csharp" label=".Net">

```csharp Program.cs
using Openfort.SDK;
using Openfort.SDK.Model;
const openfort = new OpenfortClient(YOUR_SECRET_KEY);

const notificationtriggers = await openfort.NotificationTriggers.Create(
  new CreateNotificationTriggerRequest(
    notification: "not_e0b84653-1741-4a3d-9e91-2b0fd2942f60", 
    type: "project_balance_trigger", 
    threshold: "1000000000"
  )
);
```

</TabPanel>
</Tabs>

## Create a subscription

Subscriptions define the method and target of the event.

There are 2 available subscription methods:
- **Email**: Send an email to the specified target.
- **Webhook**: Send a POST request to the specified target. To learn more about receiving webhooks, check out the [webhooks guide](/docs/guides/dashboard/webhooks) and the types `notification.developer_account.balance`, `notification.contract.balance` or `notification.project.balance`.

There can be more than one notification subscription per event.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="terminal"
>
<TabPanel id="terminal" label="curl">
```bash command-line
curl https://api.openfort.xyz/v1/notification_subscriptions \
  -u "$YOUR_SECRET_KEY:" \
  -d 'notification=not_e0b84653-1741-4a3d-9e91-2b0fd2942f60' \
  -d 'method=Email' \
  -d 'target=jaume@openfort.xyz'
```
</TabPanel>
<TabPanel id="nodejs" label="Node">

```ts server.ts
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);

const notificationsubscriptions = await openfort.notificationSubscriptions.create({ 
  notification: "not_e0b84653-1741-4a3d-9e91-2b0fd2942f60", 
  method: "Email", 
  target: "jaume@openfort.xyz"
})
```

</TabPanel>
<TabPanel id="csharp" label=".Net">

```csharp Program.cs
using Openfort.SDK;
using Openfort.SDK.Model;
const openfort = new OpenfortClient(YOUR_SECRET_KEY);

const notificationsubscriptions = await openfort.NotificationSubscriptions.Create(
  new CreateNotificationSubscriptionRequest(
    notification: "not_e0b84653-1741-4a3d-9e91-2b0fd2942f60", 
    method: "Email", 
    target: "jaume@openfort.xyz"
  )
);
```

</TabPanel>
</Tabs>


# How billing works
Learn how project-based billing works in Openfort.

Our goal at Openfort is to provide a _predictable_ billing system that grows with your project.

## How billing is organized

The Openfort Platform has "projects". A user can be a member of multiple projects. For example:

- `User 1`
  - `Project 1` (Smart Accounts, Auth, Payments)
  - `Project 2` (Smart Accounts, Auth, Payments)
- `User 2`
  - `Project 3` (Smart Accounts, Auth, Payments)

## Billing system

### Project-based Billing

Each project has an individual subscription, a plan and addons. For example, `Project 1` could be on the Pro plan and `Project 2` could be on the Free plan.

![Credit Balance](https://blog-cms.openfort.xyz/uploads/project_billing_4f33e2d7a9.png)

### Credit balance (Prepaid)

Each project has a credit balance. The credit balance is used to pay for the project's gas sponsorship.
Given that each proct supports all chains, the credit balance is shared across all chains.

You can monitor the gas report spending in by visiting the policy page.

![Policy Gas Reports](https://blog-cms.openfort.xyz/uploads/policy_report_de8f42695f.png)

### FAQ

<details>
  <summary>
    <i>Do you only support the prepaid option?</i>
  </summary>
  No, we also support the postpaid option. Please contact us for more information
  at joan@openfort.xyx.
</details>

<details>
  <summary>
    <i>What happens if my balance reaches 0?</i>
  </summary>
  Gas sponsorship will be disabled for your project. You can top up your balance
  to enable it again. If you want more flexible billing options, please contact us
  at joan@openfort.xyz, where we can enable a buffer for your project.
</details>


# Social Login
Logging in with social accounts

OAuth is commonly used for things like logging in to a social media account from a third-party app. It is a secure and convenient way to authenticate users and share information between applications.

### Social Providers
<div className="container" style={{ padding: 0 }}>
  <AuthProviders type="social" />
</div>

## Provider Token
You can use the provider token and provider refresh token returned to make API calls to the OAuth provider. For example, you can use the Google provider token to access Google APIs on behalf of your user.


# Gas Policy Strategies & Rules
This guide covers the detailed configuration of gas policies, including available strategies and rule types

## Gas Policy Strategies

Gas policies offer three distinct strategies for handling transaction fees:

<div align="center">
  <img
    alt="PolicyGas"
    src="https://blog-cms.openfort.xyz/uploads/Group_419_7e8171c854.svg"
    width="100%"
    height="100%"
  />
</div>

### 1. Sponsored Transactions

Developers cover all gas fees, removing the need for users to hold native tokens.

<Tabs
scrollable
size="small"
type="underlined"
defaultActiveId="dashboard"
>
<TabPanel id="dashboard" label="Dashboard">
  <div align="center">
    <img
      alt="PolicyERC20Payment"
      src="https://blog-cms.openfort.xyz/uploads/charge_fix_gas_a59ea440fb.png"
      width="50%"
      height="50%"
    />
  </div>
</TabPanel>
<TabPanel id="cli" label="API">
```bash
curl https://api.openfort.xyz/v1/policies/ \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d chainId=80002 \
  -d name="Sponsored Policy" \
  -d "strategy[sponsorSchema]=pay_for_user"
```
</TabPanel>
</Tabs>

### 2. Dynamic ERC20 Payment

Users pay gas fees using ERC20 tokens at a dynamic exchange rate.

<Tabs
scrollable
size="small"
type="underlined"
defaultActiveId="dashboard"
>
<TabPanel id="dashboard" label="Dashboard">
  <div align="center">
    <img
      alt="PolicyERC20Payment"
      src="https://blog-cms.openfort.xyz/uploads/gas_payment_erc20_f380972463.png"
      width="50%"
      height="50%"
    />
  </div>
</TabPanel>
<TabPanel id="cli" label="API">
```bash
curl https://api.openfort.xyz/v1/policies/ \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d chainId=43113 \
  -d name="Dynamic ERC20" \
  -d "strategy[sponsorSchema]=charge_custom_tokens" \
  -d "strategy[tokenContract]=con_..." \
  -d "strategy[tokenContractAmount]=1"
```
</TabPanel>
</Tabs>

### 3. Fixed ERC20 Payment

Users pay a fixed amount of ERC20 tokens per transaction.

<Tabs
scrollable
size="small"
type="underlined"
defaultActiveId="dashboard"
>
<TabPanel id="dashboard" label="Dashboard">
  <div align="center">
    <img
      alt="PolicyERC20Payment"
      src="https://blog-cms.openfort.xyz/uploads/charge_fix_gas_a59ea440fb.png"
      width="50%"
      height="50%"
    />
  </div>
</TabPanel>
<TabPanel id="cli" label="API">
```bash
curl https://api.openfort.xyz/v1/policies/ \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d chainId=80002 \
  -d name="Fixed ERC20" \
  -d "strategy[sponsorSchema]=fixed_rate" \
  -d "strategy[tokenContract]=con_..." \
  -d "strategy[tokenContractAmount]=10000"
```
</TabPanel>
</Tabs>

## Policy Rules

While strategies determine how gas fees are paid, rules define when and how your gas policy applies. Every policy needs at least one rule to function, and you can choose from three types:

| Rule Model           | Description                                            |
|----------------------|--------------------------------------------------------|
| **`contract_functions`**   | Sponsor interactions with smart contracts.              |
| **`account_functions`**    | Sponsor interactions with the smart account.            |
| **`limit_rules`**          | Limit the amount of gas or number of transactions over an interval. |

### Contract functions

These rules let you specify which smart contract interactions your policy covers. You might want to sponsor all interactions with your game contracts but not with external marketplaces, for instance.

<Admonition type="note" label='Wildcard policy'>

Wildcard policies allow you to sponsor any transaction for any contract without the need to add them in the policy. Enable "Catch-all sponsorship".

<img
  alt="Wildcard policy"
  src="https://blog-cms.openfort.xyz/uploads/wildcard_policy_ba98390abd.png"
  width="80%"
  height="80%"
/>

</Admonition>

To create a policy rule, you need first to add a contract to Openfort:

<Accordion
  type="default"
  openBehaviour="multiple"
  chevronAlign="left"
  size="medium"
  className="text-zinc-500 dark:text-white"
  >
    <div className="border-b dark:border-zinc-700 py-3">
      <Accordion.Item
        header={<span className="dark:text-zinc-100 text-zinc-900 font-medium">Add a contract</span>}
        id={`add-contract`}
      >

        <Admonition type="info">

        If the contract is not verified on the block explorer, you will need to enter the ABI manually. If the contract you want to interact with is a proxy contract, you will need to enter the ABI of the implementation contract.

        </Admonition>

        <Tabs
          scrollable
          size="small"
          type="underlined"
          defaultActiveId="dashboard"
        >
        <TabPanel id="bash" label="API">

        Add a contract to Openfort to an API request:

```bash command-line
curl https://api.openfort.xyz/v1/contracts \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d name="SimpleNFT" \
  -d address="0x416c...354D" \
  -d chainId="80002"
```

        </TabPanel>
        <TabPanel id="dashboard" label="Dashboard">

        Add a new contract by clicking the `Add contract` button in the [Asset contracts](https://dashboard.openfort.xyz/contracts) section, then enter:
          - The name of the contract (it can be any name you want; the name is only for identification purposes)
          - The network (`chainId`) where the smart contract is located.
          - The address of the contract.
          - The Application Binary Interface (ABI) of the contract (if not verified in the block explorer of that network).

        <div align="center">
          <img
            alt="DashboardAddContract"
            src="https://blog-cms.openfort.xyz/uploads/adding_contract_dashboard_09dce2f83c.png"
            width="50%"
            height="50%"
          />
        </div>

        </TabPanel>
        </Tabs>

      </Accordion.Item>
    </div>

</Accordion>

Once you've selected your contract, you can then choose what function you whish to enable sponsorship for. You can select `All functions` instead to allow sponsoring all functions in that specific contract.

<Tabs
scrollable
size="small"
type="underlined"
defaultActiveId="dashboard"
>
<TabPanel id="dashboard" label="Dashboard">

<div align="center">
  <img
    alt="policyRules"
    src="https://blog-cms.openfort.xyz/uploads/Screenshot_2023_05_29_at_15_53_15_40188a75a5.png"
    width="50%"
    height="50%"
  />
</div>

</TabPanel>
<TabPanel id="cli" label="API">

```bash command-line
curl https://api.openfort.xyz/v1/policy_rules \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d type="contract_functions" \
  -d functionName="mint" \
  -d "contract=con_..."
```

</TabPanel>
</Tabs>

### Account functions

These rules cover account-related operations, such as transferring ownership of accounts, managing session keys, or deploying smart accounts. They're essential for maintaining smooth account management operations within your application.

<Tabs
scrollable
size="small"
type="underlined"
defaultActiveId="dashboard"
>
  <TabPanel id="dashboard" label="Dashboard">

<div align="center">
  <img
    alt="Register Session key"
    src="https://blog-cms.openfort.xyz/uploads/Screenshot_2023_05_31_at_10_02_51_1cd0c933ba.png"
    width="50%"
    height="50%"
  />
</div>

  </TabPanel>
  <TabPanel id="cli" label="API">

```bash command-line
curl https://api.openfort.xyz/v1/policy_rules \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d type="account_functions"
```

  </TabPanel>
</Tabs>

### Limit rule

Limit rules help you control usage of your gas policy. You can set limits based on:

| Rule Type | Description | Example Use Case |
|-----------|-------------|-----------------|
| Gas per Interval | Total gas limit in timeframe | 1000 WEI/minute |
| Gas per Transaction | Gas limit per transaction | 100 WEI/transaction |
| Count per Interval | Transaction count limit | 10 transactions/minute |

<Tabs
scrollable
size="small"
type="underlined"
defaultActiveId="dashboard"
>
<TabPanel id="dashboard" label="Dashboard">

<div align="center">
  <img
    alt="Register Session key"
    src="https://blog-cms.openfort.xyz/uploads/Screenshot_2023_09_09_at_23_56_02_04f898c850.png"
    width="50%"
    height="50%"
  />
</div>

</TabPanel>
<TabPanel id="cli" label="API">

```bash command-line
curl https://api.openfort.xyz/v1/policy_rules \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d type="rate_limit" \
  -d functionName="gas_per_transaction" \
  -d gasLimit="1000000"
```

</TabPanel>
</Tabs>


# Manage teams


Openfort provides granular **access controls** to manage permissions across your organizations. For each project, a user can have one of the following roles:
- Owner
- Administrator
- Member

A default project is created when you first sign in and you'll be assigned the **Owner** role. Each member can access everything under the project. Create a separate project if you need to restrict access to certain parts.

## Manage team members

To invite others to collaborate, visit your project's team settings in the [Dashboard](https://dashboard.openfort.com/settings/project/members) to send an invite link to another user's email. The invite expires after 24 hours.

<Admonition type="note">

If you're creating an ecosystem, head to the [ecosystem guide](/docs/guides/ecosystem).

</Admonition>

### Permissions across roles [#permission-across-roles]

The table below shows the corresponding permissions for each available role you can assign a team member in the Dashboard.

| Permissions             | Owner                   | Administrator           | Member                  |
| ----------------------- | ----------------------- | ----------------------- | ----------------------- |
| **Members**             |
| Add an Administrator    | <IconCheck size={14} /> | <IconCheck size={14} /> |                         |
| Remove an Administrator | <IconCheck size={14} /> | <IconCheck size={14} /> |                         |
| Add a Member            | <IconCheck size={14} /> | <IconCheck size={14} /> |                         |
| Remove a Member         | <IconCheck size={14} /> | <IconCheck size={14} /> |                         |
| Revoke an invite        | <IconCheck size={14} /> | <IconCheck size={14} /> |                         |
| Resend an invite        | <IconCheck size={14} /> | <IconCheck size={14} /> |                         |
| Accept an invite        | <IconCheck size={14} /> | <IconCheck size={14} /> | <IconCheck size={14} /> |
| **Billing**             |
| Read invoices           | <IconCheck size={14} /> | <IconCheck size={14} /> |                         |
| Read billing email      | <IconCheck size={14} /> | <IconCheck size={14} /> |                         |
| Read billing address    | <IconCheck size={14} /> | <IconCheck size={14} /> |                         |
| Update billing address  | <IconCheck size={14} /> | <IconCheck size={14} /> |                         |
| Read payment methods    | <IconCheck size={14} /> | <IconCheck size={14} /> |                         |
| Update payment methods  | <IconCheck size={14} /> | <IconCheck size={14} /> |                         |
| **Projects**            |
| Create a project        | <IconCheck size={14} /> | <IconCheck size={14} /> | <IconCheck size={14} /> |

## Organization Overview
The default organization structure at Openfort are split in different projects. Each project has their own API Keys, players, assets and billing configuration beign completely independent one another. 

<div align="center">
  <img
    alt="organization-architecture"
    src="https://blog-cms.openfort.xyz/uploads/dev_dashboard_f6616b5d19.svg"
    width="80%"
    height="80%"
  />
</div>


# Players


Use the **Players** page of the dashboard to manage all registered players in your Openfort application.

## Player table
The **player table** displays all players that have been registered within Openfort for your selected application. This table only shows players who have been created through Openfort's systems, whether via direct authentication or through your application's integration. You can see important information including:
- Provider used for authentication
- API ID (unique identifier)
- Creation date
- Last sign-in timestamp

The **player table** is paginated to display 10 players at a time. You can navigate through the list using the "Previous" and "Next" buttons at the bottom. The current view range is displayed (e.g., "Viewing 1 to 10 of 838 results").

### Player details
Clicking on a player's API ID opens the **player details** page, where you can see comprehensive information about the selected player, including:

- Details
  - API ID
  - Description
  - Creation timestamp
  
- Metadata
  - External User ID
  
- Accounts
  - Chain (e.g., Polygon)
  - Wallet address
  - Status (Active/Inactive)
  - Creation date

- Transactions
  View and manage player transactions, including asset transfers and NFT minting

- Sessions
  Monitor and manage player authentication sessions for frictionless interactions

## Authentication
The drawer displays session data such as when the user first logged into your app, when they were last seen in your app. Please note that the "Last seen" field is a rough approximation on the order of an hour from when the user was precisely last active in your app.

If you're using a third-party authentication provider instead of Openfort's authentication solution, this section will remain empty, and you'll manage your authentication through your chosen provider's interface.

### Deleting users
From the user drawer, you can delete a user if necessary. This is an irreversible and destructive action; if the user logs into your app again, they will have a new user's ID (`playerID`), will have to relink any formerly linked accounts, and will get a new embedded wallet address. **Please take extreme care when deleting users.**

For security of user assets, Openfort does not delete the embedded wallet, and instead "soft deletes" it by disassociating it from the deleted user. If the user still has access to their login method and their wallet password, if they have set one, their wallet can be recovered after deletion.


# Webhooks
Listen for events on your Openfort account.

## What is a webhook?

Openfort uses webhooks to push real-time notifications to you about your transactions. All webhooks use HTTPS and deliver a JSON payload that can be used by your application. You can use webhook feeds to do things like:

- Granting users a game item when a transaction is confirmed.
- Store all transaction events in your own database for custom reporting/retention

## Steps to receive webhooks

You can start receiving real-time events in your app using the steps:

1. Create a local endpoint to receive requests
2. Register your development webhook endpoint
3. Test that your webhook endpoint is working properly
4. Register your production webhook endpoint
  
## Webhook object

The webhook object contains the following fields:

```json
{
  "data": {
    "id": "tin_c502d628-5bb3-42f2-b8f5-62ba4d71df3a",
    "createdAt": 1689869074,
    "object": "transactionIntent",
    "etc":"..."
  },
  "type": "transaction_intent.succeeded",
  "date": 1689869074
}
```

Where the `type` will be one of the following:
- `transaction_intent.succeeded`: The transaction intent has arrived on-chain and is confirmed.
- `transaction_intent.failed`: The transaction intent has arrived on-chain and is reverted.
- `transaction_intent.cancelled`: The transaction intent parameters were not met.
- `transaction_intent.broadcast`: The transaction intent was broadcasted.
- `balance. project`: The project balance.
- `balance.contract`: The contract balance.
- `balance.dev_account`: The balance of your backend wallet.

And the `data` will be a [transaction intent object](https://www.openfort.xyz/docs/reference/api/get-a-transaction-intent-object).

### Register your development webhook endpoint

Register your publicly accessible HTTPS URL in the Openfort [dashboard](https://dashboard.openfort.xyz/webhooks). Then decide the type of webhook you want to receive.

<Admonition type="tip">

You can create a tunnel to your localhost server using a tool like [ngrok](https://ngrok.com/download). For example: https://8733-191-204-177-89.sa.ngrok.io/webhooks

</Admonition>

<div align="center">
  <img
    alt="transaction_intent-sign"
    src="https://blog-cms.openfort.xyz/uploads/add_webhook_dashboard_d2bd1ec8ca.png"
    width="90%"
    height="90%"
  />
</div>

### Test that your webhook endpoint is working properly

Send a few test transactions to check that your webhook endpoint is receiving the events.

You can specify the number of block confirmations you want to wait before getting notified of a transaction making it on chain. The default is 0 (i.e. as soon as the transaction arrives on chain).

To do so, you need to include the `confirmationBlocks` body parameter when [creating the transaction intent](https://www.openfort.xyz/docs/reference/api/create-a-transaction-intent-object).

<div align="center">
  <img
    alt="transaction_intent-sign"
    src="https://blog-cms.openfort.xyz/uploads/webhook_logs_78c102fac5.png"
    width="90%"
    height="90%"
  />
</div>


# Branding - Wallet SDK


<div align="center">
  <img
    alt="ecosystem-rainbow-kit"
    src="https://blog-cms.openfort.xyz/uploads/rainbow_kit_ecosystem_cf5574e8a2.png"
    width="80%"
    height="80%"
  />
</div>

When instantiating the **Client SDK**, you can pass in the `appearance` object to customize the appearance of the wallet. For wallet discovery, it will use [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963) to embedded your branding.
The `appearance` object has the following properties:
- **icon**: a data url schema, compliant with [RFC-2397](https://www.rfc-editor.org/rfc/rfc2397).
- **logo**: a [URI](https://www.rfc-editor.org/rfc/rfc3986) pointing to an image. The image SHOULD be a square with 96x96px minimum resolution.
- **name**: a human-readable local alias of the Wallet Provider to be displayed to the user on the DApp. (e.g. `Example Wallet Extension` or `Awesome Example Wallet`)
- **reverseDomainNameSystem**: the Wallet MUST supply the `rdns` property which is intended to be a domain name from the Domain Name System in reverse syntax ordering such as `com.example.subdomain`. It’s up to the Wallet to determine the domain name they wish to use, but it’s generally expected the identifier will remain the same throughout the development of the Wallet. It’s also worth noting that similar to a user agent string in browsers, there are times where the supplied value could be unknown, invalid, incorrect, or attempt to imitate a different Wallet. Therefore, the DApp SHOULD be able to handle these failure cases with minimal degradation to the functionality of the DApp.

<Admonition type='info' label={`Getting the ecosystem id`}>

When creating your **client SDK** you need to add the *ecosystem ID*. It can be found in their dashboard at the [settings section](https://dashboard.openfort.xyz/settings/project/overview).
The *ecosystemWalletDomain* is the domain where your wallet UI is hosted.
</Admonition>

Therefore, when creating your wallet SDK, you can pass in the `appearance` object to customize the appearance of the wallet. 

```ts index.ts
// Set your ecosystem id. Remember to switch to your live secret key in production.
// See your ecosystem id here: https://dashboard.openfort.xyz/settings/project/overview
class EcosystemWallet extends Client {
    constructor(appMetadata?: AppMetadata) {
        super({
            appMetadata: appMetadata,
            baseConfig: {
                // URL where the UI wallet is hosted
                ecosystemWalletDomain: 'https://wallet.ecosystem.com',
                ecosystemId: 'YOUR_ECOSYSTEM_ID',
            },
            appearance: {
              icon: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAFwF52RAAAACXBIWXMAAAsTAAALEwEAmpwYAAABpElEQVQ4jZ2Sv0vDUBTFf4f9Cg',
              logo: 'https://www.example.com/logo.png',
              name: 'Ecosystem Wallet',
              reverseDomainNameSystem: 'com.example.ecosystem.wallet'
            }
        });

        // Use a Proxy to allow for new method additions
        return new Proxy(this, {
            get: (target, prop) => {
                if (prop in target) {
                    const value = target[prop as keyof EcosystemWallet];
                    return typeof value === 'function' ? value.bind(target) : value;
                }
                return undefined;
            }
        });
    }
    setPolicy(options?: { policy?: string; }): void {
        return super.setPolicy(options);
    }
  }

```

You can check all the available components in the [Client SDK reference](/docs/reference/ecosystem-js/modules/client.html).


# Onboard your ecosystem partners


After you've created your own ecosystem SDK and registered the npm package. You're now ready to onboard new projects and partners and let them use your new ecosystem wallet. 

Through the dashboard, you're able to create `child_projects` under your ecosystem, given it a name, and head to the members section to invite their emails. 

<div align="center">
  <img
    alt="ecosystem-architecture"
    src="https://blog-cms.openfort.xyz/uploads//onboard_child_7c5c3e2b45.svg" 
    width="80%"
    height="80%"
  />
</div>

-----

Each child project will have their own API keys as well as capabilities to manage smart contracts, users, and gas policies. An ecosystem can decide to share multiple `contract_id` and `policy_id` with child projects in order to take advantage of gas policy campaigns or ecosystem assets like ERC20 tokens.

<div align="center">
  <img
    alt="ecosystem-architecture"
    src="https://blog-cms.openfort.xyz/uploads/ecosystems_04a01570e7.svg"
    width="80%"
    height="80%"
  />
</div>


# Configure login methods


Openfort supports a variety of login methods for your app, including email, phone, wallet, Google, Apple, Twitter, Discord, Epic Games, Line, Telegram, and more coming.

Users can either use these account types as their upfront login method, or can link them to their profile after logging in via a different method.

### 1. Configure _upfront_ login methods in the SDK

The login methods you enable in the Openfort Dashboard should contain all of the account types that users are allowed to login with or link in your app. You can choose a subset (or all) of these account types as upfront login methods shown to users when they first login to your app.
Learn more about configuring your authentication methods in the [auth guide](/docs/guides/dashboard/social-login).

<Admonition type='info'>

As soon as you enable each provider from your dashboard, it will automatically appear as an option in the authentication page.

</Admonition>

## Using a custom auth provider
`
Openfort's ecosystem wallets are fully-compatible with any authentication provider that supports JWT-based, stateless authentication. If you're looking to add embedded wallets to your app, you can either:

- use Openfort as your authentication provider (easy to set up out-of-the-box).
- use a custom authentication provider (easy to integrate alongside your existing stack).


# Sample to create an ecosystem wallet SDK


The following is a sample and video guide on how to create a wallet SDK.

## Samples
<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href={`https://github.com/openfort-xyz/ecosystem-sample`}
    key={'openfort-auth-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Ecosystem sample'>
        {'A quick start guide to create your own wallet SDK with the ecosystem SDK'}
      </GlassPanel>
  </Link>
</div>

### Guides

<div className="video-container">
  <iframe
    src="https://www.youtube-nocookie.com/embed/FBMv3LuGoG4"
    frameBorder="1"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>


# Craft and customize your wallet


The Fort **ecosystem wallets** come with a default set of screens for authentication, session key confirmation, sign typed message, configuration, and transaction confirmation. These screens are designed to be customizable to fit your brand and user experience. Openfort provides helpers to the most popular frameworks to make it easier to integrate the ecosystem wallets.

The _default_ **Client SDK** expects the following routes to exist in your wallet UI:
| Route  | Description                                   |
|-----------------------|---------------------------|
| /sign/personal-sign    |   personal_sign   |
| /sign/eth-sign-typed-data-v-4  | eth_signTypedData_v4    |
| /sign/eth-send-transaction        | eth_signTransaction           |
| /sign/eth-request-accounts    | eth_requestAccounts |
| /sign/wallet-show-calls   | wallet_showCallsStatus |
| /sign/wallet-send-calls    | wallet_sendCalls |
| /sign/eth-grant-permissions    | wallet_grantPermissions |
| /       | Loading screen     |

<div align="center">
  <img
    alt="ecosystem-architecture"
    src="https://blog-cms.openfort.xyz/uploads/Whitelabel_wallet_design_6df94dcb9b.png"
    width="80%"
    height="80%"
  />
</div>

## React SDK
When adding the React components to your App, there are two places where the components can be customized. All but one of the theme customizations options are passed through to the Fort Tailwind plugin in your `tailwind.config.js` file.

In your **wallet UI project**, after installing the `@openfort/ecosystem-js` package to get started with the React SDK. It will be then available from `@openfort/ecosystem-js/react`. 

You can check all the available components in the [React SDK reference](/docs/reference/ecosystem-js/modules/react.html).

<Admonition type="tip">

Use the **live [ecosystem customization](https://build.openfort.xyz/)** tool to get your custom theme and components.

</Admonition>

### Colors

<div align="center">
  <img
    alt="UI-customization"
    src="https://blog-cms.openfort.xyz/uploads/UI_customization_00c256e499.jpg"
    width="80%"
    height="80%"
  />
</div>

The available colors are:

**Background colors**
- `bg000` - Lightest background color
- `bg100` - Light background color
- `bg200` - Medium background color

**Border colors**
- `border` - The color of borders

**Button colors**
- `btnPrimary` - The color of the primary button
- `btnPrimaryText` - The text color for the primary button
- `btnPrimaryHover` - The hover color for the primary button
- `btnSecondary` - The color of the secondary button
- `btnSecondaryText` - The text color for the secondary button
- `btnSecondaryHover` - The hover color for the secondary button

**Text colors**
- `title` - The color for title text
- `text` - The main text color
- `textSubtle` - The color for subtle or secondary text

**Status colors**
- `info` - The color for informational elements
- `success` - The color for success messages or indicators
- `warning` - The color for warning messages or indicators
- `error` - The color for error messages or indicators
- `critical` - The color for critical messages or indicators

These color variables can be used to customize various elements of the UI as shown in the image. For example, the main content area uses `bg200`, while the outer container uses `bg100`. Text elements use `title`, `text`, and `textSubtle` accordingly.

The button styles (`btnPrimary`, `btnSecondary`, etc.) are applied to the "Approve" and "Deny" buttons at the bottom of the UI.

## Core SDK
The **Core SDK** is the package that you will use to **receive and send** communication with the **Client SDK**. This package includes all the necessary functionality in order to onboard your users to blockchain with non-custodial wallets.

```ts main.ts
// Set your publishable key, shield publishable key and ecosystem id. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.openfort.xyz/developers/api-keys
// See your ecosystem ID here: https://dashboard.openfort.xyz/settings/project/overview

// Create a new instance of the Core SDK
const core = new Core({
    baseConfig: {
        publishableKey: "YOUR_PUBLISHABLE_KEY",
        supportedChains: [80002],
        ecosystemId: 'YOUR_ECOSYSTEM_ID',
    },
    shieldConfig: {
        shieldPublishableKey: 'YOUR_SHIELD_PUBLISHABLE_KEY',
    },
    oidcConfig: {
        redirectUri: "http://localhost:3000",
    },
});

// instantiate the event listener
const evhl = core.eventsHandler;

evhl.subscribe(MethodType.ACCOUNTS_REQUEST, (data) => {
    console.log("Event received", data);
})
evhl.listen();
```

This are the available **Method Types** that will be sent from the **Client SDK** and that you can subscribe to:

| Method  | Type                                   |
|-----------------------|---------------------------|
| ETH_SEND_TRANSACTION    | 'eth_signTransaction'     |
| ETH_TYPED_MESSAGE_V4  | 'eth_signTypedData_v4'    |
| PERSONAL_MESSAGE        | 'personal_sign'           |
| WALLET_GRANT_PERMISSIONS    | 'wallet_grantPermissions' |
| WALLET_SEND_CALLS             | 'wallet_sendCalls' |
| WALLET_SHOW_CALLS_STATUS             | 'wallet_showCallsStatus' |
| ETH_REQUEST_ACCOUNTS       | 'eth_requestAccounts'     |

You can check all the available components in the [Core SDK reference](/docs/reference/ecosystem-js/modules/core.html). You can react to receiving this events by subscribing to them and executing the necessary logic in your app, like rendering a confirmation screen or sending the transaction to the blockchain.


# Batch transactions


Smart Wallet enables you to send multiple onchain calls in a single transaction, improving UX by reducing multi-step interactions to a single click. A common example is combining an ERC-20 `approve` with a swap operation.

You can submit batch transactions using the new `wallet_sendCalls` [RPC](https://eip5792.xyz/reference/sendCalls) method.

<StepHikeCompact>
  <StepHikeCompact.Step step={1}>
    <StepHikeCompact.Details title="Check wallet compatibility for atomic batching">
      - First, verify if your app supports atomic batching (This step is crucial if your app supports multiple wallet types)
      - Use the `useCapabilities` hook from Wagmi experimental features
      - Implement fallback functionality for unsupported wallets
      
      Note: The `useWriteContracts` and `useCapabilities` hooks rely on new wallet RPC and may not be supported in all wallets.
    </StepHikeCompact.Details>
    <StepHikeCompact.Code>
          ```typescript app.tsx
                    
          function App() {
            const { data: capabilities } = useCapabilities() 
            // Returns capability object per chain:
            // {
            //   84532: {
            //     atomicBatch: {
            //       supported: true,
            //     },
            //   }  
            // }
            
            // Check if atomic batching is supported in the chain we want to interact with
            const isAtomicBatchSupported = capabilities?.[84532]?.atomicBatch?.supported
            
            return (
              <div>
                {isAtomicBatchSupported ? (
                  <BatchTransactionComponent />
                ) : (
                  <FallbackComponent />
                )}
              </div>
            )
          }
          ```
    </StepHikeCompact.Code>
  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={2}>
    <StepHikeCompact.Details title="Set up contract interactions">
      - Import required hooks: `useAccount` and `useWriteContracts` from Wagmi
      - Define your smart contract ABI
      - Initialize the `useWriteContracts` hook for batch transactions
      - Create a transaction handling function that can process multiple contract calls
      
      Important: Make sure your contract ABIs are correctly typed for better development experience.
    </StepHikeCompact.Details>

    <StepHikeCompact.Code>
          ```typescript app.tsx
                              
          // Define your contract ABI
          const abi = [
            {
              stateMutability: 'nonpayable',
              type: 'function',
              inputs: [{ name: 'to', type: 'address' }],
              name: 'safeMint',
              outputs: [],
            }
          ] as const
          
          function BatchTransactionComponent() {
            const account = useAccount()
            const { writeContracts } = useWriteContracts()
          
            const handleBatchTransaction = () => {
              writeContracts({
                contracts: [
                  {
                    address: "0x119Ea671030FBf79AB93b436D2E20af6ea469a19",
                    abi,
                    functionName: "safeMint",
                    args: [account.address],
                  },
                  // Add more contract interactions as needed
                  {
                    address: "0x119Ea671030FBf79AB93b436D2E20af6ea469a19",
                    abi,
                    functionName: "safeMint",
                    args: [account.address],
                  }
                ],
              })
            }
          
            return (
              <button 
                onClick={handleBatchTransaction}
                className="px-4 py-2 bg-blue-600 text-white rounded"
              >
                Execute Batch Transaction
              </button>
            )
          }
          ```
    </StepHikeCompact.Code>
  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={3}>
    <StepHikeCompact.Details title="Implement transaction status monitoring">
      - Add the `useCallsStatus` hook to track transaction status
      - Configure polling interval for status updates
      - Display transaction status to users
      - Handle transaction completion and errors
      
      Pro tip: The polling interval can be adjusted based on your needs, but 1 second is a good default.
    </StepHikeCompact.Details>

    <StepHikeCompact.Code>
          ```typescript app.tsx
                    
          function BatchTransactionComponent() {
            const { data: id, writeContracts } = useWriteContracts()
            const { data: callsStatus } = useCallsStatus({
              id: id as string,
              query: {
                enabled: !!id,
                // Poll every second until confirmed
                refetchInterval: (data) =>
                  data.state.data?.status === "CONFIRMED" ? false : 1000,
              },
            })
          
            // Example response structure:
            // {
            //   status: 'CONFIRMED',
            //   receipts: [
            //     {
            //       logs: [{
            //         address: '0x...',
            //         topics: ['0x...'],
            //         data: '0x...'
            //       }],
            //       status: 'success',
            //       blockHash: '0x...',
            //       blockNumber: 122414523n,
            //       gasUsed: 390000n,
            //       transactionHash: '0x...'
            //     }
            //   ]
            // }
          
            return (
              <div className="space-y-4">
                <button 
                  onClick={handleBatchTransaction}
                  className="px-4 py-2 bg-blue-600 text-white rounded"
                >
                  Execute Batch Transaction
                </button>
                
                {callsStatus && (
                  <div className="p-4 border rounded">
                    <p className="font-semibold">
                      Status: {callsStatus.status}
                    </p>
                    {callsStatus.status === 'CONFIRMED' && (
                      <p className="text-green-600">
                        Transaction confirmed! Hash: {callsStatus.receipts[0].transactionHash}
                      </p>
                    )}
                  </div>
                )}
              </div>
            )
          }
          ```
    </StepHikeCompact.Code>
  </StepHikeCompact.Step>
</StepHikeCompact>


# Create wallet button


For the best onboarding experience, we recommend adding a highly visible 'Create' or 'Create Wallet' button to your app's homepage. Adding this button streamlines the onboarding experience for new users and gets them ready to use your app in a few seconds.

Here is an example of how the button looks:

<div align="left">
  <img
    alt="create-wallet-button"
    src="https://blog-cms.openfort.xyz/uploads/createwallet_81b193f481.png"
    width="30%"
    height="30%"
  />
</div>

## Implementation with Wagmi

<Admonition type='caution' >

To make these instructions concrete, we have created a sample ecosystem wallet called **Rapidfire ID**. To interact with it, you can find its SDK in the NPM package directory: [@rapidfire/id](https://www.npmjs.com/package/@rapidfire/id).

You can check out the GitHub [repository for Rapidfire Wallet](https://github.com/openfort-xyz/ecosystem-sample) to learn how to create your own wallet.

</Admonition>

<Admonition type='tip'>

Using Wagmi offers a balanced approach that combines flexibility with developer convenience. By integrating the ecosystem wallet with Wagmi, you get access to a comprehensive set of React hooks that handle common wallet operations, state management, and chain interactions. This approach requires both `@rapidfire/id` and `Wagmi` dependencies, along with React Query, but provides a more structured development experience. While you'll still need to build your own UI components, Wagmi's hooks significantly reduce the complexity of handling wallet connections, transactions, and chain switching.

</Admonition>

<StepHikeCompact>
  <StepHikeCompact.Step step={1}>
    <StepHikeCompact.Details title="Configure Wagmi">
      First, set up your Wagmi configuration with the required chain and connector settings.
    </StepHikeCompact.Details>

    <StepHikeCompact.Code>
      ```ts wagmi.ts
                  
              chains: [polygonAmoy],
        connectors: [
          injected(),
        ],
        transports: {
          [polygonAmoy.id]: http(),
        },
      });

      declare module 'wagmi' {
        interface Register {
          config: typeof config;
        }
      }
      ```
    </StepHikeCompact.Code>
  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={2}>
    <StepHikeCompact.Details title="Create the Wallet Logo Component">
      Create a reusable wallet logo component that will be used in the button.
    </StepHikeCompact.Details>

    <StepHikeCompact.Code>
      ```tsx WalletLogo.tsx
      
      const defaultContainerStyles = {
        paddingTop: 2,
        display: 'flex',
        alignItems: 'center',
      };

              size = 24,
        containerStyles = defaultContainerStyles,
      }) {
        return (
          <div style={containerStyles}>
            <svg
              width={size}
              height={size}
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <rect
                x="2"
                y="4"
                width="20"
                height="16"
                rx="3"
                stroke="currentColor"
                strokeWidth="2"
              />
              <path
                d="M16 12C16 10.8954 16.8954 10 18 10H22V14H18C16.8954 14 16 13.1046 16 12Z"
                fill="currentColor"
              />
              <circle cx="12" cy="12" r="2" fill="currentColor" />
            </svg>
          </div>
        );
      }
      ```
    </StepHikeCompact.Code>
  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={3}>
    <StepHikeCompact.Details title="Implement the Create Wallet Button">
      Create the main button component using Wagmi's useConnect hook.
    </StepHikeCompact.Details>

    <StepHikeCompact.Code>
      ```tsx CreateWalletButton.tsx
                  
      const buttonStyles = {
        background: 'linear-gradient(135deg, #2D3436 0%, #000000 100%)',
        border: '1px solid rgba(255, 255, 255, 0.1)',
        boxSizing: 'border-box' as const,
        display: 'flex',
        alignItems: 'center',
        gap: '12px',
        width: 'auto',
        minWidth: '200px',
        fontFamily: 'Inter, system-ui, sans-serif',
        fontWeight: '600',
        fontSize: '16px',
        color: '#FFFFFF',
        padding: '12px 20px',
        borderRadius: '12px',
        cursor: 'pointer',
        transition: 'all 0.2s ease-in-out',
        boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
        ':hover': {
          transform: 'translateY(-1px)',
          boxShadow: '0 6px 8px -1px rgba(0, 0, 0, 0.1), 0 4px 6px -1px rgba(0, 0, 0, 0.06)',
        },
      };

              const { connectors, connect, data } = useConnect();

        const createWallet = useCallback(() => {
          const injectedConnector = connectors.find(
            (connector) => connector.id === 'injected'
          );
          if (injectedConnector) {
            connect({ connector: injectedConnector });
          }
        }, [connectors, connect]);

        return (
          <button style={buttonStyles} onClick={createWallet}>
            <WalletLogo />
            Create Wallet
          </button>
        );
      }
      ```
    </StepHikeCompact.Code>
  </StepHikeCompact.Step>
</StepHikeCompact>

<Admonition type='tip' label='Notes'>
For more detail, view the [`useConnect` documentation](https://wagmi.sh/react/api/hooks/useConnect).
Upon successful connection, account information can be accessed via [data](https://wagmi.sh/react/api/hooks/useConnect#data) returned from `useConnect`, or via [`useAccount`](https://wagmi.sh/react/api/hooks/useAccount).
</Admonition>

## Implementation with EIP-1193 Provider

<Admonition type='tip'>

The EIP-1193 Provider approach gives you the most granular control over your ecosystem wallet integration by directly using the SDK's Ethereum provider. This method requires only the `@rapidfire/id` package and allows you to build everything from scratch. You'll handle all wallet interactions through the standard `EIP-1193` provider interface, giving you complete flexibility in implementing wallet creation, connection flows, and transaction handling. While this approach requires more custom development work, it's ideal for applications that need specialized wallet interactions or want to minimize dependencies.

</Admonition>

<Admonition type='caution'>
To make these instructions concrete, we have created a sample ecosystem wallet called **Rapidfire ID**. To interact with it, you can find its SDK in the NPM package directory: [@rapidfire/id](https://www.npmjs.com/package/@rapidfire/id).

You can check out the GitHub [repository for Rapidfire Wallet](https://github.com/openfort-xyz/ecosystem-sample) to learn how to create your own wallet.
</Admonition>

<StepHikeCompact>
  <StepHikeCompact.Step step={1}>
    <StepHikeCompact.Details title="Initialize the SDK">
      Create a new SDK instance with your application configuration.
    </StepHikeCompact.Details>

    <StepHikeCompact.Code>
      ```ts sdk.ts
      
      // Initialize the SDK with required parameters
              appChainIds: [80002],
        appLogoUrl: 'https://a.rgbimg.com/users/b/ba/barunpatro/600/mf6B5Gq.jpg',
        appName: 'Example App',
      });
      ```
    </StepHikeCompact.Code>
  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={2}>
    <StepHikeCompact.Details title="Set up the Provider">
      Configure the Ethereum provider with chain and policy settings.

      <Admonition type='tip'>
      Make sure to set up your `NEXT_PUBLIC_POLICY_ID` in your environment variables.
      </Admonition>
    </StepHikeCompact.Details>

    <StepHikeCompact.Code>
      ```ts provider.ts
      
      // Configure the provider with chain and policy
              policy: process.env.NEXT_PUBLIC_POLICY_ID
      });
      ```
    </StepHikeCompact.Code>
  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={3}>
    <StepHikeCompact.Details title="Implement the Create Wallet Button">
      Create the button component that uses the configured provider.
    </StepHikeCompact.Details>

    <StepHikeCompact.Code>
      ```tsx CreateWalletButton.tsx
                  
      const buttonStyles = {
        background: 'linear-gradient(135deg, #2D3436 0%, #000000 100%)',
        border: '1px solid rgba(255, 255, 255, 0.1)',
        boxSizing: 'border-box' as const,
        display: 'flex',
        alignItems: 'center',
        gap: '12px',
        width: 'auto',
        minWidth: '200px',
        fontFamily: 'Inter, system-ui, sans-serif',
        fontWeight: '600',
        fontSize: '16px',
        color: '#FFFFFF',
        padding: '12px 20px',
        borderRadius: '12px',
        cursor: 'pointer',
        transition: 'all 0.2s ease-in-out',
        boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
        ':hover': {
          transform: 'translateY(-1px)',
          boxShadow: '0 6px 8px -1px rgba(0, 0, 0, 0.1), 0 4px 6px -1px rgba(0, 0, 0, 0.06)',
        },
      };
      
              const createWallet = useCallback(async () => {
          try {
            const [address] = await provider.request({
              method: 'eth_requestAccounts',
            });
            handleSuccess(address);
          } catch (error) {
            handleError(error);
          }
        }, [handleSuccess, handleError]);

        return (
          <button style={buttonStyles} onClick={createWallet}>
            <WalletLogo />
            Create Wallet
          </button>
        );
      }
      ```
    </StepHikeCompact.Code>
  </StepHikeCompact.Step>
</StepHikeCompact>


# Ecosystem dashboard configuration


<DashboardCustomization />


# FAQs
Most frequently asked questions about the Openfort platform.

### Can Openfort support my ecosystem's login system?
Yes, Openfort's architecture is built to allow thousands of new gaming ecosystems flourish. You ecosystem can be added as an OAuth provider allowing your community to be recognized.

### What if I can't find my authentication provider in the documentation?
No problem, let us know which provider you want to use and we'll get right into it.

### Can players use their existing wallets alongside Openfort Auth?
Users can link existing wallets to their account. This allows you to store and share these wallet addresses with games via the SDK for read-only use.

### What level of support and Service Level Agreements (SLAs) are provided?
At Openfort, we understand the significance of maintaining a high standard of service. Our Service Level Agreements (SLAs) reflect our commitment to providing a reliable, efficient, and safe environment for your operations.

## Security and Contingency Planning

### If Openfort were to shut down with a one-month notice, would there be scope to change the signer on the Smart Contract Wallet and use it in connection with a different provider that manages the private keys differently?

**TLDR:** With enough time, transitioning is fairly simple. You’d need to invoke the `transferOwnership` function for users to accept the new signer.

**Detailed Answer:** Yes, if Openfort shuts down with a one-month notice, it's possible to change the signer. Since Openfort wallets are non-custodial, users have control over their private keys. The key migration process would involve using the "recovery share" and "device share" from Shamir's Secret Sharing (SSS) to reconstruct the private key, allowing users to accept a new signer through the `transferOwnership` function. The new provider would need to support compatible key management systems.

### If Openfort were shut down with zero notice, would there be any scope to do a migration? Would that rely on a self-hosted Shield for the recovery share and the device share being intact?

**TLDR:** If there is no self-hosted option, users should rely on on-chain social recovery.

**Detailed Answer:** Migration is still possible, but it depends on the self-hosted Shield for the recovery share and the availability of the device share. If a self-hosted Shield is not in place, users can utilize on-chain social recovery. As long as the device share and recovery share are intact, users can reconstruct their private key and migrate to a new provider. On-chain social recovery can also help recover the wallet if the device share is lost.

### If Openfort's API were compromised, what is the risk there? Can that risk be mitigated? What’s the risk of the auth share on the private key being exposed?

**TLDR:** Both Openfort's server and Shield are encrypted. Even if an attacker obtains the auth share, they would need a secret to decrypt it.

**Detailed Answer:** If Openfort's API were compromised, the risk is limited because both the auth share and Shield service are encrypted. Even if an attacker gains access to the auth share, they would still need to decrypt it using a secret. Furthermore, since the private key is split using Shamir's Secret Sharing, the auth share alone is insufficient to reconstruct the full key without the device or recovery share.


# Sponsor transactions


One of the biggest UX enhancements unlocked by smart accounts is the ability for app developers to sponsor their users' transactions. If your ecosystem has a gas policy enabled, you can start sponsorship your user's transactions by using the `policy` in your [dashboard](https://dashboard.openfort.xyz/policies).

<Admonition type='caution' >

To make these instructions concrete, we have created a sample ecosystem wallet called **Rapidfire ID**. To interact with it, you can find its SDK in the NPM package directory: [@rapidfire/id](https://www.npmjs.com/package/@rapidfire/id).

You can check out the GitHub [repository for Rapidfire Wallet](https://github.com/openfort-xyz/ecosystem-sample) to learn how to create your own wallet.

</Admonition>

### Use a policy when injecting your provider

Sponsor all transactions that will be made with the injected provider.

<CH.Code>
```tsx app.tsx

function App() {
  useEffect(() => {
    config.getEthereumProvider({policy: 'pol_...'});
  }, []);
  return (
    <div/>
  )
}
```
```ts sdk.ts

// Initialize the SDK with required parameters
  appChainIds: [80002],
  appLogoUrl: 'https://a.rgbimg.com/users/b/ba/barunpatro/600/mf6B5Gq.jpg',
  appName: 'Example App',
});
```
</CH.Code>

### Updating the policy

Updating your policy is useful if you change chain and need to specify a different policy ID.

<CH.Code>
```tsx app.tsx

function App() {
  useEffect(() => {
    config.setPolicy({policy: 'pol_...'});
  }, []);
  return (
    <div/>
  )
}
```
```ts sdk.ts

// Initialize the SDK with required parameters
  appChainIds: [80002],
  appLogoUrl: 'https://a.rgbimg.com/users/b/ba/barunpatro/600/mf6B5Gq.jpg',
  appName: 'Example App',
});
```
</CH.Code>

-----

You can also configure your own app level policy. Check the details in the [dashboard section](/docs/guides/dashboard/gas-sponsorship).

- Using an [**external paymaster** setup.](/docs/guides/dashboard/gas-sponsorship#optional-using-external-paymasters)

- Learn how to [use **erc20 tokens**](/docs/guides/dashboard/gas-erc20) to pay for gas fees.


# Quickstart your wallet


<Admonition type="tip">
This guide and the `configuration` sections are to help developers launch their own ecosystem wallet. If you're looking to use an existing ecosystem wallet SDK, please refer to the `usage` section and install the specific ecosystem package.
</Admonition>

The [**Ecosystem SDK**](https://www.npmjs.com/package/@openfort/ecosystem-js) is the easiest way to create you ecosystem wallet. It comes with a [code-splitting environment](https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting), all the necessary tools to make **your wallet SDK** a reality. It is the easier way to create your own ecosystem wallet.

The Ecosystem SDK has **two main parts**:
1. `@openfort/ecosystem-js/client`: The **Client SDK** that you will use to create your wallet SDK.
2. `@openfort/ecosystem-js/core`: The **Core SDK** that you will use to create your wallet UI. Fort also includes a React specific package `@openfort/ecosystem-js/react` that you can use to get started faster.

## 0. Requirements

Your project will need some specific configuration to enable code splitting:
- [Typescript version 5.0.2](https://github.com/microsoft/TypeScript/releases/tag/v5.0.2) or higher.
- TS Config needs to have `compilerOptions.moduleResolution` set to `bundler`.
- Your code editor and project should have the same version of Typescript.

## 1. Install the ecosystem SDK

Install the latest version of [Ecosystem SDK](https://www.npmjs.com/package/@openfort/ecosystem-js) using your package manager of choice:

<Admonition type="info">
You will need to install `@openfort/ecosystem-js` at both your wallet SDK and wallet UI projects.
</Admonition>

<Tabs
  size="small"
  type="underlined"
  defaultActiveId="npm"
>
  <TabPanel id="npm" label="npm">

    ```sh Terminal
    npm install @openfort/ecosystem-js
    ```

  </TabPanel>
  <TabPanel id="yarn" label="Yarn">

    ```sh Terminal
    yarn add @openfort/ecosystem-js
    ```

  </TabPanel>
</Tabs>

## 2. Set your auth providers
Navigate to the **auth providers** page on the [Openfort dashboard](https://dashboard.openfort.xyz) by selecting your project and then clicking Auth providers Methods in the side bar in the [players page](https://dashboard.openfort.xyz/players). Select the account types you'd like users to be able to login with. For more information on how to enable social logins, check out the [dashboard docs](/docs/guides/dashboard/social-login).

## 3. Get your Openfort API keys
From the [Openfort Dashboard](https://dashboard.openfort.xyz) for select your desired app, navigate to the [developers page](https://dashboard.openfort.xyz/developers/api-keys) in the top bar. On the de tab, find the API keys section. Get your Openfort API keys, you will need it in the next step.

You will find two keys:
- **Publishable Key**: This value can be safely exposed in a client-side environment.
- **Secret Key**: This value should never be exposed in a client-side environment. It should be kept secure and used only in a server-side environment. Learn more on how to use it in the [server-side guide](/docs/guides/server). You can [further secure it](/docs/guides/dashboard/keys) for production applications.

To generate non custodial wallets, you will need to create a Shield instance. At the [API keys page](https://dashboard.openfort.xyz/developers/api-keys), scroll down to the Shield section and click on the **Create Shield keys** button.
A **one time pop-up** will appear with a variable called **encryption share**. Its very important that you store it safely. You will not be able to see it again.

Then, in your page, you will see two Shield keys:
- **Publishable Key**: This value can be safely exposed in a client-side environment.
- **Secret Key**: This value should never be exposed in a client-side environment.

## 4. Creating your wallet SDK

<div align="center">
  <img
    alt="fort-architecture-1"
    src="https://blog-cms.openfort.xyz/uploads/fort_framework_step_1_a97cc606f2.svg"
    width="80%"
    height="80%"
  />
</div>

The easiest way to get started is to create a [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) object in order to map the already provided functionality of the **Client SDK**. You can nevertheless change or add new methods to fit your needs.
<Admonition type='info' label={`Getting the ecosystem id`}>

When creating your **client SDK** you need to add the *ecosystem ID*. It can be found in their dashboard at the [settings section](https://dashboard.openfort.xyz/settings/project/overview).
The *ecosystemWalletDomain* is the domain where your wallet UI is hosted.
</Admonition>

<CH.Code>
```tsx main.ts
// See your ecosystem id here: https://dashboard.openfort.xyz/settings/project/overview

class EcosystemWallet extends Client {
    constructor(appMetadata?: AppMetadata) {
        super({
            baseConfig: {
                ecosystemWalletDomain: 'https://id.sample.openfort.xyz',
                ecosystemId: 'test-226353cd-dd0e-4fba-8208-58dfe29d3581',
            },
            appMetadata,
        });

        return new Proxy(this, {
            get: (target, prop) => {
                if (prop in target) {
                    const value = target[prop as keyof EcosystemWallet];
                    return typeof value === 'function' ? value.bind(target) : value;
                }
                return undefined;
            }
        });
    }
}

```
```json package.json
{
  "name": "@ecosystem/wallet",
  "version": "0.0.1",
  "main": "dist/index.js",
  "module": "dist/index.mjs",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "scripts": {
    "build": "tsup src/index.ts --format cjs,esm --dts",
    "prepublishOnly": "npm run build"
  },
  "keywords": [],
  "author": "Openfort (https://www.openfort.xyz)",
  "devDependencies": {
    "@types/node": "^20.4.5",
    "tsup": "^7.1.0",
    "typescript": "^5.6.2"
  },
  "dependencies": {
    "@openfort/ecosystem-js": "0.1.8"
  },
  "files": [
    "dist"
  ]
}
```
```json tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "lib": ["ES2022", "DOM"],
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "isolatedModules": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.spec.ts"]
}
```
</CH.Code>

You're all set! By running the `build` script you'll get a `dist` folder with the compiled code. You can now publish your package to [npm](https://www.npmjs.com/) and share it with the world.

You can check all the available client methods in the [Client SDK reference](/docs/reference/ecosystem-js/classes/client.Client.html).

## 5. Creating your wallet UI

The **wallet UI** is where your users will interact with your wallet. 

<div align="center">
  <img
    alt="fort-architecture-2"
    src="https://blog-cms.openfort.xyz/uploads/fort_framework_step_2_5ff477cb98.svg"
    width="80%"
    height="80%"
  />
</div>

Openfort `@openfort/ecosystem-js` comes with a set of pre-built components that you can use to create your wallet UI. To learn how to customize it further, head to the [UI screens guide](/docs/guides/ecosystem/configuration/wallet-ui).

In your project, 
Concretely, the `EcosystemProvider` must wrap any component or page that will use the Ecosystem SDK in your react app. It is generally recommended to render it as close to the root of your application as possible.

For example, in a [NextJS](https://nextjs.org/) or [Create React App](https://create-react-app.dev/) project, you may wrap your components like so:

<Tabs
  size="small"
  type="underlined"
  defaultActiveId="cra"
>
  <TabPanel id="cra" label="Create React App">
<CH.Code>
```tsx App.tsx
// Set your publishable key, shield publishable key and ecosystem id. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.openfort.xyz/developers/api-keys
// See your ecosystem ID here: https://dashboard.openfort.xyz/settings/project/overview
  WalletGrantPermissions,
  WalletSendCalls, 
  EthRequestAccounts, 
  AppState, 
  EthSendTransaction, 
  EthSignTypedDataV4, 
  EcosystemProvider, 
  PersonalSign, 
  withAuthenticationRequired,
  Settings,
  UnsupportedMethod,
  WalletShowCalls,
  darkFortTheme
} from '@openfort/ecosystem-js/react';

async function getShieldSession(accessToken:string):Promise<string> {
  const response = await fetch(`${process.env.REACT_APP_BACKEND_URL!}/api/protected-create-encryption-session`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${accessToken}`
    }
  });

  if (!response.ok) {
    throw new Error('Failed to fetch shield session');
  }

  const data = await response.json();
  return data.session;
}

const ProtectedRoute = ({ component, ...args }: any) => {
  const Component = withAuthenticationRequired(component, {
    onRedirecting: () => <Loading />,
  });
  return <Component {...args} />;
};

const nav = useNavigate()
return (
<EcosystemProvider 
  appName={process.env.REACT_APP_APP_NAME}
  supportedChains={[80002]}
  appearance={darkFortTheme}
  logoUrl='https://purple-magnificent-bat-958.mypinata.cloud/ipfs/QmfQrh2BiCzugFauYF9Weu9SFddsVh9qV82uw43cxH8UDV'
  onRedirectCallback={(appState?: AppState) => nav((appState && appState.returnTo) || window.location.pathname)} 
  publishableKey={process.env.REACT_APP_OPENFORT_PUBLIC_KEY!}
  ecosystemId={process.env.REACT_APP_OPENFORT_ECOSYSTEM_ID!}
  shieldConfig={{
    shieldPublishableKey: process.env.REACT_APP_SHIELD_PUBLIC_KEY!,
    getShieldSession: getShieldSession 
  }}
  >
  <Routes>
    <Route path='/sign/personal-sign' element={<ProtectedRoute component={PersonalSign} />} />
    <Route path='/sign/eth-sign-typed-data-v-4' element={<ProtectedRoute component={EthSignTypedDataV4} />} />
    <Route path='/sign/eth-send-transaction' element={<ProtectedRoute component={EthSendTransaction} />} />
    <Route path='/sign/wallet-show-calls' element={<ProtectedRoute component={WalletShowCalls} />} />
    <Route path='/sign/wallet-grant-permissions' element={<ProtectedRoute component={WalletGrantPermissions} />} />
    <Route path='/sign/wallet-send-calls' element={<ProtectedRoute component={WalletSendCalls} />} />
    <Route path='/sign/eth-request-accounts' element={<ProtectedRoute component={EthRequestAccounts} />} />
    <Route path='/settings' element={<ProtectedRoute component={Settings} />} />
    <Route path='/' element={<ProtectedRoute component={Loading} />} />
    <Route path='*' element={<UnsupportedMethod />} />
  </Routes>
</EcosystemProvider>
);
}

```
```tsx Loading.tsx

const Loading: React.FC = () => {
    return (
        <div className="fixed inset-0 bg-black flex items-center justify-center">
            <div className="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-white">
                <span className="sr-only">Loading...</span>
            </div>
        </div>
    );
};

```
</CH.Code>
  </TabPanel>
</Tabs>

Check all the available core methods in the [Core SDK reference](/docs/reference/ecosystem-js/classes/core.Core.html).

{/* <div align="center">
  <img
    alt="ecosystem-architecture"
    src="https://blog-cms.openfort.xyz/uploads/ecosystems_04a01570e7.svg"
    width="80%"
    height="80%"
  />
</div> */}

{/* <Admonition type='note'>
Security Considerations
The Openfort SDK ensures secure transactions using the following mechanisms:

- **SignableHash**: All transactions are represented by a `signableHash`, ensuring the integrity of each user action.
- **Access Tokens**: Authenticated via trusted third-party providers to ensure user identity is securely managed.

</Admonition> */}
{/* 
### 2. Set your login methods

### 3. Get your Openfort ecosystem ID

### 4. Import Fort into your app

### 5. Use Fort! */}


# The Wallet Framework for Chains.


The Ecosystem Wallet Framework represents a comprehensive solution for enterprises and developers seeking to implement robust, scalable wallet infrastructure across their blockchain ecosystem. This framework addresses the complexities of wallet architectures while maintaining enterprise-grade security and seamless integration capabilities.

<div align="center">
  <img
    alt="Picture of ecosystems and wallet"
    src="https://blog-cms.openfort.xyz/uploads/openfort_ecosystem_43e2988f53.png"
    width="80%"
    height="80%"
  />
</div>

## Why we built this

Let's be honest - building a smart wallet system from the ground up is no walk in the park. You've got to juggle quite a few balls: setting up authentication, picking the right smart contracts for accounts, implementing signers for ownership, and getting all the infrastructure ready for transaction sponsorship and bundling. Phew!

Sure, you could use a third-party provider to handle all this, but here's the tricky part: it needs to be flexible enough to adapt to your needs while still having as little vendore lock-in to integrate. And let's not forget about the developer experience - because nobody wants to spend weeks just figuring out how to implement a wallet system.

### What's in the box?

Here's the cool stuff you get with the Ecosystem SDK:

- **User Management**: Think of it as your bouncer - keeping track of who's who and making sure only the right people get in
- **Smooth Wallet Onboarding**: We make it super easy for users to get started with their wallets, add funds, and jump right in
- **Your Wallet, Your Rules**: Want to make it look and feel like your own? No problem! You've got full control through our whitelabel dashboard and customizable packages
- **Works Everywhere**: Whether you're building on Unity, Unreal Engine, or browsers, we've got you covered

### How it all fits together

The Ecosystem SDK is built like a well-organized kitchen, with three main stations:

1. **Developer Integration Layer**: Where you cook up your integration
2. **Client-Wallet Communication**: The service window where orders (transactions) get passed
3. **Blockchain Interaction**: Where the magic happens on the blockchain

<div align="center">
  <img
    alt="Ecosystem SDK architecture"
    src="https://blog-cms.openfort.xyz/uploads/fort_framework_1e74c0aee1.svg"
    width="70%"
    height="70%"
  />
</div>

## The main ingredients

### Client SDK (`@openfort/ecosystem/client`)
Think of this as your head chef - it runs the show. It handles everything from creating your custom wallet SDK to managing pop-ups and transactions. The best part? It lives right in your app's front-end and can wear your brand's colors. It even comes with built-in security features and plays nice with all the popular blockchain tools.

<Admonition type="tip">
The Client SDK is EIP-1193 compatible, so it works great with popular tools like [viem](https://viem.sh)!
</Admonition>

### Communication Module (`@openfort/ecosystem/core`)
This is your maitre d' - making sure everything flows smoothly between your client and the wallet. It helps new users get set up with their non-custodial wallets and works in any browser environment. Need more details? Check out our [wallet guide](/docs/guides/javascript/wallets).

### Framework Prefabs
These are like your ready-to-use recipe cards. We've got special helpers for different frameworks, including a really nice setup for [React](https://react.dev/) (`@openfort/ecosystem/react`). And yes, you can customize all the components to match your style!

## "But why not just use embedded wallets?"

Good question! While embedded wallets might seem simpler at first glance, they can actually create quite a headache when you're working across an ecosystem. Here's why:

### The Embedded Wallet setup
Picture this: every single app needs its own separate setup - installing packages, generating keys in iframes, handling authentication... It's like having to build a new kitchen for every restaurant in your chain!

<div align="center">
  <img
    alt="embedded wallets with apps"
    src="https://blog-cms.openfort.xyz/uploads/embedded_wallet_architecture_1629fefe7b.jpg"
    width="80%"
    height="80%"
  />
</div> 

### The Not-So-Fun parts of embedded wallets

1. **Authentication gets messy**
   - Every app needs its own bouncer (authentication system)
   - OAuth2 providers get confused when trying to share wallet access
   - There's no good way to keep track of who's logged in where

2. **Less control than you'd like**
   - Your partners need access to the master keys (Admin credentials)
   - It's harder to keep track of who's spending what
   - No central control room for permissions

3. **More work for everyone**
   - Each partner has to figure out their own wallet setup
   - More chances for security slip-ups
   - No easy way to see what's happening across all apps

## Why the Ecosystem SDK is better

<div align="center">
  <img
    alt="ecosystem wallet with apps"
    src="https://blog-cms.openfort.xyz/uploads/ecosystem_architecture_3b71d2591d.jpg"
    width="80%"
    height="80%"
  />
</div>

What you get:
- One login system that works everywhere (no more authentication headaches!)
- Control all permissions from one place
- A slick dashboard with your brand to onboard projects
- Paymasters and smart accounts by default
- One solid security setup for everything

<div className="video-container">
  <iframe
    src="https://www.youtube-nocookie.com/embed/pzMm86rmC3w"
    frameBorder="1"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>


# Integrating with wallet connectors


Using a **wallet library** provides the most streamlined path to implementing a wallet UI, offering a complete solution with pre-built UI components and a polished user experience out of the box. This approach builds on top of Wagmi and includes additional UI components like the `ConnectButton`, ready-to-use themes, and built-in transaction interfaces. While it requires the most dependencies (`@rapidfire/id`, `Wagmi`, `React Query`, and `RainbowKit` -for example), it significantly reduces development time by providing a complete wallet interface solution. 

<Admonition type='caution' >

To make these instructions concrete, we have created a sample ecosystem wallet called **Rapidfire ID**. To interact with it, you can find its SDK in the NPM package directory: [@rapidfire/id](https://www.npmjs.com/package/@rapidfire/id).

You can check out the GitHub [repository for Rapidfire Wallet](https://github.com/openfort-xyz/ecosystem-sample) to learn how to create your own wallet.

</Admonition>

## Getting an EIP-1193 provider

All of Ecosystem SDK wallets can 
<Admonition type='info'>

[EIP-1193](https://eips.ethereum.org/EIPS/eip-1193), also known as the Ethereum JavaScript API, is a standardized interface for how applications can request information, signatures, and transactions from a connected wallet.

</Admonition>

To get a wallet's EIP-1193 provider, use the `getEthereumProvider` method:

<CH.Code>
```tsx main.tsx

// This example assumes you have already checked that Openfort 'embeddedState' is 
// `ready` and the user is `authenticated`
const provider = await ecosystemWalletInstance.getEthereumProvider();
```
```ts rapidfireConfig.ts

  appChainIds: [80002],
  appLogoUrl: 'https://a.rgbimg.com/users/b/ba/barunpatro/600/mf6B5Gq.jpg',
  appName: 'Example App',
});

```
</CH.Code>

When requesting signatures and transactions from the wallet, you can either choose to interface with the **EIP-1193** provider directly, or to pass it to a library like `wagmi` or `viem`.

<Admonition type='tip'>

If you want to check out the sample using the `@rapidfire/id` directly, you can find it in the [Rapidfire SDK repository](https://github.com/openfort-xyz/ecosystem-sample/tree/main/ecosystem-sdk/sdk-sample). You will see it includes examples using [ethers](https://docs.ethers.org/v5/), [connectKit](https://docs.family.co/connectkit), [rainbowKit](https://www.rainbowkit.com/) and [wagmi](https://wagmi.sh/).

</Admonition>

## Implementation with RainbowKit

<div align="center">
  <img
    alt="ecosystem-rainbow-kit"
    src="https://blog-cms.openfort.xyz/uploads/rainbow_kit_ecosystem_cf5574e8a2.png"
    width="80%"
    height="80%"
  />
</div>

### 1. Install dependencies
Install the `@rapidfire/id` SDK and its peer dependencies:

```bash
npm i @rapidfire/id @rainbow-me/rainbowkit @tanstack/react-query
```

### 2. Create the connector
```ts config.ts

  appChainIds: [80002],
  appLogoUrl: 'https://a.rgbimg.com/users/b/ba/barunpatro/600/mf6B5Gq.jpg',
  appName: 'Example App',
});
```

### 3. Wrap app with providers
At the highest level of your applications, wrap the component with the wagmi, QueryClient, and RainbowKit providers. Pass the configuration you created in step 2 to the wagmi provider.

All of **ecosystem wallets** can 
<Admonition type='info'>

[EIP-1193](https://eips.ethereum.org/EIPS/eip-1193), also known as the Ethereum JavaScript API, is a standardized interface for how applications can request information, signatures, and transactions from a connected wallet.

</Admonition>

To get a wallet's EIP-1193 provider, use the `getEthereumProvider` method:

<CH.Code>
```tsx _app.tsx

const queryClient = new QueryClient();

  useEffect(() => {
    if (!identityInstance) return;
    identityInstance.getEthereumProvider();
  }, []);

  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <Component {...pageProps} />
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```
```ts wagmiConfig.ts

  chains: [polygonAmoy],
  connectors: [injected()],
  transports: {
    [polygonAmoy.id]: http(),
  },
});
```
```ts config.ts

  appChainIds: [80002],
  appLogoUrl: 'https://a.rgbimg.com/users/b/ba/barunpatro/600/mf6B5Gq.jpg',
  appName: 'Example App',
});
```
</CH.Code>

### 4. Use the `ConnectButton`

Import the `ConnectButton` and use to prompt users to connect to their provider **ecosystem wallet**.

```tsx

function Page() {
  return (
    <div>
      <h1> My app </h1>
      ...
      <ConnectButton />
    </div>
  );
}
```

Thats it! You can now use any wagmi hook in your application to interact with the connected wallet. When users connect and transact with their wallet, Openfort will open a pop-up for users to authorize any actions.


# Create a React Native App


<Admonition type='caution' >

To make these instructions concrete, we have created a sample ecosystem wallet called **Rapidfire ID**. To interact with it, you can find its SDK in the NPM package directory: [@rapidfire/id](https://www.npmjs.com/package/@rapidfire/id).

You can check out the GitHub [repository for Rapidfire Wallet](https://github.com/openfort-xyz/ecosystem-sample) to learn how to create your own wallet.

</Admonition>

This guide will walk you through adding support for any **ecosystem wallet** into a React Native app by integrating the [Mobile Wallet Protocol Client](https://www.npmjs.com/package/@mobile-wallet-protocol/client).

<Admonition type="tip">
  If you need a template or scaffold to start with, you can check out the [Ecosystem Wallet Expo Example](https://github.com/openfort-xyz/ecosystem-wallet-expo-example).
</Admonition>

## Prerequisites

### Install peer dependencies

The Mobile Wallet Protocol Client library requires the [Expo WebBrowser](https://docs.expo.dev/versions/latest/sdk/webbrowser/) and [Async Storage](https://react-native-async-storage.github.io/async-storage/docs/install) packages to be installed.
Follow the instructions on the respective pages for any additional setup.

<CH.Code>

```zsh [npm]
npm i expo expo-web-browser @react-native-async-storage/async-storage
```

```zsh [yarn]
yarn add expo expo-web-browser @react-native-async-storage/async-storage
```
</CH.Code>

### Polyfills

Mobile Wallet Protocol Client requires `crypto.randomUUID`, `crypto.getRandomValues`, and `URL` to be polyfilled globally since they are not available in the React Native environment.

Below is an example of how to polyfill these functions in your app using the [expo-crypto](https://docs.expo.dev/versions/latest/sdk/crypto/) and [expo-standard-web-crypto](https://github.com/expo/expo/tree/master/packages/expo-standard-web-crypto/) packages.

<CH.Code>

```zsh [npm]
npm i expo-crypto expo-standard-web-crypto react-native-url-polyfill
```

```zsh [yarn]
yarn add expo-crypto expo-standard-web-crypto react-native-url-polyfill
```

</CH.Code>

<CH.Code>

```js [polyfills.js]

polyfillWebCrypto();
crypto.randomUUID = randomUUID;
```

```tsx [App.tsx]

/// ...
```
</CH.Code>

## Setup

### Install Mobile Wallet Protocol Client

Add the latest version of Mobile Wallet Protocol Client to your project.

<CH.Code>

```zsh [npm]
npm i @mobile-wallet-protocol/client@latest
```

```zsh [yarn]
yarn add @mobile-wallet-protocol/client@latest
```

</CH.Code>

## Usage

Mobile Wallet Protocol Client provides 2 interfaces for mobile app to interact with the Smart Wallet, an EIP-1193 compliant provider interface and a wagmi connector.

<Admonition type="tip">
  If your app is using wallet aggregator, go straight to **Option 2: Wagmi Connector** for 1-line integration. :)
</Admonition>

### Option 1: EIP-1193 Provider

Create a new `EIP1193Provider` instance, which is EIP-1193 compliant.

```tsx [App.tsx]

// Step 1. Initialize provider with your dapp's metadata and target wallet
const metadata = {
  name: "My App Name",
  customScheme: "myapp://", // only custom scheme (e.g. `myapp://`) is supported in v1.0.0
  chainIds: [8453],
  logoUrl: "https://example.com/logo.png",
};
const provider = new EIP1193Provider({
    metadata,
    wallet: {
        type: 'web',
        name: "Rapid fire wallet",
        scheme: 'https://id.sample.openfort.xyz',
        iconUrl: 'https://purple-magnificent-bat-958.mypinata.cloud/ipfs/QmfQrh2BiCzugFauYF9Weu9SFddsVh9qV82uw43cxH8UDV',
    },
});

// ...

// 2. Use the provider
const addresses = await provider.request({ method: "eth_requestAccounts" });
const signedData = await provider.request({
  method: "personal_sign",
  params: ["0x48656c6c6f20776f726c6421", addresses[0]],
});
```

### Option 2: Wagmi Connector

Add the latest verion of Mobile Wallet Protocol wagmi-connectors to your project.

<CH.Code>

```zsh [npm]
npm i @mobile-wallet-protocol/wagmi-connectors@latest
```

```zsh [yarn]
yarn add @mobile-wallet-protocol/wagmi-connectors@latest
```

</CH.Code>

Simply 
```ts [config.ts]
  createConnectorFromWallet,
  Wallets,
} from "@mobile-wallet-protocol/wagmi-connectors";

const metadata = {
  name: "My App Name",
  customScheme: "myapp://", // only custom scheme (e.g. `myapp://`) is supported in v1.0.0
  chainIds: [8453],
  logoUrl: "https://example.com/logo.png",
};

  chains: [base],
  connectors: [
    createConnectorFromWallet({
      metadata,
      wallet: {
        type: 'web',
        name: "Rapid fire wallet",
        scheme: 'https://id.sample.openfort.xyz',
        iconUrl: 'https://purple-magnificent-bat-958.mypinata.cloud/ipfs/QmfQrh2BiCzugFauYF9Weu9SFddsVh9qV82uw43cxH8UDV',
      },
    }),
  ],
  transports: {
    [base.id]: http(),
  },
});
```

Then you can use wagmi's react interface to interact with the Smart Wallet.

```tsx [App.tsx]

// ...

const { connect, connectors } = useConnect();

return (
  <Button
    title={"Connect"}
    onPress={() => {
      connect({ connector: connectors[0] });
    }}
  />
);
```

## Gas Sponsorship

If you want to sponsor transactions, you need to add `#policy=POLICY_ID` to the wallet scheme.

```
#policy=POLICY_ID
```

For example:

```ts [config.ts]
  createConnectorFromWallet,
  Wallets,
} from "@mobile-wallet-protocol/wagmi-connectors";

const metadata = {
  name: "My App Name",
  customScheme: "myapp://", // only custom scheme (e.g. `myapp://`) is supported in v1.0.0
  chainIds: [8453],
  logoUrl: "https://example.com/logo.png",
};

  chains: [base],
  connectors: [
    createConnectorFromWallet({
      metadata,
      wallet: {
        type: 'web',
        name: "Rapid fire wallet",
        scheme: 'https://id.sample.openfort.xyz#policy=pol_a909d815-9b6c-40b2-9f6c-e93505281137',
        iconUrl: 'https://purple-magnificent-bat-958.mypinata.cloud/ipfs/QmfQrh2BiCzugFauYF9Weu9SFddsVh9qV82uw43cxH8UDV',
      },
    }),
  ],
  transports: {
    [base.id]: http(),
  },
});
```


# Security & Trust at Openfort
Protecting your users' data with rigorous security measures and industry best practices.

<Security />


# Signature Verification


Verifying signatures for smart contract wallets involves specific considerations since the smart contract itself cannot produce a signature. Instead, it provides a function:  

```solidity
function isValidSignature(bytes32 _hash, bytes memory _signature) returns (bytes4 magicValue);
```  

This function, defined in [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271), is called to verify if a given signature is valid.  

For a Smart Wallet, a signature is valid if it is signed by a current signer (or "owner") of the wallet. For instance, a user might sign a message using their passkey. When the `isValidSignature` function is called on their Smart Wallet, it validates the signature because the user's passkey is authorized as an owner.  

The following section outlines how to implement both personal message signing and typed data signing using wagmi.

## Message Signing

For basic message signing (personal_sign), you can use wagmi's `useSignMessage` hook. Here's an example implementation:

```tsx

function SignMessage() {
  const { signMessage, data: signature, isPending, error } = useSignMessage()

  const handlePersonalSign = () => {
    signMessage({ message: 'Hello World' })
  }

  return (
    <div>
      <button 
        onClick={handlePersonalSign}
        disabled={isPending}
      >
        {isPending ? 'Signing...' : 'Sign Message'}
      </button>
      
      {signature && (
        <div>
          <p>Signature: {signature}</p>
        </div>
      )}
      
      {error && <div>Error: {error.message}</div>}
    </div>
  )
}
```

## Typed Data Signing

For more complex signatures, you can use typed data signing (EIP-712) with wagmi's `useSignTypedData` hook:

```tsx

function SignTypedData() {
  const { signTypedData, data: signature, isPending, error } = useSignTypedData()

  const types = {
    Mail: [
      {name: 'from', type: 'Person'},
      {name: 'to', type: 'Person'},
      {name: 'content', type: 'string'},
    ],
    Person: [
      {name: 'name', type: 'string'},
      {name: 'wallet', type: 'address'},
    ],
  }

  const handleTypedMessage = () => {
    signTypedData({
      domain: {
        chainId: 1, // Replace with your chain ID
        name: 'Example DApp',
        verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
        version: '1',
      },
      types,
      message: {
        from: { name: 'Alice', wallet: '0x2111111111111111111111111111111111111111' },
        to: { name: 'Bob', wallet: '0x3111111111111111111111111111111111111111' },
        content: 'Hello!',
      },
      primaryType: 'Mail',
    })
  }

  return (
    <div>
      <button 
        onClick={handleTypedMessage}
        disabled={isPending}
      >
        {isPending ? 'Signing...' : 'Sign Typed Data'}
      </button>
      
      {signature && (
        <div>
          <p>Signature: {signature}</p>
        </div>
      )}
      
      {error && <div>Error: {error.message}</div>}
    </div>
  )
}
```

Both signing methods work seamlessly with Smart Contract Wallets that implement EIP-1271, allowing for a consistent signing experience across EOA and Smart Contract Wallets.


# Wagmi template to create a web app


The following is a quick and easy implementation for getting started with [Wagmi](https://wagmi.sh/) template and the ecosystem wallet of choice.

<Admonition type='caution' >

To make these instructions concrete, we have created a sample ecosystem wallet called **Rapidfire ID**. To interact with it, you can find its SDK in the NPM package directory: [@rapidfire/id](https://www.npmjs.com/package/@rapidfire/id).

You can check out the GitHub [repository for Rapidfire Wallet](https://github.com/openfort-xyz/ecosystem-sample) to learn how to create your own wallet.

</Admonition>

This guide will walk you through integrating the ecosystem wallet Rapidfire ID.

<Admonition type="tip">
  If you need a template or scaffold to start with, you can check out the [Rapidfire Wagmi Example](https://github.com/openfort-xyz/ecosystem-sample/tree/main/ecosystem-sdk/sdk-sample).
</Admonition>

<StepHikeCompact>
  <StepHikeCompact.Step step={1}>
    <StepHikeCompact.Details title="Create a new Wagmi project">
      - Run the project creation command using your preferred package manager
      - Follow the CLI prompts to set up your project
      
    </StepHikeCompact.Details>

    <StepHikeCompact.Code>

          ```bash terminal
          npm create wagmi
          ```

    </StepHikeCompact.Code>
  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={2}>
    <StepHikeCompact.Details title="Install dependencies and start development server">
      - Install all required dependencies
      - Start the development server
      - Your app should now be running on localhost
    </StepHikeCompact.Details>

    <StepHikeCompact.Code>

          ```bash terminal
          npm install @rapidfire/id
          npm install
          npm run dev
          ```

    </StepHikeCompact.Code>
  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={3}>
    <StepHikeCompact.Details title="Configure Wagmi with Smart Wallet">
      - Update the Wagmi configuration file.
      - Set up `polygonAmoy` as the primary chain.
      - Configure wallet connector with injected wallet preference.
      
    </StepHikeCompact.Details>

    <StepHikeCompact.Code>

        ```ts wagmi.ts
                        
                  chains: [polygonAmoy],
          connectors: [
            injected(),
          ],
          transports: {
            [polygonAmoy.id]: http(),
          },
        });

        declare module 'wagmi' {
          interface Register {
            config: typeof config;
          }
        }
        ```

    </StepHikeCompact.Code>
  </StepHikeCompact.Step>
  <StepHikeCompact.Step step={4}>
    <StepHikeCompact.Details title="Wrap App in Context Provider">
      Wrap your app in the `WagmiProvider` React Context Provider and pass the **config** you created earlier to the **value** property.

    </StepHikeCompact.Details>
    <StepHikeCompact.Code>
      <CH.Code>
        ```tsx app.tsx
                
        function App() {
          useEffect(() => {
            config.getEthereumProvider();
          }, []);
          return (
            <WagmiProvider config={config}>
              {/** ... */}
            </WagmiProvider>
          )
        }
        ```
        ```ts config.ts
        
        // Initialize the SDK with required parameters
                  appChainIds: [84532],
          appLogoUrl: 'https://a.rgbimg.com/users/b/ba/barunpatro/600/mf6B5Gq.jpg',
          appName: 'Example App',
        });
        ```
        </CH.Code>

    </StepHikeCompact.Code>
  </StepHikeCompact.Step>
  <StepHikeCompact.Step step={5}>
    <StepHikeCompact.Details title="Keep building">
      You can find everything you need here: https://wagmi.sh/react/api/hooks

    </StepHikeCompact.Details>
  </StepHikeCompact.Step>
</StepHikeCompact>


# Linking & unlinking accounts
Linking additional accounts

The user identity represents an authentication method associated to the user. For example, if a user signs in using their email, an email identity will be associated with the user.

Developers can use Openfort to prompt users to link additional accounts (such as a wallet or Discord profile) at any point in their user journey, not just during login.
## Linking accounts
### Link email
Links an email and password to an existing account using an authentication token.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="javascript"
>
    <TabPanel id="javascript" label="Javascript">
<CH.Code>
```tsx auth.tsx

const email = 'EMAIL';
const password = 'PASSWORD';
const authToken = 'YOUR_USER_AUTH_TOKEN';

async function linkEmailPassword() {
  await openfort.linkEmailPassword({email, password, authToken});
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  }
});

```
</CH.Code>
    </TabPanel>
</Tabs>

### Link social accounts
Initializes an OAuth linking process.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="javascript"
>
    <TabPanel id="javascript" label="Javascript">
<CH.Code>
```tsx auth.tsx
const provider = 'OAuth provider';

async function initLinkOAuth() {
  await openfort.initLinkOAuth({provider});
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  }
});

```
</CH.Code>
    </TabPanel>
</Tabs>

### Link wallets
Links a wallet using SIWE.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="javascript"
>
    <TabPanel id="javascript" label="Javascript">
<CH.Code>
```tsx auth.tsx

const signature = 'SIWE signature';
const message = 'SIWE message';
const walletClientType = 'Wallet client type';
const connectorType = 'Connector type';
const authToken = 'YOUR_USER_AUTH_TOKEN';

async function linkWallet() {
  await openfort.linkWallet({signature, message, walletClientType, connectorType, authToken});
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  }
});

```
</CH.Code>
    </TabPanel>
</Tabs>

### Link third party providers
Links a third party provider to an existing account using an authentication token.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="javascript"
>
    <TabPanel id="javascript" label="Javascript">
<CH.Code>
```tsx auth.tsx
const provider = 'Third Party provider';
const token = 'Third Party token';
const tokenType = 'Type of the token (idToken or customToken)'

async function linkThirdParty() {
  await openfort.linkThirdPartyProvider({provider, token, tokenType});
}
```
</CH.Code>
    </TabPanel>
</Tabs>

## Unlinking accounts
Once a user has linked additional accounts to their profile, you may also want to give them the option to unlink those accounts.

### Unlink email
Unlinks an email and password from an existing account using an authentication token.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="javascript"
>
    <TabPanel id="javascript" label="Javascript">
<CH.Code>
```tsx auth.tsx
const email = 'EMAIL';

async function unlinkEmailPassword() {
  await openfort.unlinkEmailPassword(email);
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  }
});

```
</CH.Code>
    </TabPanel>
</Tabs>

### Unlink social accounts
Unlinks an OAuth provider from the account.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="javascript"
>
    <TabPanel id="javascript" label="Javascript">
<CH.Code>
```tsx auth.tsx
const provider = 'OAuth provider';

async function unLinkOAuth() {
  await openfort.unLinkOAuth({provider});
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  }
});

```
</CH.Code>
    </TabPanel>
</Tabs>

### Unlink wallets
Unlinks a wallet.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="javascript"
>
    <TabPanel id="javascript" label="Javascript">
<CH.Code>
```tsx auth.tsx

const address = 'Wallet address';
const authToken = 'YOUR_USER_AUTH_TOKEN';

async function unlinkWallet() {
  await openfort.unlinkWallet({provider, address});
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  }
});

```
</CH.Code>
    </TabPanel>
</Tabs>

### Unlink third party provider
Unlinks a third party provider from an existing account using an authentication token.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="javascript"
>
    <TabPanel id="javascript" label="Javascript">
<CH.Code>
```tsx auth.tsx
const provider = 'Third Party provider';
const token = 'Third Party token';
const tokenType = 'Type of the token (idToken or customToken)'

async function unlinkThirdParty() {
  await openfort.unlinkThirdPartyProvider({provider, token, tokenType});
}
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  }
});

```
</CH.Code>
    </TabPanel>
</Tabs>


# Third-party auth providers
Integrate with existing auth providers and backends

Openfort's embedded signers are fully-compatible with any authentication provider that supports JWT-based, stateless authentication. If you're looking to add embedded signers to your app, you can either:

You will need to call the `authenticateWithThirdPartyProvider` method:
```tsx

await openfort.authenticateWithThirdPartyProvider({
    provider: ThirdPartyOAuthProvider.FIREBASE, // or SUPABASE, etc.
    token: "YOUR_USER_AUTH_TOKEN",
    tokenType: TokenType.ID_TOKEN, // or CUSTOM_TOKEN
});
```

<Admonition type='note'>

To make these instructions concrete, this guide uses [Firebase](https://firebase.com) as a sample third party auth provider that you can integrate alongside Openfort.

</Admonition>

Follow the guide on how to [configure third party auth](/docs/guides/dashboard/external-auth) to learn more.
The supported loginMethods are `'accelbyte'`, `'custom'`, `'firebase'`, `'supabase'`, `'lootlocker'`, `'playfab'`, `'telegramMiniApp'` and `'oidc'`.

<CH.Code>
```tsx auth.tsx

async function loginWithGoogle() {
  const googleProvider = new GoogleAuthProvider();

  signInWithPopup(auth, googleProvider)
    .then(async (result) => {
      const idToken = await result.user.getIdToken();
      const token = await openfort.authenticateWithThirdPartyProvider({provider:ThirdPartyOAuthProvider.FIREBASE, token:idToken, tokenType:TokenType.ID_TOKEN});
    })
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  }
});

```
</CH.Code>

Uppon successful authentication, the SDK will return:
```json response.json
{
  "id": "pla_cc9ed2b7-c5f5-4c43-8dca-c4b104ba1762",
  "object": "player",
  "createdAt": 1710976453,
  "linkedAccounts": [
      {
          "provider": "firebase",
          "disabled": false,
          "externalUserId": "2"
      }
  ]
}
```


# External Wallet Login
Authenticate users with external wallets

Connect wallet via the [Sign in With Ethereum (SIWE)](https://eips.ethereum.org/EIPS/eip-4361) standard. Catered to users who prefer to authenticate using their external wallets, supporting various types such as injected, browser-based, and mobile wallets. Openfort’s integration facilitates a secure and direct authentication process using these wallets.

First create a challenge for the user to sign with their wallet by constructing a SIWE challenge using the nonce returned from the server:

<CH.Code>
```tsx auth.tsx
const address = 'EXTERNAL_WALLET_ADDRESS';

async function initSIWE() {
  await openfort.initSIWE({address});
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  }
});
```
</CH.Code>

Then, verify the SIWE signature to authenticate the user:
- `walletClientType`: e.g. coinbaseWallet, metamask, etc.
- `connectorType`: wallet_connect_v2, injected, coinbase_wallet, etc.

```jsx
const address = 'EXTERNAL_WALLET_ADDRESS';

async function authSIWE(signature, message, walletClientType, connectorType) {
  await openfort.authenticateWithSIWE({
    signature: signature,
    message: SIWEMessage,
    connectorType: connector?.type,
    walletClientType: connector?.name,
  });
}
```

And you’re done! The user is now authenticated and can access your application.

Uppon successful authentication, the SDK will return a token that can be used to authenticate the user in your application.

```json response.json
{
  "player": {
      "id": "pla_cc9ed2b7-c5f5-4c43-8dca-c4b104ba1762",
      "object": "player",
      "createdAt": 1710976453,
      "linkedAccounts": [
          {
              "provider": "wallet",
              "address": "0x1234567890abcdef",
              "disabled": false,
          }
      ]
  },
  "token": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImNmODNlMTM1N2VlZmI4YmRmMTU0Mjg1MGQ2NmQ4MDA3ZDYyMGU0MDUwYjU3MTVkYzgzZjRhOTIxZDM2Y2U5Y2U0N2QwZDEzYzVkODVmMmIwZmY4MzE4ZDI4NzdlZWMyZjYzYjkzMWJkNDc0MTdhODFhNTM4MzI3YWY5MjdkYTNlIn0.eyJhdWQiOiJwcm9fOGY3ZTM1NTktMjhkNy00MWE2LTgxNGMtMjU0OTkzZTdkNjFkLXRlc3QiLCJleHAiOjE3MTA5ODI2MDIsImlhdCI6MTcxMDk3OTAwMiwiaXNzIjoib3BlbmZvcnQueHl6Iiwic2lkIjoiMzhhMDdmMzktMTUxOS00MjE0LWJmNmMtNzI0Zjg0ZDBiZGQwIiwic3ViIjoicGxhX2NjOWVkMmI3LWM1ZjUtNGM0My04ZGNhLWM0YjEwNGJhMTc2MiJ9.EcFtS__GwyxJu1S3tO7jMBbTCIJCpqsoNxxJrqILrKjNl2N5-SIMG2z_s2Vs8ztG6KAVy6zIp6P9GzfD7s4JiA",
  "refreshToken": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImNmODNlMTM1N2VlZmI4YmRmMTU0Mjg1MGQ2NmQ4MDA3ZDYyMGU0MDUwYjU3MTVkYzgzZjRhOTIxZDM2Y2U5Y2U0N2QwZDEzYzVkODVmMmIwZmY4MzE4ZDI4NzdlZWMyZjYzYjkzMWJkNDc0MTdhODFhNTM4MzI3YWY5MjdkYTNlIn0.eyJzaWQiOiIzOGEwN2YzOS0xNTE5LTQyMTQtYmY2Yy03MjRmODRkMGJkZDAiLCJpYXQiOjE3MTA5NzkwMDIsImV4cCI6MTcxMzU3MTAwMn0.koNd4eoevBQQR3-z0CMGL5qVzOURZEeAgjvrHMRloLgDbScS2Qbi4W-vf2fE0fYOWUIAHnAq7cDABNwSQrEvSQ"
}
```


# Guest Mode
Enable users to quickly start using your application without registration

Guest accounts allow users to immediately start using your application without going through a full registration process. This feature is particularly useful for applications where you want to reduce friction in the user onboarding process.

### Key Features

- They are locally persisted, so guest users can leave and return to the same account on the same device.
- Locally persisted sessions.
- Fully functional embedded wallets.
- Upgradeable to fully logged-in accounts. 
- They can be logged out and deleted as needed.

<Admonition type='note'>

User data and embedded wallets from guest sessions cannot be merged into an existing user account — guest accounts can only be upgraded into a new user account. If a guest user wants to log in with an existing account, you must delete the guest user session first.

</Admonition>

## Implementation

### Create a guest account (client-side)

Use the `signUpGuest` method from the Openfort SDK to create a guest account:

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="javascript"
>
    <TabPanel id="javascript" label="Javascript">
<CH.Code>
```tsx auth.tsx

async function handleGuest() {
  try {
    const data = await openfort.signUpGuest();
    // Handle successful guest registration
    // The response includes player information and authentication tokens
  } catch (error) {
    // Handle error
  }
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  }
});

```
</CH.Code>
</TabPanel>
</Tabs>

Upon successful registration, you'll receive a response containing the player information and authentication tokens:

```json
{
  "player": {
    "id": "pla_...",
    "object": "player",
    "createdAt": 1234567890,
    "linkedAccounts": []
  },
  "token": "eyJhbG...",
  "refreshToken": "eyJhbG..."
}
```

<Admonition type="tip" label='integration tip'>

- Display guest access alongside normal login options
- Use clear labeling to distinguish between guest and full account creation

```javascript
const LoginOptions = () => {
  return (
    <div className="space-y-4">
      <Button onClick={handleGuest}>
        Continue as Guest
      </Button>
      <Button onClick={() => router.push("/login")}>
        Login or Create Account
      </Button>
    </div>
  );
};
```
</Admonition>

### Upgrade a guest user to a logged-in user
Simply call [link method](/docs/guides/javascript/auth/user-management/linking) to enable the guest user to upgrade their account to a logged-in account using any authentication method of their choice.

## Example Implementation

Here's a complete example of a guest authentication flow:

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="javascript"
>
    <TabPanel id="javascript" label="Javascript">
```javascript

function GuestAuth() {
  const router = useRouter();
  const [status, setStatus] = useState(null);

  const handleGuest = async () => {
    setStatus({
      type: "loading",
      title: "Creating guest account...",
    });

    try {
      const data = await openfort.signUpGuest();
      
      setStatus({
        type: "success",
        title: "Guest account created",
      });
      
      // Store credentials and redirect
      openfort.storeCredentials({
        player: data.player.id,
        accessToken: data.token,
        refreshToken: data.refreshToken,
      });
      
      router.push("/");
    } catch (error) {
      setStatus({
        type: "error",
        title: "Error creating guest account",
      });
    }
  };

  return (
    <div>
      <Button onClick={handleGuest}>
        {status?.type === "loading" ? (
          <Loading />
        ) : (
          "Continue as Guest"
        )}
      </Button>
    </div>
  );
}
```
</TabPanel>
</Tabs>


# Social Login (OAuth)


To initiate sign in, you can use the `initOAuth()` method from the Openfort JavaScript library and provide a `redirectTo` URL which points to a callback route.
- **Implicit flow**: that's all you need to do. The user will be taken to Google's consent screen, and finally redirected to your app with an access and refresh token pair representing their session.
- **Pooling flow**: for example in Server-Side Auth, you need to redirect the user back to your website.

You will need to call the `initOAuth` method:

```tsx

await openfort.initOAuth({
    provider: OAuthProvider.GOOGLE, // or FACEBOOK, TWITTER, etc.
    options: {
      // Depdening on the flow
      // redirectTo: 'https://your-website.com/login',
      // usePooling: true,
    },
});
```

<Admonition type='note'>

Configure your social login providers at [your dashboard](https://dashboard.openfort.xyz/players/auth/providers).
Follow the guide on how to [configure social login](/docs/guides/dashboard/social-login) to learn more.

</Admonition>

Configure your social login providers from your dashboard. Follow the guide on how to [configure social login](/docs/guides/dashboard/social-login) to learn more.
The supported loginMethods are `'google'`, `'twitter'`, `'discord'`, `'facebook'`, `'telegram'`, `'line'` or `'epic_games'`.

<Tabs
  scrollable
  type="underlined"
  defaultActiveId="implicit"
  queryGroup="platform"
>
  <TabPanel id="implicit" label="Implicit flow">
<CH.Code>
```tsx auth.tsx

function AuthButton() {
  return (
    <button onClick={async () => {
      const {url} = await openfort.initOAuth({
        provider: OAuthProvider.FACEBOOK,
        options: {
          redirectTo:'https://your-website.com/login',
        },
      });
      window.location.href = url;
    }}
    >
      Continue with Facebook
    </button>
  );
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  }
});

```
</CH.Code>

```json response.json
{
  "url": "redirect-url",
  "key": "key"
}
```

    Now you can redirect the user to the initOAuth.url and when the process is done, you will be redirected to the redirectTo url with tokens `https://your-website.com?access_token=...&refresh_token=...&player_id=...`
    You can then use those parameters to authenticate the user:

```ts
openfort.storeCredentials({
    player: player_id,
    accessToken: access_token,
    refreshToken: refresh_token,
  });
```
  </TabPanel>
  <TabPanel id="pooling" label="Pooling flow">

    You can pool the auth with the key returned from the initOAuth, this will check if the auth is ready every 0.5 seconds for 5 minutes sessions live for 1 hour, so you can pool the auth again if you need to.
<CH.Code>
```tsx auth.tsx

function AuthButton() {
  return (
    <button onClick={async () => {
      const {key} = await openfort.initOAuth({
        provider: OAuthProvider.FACEBOOK,
        options: {
          usePooling: true,
        },
      });
      await openfort.poolOAuth(key);
    }}
    >
      Continue with Facebook
    </button>
  );
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  }
});

```
</CH.Code>
  </TabPanel>
</Tabs>

Uppon successful authentication, the SDK will return a token that can be used to authenticate the user in your application.

```json response.json
{
  "player": {
      "id": "pla_cc9ed2b7-c5f5-4c43-8dca-c4b104ba1762",
      "object": "player",
      "createdAt": 1710976453,
      "linkedAccounts": [
          {
              "provider": "facebook",
              "disabled": false,
              "externalUserId": "2"
          }
      ]
  },
  "token": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImNmODNlMTM1N2VlZmI4YmRmMTU0Mjg1MGQ2NmQ4MDA3ZDYyMGU0MDUwYjU3MTVkYzgzZjRhOTIxZDM2Y2U5Y2U0N2QwZDEzYzVkODVmMmIwZmY4MzE4ZDI4NzdlZWMyZjYzYjkzMWJkNDc0MTdhODFhNTM4MzI3YWY5MjdkYTNlIn0.eyJhdWQiOiJwcm9fOGY3ZTM1NTktMjhkNy00MWE2LTgxNGMtMjU0OTkzZTdkNjFkLXRlc3QiLCJleHAiOjE3MTA5ODI2MDIsImlhdCI6MTcxMDk3OTAwMiwiaXNzIjoib3BlbmZvcnQueHl6Iiwic2lkIjoiMzhhMDdmMzktMTUxOS00MjE0LWJmNmMtNzI0Zjg0ZDBiZGQwIiwic3ViIjoicGxhX2NjOWVkMmI3LWM1ZjUtNGM0My04ZGNhLWM0YjEwNGJhMTc2MiJ9.EcFtS__GwyxJu1S3tO7jMBbTCIJCpqsoNxxJrqILrKjNl2N5-SIMG2z_s2Vs8ztG6KAVy6zIp6P9GzfD7s4JiA",
  "refreshToken": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImNmODNlMTM1N2VlZmI4YmRmMTU0Mjg1MGQ2NmQ4MDA3ZDYyMGU0MDUwYjU3MTVkYzgzZjRhOTIxZDM2Y2U5Y2U0N2QwZDEzYzVkODVmMmIwZmY4MzE4ZDI4NzdlZWMyZjYzYjkzMWJkNDc0MTdhODFhNTM4MzI3YWY5MjdkYTNlIn0.eyJzaWQiOiIzOGEwN2YzOS0xNTE5LTQyMTQtYmY2Yy03MjRmODRkMGJkZDAiLCJpYXQiOjE3MTA5NzkwMDIsImV4cCI6MTcxMzU3MTAwMn0.koNd4eoevBQQR3-z0CMGL5qVzOURZEeAgjvrHMRloLgDbScS2Qbi4W-vf2fE0fYOWUIAHnAq7cDABNwSQrEvSQ"
}
```


# Email and Password
Allow users to sign in with a password connected to their email 

Users often expect to sign in to your site with a password. Openfort Auth helps you implement password-based auth safely, using secure configuration options and best practices for storing and verifying passwords.

{/* Set up password for your Openfort project.

- Enable the email provider in your [Openfort Project](/dashboard/project/_/auth/providers)
- Configure the Site URL and any additional redirect URLs in the [authentication management tab](/dashboard/project/_/auth/url-configuration).
- The Site URL represents the default URL that the user will be redirected to after clicking on the email signup confirmation link. */}

<Admonition type='note'>

You can update the server sending email notifications and the email templates through your dashboard. Visit the guide on how to [update password authentication](/docs/guides/dashboard/password/custom-smtp) to learn more.

</Admonition>

## Sign up a user

You directly receives the access token after the user confirms their email. 

  To sign up the user, call signUpWithEmailPassword() with their email address and password.

  You can optionally specify a URL to redirect to after the user clicks the confirmation link. This URL must be configured as a Redirect URL. If you don't specify a redirect URL, the user is automatically redirected to your site URL.
  
  
<CH.Code>
```tsx auth.tsx

async function signUpNewUser(email:string, password:string, firstName:string, lastName:string) {
  await openfort.signUpWithEmailPassword({
    email: email,
    password: password,
    options: {
      data: {
        name: firstName + ' ' + lastName,
      },
    },
  });
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  }
});

```
</CH.Code>
  If you want the users to verify their email, you can send them an email after sign up with:

```ts
await openfort.requestEmailVerification({
    email: email,
    redirectUrl: 'http://example.com/account/register',
  });
```

## Log in a user

When your user signs in, call logInWithEmailPassword() with their email address and password:

```ts 

const openfort = new Openfort({
  baseConfiguration: {
      publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY"
  }
});

async function logInpUser() {
  await openfort.logInWithEmailPassword({
    email: email,
    password: password
  });
}
```

Uppon successful authentication, the SDK will return a token that can be used to authenticate the user in your application.

```json response.json
{
  "player": {
      "id": "pla_cc9ed2b7-c5f5-4c43-8dca-c4b104ba1762",
      "object": "player",
      "createdAt": 1710976453,
      "linkedAccounts": [
          {
              "provider": "email",
              "disabled": false,
              "verified": true,
              "email": "hello@example.com"
          }
      ]
  },
  "token": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImNmODNlMTM1N2VlZmI4YmRmMTU0Mjg1MGQ2NmQ4MDA3ZDYyMGU0MDUwYjU3MTVkYzgzZjRhOTIxZDM2Y2U5Y2U0N2QwZDEzYzVkODVmMmIwZmY4MzE4ZDI4NzdlZWMyZjYzYjkzMWJkNDc0MTdhODFhNTM4MzI3YWY5MjdkYTNlIn0.eyJhdWQiOiJwcm9fOGY3ZTM1NTktMjhkNy00MWE2LTgxNGMtMjU0OTkzZTdkNjFkLXRlc3QiLCJleHAiOjE3MTA5ODI2MDIsImlhdCI6MTcxMDk3OTAwMiwiaXNzIjoib3BlbmZvcnQueHl6Iiwic2lkIjoiMzhhMDdmMzktMTUxOS00MjE0LWJmNmMtNzI0Zjg0ZDBiZGQwIiwic3ViIjoicGxhX2NjOWVkMmI3LWM1ZjUtNGM0My04ZGNhLWM0YjEwNGJhMTc2MiJ9.EcFtS__GwyxJu1S3tO7jMBbTCIJCpqsoNxxJrqILrKjNl2N5-SIMG2z_s2Vs8ztG6KAVy6zIp6P9GzfD7s4JiA",
  "refreshToken": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImNmODNlMTM1N2VlZmI4YmRmMTU0Mjg1MGQ2NmQ4MDA3ZDYyMGU0MDUwYjU3MTVkYzgzZjRhOTIxZDM2Y2U5Y2U0N2QwZDEzYzVkODVmMmIwZmY4MzE4ZDI4NzdlZWMyZjYzYjkzMWJkNDc0MTdhODFhNTM4MzI3YWY5MjdkYTNlIn0.eyJzaWQiOiIzOGEwN2YzOS0xNTE5LTQyMTQtYmY2Yy03MjRmODRkMGJkZDAiLCJpYXQiOjE3MTA5NzkwMDIsImV4cCI6MTcxMzU3MTAwMn0.koNd4eoevBQQR3-z0CMGL5qVzOURZEeAgjvrHMRloLgDbScS2Qbi4W-vf2fE0fYOWUIAHnAq7cDABNwSQrEvSQ"
}
```

## Resetting a password (Forgot password)
### Step 1: Create a reset password page
Create a reset password page. This page should be publicly accessible.
Collect the user's email address and request a password reset email. Specify the redirect URL, which should point to the URL of a change password page. 

```ts 
await openfort.requestResetPassword({
  email: 'hello@example.com',
  redirectUrl: 'http://example.com/account/update-password',
})
```

### Step 2: Create a change password page
Create a change password page at the URL you specified in the previous step. This page should be accessible only to authenticated users.
Collect the user's new password and call updateUser to update their password.

You should also pass the state parameters, which should be available in the URL of the change password page. This is to prevent CSRF attacks.

```ts 
await openfort.resetPassword({
  email: 'hello@example.com',
  password: 'new-password',
  state: 'verification-state',
})
```


# User Management
Using Openfort Auth to manage users.

## The user object

Use the Auth Players page of the dashboard to manage all of your app's users and their linked accounts.

Every authenticated user with Openfort Auth results in a JSON that combines the user's information with the Openfort player `id`:

```json
    {
      "id": "pla_ff54b031-a878-4ca2-9cf5-ae190f921e9b",
      "object": "player",
      "createdAt": 1691658234,
      "linkedAccounts": [
        {
          "provider": "email",
          "email": "jaume@openfort.xyz",
          "disabled": false,
          "updatedAt": 1691658234
        }
      ]
    }
```

After a player has authenticated, an Openfort player `id` is created for them and is accessible through your Openfort Dashboard.

<div align="center">
  <img
    width="100%"
    height="100%"
    src="https://blog-cms.openfort.xyz/uploads/authenticated_players_47fca49025.png?updated_at=2023-11-09T20:08:24.682Z"
    alt='authenticated players'
  />
</div>

## Deleting users

From the user drawer, you can delete a user if necessary. This is an irreversible and destructive action although the associated player will not be deleted; if the user logs into your app again, they will have a new player id, will have to relink any formerly linked accounts, and will get a new embedded signer address. Please take extreme care when deleting users.


# User Session (JWT/Authorization)
Using Openfort Auth to onboard new users.

## What is a session?

A session is created when a user signs in. By default, it lasts 1 hour and a user can have an unlimited number of active sessions.

A session is represented by the Openfort Auth access token in the form of a JWT, and a refresh token which is a unique string.

Access tokens are designed to be short lived while refresh tokens never expire but can only be used once. You can exchange a refresh token only once to get a new access and refresh token pair. 

This process is called **refreshing the session.** 

A session terminates, depending on configuration, when:

- The user clicks sign out.
- The user changes their password or performs a security sensitive action.
- It times out due to inactivity.
- It reaches its maximum lifetime.
- A user signs in on another device.

### Access token format
Openfort access tokens are JSON Web Tokens (JWT), signed with the ES256 algorithm. These JWTs include certain information about the user in its claims, namely:

- `sid` is the user’s current session ID
- `sub` is the user’s player Id
- `iss` is the token issuer, which should always be openfort.xyz
- `aud` is your Openfort app ID
- `iat` is the timestamp of when the JWT was issued
- `exp` is the timestamp of when the JWT will expire and is no longer valid. This is generally 1 hour after the JWT was issued.

## Authorizing requests with the access token
To include the current user's access token on requests to your backend, follow the instructions below. Make sure to follow the appropriate instructions if your app uses local storage.

```ts
const authToken = openfort.getAccessToken();

const response = await fetch(<your-api-route>, {
    method: <your-request-method>
    body: <your-request-body>,
    headers: {
        'Authorization': `Bearer ${accessToken}`, 
        /* Add any other request headers you'd like */
    }
});
```

<Admonition type='tip'>

Visit our guide to [verify tokens server-side](/docs/guides/server/access-token) to learn how to validate the access token on your backend.

</Admonition>

## Log out a user

When your user logs out, call `logout()` to remove them from the browser session and any objects from localStorage.

```js
const openfort = new Openfort({
  baseConfiguration: {
      publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY"
  }
});

async function logout() {
  await openfort.logout();
}
```

Upon sign out, all refresh tokens and potentially other database objects related to the affected sessions are destroyed and the client library removes the session stored in the browser.

<Admonition type="caution">

Access tokens of revoked sessions remain valid until their expiry time, encoded in the `exp` claim. The user won't be immediately logged out and will only be logged out when the access token expires. 

</Admonition>


# iframe Service
Use Openfort embedded signer to seamlessly create non-custodial smart accounts for your players.

The iframe service is a crucial element in ensuring the security and privacy of a user's private keys. The isolated iframe operates as a secure environment, managing the private key and executing wallet operations. This setup is pivotal because it keeps the private key confined to an in-memory state within the iframe, never storing it in a database or allowing it to persist beyond the session. This isolation also means the private key is protected from potential exposure or theft, as it's inaccessible to both the app's code and the Openfort SDK.

<Admonition type="info">
Self hosting and writing your own iframe communication code is a complex task. We recommend using the [@openfort/openfort-js](https://www.npmjs.com/package/@openfort/openfort-js) to interact with the iframe. The SDK provides a simple and secure way to communicate with the iframe service. 
</Admonition>

This guide provides a step-by-step approach to downloading and running the openfort/iframe Docker image, which is hosted on Docker Hub. By following these instructions, you will be able to set up and host the image on your local machine or server environment.

## Hosting the iframe
### Prerequisites
Before you begin, make sure you have the following installed:
- Docker: Ensure you have Docker installed on your machine. If not, download and install Docker from the [official website](https://docs.docker.com/engine/install/).

### Step 1: Pulling the Docker Image
To start, you'll need to pull the openfort/iframe image from Docker Hub. Open a terminal and run the following command:

```bash
docker pull openfort/iframe
```

 or use the following command to pull the image from the Docker Hub:

<div className="grid md:grid-cols-12 gap-4 not-prose">
  {image.map((x) => (
    <div className="col-span-4" key={x.href}>
      <Link href={x.href} passHref>
        <GlassPanel icon={'/docs/img/icons/docker-icon'} hasLightIcon={true} title={x.name}>
          {x.description}
        </GlassPanel>
      </Link>
    </div>
  ))}
</div>

  {
    name: 'iframe docker image',
    description: 'Self-hostable iframe service for key generation and signing transactions.',
    href: 'https://hub.docker.com/r/openfort/iframe',
  }
]

This command downloads the latest version of the openfort/iframe image to your local machine. If you need a specific version, you can tag it like this: openfort/iframe:tagname.

### Step 2: Running the Docker Image
Once the image is pulled, you can run it as a container. To do this, execute the following command in your terminal:

```bash
docker run -d -p 8080:80 openfort/iframe
```
Here, -d runs the container in detached mode (in the background), and -p 8080:80 maps port 80 of the container to port 8080 on your host machine. Adjust the port settings as needed for your environment.

### Step 3: Accessing the Application
After the container starts, you can access the application by opening a web browser and navigating to http://localhost:8080. You should see the Openfort iframe service running and ready for use.

## Interacting with the iframe
The iframe service provides a set of APIs that allow you to interact with the embedded signer. These APIs enable you to create, sign, and broadcast transactions, as well as manage accounts and keys.

### Communicating with the iframe

We have created a client side library to help you interact with the iframe service. You can find the library on:

<div className="grid md:grid-cols-12 gap-4 not-prose">
  {examples.map((x) => (
    <div className="col-span-4" key={x.href}>
      <Link href={x.href} passHref>
        <GlassPanel icon={'/docs/img/icons/github-icon-light'} hasLightIcon={true} title={x.name}>
          {x.description}
        </GlassPanel>
      </Link>
    </div>
  ))}
</div>

  {
    name: 'iframe client SDK',
    description: 'A client library to communicate with the Openfort iframe service.',
    href: 'https://github.com/openfort-xyz/iframe-client',
  }
]


# Shield (automatic recovery)
Use Openfort embedded signer to seamlessly create non-custodial smart accounts for your players.

<Admonition type="info">
This guide is for developers that want to self-host Shield (automatic recovery) for their users. If you are a user looking to use Shield and to understand how it works, please refer to the [user guide](/docs/guides/javascript/embedded-signer/recovery).
</Admonition>

In automatic recovery, Openfort uses Shield to encrypt and store the **recovery share** of the embedded signer on behalf of the user. 

<Admonition type='caution'>
In the case you do not require a passcode from your users, you are trusting whoever hosts Shield's infrastructure as well as setting the user's authentication token as the sole root of trust for their wallet. We generally recommend you prompt users to set a recovery passcode upfront, especially as assets in a wallet grow.
</Admonition>

<div className="grid md:grid-cols-12 gap-4 not-prose">
  {image.map((x) => (
    <div className="col-span-4" key={x.href}>
      <Link href={x.href} passHref>
        <GlassPanel icon={'/docs/img/icons/github-icon-light'} hasLightIcon={true} title={x.name}>
          {x.description}
        </GlassPanel>
      </Link>
    </div>
  ))}
</div>

  {
    name: 'Shield',
    description: 'Self-hostable Shield service.',
    href: 'https://github.com/openfort-xyz/shield',
  }
]

### Communicating with Shield

We have created a client side library to help you interact with the Shield service. You can find the library on:

<div className="grid md:grid-cols-12 gap-4 not-prose">
  {examples.map((x) => (
    <div className="col-span-4" key={x.href}>
      <Link href={x.href} passHref>
        <GlassPanel icon={'/docs/img/icons/github-icon-light'} hasLightIcon={true} title={x.name}>
          {x.description}
        </GlassPanel>
      </Link>
    </div>
  ))}
</div>

  {
    name: 'Shield client SDK',
    description: 'A client library to communicate with the Openfort Shield service.',
    href: 'https://github.com/openfort-xyz/shield-js',
  }
]


# Advanced (self-hosted)
Self-hosting, advanced configuration, and more.

<Admonition type="note">
These are **low-level** guides for developers who want to customize the signer experience. If you're looking for a quick way to get started, check out the [quick start guide](/docs/guides/javascript/embedded-signer/recovery).
</Admonition>

Openfort's embedded signer is designed for complete customization and control. This guide will walk you through the advanced features and configurations available to you.

<div align="center">
  <img
    alt="advanced-embedded-signer"
    src="https://blog-cms.openfort.xyz/uploads/advanced_embedded_signer_fe10857ce7.svg?updated_at=2024-03-22T17:52:51.307Z"
    width="50%"
    height="50%"
  />
</div>

## Self-hosting

<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href={`/guides/auth/advanced/iframe`}
    key={'iframe'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='iframe'>
        {'Learn how reconstruct and create an embedded Signer. Deploy your own iframe and interact with it.'}
      </GlassPanel>
  </Link>

    <Link
    href={`/guides/auth/advanced/shield`}
    key={'shield'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Shield'>
        {'Learn how host your own automatic recovery server.'}
      </GlassPanel>
  </Link>
</div>


# Exporting the embedded signer
Learn how to export the private key

This allows them to use their embedded signer address with another wallet client, such as Metamask in any application. 
Note that this embedded signer is only controlling the smart account and does not hold assets in it. If you want to simply transfer ownership to a Metamask and interact with a smart contract, we'll recommend checking the [transfer ownership section](/docs/guides/javascript/smart-wallet/advanced/transfer-ownership).

To have your user 
If your user is not `authenticated` or has not yet created an embedded signer in your game, this method will fail.

As an example, you might attach `exportPrivateKey` as an event handler to an 
<CH.Code>
```tsx ExportWalletButton.tsx

// This example assumes you have already checked that Openfort 'embeddedState' is 
// `ready` and the user is `authenticated`
function ExportWalletButton() {
  const handleExportWalletButton = async () => {
    const privateKey = await openfort.exportPrivateKey();
    console.log(privateKey);
  };

  return (
      <button onClick={handleExportWalletButton}>
        {'Export my wallet'}
      </button>
  );
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
  shieldConfiguration: {
    shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
  },
});
```
</CH.Code>

<Admonition type="info">

When your user exports their embedded signer, their private key is assembled on a different origin than your app's origin. This means neither you nor Openfort can ever access your user's private key. **Your user is the only party that can ever access their full private key.**

</Admonition>


# Create and recover signers
Create and manage embedded wallets for your users

<Header />

<Decide />

<Automatic />

<Admonition type='note'>
An encryption session is requested every time `configureEmbeddedSigner` is called. The encryption session is only valid for **a single use**.
</Admonition>

Once we've secured the backend we setup the client side:

<Tabs
scrollable
size="small"
type="underlined"
defaultActiveId="openfort-auth"
>
<TabPanel id="openfort-auth" label="Openfort auth">

<CH.Code>
```tsx configure.tsx

async function authSetAutomaticRecoveryMethod(email:string, password:string) {
    const response = await openfort.signUpWithEmailPassword({email, password});
    const chainId = 80002;
    const shieldAuth: ShieldAuthentication = {
        auth: ShieldAuthType.OPENFORT,
        token: response.token,
        encryptionSession: await getEncryptionSession()
    };
    await openfort.configureEmbeddedSigner(chainId, shieldAuth);
}
```
```ts encryptionSession.ts
const getEncryptionSession = async (): Promise<string> => {
    try {
        const response = await fetch('https://your-api-endpoint.com/api/protected-create-encryption-session', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({})
        });
        const data = await response.json();
        return data.session;
    } catch (error) {
        throw new Error('Failed to create encryption session');
    }
};
```
```ts openfortConfig.ts

const openfort = new Openfort({
    baseConfiguration: {
        publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
    },
    shieldConfiguration: {
        shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
    },
});
```
</CH.Code>
</TabPanel>

<TabPanel id="third-party-auth" label="Third party auth">
This example will showcase **Firebase** as the third-party auth provider. You can replace it with any other [third-party auth provider](/docs/guides/javascript/auth/external-auth).

<CH.Code>
```tsx configure.tsx

async function authSetAutomaticRecoveryMethod(idToken: string) {
    await openfort.authenticateWithThirdPartyProvider({provider: ThirdPartyOAuthProvider.FIREBASE, token: idToken, tokenType: TokenType.idToken});
    const chainId = 80002;
    const shieldAuth = {
        auth: ShieldAuthType.OPENFORT,
        token: idToken,
        authProvider: "firebase",
        tokenType: "idToken",
        encryptionSession: await getEncryptionSession()
    };
    await openfort.configureEmbeddedSigner(chainId, shieldAuth);
}
```
```ts encryptionSession.ts
const getEncryptionSession = async (): Promise<string> => {
    try {
        const response = await fetch('https://your-api-endpoint.com/api/protected-create-encryption-session', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({})
        });
        const data = await response.json();
        return data.session;
    } catch (error) {
        throw new Error('Failed to create encryption session');
    }
};
```
```ts openfortConfig.ts

const openfort = new Openfort({
    baseConfiguration: {
        publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
    },
    shieldConfiguration: {
        shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
    },
});
```
</CH.Code>

</TabPanel>
</Tabs>

<Admonition type='tip'>
We recommend enabling user-based recovery for users. This is especially important to enforce as the value of assets in a user's wallet grows.
</Admonition>

---

<UserBased />

<Tabs
scrollable
size="small"
type="underlined"
defaultActiveId="openfort-auth"
>
<TabPanel id="openfort-auth" label="Openfort auth">

<CH.Code>
```tsx configure.tsx

async function authSetPasswordRecoveryMethod(email:string, password:string, recoveryPassword:string) {
    const response = await openfort.signUpWithEmailPassword({email, password});
    const chainId = 80002;
    const shieldAuth: ShieldAuthentication = {
        auth: ShieldAuthType.OPENFORT,
        token: response.token
    };
    await openfort.configureEmbeddedSigner(chainId, shieldAuth, recoveryPassword);
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
    shieldConfiguration: {
        shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
        shieldEncryptionKey: "YOUR_SHIELD_ENCRYPTION_SHARE",
    },
});
```
</CH.Code>
</TabPanel>

<TabPanel id="third-party-auth" label="Third party auth">
This example will showcase **Firebase** as the third-party auth provider. You can replace it with any other third-party auth provider [supported by Openfort](/docs/guides/javascript/auth/external-auth) or with [Custom Auth](/docs/guides/javascript/auth/custom-auth).

<CH.Code>
```tsx configure.tsx

async function authAndSetPassordRecoveryMethod(idToken: string, password: string) {
    await openfort.authenticateWithThirdPartyProvider({provider:ThirdPartyOAuthProvider.FIREBASE, token: idToken, tokenType: TokenType.idToken});
    const chainId = 80002;
    const shieldAuth: ShieldAuthentication = {
        auth: ShieldAuthType.OPENFORT,
        token: idToken,
        authProvider: "firebase",
        tokenType: "idToken",
    };
    await openfort.configureEmbeddedSigner(chainId, shieldAuth, password);
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
    shieldConfiguration: {
        shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
        shieldEncryptionKey: "YOUR_SHIELD_ENCRYPTION_SHARE",
    },
});
```
</CH.Code>
</TabPanel>

</Tabs>

---

<Pregenerate />


# Sign messages with the embedded signer 


To request personal signatures from your embedded signer, you can either:

- use the wallet's EIP-1193 provider to send JSON-RPC requests to the wallet directly.
- pass the wallet to a library like `viem`, `ethers`, or `wagmi`.
- for the embedded signer specifically, use Openfort's native `signMessage` and `sendTypedMessage` methods.

The guide below explains how to request signatures and transactions via the **Openfort native methods**.

## Signing messages

To request a signature from a user, use the `signMessage` method.

When invoked, `signMessage` will request an EIP-191 [personal_sign](https://docs.metamask.io/wallet/reference/personal_sign/) signature from the embedded signer, and returns a Promise for the user's signature as a string.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="evm"
>
    <TabPanel id="evm" label="EVM">

    <CH.Code>
    ```tsx client.tsx
    
    // This example assumes you have already checked that Openfort 'embeddedState' is 
    // `ready` and the user is `authenticated`
    async function signMessageButton(message:string) {
      await openfort.signMessage(message);
    }
    ```
    ```ts openfortConfig.ts
    
    const openfort = new Openfort({
      baseConfiguration: {
        publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
      },
      shieldConfiguration: {
        shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
      },
    });

        ```
    </CH.Code>
    </TabPanel>
</Tabs>

## Signing typed data

To have a user sign an EIP-712 typed data signature, use the `signTypedData` method.

When invoked, `signTypedData` will request an EIP-721 [eth_signTypedData_v4](https://docs.metamask.io/wallet/reference/eth_signtypeddata_v4/) signature from the embedded signer, and returns a Promise for the user's signature as a string.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="evm"
>
    <TabPanel id="evm" label="EVM">
    <CH.Code>
    ```tsx client.tsx
    
    // This example assumes you have already checked that Openfort 'embeddedState' is 
    // `ready` and the user is `authenticated`
    async function signTypedMessageButton(domain: any, types: any, value: any) {
      await openfort.signTypedData(domain, types, value);
    }
    ```
    ```ts openfortConfig.ts
    
    const openfort = new Openfort({
      baseConfiguration: {
        publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
      },
      shieldConfiguration: {
        shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
      },
    });

        ```
    </CH.Code>
    </TabPanel>
</Tabs>


# Update recovery method
Switch between different recovery methods

Once a wallet has been created, users have the ability to upgrade from automatic recovery to a user-owned recovery method, or to switch between different user-owned recovery methods.

## Upgrading a user's recovery method

To update the recovery method, you will need to call the `setEmbeddedRecovery`:

```tsx
await openfort.setEmbeddedRecovery({
    recoveryMethod,
    recoveryPassword,
    encryptionSession,
});
```

In order to update the recovery method, you will need to request the user for their **password**.

<Admonition type='tip'>
Users can **reset their password** using this method as well.
</Admonition>

When calling `setEmbeddedRecovery`, then recovery method will be updated to the new method provided. The user won't be required to reconstruct their embedded signer right after.

As an example, you might add `setEmbeddedRecovery` as an event handler for a set recovery button in your app:

<CH.Code>
```tsx UpdateRecoveryButton.tsx

// This example assumes you have already checked that Openfort 'embeddedState' is 
// `ready` and the user is `authenticated`
function AddOrUpdateRecoveryButton() {
  const handleUpdateRecovery = async () => {
    const password = (
        document.querySelector(
          `input[name="password"]`
        ) as HTMLInputElement
      ).value;
    const recoveryMethod = RecoveryMethod.PASSWORD;
    const recoveryPassword = password;
    const encryptionSession = await getEncryptionSession();
    await setWalletRecovery({
      recoveryMethod,
      recoveryPassword,
      encryptionSession,
    });
  };

  return (
    <div>
      <input
        name={'password'}
        placeholder="password recovery"
      />
      <button onClick={handleUpdateRecovery}>
        {'Add recovery to your wallet'}
      </button>
    </div>
  );
}
```
```ts encryptionSession.ts
const getEncryptionSession = async (): Promise<string> => {
    try {
        const response = await fetch('https://your-api-endpoint.com/api/protected-create-encryption-session', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({})
        });
        const data = await response.json();
        return data.session;
    } catch (error) {
        throw new Error('Failed to create encryption session');
    }
};
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
  shieldConfiguration: {
    shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
  },
});

```
</CH.Code>


# Integrate React app on Telegram mini-app
Learn how you can integrate React app on Telegram mini-app

## Overview

<Admonition type='tip'>
Building a new app? Check out the [Sample Telegram](https://github.com/openfort-xyz/sample-telegram/), which includes a basic Telegram &lt;&gt; Openfort integration.
</Admonition>

## Prerequisites

We will be using the Openfort SDK to integrate the React app on Telegram mini-app. If you haven't set up the Openfort SDK in your project, follow the [quickstart guide](/docs/guides/unity/quickstart).

## Configuration

### Telegram mini-app setup

+ Create a Telegram bot and get the bot token. Follow the [official guide](https://core.telegram.org/bots#6-botfather) to create a bot and get the token.

+ [Configure your project providers](https://dashboard.openfort.xyz/players/auth/providers)
  Enable the Telegram provider and add the bot username and bot token.

  <div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/2025_01_20_12_48_33_fcb40b590d.jpg?updated_at=2025-01-20T11:50:42.131Z"
    alt='Contract Info'
  />
  </div>
  
  Enable the Telegram (Mini-app) provider and add the bot token.

  <div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/2025_01_20_12_48_39_67bcb69b01.jpg?updated_at=2025-01-20T11:50:51.897Z"
    alt='Contract Info'
  />
  </div>

## Frontend setup

  + In your frontend project, we will authenticate the user with the Telegram provider.

  ```ts
  await openfort.authenticateWithThirdPartyProvider({
    provider: ThirdPartyOAuthProvider.TELEGRAM_MINI_APP,
    token: initDataRaw,
    tokenType: TokenType.CUSTOM_TOKEN
  });
  ```

  The `token` is the `initDataRaw` you receive from the Telegram SDK after initializing the Telegram mini-app.

  In react, you would use `@telegram-apps/sdk-react` to retrieve the `initDataRaw`:

  ```tsx
      
  const SampleComponent = () => {
    const { initDataRaw } = retrieveLaunchParams();

    useEffect(() => {
      if (initDataRaw) {
        openfort.authenticateWithThirdPartyProvider({
          provider: ThirdPartyOAuthProvider.TELEGRAM_MINI_APP,
          token: initDataRaw,
          tokenType: TokenType.CUSTOM_TOKEN
        }).then(() => {
          console.log("Authenticated!");
        }).catch((error) => {
          console.error("Failed to authenticate:", error);
        })
      }
    }, [initDataRaw]);

    // ... other code
  }
  ```

  For more information on how to integrate the Telegram mini-app SDK, refer to the [official documentation](https://core.telegram.org/widgets/login).

  More information about external authentication can be found in the [external auth guide](/docs/guides/javascript/auth/external-auth).


# Using session keys
How to create and manage session keys

<SessionKeys />

<Admonition type="tip">

Check out our sample registering a session key with an account with a non-custodial signer: [GitHub source](https://github.com/openfort-xyz/openfort-js/tree/main/examples/apps/auth-sample).

</Admonition>

## Configuration

This section will guide you through the process of registering a session key and using it to mint an asset with a player's smart account. You can choose to create the session key using a **web3 libraries** or using the **Openfort native method**.

<Tabs
scrollable
size="medium"
type="underlined"
defaultActiveId="eip"
>
  <TabPanel id="eip" label="Standard (EIP-1193 provider)">

  
Using [EIP-7715](https://github.com/pedrouid/ERCs/blob/19c16341c57f6ac8770cb778d60845dcf30f6a40/ERCS/erc-7715.md). The `request` method of the EIP-1193 provider can be used to request signatures. First, get the provider:

<CH.Code>
```tsx client.tsx
// This example assumes you have already checked that Openfort 'embeddedState' is 
// `ready` and the user is `authenticated`
const provider = openfort.getEthereumProvider();
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
  shieldConfiguration: {
    shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
  },
});

```
</CH.Code>

Smart wallets support sending a batch of transactions in a single, atomic submission to the network.

To register a session key with a smart wallet, call the `wallet_grantPermissions` method.

As an example, you might batch together a transaction to approve a USDC spender and to transfer USDC like so:

```tsx

const sessionKey = generatePrivateKey();
const accountSession = privateKeyToAccount(sessionKey).address;

await provider.request({
  method: 'wallet_grantPermissions',
  params: [
    {
      signer:{
        type: "account",
        data:{
          id: accountSession
        }
      },
      expiry: 60 * 60 * 24,
      permissions: [
        {
          type: 'contract-call',
          data: {
            address: '0x2522f4fc9af2e1954a3d13f7a5b2683a00a4543a',
            calls: []
          },
          policies: []
        }
      ],
    },
  ],
});
```

Popular web3 libraries provide convenient methods for registering session keys:

| Library | Method |
|---------|--------|
| Viem | [Use the `wallet_grantPermissions` action](https://viem.sh/experimental/erc7715/grantPermissions) |

  </TabPanel>
  <TabPanel id="custom" label="Custom">
    <Tabs
    scrollable
    size="tiny"
    type="pills"
    defaultActiveId="client"
    >
      <TabPanel id="client" label="Client session key">
<Admonition type="note">

For a general overview of session keys, see the [Session keys](https://www.openfort.xyz/blog/technical-dive-session-keys) post. For more information about how to use the session key endpoints, you can visit our [API documentation](/docs/reference/api/create-a-session-key).

</Admonition>

  ### 1. Create a session key - <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Client side</span>

  After you have authenticated your user with your regular authentication system, you can create a session key for them.
  To create a session key, you need to generate a key pair on the client-side and send the address computed from the public key to your server.

  Using one of the official Openfort [client libraries](/docs/libraries) everything is handled for you.

  1. Install the client-side library:

  ```bash command-line
  npm install @openfort/openfort-js --save
  ```

  2. Initialize Openfort and create a session key:

  ```ts client.ts
  // Set your public key. Remember to switch to your live PUBLIC key in production.
  // See your keys here: https://dashboard.openfort.xyz/developers/api-keys
    const openfort = new Openfort({
    baseConfiguration: {
        publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY"
    }
  });

  const sessionKey = openfort.configureSessionKey();
  ```

  </TabPanel>

<TabPanel id="server" label="Server session key">

  ### 1. Create a session key - <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Client side</span>

Using [ethers](https://www.npmjs.com/package/ethers), you can create a key pair on the server side of you application.

```ts
const sessionKey = ethers.Wallet.createRandom();
```

The parameter `sessionKey` contains the address that you will need to register.

</TabPanel>
</Tabs>

  After creating the session key, you can go ahead and register it.

  ### 2. Register a session key - <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Server side</span> <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Client side</span>

  To register a session key, first send the address from the session key to your server.
  You can get the address from the session key object created above like this:

  ```ts client.ts
  const address = sessionKey.address;
  ```

  Then, from your server you can make a request to the Openfort API or use one of our [server libraries](/docs/libraries) to register the session key.

  Install Openfort in your server-side and initialize it with your secret key.

  <Tabs
    scrollable
    size="small"
    type="rounded-pills"
    defaultActiveId="node"
  >
  <TabPanel id="node" label="Node">
  ```bash command-line
  npm install @openfort/openfort-node
  ```

  Initialize '@openfort/openfort-node' with your secret key.

  ```ts server.ts
    const openfort = new Openfort('sk_test_...');
  ```

  </TabPanel>
  <TabPanel id="net" label=".Net">
  ```bash command-line
  dotnet add package Openfort.SDK
  ```

  Initialize 'Openfort.SDK' with your secret key.

  ```csharp server.cs
  using Openfort.SDK;
  using Openfort.SDK.Model;

  var openfort = new OpenfortClient("sk_test_...");
  ```
  </TabPanel>
  </Tabs>

  The created session key would be valid since the 25th of May 2023 at 7:50 GMT (timestamp `1685001000`) and last for 1 hour (timestamp `1685001000`).
  For a useful resource to calculate timestamps online, visit [UNIX Timestamp](https://www.unixtimestamp.com/).

  Note how the `externalOwnerAddress` parameter is used to indicate the address of owner of the account that will be created under the specified player. It's only necessary to specify this parameter when the player is doesn't yet have an account in that chain.

  Also, note how a `policy` is used to indicate the policy that will be used to sponsor the gas fees of the transaction to register the session key.

  In this example `externalOwnerAddress` is used to indicate the address of the owner of the account that will be created under the specified player.

  Register the session key using Openfort:

  <Tabs
    scrollable
    size="small"
    type="rounded-pills"
    defaultActiveId="node"
  >
  <TabPanel id="bash" label="curl">

  ```bash command-line
  curl https://api.openfort.xyz/v1/sessions \
    -H "Authorization: Bearer $YOUR_SECRET_KEY" \
    -d player=pla_... \
    -d address="0x76e6...9341" \
    -d chainId=80002 \
    -d validUntil=1685004600 \
    -d validAfter=0 \
    -d externalOwnerAddress="0x41e6...9341" \
    -d policy=pol_...
  ```

  </TabPanel>
  <TabPanel id="node" label="Node">

  ```ts server.ts
  const sessionKeyAddress = '0x76e6...9341'
  const policyId = 'pol_...'
  const playerId = 'pla_...'
  const validUntil = 1685001000
  const validAfter = 0
  const chainId = 80002
  const externalOwnerAddress = '0x41e6...9341'

  const playerSession = await openfort.sessions.create({
    player: playerId,
    address: sessionKeyAddress,
    chainId: chainId,
    validUntil: validUntil,
    validAfter: validAfter,
    policy: policyId,
    externalOwnerAddress: externalOwnerAddress,
  })
  ```

  </TabPanel>
  </Tabs>

  After registering the session key, you can see it in the dashboard under the player's page.

  <div align="center">
    <img
      alt="DashboardRegisterSessionKey"
      src="https://blog-cms.openfort.xyz/uploads/dashboard_session_keys_931c5a570a.png"
      width="70%"
      height="70%"
    />
  </div>

  ### 3. Sign the session key - <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Client side</span>

  The owner of the account of the player needs then to authorize the new session key.

  To do so, it needs to sign the `userOperationHash` from the `nextAction` object returned by the API call to register the session key.

  nextAction response object from transaction_intents

  ```json
  "nextAction": {
      "type": "sign_with_wallet",
      "payload": {
          "signableHash": "0x91b4efe3648c79467f7b50aa9bb1b4eae383a52dd6d741d39ece29ed2ef8362d"
      }
  },
  ```

  Once the content of the `nextAction` parameter above is signed by the owner signer of the account,
  it has to be sent to Openfort using the endpoint `/v1/sessions/:id/signature` as shown below:

  Sign and send the session key registration:

  <Tabs
    scrollable
    size="small"
    type="rounded-pills"
    defaultActiveId="js"
  >
  <TabPanel id="bash" label="curl">

  ```bash command-line
  curl https://api.openfort.xyz/v1/sessions/ses_.../signature \
    -H "Authorization: Bearer $YOUR_PUBLISHABLE_KEY" \
    -d signature="xyz..."
  ```

  </TabPanel>
  <TabPanel id="js" label="JavaScript">

  ```ts client.ts
  await openfort.sendSignatureSessionRequest(
    playerSession.id,
    SIGNED_USED_OP_HASH
  )
  ```
  </TabPanel>
  </Tabs>

  ### 4. Using the session key - <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Server side</span> <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Client side</span>

  After the session key is registered, it can be used to authenticate requests from the player.
  Whenever you create a transaction intent from your backend, a signature will be needed from the session key or owner of the players' smart account.

  Create a transaction intent:

  <Tabs
    scrollable
    size="small"
    type="rounded-pills"
    defaultActiveId="node"
  >
  <TabPanel id="bash" label="curl">

  ```bash command-line
  curl https://api.openfort.xyz/v1/transaction_intents \
    -H "Authorization: Bearer $YOUR_SECRET_KEY" \
    -d player=pla_... \
    -d address="0x76e6...9341" \
    -d chainId=80002 \
    -d policy=pol_...
  ```

  </TabPanel>
  <TabPanel id="node" label="Node">

  ```ts server.ts
  const playerId = 'pla_...'
  const policyId = 'pol_...'
  const contractId = 'con_...'
  const chainId = 80002
  const optimistic = true

  const interaction: Interaction = {
    contract: contractId,
    functionName: 'mint',
    functionArgs: [playerId],
  }
  const transactionIntent = await openfort.transactionIntents.create({
    player: playerId,
    chainId: chainId,
    optimistic: optimistic,
    interactions: [interaction],
    policy: policyId,
  })
  ```

  </TabPanel>
  </Tabs>

  After creating the transaction intent, the session key will need to sign the nextAction `userOperationHash` and send it to Openfort.

  To do so, pass the `userOperationHash` to the `sendSignatureTransactionIntentRequest` method of the Openfort client library.
  Load session key and sign a transaction intent:

  ```ts client.ts
  const openfortTransactionResponse =
    await openfort.sendSignatureTransactionIntentRequest(
      collectResponseJSON.data.id,
      userOperationHash
    )
  ```

  ### 5. Revoke a session key - <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Client side</span> <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Server side</span>

  The owner of the account can always revoke the session key.

  To do so, it needs to sign the `userOperationHash` from the `nextAction` object returned by the API call to revoke the session key.

  Create a transaction intent:

  <Tabs
    scrollable
    size="small"
    type="rounded-pills"
    defaultActiveId="javascript"
  >
  <TabPanel id="bash" label="curl">

  ```bash command-line
  curl https://api.openfort.xyz/v1/sessions/revoke \
    -H "Authorization: Bearer $YOUR_SECRET_KEY" \
    -d player=pla_... \
    -d address="0x76e6...9341" \
    -d chainId=80002 \
    -d policy=pol_...
  ```

  </TabPanel>
  <TabPanel id="javascript" label="Node">

  ```ts server.ts
  const playerId = 'pla_...'
  const policyId = 'pol_...'
  const chainId = 80002
  const sessionKeyAddress = '0x76e6...9341'

  const revokeSession = await openfort.sessions.revoke({
    player: playerId,
    address: sessionKeyAddress,
    chainId: chainId,
    optimistic: true,
    policy: policyId,
  })
  ```

  </TabPanel>
  </Tabs>

  Sign the transaction to revoke the session key and remove from client side:

  <Tabs
    scrollable
    size="small"
    type="rounded-pills"
    defaultActiveId="javascript"
  >
  <TabPanel id="javascript" label="JavaScript">
  ```ts client.ts
  const openfortTransactionResponse =
    await openfort.sendSignatureTransactionIntentRequest(
      revokeResponseJSON.data.id,
      userOperationHash
    );
  ```
  </TabPanel>
  </Tabs>
    </TabPanel>
</Tabs>

  {/* Finish with a video. This also appears in the Sidebar via the "tocVideo" metadata */}

  <div className="video-container">
    <iframe
      src="https://www.youtube-nocookie.com/embed/rh2E02PATlU"
      frameBorder="1"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowFullScreen
    ></iframe>
  </div>


# Sign messages with custodial wallets


<Admonition type="note">

This guide is for custodial smart accounts. If you are using non-custodial smart accounts, you should use the Sign Messages with Openfort's embedded signer.

</Admonition>

Signing and verifying messages for smart accounts is different than with EOAs.  There are a few reasons why:

- With an EOA, the address is effectively the public key of the private key used for signing.  Therefore, verifying a EOA signature is as simple as [recovering](https://soliditydeveloper.com/ecrecover) the signature and compare the recovered public key with the address.
  - With a smart account, the address is the address of a smart contract that has no cryptographic link to the signing private key.  Therefore, you must use [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) to validate the message.

- With an EOA, you don't have to deploy the account.  It just exists.
  - Since smart accounts need to be deployed, it may not be clear how you can validate messages against a smart account not yet deployed.

### Signing messages

To sign messages:

```ts server.ts
// Set your secret key. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.openfort.xyz/developers/api-keys
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);

const _domain = {
  name: "Openfort",
  version: "0.5",
  chainId: 13337,
  verifyingContract: "0x9b5AB198e042fCF795E4a0Fa4269764A4E8037D2",
};
const types = {
  Mail: [
    { name: "from", type: "Person" },
    { name: "to", type: "Person" },
    { name: "content", type: "string" },
  ],
  Person: [
    { name: "name", type: "string" },
    { name: "wallet", type: "address" },
  ],
};
const mail = {
  from: {
    name: "Alice",
    wallet: "0x2111111111111111111111111111111111111111",
  },
  to: {
    name: "Bob",
    wallet: "0x3111111111111111111111111111111111111111",
  },
  content: "Hello!",
};
const structHash = ethers.utils._TypedDataEncoder.hash(domain, types, mail);

const signature = await openfort.accounts.signPayload({ 
  id: "acc_4194ad24-c818-4e5c-b003-9cc2aa7df53b", 
  hash: structHash,
  domain: domain
  value: mail,
  types: types,
});
```

### Validating signatures

You can validate signatures with [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271). Here's an example with ethers:

```ts client.ts
const ethers = require("ethers");

async function verifySignature(hash, signature, address) {
  let provider = new ethers.providers.JsonRpcProvider(providerUrl);
  const ABI =   {
    inputs: [
      {
        internalType: "bytes32",
        name: "_hash",
        type: "bytes32",
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes",
      },
    ],
    name: "isValidSignature",
    outputs: [
      {
        internalType: "bytes4",
        name: "",
        type: "bytes4",
      },
    ],
    stateMutability: "view",
    type: "function",
  };
  const iface = new ethers.utils.Interface(ABI);
  const encodedDataDeposit = iface.encodeFunctionData("isValidSignature", [
    hash,
    signature,
  ]);

  const tx = {
    to: address,
    data: encodedDataDeposit,
  };
  return await provider.call(tx);
}
```


# Use Social Recovery
Learn how to emable social recovery

One of the main hurdles in enhancing gaming experiences within Web3 environments is ensuring player account security. Unlike traditional gaming accounts, where password recovery is straightforward, Web3 accounts often require meticulous management of a seed phrase to prevent loss of access. This can be a daunting task for players, necessitating either a fail-safe method to secure the seed phrase or reliance on a centralized system to handle key management.

<Admonition type="tip">
  By default, Openfort is not a guardian. You need to pass the `defaultGuardian` as **true** parameter to register Openfort as a guardian when creating a new smart account when using [create account](/docs/reference/api/create-an-account-object).
</Admonition>

To address this, gaming platforms can implement a "guardian" system. Guardians are trusted entities or mechanisms designated to facilitate the recovery of a player's account. If a player misplaces their access key, they can create a new one and request their guardians to authorize this new key as the account's official access method, effectively regaining control over their account.

This guardian system can be applied in two primary recovery scenarios:

1. **Self-Recovery:** Players have the option to configure their account recovery using another authentication factor they control, such as a hardware passkey or an alternative Web3 wallet. This method empowers players with direct control over their account recovery process, enhancing security and convenience.
2. **Game-Assisted Recovery:** a player might designate the game developer or platform as their guardian. In the event of losing access to their account, the player would reach out to the game's support team, who would then facilitate the account recovery on their behalf.

<Admonition type="note">

For a general overview of social recovery, see the [Recoverable Accounts](https://www.openfort.xyz/blog/recoverable-accounts) post.

</Admonition>

## Configure assisted recovery
This guide will go through all the necessary steps to complete a recovery with Openfort as a guardian. The default implementation of the endpoint includes:
- Threshold: 1:1
- Guardian: Openfort
- Time lock: 2 days

### 1. Set up Openfort - <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Server side</span>

Use our official libraries to access the Openfort API from your application:

Install Openfort:

```bash command-line
npm install @openfort/openfort-node --save
```

Initialize @openfort/openfort-node:

```ts server.ts
const Openfort = require('@openfort/openfort-node').default
const openfort = new Openfort(YOUR_SECRET_KEY)
```

### 2. Start recovery process
Openfort will perform a Start Recovery operation to recover the account from the current owner to the new owner.

The `policy` parameter is a policy that will be used to sponsor the transaction. You can find more information about policies in our [documentation](/docs/reference/api/list-policies).
Bear in mind that this policy needs to have a `account_functions` policy rule to allow the sponsorship of this operation.

<Tabs
  scrollable
  size="small"
  type="rounded-pills"
  defaultActiveId="javascript"
>
<TabPanel id="bash" label="curl">

```bash command-line
curl https://api.openfort.xyz/v1/account/acc_.../start_recovery \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d newOwnerAddress="0x416c...354D" \
  -d policy="pol_..."
```

</TabPanel>
<TabPanel id="javascript" label="Node">

```ts server.ts
const accountId = 'acc_...';
const policy = 'pol_...';
const newOwnerAddress = '0x416c...354D';
const playerTransferOwnership = await openfort.accounts.startRecovery(
  {
    id: accountId,
    policy: policy,
    newOwnerAddress: newOwnerAddress,
  }
)
```

</TabPanel>
</Tabs>

### 3. Complete recovery
After complying with the period of time `lockPeriod`, the guardian has a `securityPeriod` to confirm the proposal. In this case, Openfort will submit the needed signature to complete the recovery of the account.

<Tabs
  scrollable
  size="small"
  type="rounded-pills"
  defaultActiveId="node"
>
<TabPanel id="bash" label="curl">

```bash command-line
curl https://api.openfort.xyz/v1/account/acc_.../complete_recovery \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d newOwnerAddress="0x416c...354D" \
  -d policy="pol_..."
```

</TabPanel>
<TabPanel id="node" label="Node">

```ts server.ts
const accountId = 'acc_...';
const policy = 'pol_...';
const newOwnerAddress = '0x416c...354D';
const playerTransferOwnership = await openfort.accounts.completeRecovery(
  {
    id: accountId,
    policy: policy,
    newOwnerAddress: newOwnerAddress,
  }
);
```
</TabPanel>
</Tabs>


# Transfer the owner of an account
Learn how to transfer the ownership of an Openfort smart contract.

With Openfort, you can change the ownership of an account from one address to another. Your players can take ownership of their account without ever having to go through exposing a private key. Secure, frictionless, and easy.

There are 2 steps involved in transferring account ownership:

- **transferOwnership**: starts the ownership transfer of the contract to a new account. Called through the API and performed by Openfort.
- **acceptOwnership**: the new owner accepts the ownership transfer. Performed in the client side by the new owner.

Openfort accounts implement [Ownable2Step](https://docs.openzeppelin.com/contracts/4.x/api/access#Ownable2Step) from [Openzeppelin](https://www.openzeppelin.com/) to create a secure way of transferring account ownership. You can check out the code that allows for this behavior in their [GitHub repository](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol).

<Admonition type="note">

For more information about how to use the sesion key endpoints, you can visit our [API documentation](/docs/reference/api/request-transfer-ownership-of-account).
Check out our sample with a transfer ownership example: [GitHub source](https://github.com/openfort-xyz/samples/tree/main/ssv-social-nextjs) and [video walkthrough](https://youtu.be/xBzl8hk__P8?t=264).

</Admonition>

## Quickstart

This guide will go though all the necessary steps to transfer account ownership.

### 1. Set up Openfort - <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Server side</span>

Use our official libraries to access the Openfort API from your application:

Install Openfort Node.js library:

```bash command-line
npm install @openfort/openfort-node --save
```

Initialize '@openfort/openfort-node' with your secret key:

```ts server.ts
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);
```

### 2. Request transfer ownership - <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Server side</span>

Openfort will perform a [`transferOwnership`](https://docs.openzeppelin.com/contracts/4.x/api/access#Ownable2Step-transferOwnership-address-) operation to transfer the ownership of the account from the current owner to the new owner.

The `policy` parameter is a policy that will be used to sponsor the transaction. You can find more information about policies in our [documentation](/docs/reference/api/list-policies).
Bear in mind this policy needs to have a `account_functions` policy rule to allow the sponsorship of this operation.

<Tabs
  scrollable
  size="small"
  type="rounded-pills"
  defaultActiveId="node"
>
<TabPanel id="bash" label="curl">

```bash command-line
curl https://api.openfort.xyz/v1/accounts/acc_.../request_transfer_ownership \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d newOwnerAddress="0x416c...354D" \
  -d "policy=pol_..."
```

</TabPanel>
<TabPanel id="node" label="Node">

```ts server.ts
const accountId = 'acc_...';
const policy = 'pol_...';
const newOwnerAddress = '0x416c...354D';
const playerTransferOwnership = await openfort.accounts.requestTransferOwnership(
  {
    id: accountId,
    policy: policy,
    newOwnerAddress: newOwnerAddress,
  }
);
```

</TabPanel>
</Tabs>

### 3. Accept account ownership - <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Client side</span>

Using [Wagmi](https://wagmi.sh/) React hooks, you can accept the account ownership by performing an [`acceptOwnership`](https://docs.openzeppelin.com/contracts/4.x/api/access#Ownable2Step-acceptOwnership--) operation to the account address. 
Find a working example of how to accept account ownership in our GitHub repository [component sample](https://github.com/openfort-xyz/samples/blob/main/ssv-social-nextjs/components/accept-ownership.tsx).

Accept account ownership from client side:

```jsx accept-ownership.tsx
  usePrepareContractWrite,
  useContractWrite,
  useWaitForTransaction,
} from 'wagmi'

const { config } = usePrepareContractWrite({
  address: accountAddress,
  abi: [
    {
      inputs: [],
      name: 'acceptOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
  ],
  functionName: 'acceptOwnership',
})

const { data, write } = useContractWrite(config)

const { isLoading, isSuccess } = useWaitForTransaction({
  hash: data?.hash,
});

```
{/* Finish with a video. This also appears in the Sidebar via the "tocVideo" metadata */}

<div className="video-container">
  <iframe
    src="https://www.youtube-nocookie.com/embed/xBzl8hk__P8"
    frameBorder="1"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>


# Relay.link integration
Learn how to bridge tokens in your game.

The sample allows you to convert any tokens, using [Relay.link](https://relay.link/). Bridging rates are determined via the bridge provider, and depend on supply and demand of the respective tokens.

## Samples
<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href={`https://github.com/openfort-xyz/reservoir0x-relay-embeddedwallet`}
    key={'openfort-auth-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Bridge with Relay'>
        {'A quick start guide to integrate smart accounts with Relay Link'}
      </GlassPanel>
  </Link>
</div>


# Uniswap V3 integration
Learn how to swapping tokens in your game.

The API allows you to convert any tokens, using [Uniswap V3](https://docs.uniswap.org/sdk/v3/overview). Conversion rates are determined via an Automated Market Maker mechanism, and depend on supply and demand of the respective tokens.

<Tabs
  scrollable
  size="medium"
  type="underlined"
  defaultActiveId="api"
>
<TabPanel id="api" label="API">

  To exchange tokens, simply make a `POST` request to Openfort's exchange API:

    ```
    https://api.openfort.xyz/v1/exchange
    ```
  In the body of the request:

  - Include the contract addresses of the desired `tokenInAddress` and `tokenOutAddress` tokens
  - Include a `fromAddress` that contains the address from which the token is swapped. 
  - Include an `amount` to swap, either a desired input and output token amount.

  Depending on the "direction" of the conversion, there are two different `tradeType`s, which are covered with examples below too. Let's assume we have two tokens IN and OUT:

  ### Converting with an exact input amount
  - The player wants to swap 100 IN to OUT:
  1. we first need to get the amount of OUT we can expect to get for 100 IN.
  2. then convert it with an `EXACT_INPUT` to make sure we get the highest amount of OUT for our 100 IN.
  ### Converting with an exact output amount
  - The player wants to buy 10 OUT:
  1. here we first fetch the required amount of IN to obtain 10 OUT.
  2. then convert it with an `EXACT_OUTPUT` to make sure get exactly 10 OUT.

  Below is a sample cURL command for generating a new wallet for a user with Openfort:

  ```bash command-line
  curl https://api.openfort.xyz/v1/exchange \
    -u "$YOUR_SECRET_KEY:" \
    -d 'chainId=80002' \
    -d 'fromAddress="0x45..."' \
    -d 'tokenInAddress="0x45..."' \
    -d 'tokenOutAddress="0x45..."' \
    -d 'amount="100000"' \
    -d 'tradeType=EXACT_INPUT'
  ```
    A successful response will include the new user object along with their user's ID (`playerID`), like below:

    ```bash json
      {
        "id": "tin_c502d628-5bb3-42f2-b8f5-62ba4d71df3a",
        "createdAt": 1689869074,
        "object": "transactionIntent",
        "abstractionType": "accountAbstractionV6",
        "details": {
          "userOperationHash": "0x25d3...005c",
          "userOperation": {
            "sender": "0x48930Cd730652bf0B18Ef8c80cD0Fa1Cc72A233E",
            "nonce": "0x2",
            "initCode": "0x",
            "callData": "0xb61d...0000",
            "callGasLimit": "0x27863",
            "verificationGasLimit": "0x16001",
            "preVerificationGas": "0xb818",
            "maxFeePerGas": "0x62590091",
            "maxPriorityFeePerGas": "0x62590091",
            "paymasterAndData": "0x3210...b51c",
            "signature": "0x6202...3d1b"
          },
        },
        "chainId": 80002,
        "updatedAt": 1689869074,
        "policy": {
          "id": "pol_..."
        },
        "player": {
          "id": "pla_..."
        },
        "account": {
          "id": "acc_..."
        },
        "response": {
          "createdAt": 1689869074,
          "logs": [
            {
              "removed": false,
              "transactionIndex": 0,
              "blockNumber": 44904492,
              "transactionHash": "0x25d3...005c",
              "address": "0x5FF1...2789",
              "topics": [
                "0xbb47...f972"
              ],
              "data": "0x",
              "logIndex": 0,
              "blockHash": "0x8a69...6d59"
            }
          ],
          "blockNumber": 8789286,
          "transactionHash": "0x25d3...005c",
          "to": "0x0576...1B57",
          "gasUsed": "336730",
          "status": 1
        },
        "interactions": [
          {
            "functionName": "mint",
            "value": "100000000000000",
            "contract": "0x0576...1B57",
            "functionArgs": [
              "0x63B7...484f"
            ]
          }
        ]
      }
    ```
    </TabPanel>
</Tabs>

<Admonition type="note">

Check the [Quote Swap endpoint](https://www.openfort.xyz/docs/reference/api/quote-token-swap) to get a quotation before executing the conversion.

</Admonition>


# Using smart wallets


Smart wallets in Openfort are your primary interface for blockchain interactions. Once an embedded signer is set up, a smart wallet is automatically created and associated for your user.

## Getting an EIP-1193 provider

All of Openfort's wallets can 
<Admonition type='info'>

[EIP-1193](https://eips.ethereum.org/EIPS/eip-1193), also known as the Ethereum JavaScript API, is a standardized interface for how applications can request information, signatures, and transactions from a connected wallet.

</Admonition>

To get a wallet's EIP-1193 provider, use the openfort `getEthereumProvider` method:

<CH.Code>
```tsx main.tsx
// This example assumes you have already checked that Openfort 'embeddedState' is 
// `ready` and the user is `authenticated`
const provider = await openfort.getEthereumProvider();
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
  shieldConfiguration: {
    shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
  },
});

```
</CH.Code>

When requesting signatures and transactions from the wallet, you can either choose to interface with the **EIP-1193** provider directly, or to pass it to a library like `wagmi` or `viem`.


# Funding wallets
Simplify onnramping funds to your embedded wallet.

<Funding />


# Handling networks


The following guide will show you how to handle networks with Openfort's smart wallets using the EIP-1193 provider.

<Admonition type='info'>

You can also use Viem's [`switchChain`](https://wagmi.sh/core/api/actions/switchChain) method with the chain ID you wish to switch to.

</Admonition>

## Get the current network

To get the current network, you can use the `eth_chainId` request (with no `params`)

```ts
await wallet.provider.request({
 "method": "eth_chainId",
 "params": [],
});
```

## Switch networks

To switch the smart wallet to a different network, send a [`wallet_switchEthereumChain`](https://docs.metamask.io/wallet/reference/wallet_switchethereumchain/) **JSON-RPC request to the wallet's EIP-1193 provider**. In the request's `params`, specify your target `chainId` as a hexadecimal string.

```ts
await wallet.provider.request({
  method: 'wallet_switchEthereumChain',
  // Replace '0x5' with the chainId of your target network
  params: [{chainId: '0x5'}],
});
```


# Integrating with web3 libraries
Using web3 libraries to interact with wallets and smart contracts.

Openfort's `wallet` object is fully compatible with popular web3 libraries for interfacing wallets, including [`ethers`](/docs/guides/javascript/smart-wallet/libraries#ethers), and [`wagmi`](/docs/guides/javascript/smart-wallet/libraries#wagmi).

Read below to learn how to best integrate Openfort alongside these libraries.

## Ethers
Ethers represents connected wallets as a [provider](https://docs.ethers.org/v5/api/providers/provider/), which can be used to take read-only actions with the wallet, and a [signer](https://docs.ethers.org/v5/api/signer/), which can be used to take write actions (signatures and transactions).

Call the wallet's `getEthereumProvider` method to get a provider:

<CH.Code>
```tsx client.tsx
// This example assumes you have already checked that Openfort 'embeddedState' is 
// `ready` and the user is `authenticated`
const web3Provider = new ethers.providers.Web3Provider(provider);
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
  shieldConfiguration: {
    shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
  },
});

```
</CH.Code>
Then, call the provider's `getSigner` method to get the corresponding signer:

```tsx
const signer = web3Provider.getSigner();
```

You can then use the [provider](https://docs.ethers.org/v5/api/providers/provider/) and [signer](https://docs.ethers.org/v5/api/signer/) to get information about the wallet or request signatures and transactions.

---

## Viem

Viem represents connected wallets as a [wallet client](https://viem.sh/docs/clients/wallet) object, which you can use to get information about the current wallet or the request signatures and transactions.

To get a viem wallet client for a user's connected wallet, first 
```tsx
// Replace `sepolia` with your desired network
```

Lastly, get the wallet's EIP1193 provider using the wallet's `getEthereumProvider` method and pass it to viem's `createWalletClient` method like so:

<CH.Code>
```tsx client.tsx
// This example assumes you have already checked that Openfort 'embeddedState' is 
// `ready` and the user is `authenticated`
const provider = await wallet.getEthereumProvider();
const walletClient = createWalletClient({
  chain: sepolia,
  transport: custom(provider),
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
  shieldConfiguration: {
    shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
  },
});

```
</CH.Code>

You can then use the [wallet client](https://viem.sh/docs/clients/wallet) to get information about the wallet or request signatures and transactions.

---

## Wagmi
[Wagmi](https://wagmi.sh/) is a set of React hooks for interfacing with Ethereum wallets, allowing you read wallet state, request signatures or transactions, and take read and write actions on the blockchain.

**Openfort is fully compatible with [wagmi](https://wagmi.sh/), and you can use wagmi's React hooks to interface with external and embedded wallets from Openfort. Just follow the steps below!**

<Admonition type='tip' label='Want to start building right away?'>

Check out the [wagmi starter repo](https://github.com/openfort-xyz/openfort-js/tree/main/examples/apps/wallet-libraries/next-wagmi).
Checkout the [wagmi live demo](https://wagmi.openfort.xyz).

</Admonition>

### 1. Install dependencies

Install the latest versions of `wagmi`, `@tanstack/react-query` and `@openfort/openfort-js`:

```sh
npm i wagmi @tanstack/react-query @openfort/openfort-js
```

### 2. Setup TanStack Query

To start, set up your app with the [TanStack Query's React Provider](https://tanstack.com/query/v5/docs/framework/react/overview). Wagmi uses TanStack Query under the hood to power its data fetching and caching of wallet and blockchain data.

```tsx
```

Next, create a new instance of the [`QueryClient`](https://tanstack.com/query/v4/docs/reference/QueryClient):

```tsx
const queryClient = new QueryClient();
```

Then, wrap your app's components with the [`QueryClientProvider`](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider). This must be rendered inside the `WagmiProvider` component.

```tsx
<WagmiProvider config={config}>
  <QueryClientProvider client={queryClient}>
    <Connect />
  </QueryClientProvider>
</WagmiProvider>
```
For the [`client`](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider) property of the `QueryClientProvider`, pass the [`queryClient`](https://tanstack.com/query/v4/docs/reference/QueryClient) instance you created.

### 3. Setup Wagmi

To build your `wagmi` config, 
```tsx wagmi.tsx

  chains: [sepolia],
  connectors: [injected()],
  transports: {
    [sepolia.id]: http(),
  },
});
```

### 4. Create Openfort Connector

You'll need to create a custom connector for Openfort. Create a new file `openfortConnector.ts`:

```tsx main.tsx

const queryClient = new QueryClient();

  useEffect(() => {
    if (!openfortInstance) return;
    openfortInstance.getEmbeddedState();
    openfortInstance.getEthereumProvider(); // EIP-6963
  }, [openfortInstance]);

  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <Connect />
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```

### 5. Connector list

Create a new file `Connect.tsx` to list the available connectors and handle the connection. When you press on Openfort, then you will be redirected to the authentication page that you should implement. You can find an example of the authentication page in the [Openfort documentation](https://github.com/openfort-xyz/openfort-js/blob/main/examples/apps/wallet-libraries/vite-wagmi/src/components/Authenticate.tsx).

```tsx Connect.tsx

  const chainId = useChainId();
  const {connectors, connect, error} = useConnect();
  const navigate = useNavigate();
  const [activeConnector, setActiveConnector] =
    React.useState<Connector | null>(null);

  React.useEffect(() => {
    if (
      error &&
      activeConnector?.name === 'Openfort' &&
      error.message ===
        'Unauthorized - must be authenticated and configured with a signer'
    ) {
      navigate('/authentication');
    }
  }, [error, activeConnector, navigate]);

  const handleConnect = (connector: Connector) => {
    setActiveConnector(connector);
    connect({connector, chainId});
  };

  return (
    <div>
      <div className="buttons">
        {connectors
          .filter((connector) => !connector.name.includes('Injected'))
          .map((connector) => (
            <ConnectorButton
              key={connector.uid}
              connector={connector}
              onClick={() => handleConnect(connector)}
            />
          ))}
      </div>
      {error && <div className="error">Error: {error.message}</div>}
    </div>
  );
}

function ConnectorButton({
  connector,
  onClick,
}: {
  connector: Connector;
  onClick: () => void;
}) {
  const [ready, setReady] = React.useState(false);
  React.useEffect(() => {
    (async () => {
      const provider = await connector.getProvider();
      setReady(!!provider);
    })();
  }, [connector, setReady]);

  return (
    <button
      className="button"
      disabled={!ready}
      onClick={onClick}
      type="button"
    >
      {connector.name}
    </button>
  );
}
```

### 6. Complete example
Altogether, this should look like:

<CH.Code>
```tsx app.tsx

const queryClient = new QueryClient();

  useEffect(() => {
    if (!openfortInstance) return;
    openfortInstance.getEmbeddedState();
    openfortInstance.getEthereumProvider(); // EIP-6963
  }, [openfortInstance]);

  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <Connect />
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```
```tsx main.tsx

const OPENFORT_PUBLISHABLE_KEY = 'pk_test_505bc088-905e-5a43-b60b-4c37ed1f887a';
const SHIELD_PUBLISHABLE_KEY = 'a4b75269-65e7-49c4-a600-6b5d9d6eec66';

  baseConfiguration: {
    publishableKey: OPENFORT_PUBLISHABLE_KEY,
  },
  shieldConfiguration: {
    shieldPublishableKey: SHIELD_PUBLISHABLE_KEY,
  },
});

const router = createBrowserRouter([
  {
    path: '/',
    element: <App />,
  },
  {
    path: '/authentication',
    element: <Authenticate openfortInstance={openfortInstance} />,
  },
]);

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>
);
```
```tsx wagmi.tsx

  chains: [sepolia],
  connectors: [injected()],
  transports: {
    [sepolia.id]: http(),
  },
});
```
```tsx Connect.tsx

  const chainId = useChainId();
  const {connectors, connect, error} = useConnect();
  const navigate = useNavigate();
  const [activeConnector, setActiveConnector] =
    React.useState<Connector | null>(null);

  React.useEffect(() => {
    if (
      error &&
      activeConnector?.name === 'Openfort' &&
      error.message ===
        'Unauthorized - must be authenticated and configured with a signer'
    ) {
      navigate('/authentication');
    }
  }, [error, activeConnector, navigate]);

  const handleConnect = (connector: Connector) => {
    setActiveConnector(connector);
    connect({connector, chainId});
  };

  return (
    <div>
      <div className="buttons">
        {connectors
          .filter((connector) => !connector.name.includes('Injected'))
          .map((connector) => (
            <ConnectorButton
              key={connector.uid}
              connector={connector}
              onClick={() => handleConnect(connector)}
            />
          ))}
      </div>
      {error && <div className="error">Error: {error.message}</div>}
    </div>
  );
}

function ConnectorButton({
  connector,
  onClick,
}: {
  connector: Connector;
  onClick: () => void;
}) {
  const [ready, setReady] = React.useState(false);
  React.useEffect(() => {
    (async () => {
      const provider = await connector.getProvider();
      setReady(!!provider);
    })();
  }, [connector, setReady]);

  return (
    <button
      className="button"
      disabled={!ready}
      onClick={onClick}
      type="button"
    >
      {connector.name}
    </button>
  );
}
```
</CH.Code>

**That's it! You've successfully integrated Openfort alongside `wagmi` in your app! 🎉**

### 7. Use `wagmi` throughout your app

Once you've completed the setup above, you can use wagmi's React hooks throughout your app to interface with wallets and take read and write actions on the blockchain.

To use wagmi hooks, like `useAccount`, in your components, 
```tsx

  const {address} = useAccount();
  return <p>Wallet address: {address}</p>;
}
```

### Demo app with WAGMI

Feel free to take a look at the app's source code to see an end-to-end implementation of Openfort with wagmi:

<div className="grid md:grid-cols-12 gap-4 not-prose">
  {examples.map((x) => (
    <div className="col-span-4" key={x.href}>
      <Link href={x.href} passHref>
        <GlassPanel icon={'/docs/img/icons/github-icon-light'} hasLightIcon={true} title={x.name}>
          {x.description}
        </GlassPanel>
      </Link>
    </div>
  ))}
</div>

  {
    name: 'Wagmi template',
    description: 'Using Openfort accounts with wagmi.',
    href: 'https://github.com/openfort-xyz/openfort-js/tree/main/examples/apps/wallet-libraries/vite-wagmi',
  },
]


# Requesting signatures and transactions


To request signatures or transactions from a connected wallet, you can either:

- use the wallet's EIP-1193 provider to send JSON-RPC requests to the wallet directly.
- pass the wallet to a library like `viem`, `ethers`, or `wagmi`.
- for the embedded wallet specifically, create a `transactionIntent` from the **server** and `signMessage` it with the **embedded signer (client)**.

<Admonition type='tip' label={`The request method`}>
At a high-level, the EIP-1193 provider implements a method called `request` that accepts an object with the following fields:

- **`method`**: the name of a JSON-RPC request to send to the wallet
- **`params`**: any parameters to include with the request
</Admonition>

## Signatures

You can choose to create the session key using a web3 libraries or using the Openfort native method.

<Tabs
  scrollable
  size="large"
  type="underlined"
  defaultActiveId="eip"
>
<TabPanel id="eip" label="Standard (EIP-1193 provider)">

### Signing messages

The `request` method of the EIP-1193 provider can be used to request signatures. First, get the provider:

<CH.Code>
```tsx client.tsx
// This example assumes you have already checked that Openfort 'embeddedState' is 
// `ready` and the user is `authenticated`
const provider = openfort.getEthereumProvider();
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
  shieldConfiguration: {
    shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
  },
});

```
</CH.Code>

Then use the provider's `request` method with `eth_sign` or related methods:

```tsx
const message = "Sign this message";
const signature = await provider.request({
  method: 'personal_sign',
  params: [message, address]
});
```

If you've integrated Openfort with another web3 library, you can also use that library's syntax for requesting signatures from the wallet:

| Library | Method |
|---------|--------|
| Ethers | [Use the signer's `signMessage` method](https://docs.ethers.org/v5/api/signer/#Signer-signMessage) |
| Wagmi | [Use the `useSignMessage` hook](https://wagmi.sh/react/api/hooks/useSignMessage) |
| Viem | [Use the `signMessage` action](https://viem.sh/account-abstraction/accounts/smart/signMessage) |

### Signing typed data

The `request` method of the EIP-1193 provider can be used to Sign typed data. First, get the provider:

<CH.Code>
```tsx client.tsx
// This example assumes you have already checked that Openfort 'embeddedState' is 
// `ready` and the user is `authenticated`
const provider = openfort.getEthereumProvider();
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
  shieldConfiguration: {
    shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
  },
});

```
</CH.Code>

Then use the provider's `request` method with `eth_sign` or related methods:

```tsx
const address = "0x0000000000000000000000000000000000000000";

const domain = {
  name: "Ether Mail",
  version: "1",
  chainId: 1,
  verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
};

const types = {
  EIP712Domain: [
    { name: "name", type: "string" },
    { name: "version", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "verifyingContract", type: "address" },
  ],
  Person: [
    { name: "name", type: "string" },
    { name: "wallet", type: "address" },
  ],
  Mail: [
    { name: "from", type: "Person" },
    { name: "to", type: "Person" },
    { name: "contents", type: "string" },
  ],
};

const message = {
  from: { name: "Cow", wallet: "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826" },
  to: { name: "Bob", wallet: "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB" },
  contents: "Hello, Bob!",
};

const signature = await provider.request({ method: "eth_signTypedData_v4",
  params: [address, JSON.stringify({ domain, types, primaryType: "Mail", message })],
});
```

If you've integrated Openfort with another web3 library, you can also use that library's syntax for signing typed data from the wallet:

| Library | Method |
|---------|--------|
| Ethers | [Use the signer's `_signTypedData` method](https://docs.ethers.org/v5/api/signer/#Signer-signTypedData) |
| Wagmi | [Use the `useSignTypedData` hook](https://wagmi.sh/react/api/hooks/useSignTypedData) |
| Viem | [Use the `signTypedData` action](https://viem.sh/account-abstraction/accounts/smart/signTypedData) |

</TabPanel>

<TabPanel id="custom" label="Custom">

### Signing messages

To request a signature from a user, use the `signMessage` method.

When invoked, `signMessage` will request an EIP-191 [personal_sign](https://docs.metamask.io/wallet/reference/personal_sign/) signature from the embedded signer, and returns a Promise for the user's signature as a string.

<CH.Code>
```tsx client.tsx

// This example assumes you have already checked that Openfort 'embeddedState' is 
// `ready` and the user is `authenticated`
async function signMessageButton(message:string) {
  await openfort.signMessage(message);
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
  shieldConfiguration: {
    shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
  },
});

```
</CH.Code>

### Signing typed data

To have a user sign an EIP-712 typed data signature, use the `signTypedData` method.

When invoked, `signTypedData` will request an EIP-721 [eth_signTypedData_v4](https://docs.metamask.io/wallet/reference/eth_signtypeddata_v4/) signature from the embedded signer, and returns a Promise for the user's signature as a string.

<CH.Code>
```tsx client.tsx

// This example assumes you have already checked that Openfort 'embeddedState' is 
// `ready` and the user is `authenticated`
async function signTypedMessageButton(domain: any, types: any, value: any) {
  await openfort.signTypedData(domain, types, value);
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
  shieldConfiguration: {
    shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
  },
});

```
</CH.Code>

</TabPanel>
</Tabs>

## Transactions

You can choose to create the session key using a web3 libraries or using the Openfort native method.

<Tabs
  scrollable
  size="large"
  type="underlined"
  defaultActiveId="eip-avoid-layout-shift"
>
<TabPanel id="eip-avoid-layout-shift" label="Standard (EIP-1193 provider)">

### Native transaction

Get the provider and optionally configure [gas policy](/docs/guides/dashboard/gas-sponsorship) to make a sponsored transaction:

<CH.Code>
```tsx client.tsx
// This example assumes you have already checked that Openfort 'embeddedState' is 
// `ready` and the user is `authenticated`
const provider = await openfort.getEthereumProvider({
      policy: 'pol_...',
    }
```
``` openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
  shieldConfiguration: {
    shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
  },
});

```
</CH.Code>

Then, using the provider's `request` method, send a [`eth_sendTransaction`](https://docs.metamask.io/wallet/reference/eth_sendtransaction/) JSON-RPC to the wallet. In the `params` array, include as the first entry an object containing the transaction's parameters, such as **to**, **value**, **data**, **gasLimit**, **maxPriorityFeePerGas**, **maxFeePerGas**, and **gasPrice**.

```tsx
const transactionRequest = {
  to: '0xRecipientAddress',
  value: 100000,
};
const txHash = await provider.request({
  method: 'eth_sendTransaction',
  params: [transactionRequest],
});
```

See [these docs](https://docs.metamask.io/wallet/reference/eth_sendtransaction/) for the parameters that can be passed in `eth_sendTransaction`.

<Admonition type='info'>
You do not need to specify from as we populate it from the user's connected wallet, and you can pass either a number, bigint, or a hexadecimal string into the value parameter.
</Admonition>

If you've integrated Openfort with another web3 library, you can also use that library's syntax for sending transactions from the wallet:

| Library | Method |
|---------|--------|
| Ethers | Use the signer's [`sendTransaction` method.](https://docs.ethers.org/v5/api/signer/#Signer-sendTransaction) |
| Wagmi | Use the [`useSendTransaction` hook.](https://wagmi.sh/react/api/hooks/useSendTransaction) |
| Viem | [`sendTransaction` action](https://viem.sh/account-abstraction/actions/bundler/sendUserOperation) |

### Smart Contracts

Calling a smart contract is a special case of sending a transaction. To call a smart contract, you should send a transaction with the following parameters:

- **`to`**: the address of the smart contract to call
- **`data`**: the encoded function call data
- **`value`**: any value to send (for payable functions)

To prepare the calldata for a smart contract interaction, we recommend using viem's [encodeFunctionData](https://viem.sh/docs/contract/encodeFunctionData#encodefunctiondata) method, like so:

```tsx

const data = encodeFunctionData({
  abi: contractAbi,
  functionName: 'methodName',
  args: [arg1, arg2]
});
```
You can then [send a transaction](/docs/guides/javascript/smart-wallet/send#transactions) from the wallet as normal, and pass the calldata in the **`data`** field of the transaction request:
```tsx
const transactionRequest = {
  to: '0xTheContractAddress',
  data: data,
  value: 100000, // Only necessary for payable methods
};
const txHash = await provider.request({
  method: 'eth_sendTransaction',
  params: [transactionRequest]
});
```

### Batched transactions
Smart wallets support sending a batch of transactions in a single, atomic submission to the network.

To send a batched transactions with a smart wallet, call the `wallet_sendCalls` method with a calls array the transactions to batch together.

As an example, you might batch together a transaction to approve a USDC spender and to transfer USDC like so:

```tsx
const transactionRequest = {
  to: '0xTheContractAddress',
  data: data,
  value: 100000, // Only necessary for payable methods
};
const txHash = await provider.request({
  method: 'wallet_sendCalls',
  params: [
    {
      calls: [
        // Approve transaction
        {
          to: USDC_ADDRESS,
          data: encodeFunctionData({
            abi: USDC_ABI,
            functionName: 'approve',
            args: ['insert-spender-address', BigInt(1e6)],
          }),
        },
        // Transfer transaction
        {
          to: USDC_ADDRESS,
          data: encodeFunctionData({
            abi: USDC_ABI,
            functionName: 'transfer',
            args: ['insert-recipient-address', BigInt(1e6)],
          }),
        },
      ],
    },
  ],
});
```

If you've integrated Openfort with another web3 library, you can also use that library's syntax for sending batched transactions from the wallet:

| Library | Method |
|---------|--------|
| Wagmi | Use the [`useWriteContracts` hook.](https://wagmi.sh/react/api/hooks/useWriteContracts#usewritecontracts) |
| Viem | [`sendCalls` action](https://viem.sh/experimental/eip5792/sendCalls) |

</TabPanel>

<TabPanel id="custom" label="Custom">

### 1. Create a transaction- <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Server side</span>

Create a request to your backend to create a transaction. In the body of the request:
- Include the `player` that signs the transaction.
- Include the `policy` that interacts with the contract for gas. If non-existent the user will need to have gas tokens.
- Include `optimistic` if you want the transactions to be confirmed faster.

Depending on the type of transaction you're creating you'll define `interactions`. The `interactions` field is an array of objects that contain the information of the contract to interact with, the function to call, and the arguments to pass to the function.
- the interactions field contains the `contract` that has previously been added to Openfort.
- the `functionName` defines the function to call from within the contract. 
- If there exist more than one function with the same name, the `functionArgs` will be used to determine which function to call. 

<Tabs
scrollable
size="medium"
type="underlined"
defaultActiveId="native"
>
<TabPanel id="native" label="Native">

Send the value of native tokens in the smallest denomination of the native currency i.e. wei (10^18) and as a `string`.

<Admonition type="tip">

The `to` parameter accepts:
- any valid account `address` e.g. 0x680d2719F09B23F644c136Ab7336D42b6a76AdcC
- a player `id` e.g. pla_...
- an account `id` e.g. acc_...

</Admonition>

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="terminal"
>
<TabPanel id="terminal" label="curl">

```bash command-line
curl https://api.openfort.xyz/v1/transaction_intents \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d player="pla_..." \
  -d policy="pol_..." \
  -d chainId=80002 \
  -d optimistic=true \
  -d "interactions[0][value]=1000" \
  -d "interactions[0][to]=pla_..."
``` 

</TabPanel>
<TabPanel id="nodejs" label="Node">

```ts server.ts
// Set your secret key. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.openfort.xyz/developers/api-keys
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);

const playerId = "pla_...";
const policyId = "pol_...";
const chainId = 80002;
const optimistic = false;

const interaction_transfer = {
  value: "100",
  to: playerId
};

await openfort.transactionIntents.create({
    "player":playerId,
    "chainId":chainId,
    "optimistic":optimistic,
    "interactions":[interaction_transfer],
    "policy":policyId
  });
```

</TabPanel>
<TabPanel id="csharp" label=".Net">

```csharp Program.cs
string policyId = "pol_...";
string playerId = "pla_...";
int chainId = 80002;
bool optimistic = false;

var interactionTransfer = new Interaction
(
  value: "100",
  to: playerId
);

var transactionIntentRequest = new CreateTransactionIntentRequest
    (
        player: playerId,
        chainId: chainId,
        policy: policyId,
        externalOwnerAddress: null!,
        optimistic: optimistic,
        confirmationBlocks: 0,
        interactions: new List<Interaction> { interactionTransfer}
    );
await client.TransactionIntents.Create(transactionIntentRequest);
```

</TabPanel>
</Tabs>

<Admonition type="info">

The `policy` used to sponsor a transaction that sends native tokens should have the `account_functions` policy rule.

</Admonition>

For a useful resource for computing the Wei, you can visit the [wei calculator](https://eth-converter.com/).

</TabPanel>
<TabPanel id="simple" label="Smart Contracts">

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="terminal"
>
<TabPanel id="terminal" label="curl">

```bash command-line
curl https://api.openfort.xyz/v1/transaction_intents \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d player="pla_..." \
  -d policy="pol_..." \
  -d chainId=80002 \
  -d optimistic=true \
  -d "interactions[0][contract]"="con_..." \
  -d "interactions[0][functionName]"="mint" \
  -d "interactions[0][functionArgs][0]"="0x63B7...484f"
```

</TabPanel>
<TabPanel id="nodejs" label="Node">

```ts server.ts
// Set your secret key. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.openfort.xyz/developers/api-keys
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);

const playerId = "pla_...";
const contractId = "con_...";
const policyId = "pol_...";
const chainId = 80002;
const optimistic = false;

const interaction_mint = {
  contract: contractId,
  functionName: "mint",
  functionArgs: [playerId],
};

await openfort.transactionIntents.create({
    "player":playerId,
    "chainId":chainId,
    "optimistic":optimistic,
    "interactions":[interaction_mint],
    "policy":policyId
  });
```

</TabPanel>
<TabPanel id="csharp" label=".Net">

```csharp Program.cs
string policyId = "pol_...";
string contractId = "con_...";
string playerId = "pla_...";
int chainId = 80002;
bool optimistic = false;

var interactionMint = new Interaction
(
  contract: contractId,
  functionName: "mint",
  functionArgs: new List<object> { playerId }
);

var transactionIntentRequest = new CreateTransactionIntentRequest
    (
        player: playerId,
        chainId: chainId,
        policy: policyId,
        optimistic: optimistic,
        interactions: new List<Interaction> { interactionMint }
    );
await client.TransactionIntents.Create(transactionIntentRequest);
```

</TabPanel>
</Tabs>

</TabPanel>
<TabPanel id="batch" label="Batch">

Smart accounts support batching transactions, allowing multiple actions to be rolled into one. This feature significantly simplifies Web3 interactions for your users. For example, instead of executing `approve()` and then `transfer()`, your user can perform both in a single transaction.

Batching transactions offers several key benefits:
- Users only wait for one transaction to complete instead of multiple.
- Users save on gas fees.
- If any transaction in the batch fails, the entire batch reverts, preventing users from ending up in an inconsistent state. This characteristic is known as "atomicity."

Fore security reasons, there is a limit of 9 interactions per transaction intent.

<Admonition type="tip">

To execute a batch transaction, you can send a transaction intent with **multiple interactions**, and each interaction will be executed in the order they are received.

</Admonition>

<Admonition type="note">

Openfort systems check the contract's ABI to find a function signature based on the `functionName` that you provide and the number of `functionArgs`.

In the case that, in your contract, you have multiple functions with the same `functionName` and number of arguments, you can also include the `functionName` together with the argument types e.g. mint(address)

</Admonition>

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="terminal"
>
<TabPanel id="terminal" label="curl">

```bash command-line
curl https://api.openfort.xyz/v1/transaction_intents \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d player="pla_...", \
  -d policy="pol_..." \
  -d chainId=80002 \
  -d optimistic=true \
  -d "interactions[0][contract]=con_..." \
  -d "interactions[0][functionName]=mint" \
  -d "interactions[0][functionArgs][0]=0x63B7...484f" \
  -d "interactions[1][contract]=con_..." \
  -d "interactions[1][functionName]=transfer" \
  -d "interactions[1][functionArgs][0]=0x32B7...213d"
```

</TabPanel>
<TabPanel id="nodejs" label="Node">

```ts server.ts
// Set your secret key. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.openfort.xyz/developers/api-keys
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);

const playerId = "pla_...";
const contractId = "con_...";
const policyId = "pol_..."; 
const chainId = 80002;
const optimistic = false;

const interaction_mint = {
  contract: contractId,
  functionName: "mint",
  functionArgs: [playerId],
};
const interaction_transfer = {
  contract: contractId,
  functionName: "transfer",
  functionArgs: [playerId],
};

await openfort.transactionIntents.create({
    "player":playerId,
    "chainId":chainId,
    "optimistic":optimistic,
    "interactions":[interaction_mint, interaction_transfer],
    "policy":policyId
  });
```

</TabPanel>
<TabPanel id="csharp" label=".Net">

```csharp Program.cs
string policyId = "pol_...";
string contractId = "con_...";
string playerId = "pla_...";
int chainId = 80002;
bool optimistic = false;

var interactionMint = new Interaction
(
  contract: contractId,
  functionName: "mint",
  functionArgs: new List<object> { playerId }
);

var interactionTransfer = new Interaction
(
  contract: contractId,
  functionName: "transfer",
  functionArgs: new List<object> { playerId }
);

var transactionIntentRequest = new CreateTransactionIntentRequest
    (
        player: playerId,
        chainId: chainId,
        policy: policyId,
        externalOwnerAddress: null!,
        optimistic: optimistic,
        confirmationBlocks: 0,
        interactions: new List<Interaction> { interactionMint, interactionTransfer}
    );
await client.TransactionIntents.Create(transactionIntentRequest);
```

</TabPanel>
</Tabs>

</TabPanel>
</Tabs>

### 2. Sign the transaction with the embedded signer. - <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Client side</span>
Use the `nextAction` returned by the backend to sign the transaction with the embedded signer.

The transaction will be automatically signed and broadcasted by using the `sendSignatureTransactionIntentRequest` method.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="javascript"
>
    <TabPanel id="javascript" label="Javascript">
```js
const handleCollectButtonClick = async () => {
  const collectResponse = await fetch(`https://your-backend.com/api/mint`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
  });
  const collectResponseJSON = await collectResponse.json();

  if (collectResponseJSON.data?.nextAction) {
    // This example assumes you have already checked that Openfort 'embeddedState' is 
    // `ready` and the user is `authenticated`
    const response = await openfort.sendSignatureTransactionIntentRequest(
      collectResponseJSON.data.id,
      collectResponseJSON.data.nextAction.payload.userOperationHash
    );
    console.log("response", response);
  }
  console.log("success:", collectResponseJSON.data);
};
```
    </TabPanel>
</Tabs>

</TabPanel>
</Tabs>


# Authentication
Use Openfort to authenticate and create non-custodial accounts

GlassPanel,
  IconPanel,
  Button,
  IconChevronRight,
} from '@/components/ui'

At a high-level, onboarding users onchain breaks down into three core questions: who is taking the onchain action (the user), through what means are they able to control this action (the signer) and where is the affected state (the account).

**With Openfort, your app can authenticate users across web2 and web3 accounts, including:**

- **Email**, via password recovery
- **Wallet**: via Sign In With Ethereum ([SIWE](https://eips.ethereum.org/EIPS/eip-4361)) standard
- **Web2 social accounts**: via [OAuth2.0 Protocol](https://oauth.net/2/) (Google, Facebook, Twitter, Discord & more.)

These methods can be configured as either login or [link](/docs/guides/javascript/auth/user-management) options for users. Once authenticated, Openfort creates a common player object that includes the user's ID (`playerID`) and all linked accounts, treating all users equally regardless of their authentication method.

The Openfort Auth can be plugged into any front-end/user interface you already have.

### Guides

<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href={`/guides/javascript/auth/password`}
    key={'user-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Authenticating with email'>
        {'Learn how to authenticate users with email.'} 
      </GlassPanel>
  </Link>

    <Link
    href={`/guides/javascript/embedded-signer/recovery`}
    key={'user-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Non-custodial signer'>
        {'Create a non-custodial signer for your users.'}
      </GlassPanel>
  </Link>

    <Link
    href={`/guides/javascript/smart-wallet/advanced/session-keys`}
    key={'user-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Session keys'>
        {'Create session keys with smart wallets'}
      </GlassPanel>
  </Link>

</div>

### Templates
<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href="https://github.com/openfort-xyz/openfort-js/tree/main/examples/apps/auth-sample"
    key="user-accounts"
    className="col-span-12 md:col-span-4"
  >
    <GlassPanel title="Auth with NextJS" icon="/docs/img/icons/github-icon-light" hasLightIcon={true}>
      {'Openfort comlete sample solution for NextJS.'}
    </GlassPanel>
  </Link>

    <Link
    href="https://github.com/openfort-xyz/samples/tree/main/web3auth-nextjs"
    key="user-accounts"
    className="col-span-12 md:col-span-4"
  >
    <GlassPanel title="Auth with Web3Auth" icon="/docs/img/icons/github-icon-light" hasLightIcon={true}>
      {'Integration with an external signer like Web3Auth.'}
    </GlassPanel>
  </Link>

    <Link
    href="hhttps://github.com/openfort-xyz/embedded-wallet-firebase-auth-sample-nextjs"
    key="user-accounts"
    className="col-span-12 md:col-span-4"
  >
    <GlassPanel title="Auth with Firebase" icon="/docs/img/icons/github-icon-light" hasLightIcon={true}>
      {'Integration with thirdparty auth proividers like Firebase.'}
    </GlassPanel>
  </Link>
</div>


# FAQs
Most frequently asked questions about the Openfort platform.

### What is an embedded wallet?
An embedded wallet is a in-app wallet designed to onboard both web2 and web3 users simultaneously. Nexus includes several core components:

- Authentication: A single-sign on authentication experience with familiar social logins
- Signer: An embedded signer accessible across all devices and games
- Account: The asset layer, powering users onchain to manage their assets

### How is an embedded wallet different to existing web3 wallets?
Unlike browser extension wallets like MetaMask, which can be challenging for users to set up, or "embedded signers" that are limited to a single application, Openfort Identity offers a balance of user-friendliness and versatility.
Openfort Identity allows users to use the same wallet across all their games and marketplaces, rather than having one wallet per game.

### How does an embedded wallet's key management work?
Openfort uses a smart contract wallet system on EVM chains. Transactions are processed only if they're signed by either the player (embedded signer) or the game (session key).
- Private key: Using an SSS approach to split the key in three shards only to be reconstructed on the player's client side. 
- Session key: Temporary key used created by the player authorizing a third party to make transactions under a scooped permission set.

### What platforms does embedded wallet support?
|  Functionality | Web | Unity | Unreal | PlayStation | Xbox |
|:--------------:|:---:|:-----:|:------:|:-----------:|:----:|
| Authentication | Yes | Yes   | Yes    | No          | No   |
| Transactions   | Yes | Yes   | Yes    | No          | No   |

### What types of providers does authentication support?
Openfort supports familiar social logins and passwordless email sign-in. You can also 
### Can users Yes, you can use the endpoints provide to [
### How does wallet recovery work with Openfort?
With Openfort you can recover the account if you forget your email/social login as long as you have a majority of 2/3 key shards.

In the event of not having the majority of shards, we've implemented a [social recovery](/docs/guides/javascript/smart-wallet/advanced/social-recovery) where the private key can be reconstructed.

### Can a user change their associated email address for a pre-generated wallet?
No, a user cannot change their email address once they have created a pre-generated wallet. If they need to change their email address, they will need to create a new wallet.

### How will embedded wallets integrate with existing authentication or account systems?

**Option 1: Full Authentication & Signer.** If you're starting from scratch, a very common way to use Nexus is as your game's primary identity and wallet (as games like Rogue Nation do).

**Option 2: Existing Authentication & Signer.** However, many games will already have an account system that they will be reluctant to migrate away from. Easy solution, integrate your authentication with Nexus while using the signer solution.

**Option 3: Existing Authentication & Existing Signer.** You might be already using a wallet provider and want to upgrade to smart accounts.

### What level of support and Service Level Agreements (SLAs) are provided?
At Openfort, we understand the significance of maintaining a high standard of service. Our Service Level Agreements (SLAs) reflect our commitment to providing a reliable, efficient, and safe environment for your operations.

## Security and Contingency Planning

### If Openfort were to shut down with a one-month notice, would there be scope to change the signer on the Smart Contract Wallet and use it in connection with a different provider that manages the private keys differently?

**TLDR:** With enough time, transitioning is fairly simple. You’d need to invoke the `transferOwnership` function for users to accept the new signer.

**Detailed Answer:** Yes, if Openfort shuts down with a one-month notice, it's possible to change the signer. Since Openfort wallets are non-custodial, users have control over their private keys. The key migration process would involve using the "recovery share" and "device share" from Shamir's Secret Sharing (SSS) to reconstruct the private key, allowing users to accept a new signer through the `transferOwnership` function. The new provider would need to support compatible key management systems.

### If Openfort were shut down with zero notice, would there be any scope to do a migration? Would that rely on a self-hosted Shield for the recovery share and the device share being intact?

**TLDR:** If there is no self-hosted option, users should rely on on-chain social recovery.

**Detailed Answer:** Migration is still possible, but it depends on the self-hosted Shield for the recovery share and the availability of the device share. If a self-hosted Shield is not in place, users can utilize on-chain social recovery. As long as the device share and recovery share are intact, users can reconstruct their private key and migrate to a new provider. On-chain social recovery can also help recover the wallet if the device share is lost.

### If Openfort's API were compromised, what is the risk there? Can that risk be mitigated? What’s the risk of the auth share on the private key being exposed?

**TLDR:** Both Openfort's server and Shield are encrypted. Even if an attacker obtains the auth share, they would need a secret to decrypt it.

**Detailed Answer:** If Openfort's API were compromised, the risk is limited because both the auth share and Shield service are encrypted. Even if an attacker gains access to the auth share, they would still need to decrypt it using a secret. Furthermore, since the private key is split using Shamir's Secret Sharing, the auth share alone is insufficient to reconstruct the full key without the device or recovery share.


# Build with React Native


GlassPanel,
  IconPanel,
  Button,
  IconChevronRight,
} from '@/components/ui'

## 1. Install Required Dependencies

Install the latest version of the [Openfort React Native SDK](https://www.npmjs.com/package/@openfort/react-native) and its required dependencies:

```sh Terminal
# Install Openfort React Native SDK
yarn add @openfort/react-native

# Install required dependencies
yarn add buffer react-native-crypto react-native-get-random-values react-native-randombytes stream-browserify react-native-mmkv
```

## 2. Configure Metro

Create or update your `metro.config.js` to include the necessary Node.js module shims:

```javascript
// metro.config.js
const { getDefaultConfig } = require('expo/metro-config');

module.exports = (() => {
  const config = getDefaultConfig(__dirname);

  // Add shims for Node.js modules
  config.resolver.extraNodeModules = {
    crypto: require.resolve('react-native-crypto'),
    stream: require.resolve('stream-browserify'),
    buffer: require.resolve('buffer'),
  };

  return config;
})();
```

## 3. Set up auth providers

Navigate to the **auth providers** page on the [Openfort dashboard](https://dashboard.openfort.xyz) by selecting your project and clicking Auth Providers Methods in the side bar in the [players page](https://dashboard.openfort.xyz/players). Select the account types you'd like users to be able to login with.

## 4. Get your Openfort keys

From the [Openfort Dashboard](https://dashboard.openfort.xyz), select your desired app and navigate to the [developers page](https://dashboard.openfort.xyz/developers/api-keys). You'll need:

- **Publishable Key**: Safe to expose in client-side environment
- **Secret Key**: Must be kept secure and used only server-side
- **Shield Keys**: Required for non-custodial wallets
  - Create Shield keys in the Shield section
  - Securely store the encryption share shown in the one-time popup
  - You'll get both a Publishable and Secret Shield key

## 5. Configure your app

### Import Polyfills

First, 
```javascript
```

### Set up the WebView

Add the Openfort Communication WebView to your app's root layout:

```typescript
// app/_layout.tsx

  return (
    <>
      <OpenfortCommunicationWebView />
      <Slot />
    </>
  );
}
```

### Initialize Openfort

Configure the Openfort SDK with your keys:

```typescript

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
  shieldConfiguration: {
    shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
  }
});
```

<Admonition type='note' label='Important'>
Because we use `mmkv` storage, expo-go will not work. Use `expo run:ios` or `expo run:android` to run your app.
</Admonition>

## Next Steps

Now that you've configured your app, you can use `openfort` throughout to access the Openfort SDK. Check out our [starter repo](https://github.com/openfort-xyz/react-native-auth-sample) to see a complete integration.


# Browse sample projects
Resources for getting started building with Openfort.

GlassPanel,
  IconPanel,
  Button,
  IconChevronRight,
} from '@/components/ui'

Explore the library of sample projects using Openfort.

Find even more samples in our [GitHub repository](https://github.com/openfort-xyz/samples#readme).

## Samples
<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href={`https://github.com/openfort-xyz/openfort-js/tree/main/examples/apps/auth-sample`}
    key={'openfort-auth-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Openfort Auth'>
        {'Openfort Auth Sample in a NextJS project.'}
      </GlassPanel>
  </Link>

  <Link
    href={`https://github.com/openfort-xyz/openfort-js/tree/main/examples/apps/wallet-libraries/vite-wagmi`}
    key={'openfort-auth-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Wagmi'>
        {'Wagmi sample with embedded signer.'}
      </GlassPanel>
  </Link>

  <Link
    href={`https://github.com/openfort-xyz/sample-browser-nextjs-embedded-signer`}
    key={'openfort-auth-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Third party auth'>
        {'Third-party auth with embedded signer.'}
      </GlassPanel>
  </Link>

</div>

## Templates
<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href={`/guides/javascript/resources/telegram-react`}
    key={'user-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Telegram mini-app with React'>
        {'Use Openfort to build a Telegram mini-app.'}
      </GlassPanel>
  </Link>

  <Link
    href={`https://github.com/openfort-xyz/openfort-fc-frames-demo`}
    key={'user-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Farcaster Frame'>
        {'Build Frames and make transactions onchain with Openfort.'}
      </GlassPanel>
  </Link>

  <Link
    href={`https://github.com/openfort-xyz/lost-dungeon`}
    key={'user-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Open source Lost Dungeon'>
        {'Discover how Lost Dungeon (Openfort game) is built.'}
      </GlassPanel>
  </Link>

</div>

Implemented your own library or an example you'd like to share? Send a link to your code to support@openfort.xyz and we'll be happy to add it to the list!


# JavaScript SDK Troubleshooting
The Openfort SDK for JavaScript helps you integrate your game.

## Table of Contents
1. [Vite Build Errors](#vite-build-errors)
2. [Webpack Build Errors](#webpack-build-errors)
3. [Next.js Build Errors](#nextjs-build-errors)
4. [Support](#support)

## Vite Build Errors

### Q: I'm getting warnings like "Module "buffer" has been externalized for browser compatibility" when building with Vite. How do I fix this?

A: This issue is caused by missing Node polyfills in your bundled web application. To resolve it:

1. Install `vite-plugin-node-polyfills`:
   ```bash
   npm i --save-dev vite-plugin-node-polyfills
   # or
   yarn add --dev vite-plugin-node-polyfills
   ```

2. Update your `vite.config.js` or `vite.config.ts`:
   ```javascript
         
        plugins: [
       react(), 
       nodePolyfills()
     ],
   })
   ```

3. Restart your development server.

### Q: I'm getting a "Cannot read properties of undefined (reading 'from')" error in hdkey-without-crypto.js. How do I fix this?

A: This error is related to the `ethereum-cryptography` package. To fix it:

1. Install the `buffer` package:
   ```bash
   npm install buffer
   # or
   yarn add buffer
   ```

2. Update your `vite.config.ts`:
   ```javascript
         
        plugins: [
       react(),
       nodePolyfills({
         globals: {
           Buffer: false
         }
       })
     ],
     define: { 
       global: {},
     },
   })
   ```

3. Restart your Vite dev server.

### Q: I'm getting a "require is not defined" error when using `vite preview`. How do I fix this?

A: Add the following to your `vite.config.ts` file:

```javascript
  // ... your existing config
  build: {
    commonjsOptions: {
      transformMixedEsModules: true
    }
  },
})
```

Then rebuild your project before running `vite preview`.

## Webpack Build Errors

### Q: I'm getting "Module not found" errors for Node.js core modules when using create-react-app. How do I fix this?

A: This is due to Webpack 5 not including Node.js polyfills by default. To fix it:

1. Install required packages:
   ```bash
   npm install --save-dev react-app-rewired crypto-browserify stream-browserify assert stream-http https-browserify os-browserify url buffer process
   # or
   yarn add --dev react-app-rewired crypto-browserify stream-browserify assert stream-http https-browserify os-browserify url buffer process
   ```

2. Create a `config-overrides.js` file in your project root:
   ```javascript
   const webpack = require('webpack');
   module.exports = function override(config) {
     const fallback = config.resolve.fallback || {};
     Object.assign(fallback, {
       crypto: require.resolve('crypto-browserify'),
       stream: require.resolve('stream-browserify'),
       assert: require.resolve('assert'),
       http: require.resolve('stream-http'),
       https: require.resolve('https-browserify'),
       os: require.resolve('os-browserify'),
       url: require.resolve('url'),
     });
     config.resolve.fallback = fallback;
     config.plugins = (config.plugins || []).concat([
       new webpack.ProvidePlugin({
         process: 'process/browser',
         Buffer: ['buffer', 'Buffer'],
       }),
     ]);
     config.module.rules.push({
       test: /\.m?js/,
       resolve: {
         fullySpecified: false,
       },
     });
     return config;
   };
   ```

3. Update your `package.json` scripts:
   ```json
   "scripts": {
     "start": "react-app-rewired start",
     "build": "react-app-rewired build",
     "test": "react-app-rewired test",
     "eject": "react-scripts eject"
   }
   ```

### Q: How do I deal with 'failed to parse source map' warnings?

A: You can disable these warnings by adding `GENERATE_SOURCEMAP=false` to your start script in `package.json`:

```json
"scripts": {
    "start": "GENERATE_SOURCEMAP=false react-app-rewired start",
    // ...
},
```

## Next.js Build Errors

### Q: I'm getting a "Named 
A: Add the following to your `next.config.js`:

```javascript
const nextConfig = {
  // ... other next config
  experimental: {
    esmExternals: false,
  },
};
```

### Q: I'm having issues importing SDK modules in Next.js 13 with the App Router. What should I do?

A: Use the SDK Code Splitting method for imports:

```typescript
```

### Q: I'm getting a "Cannot read properties of undefined (reading 'fromMasterSeed')" error in Next.js 12. How do I fix this?

A: Add the following to your `next.config.js`:

```javascript
const nextConfig = {
  // ... other next config
  experimental: {
    esmExternals: false,
  },
};
```

### Q: I'm getting a "Could not detect network" error on Next.js 14 API endpoint with JsonRpcProvider. How do I fix this?

A: You have three options:
1. Downgrade to Next.js 13
2. Upgrade to Ethers v6
3. Use the solution provided [in this GitHub issue discussion](https://github.com/ethers-io/ethers.js/issues/3952#issuecomment-1698913553)


# Using the Openfort SDKs


There are **two** steps to configure Openfort's embedded wallets in your application:
- Configure the embedded signer configuration.
- Wait for the embedded signer to be ready.

## Embedded signer configuration

The Openfort SDKs provide a way to configure a non-custodial embedded signer that can be used to sign transactions and interact with the blockchain.
The **`configureEmbeddedSigner`** is the method responsible for setting up and creating the non-custodial wallet.

<CH.Code>
```ts config.ts

// This example assumes that the user is `authenticated`
async function configure(password:string, auth_token:string){
  const chainId = 80002;
  const shieldAuth = {
    auth: ShieldAuthType.OPENFORT,
    token: auth_token,
  };
  await openfort.configureEmbeddedSigner(chainId, shieldAuth, password);
}
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
  shieldConfiguration: {
    shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
    shieldEncryptionKey: "YOUR_SHIELD_ENCRYPTION_SHARE",
  },
});

```
</CH.Code>

The `configureEmbeddedSigner` will include a `chainID` parameter, which is the identifier of the blockchain network you want to interact with and create an embedded signer there. You can read the list of supported chains [here](/docs/chains).

Let's go over the rest of the `shieldAuth` parameters of the `configureEmbeddedSigner` method:
| Parameter         | Description                                                                                                                                                                            |
|-------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| auth              | Defines how the `token` parameter is going to be verified. Can be either  **openfort** or **custom**, defining if the token is going to be verified by Openfort or by another backend. |
| token             | The `access_token` or `id_token` that will be used to verify that the user is logged in in your application.                                                                           |

<Admonition type="tip">

**Automatic embedded signer creation**: to offer a frictionless onboarding, you can enlable automatic embedded signer creation. Learn more about it [how to enable automatic recovery](/docs/guides/javascript/embedded-signer/recovery).

</Admonition>

## Waiting for ready

When calling `configureEmbeddedSigner`, the SDK will go through a series of states before it is ready to be used. These states are represented by the enum:

| State                                   | Description                                                            |
|-----------------------------------------|------------------------------------------------------------------------|
| **0** - NONE                            | The initial state of the SDK.                                          |
| **1** - UNAUTHENTICATED                 | Before the user is authenticated.                                      |
| **2** - EMBEDDED_SIGINER_NOT_CONFIGURED | Before calling the `configureEmbeddedSigner`.                          |
| **3** - CREATING_ACCOUNT                | If no account exists for the current chainID, when it will be created. |
| **4** - READY                           | The embedded signer is ready to be used                                |

**As a consequence, it's important to wait until the `embeddedState` has finished initializing before you use the embedded signer**, to ensure that the state you consume is accurate and not stale.

To determine whether the Openfort SDK has initialized the embedded signer, you can call the method `getEmbeddedState` and check if the state is `READY`:

<CH.Code>
```ts main.ts

const state = openfort.getEmbeddedState()
```
```ts openfortConfig.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
  shieldConfiguration: {
    shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
  },
});

```
</CH.Code>


# Overview of smart wallets


<WalletsOverview />


# Openfort Kit Button


To use the Openfort Kit Button, you will need to use the `OpenfortKitButton` component. This component will render a button that will open the Openfort login screen when clicked.

```jsx

function App() {
  return (
    <div>
      <OpenfortKitButton />
    </div>
  );
};
```

This button will use the default configuration of the Openfort Kit, but you can customize the theme properties of the button.

There are other customization properties:

- `showAvatar`: Show the avatar of the user
- `showBalance`: Show the balance of the user
- `label`: The label of the button when the user is not connected

The `OpenfortKitButton` component also provides a `onClick` callback that will be called when the user clicks the button.


# Customize the Openfort UI


<OpenfortKitTheme  />

```jsx
<OpenfortKitProvider theme="YOUR THEME" {/* other props */}>
  {/* Your app here */}
</OpenfortKitProvider>
```

## More customization

Openfort Kit uses ConnectKit, and offers the same theming and customization options. You can edit fonts, colors, and other styling via the theme and customTheme props. For detail, see the [ConnectKit docs](https://docs.family.co/connectkit/customization).


# Configuration


In this guide, we will show you how to use the Openfort Kit configuration to customize the look and feel of the Openfort login screen, configure your signer and more.

To learn more about the provider configuration, go to the [provider configuration page](/docs/guides/react/configuration/provider).

This is a full example of how to use the `OpenfortKitProvider` with password authentication and a `retro` theme, using `beamTestnet` and `polygonAmoy` chains.

```jsx

const config = createConfig(
  getDefaultConfig({
    appName: 'OpenfortKit Next.js demo',
    chains: [beamTestnet, polygonAmoy],

    walletConnectProjectId: process.env.NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID!,
  })
);

const queryClient = new QueryClient();

  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <OpenfortKitProvider

          // Set the publishable key of your OpenfortKit account. This field is required.
          publishableKey={process.env.NEXT_PUBLIC_OPENFORT_PUBLIC_KEY!}

          // Set the wallet configuration. In this example, we will be using the embedded signer.
          walletConfig={{
            createEmbeddedSigner: true,

            embeddedSignerConfiguration: {
              shieldPublishableKey: process.env.NEXT_PUBLIC_SHIELD_API_KEY!,

              // Set the recovery method you want to use, in this case we will use the automatic recovery method
              recoveryMethod: RecoveryMethod.AUTOMATIC,

              // Set the encryption key endpoint to encrypt the recovery data
              createEncryptedSessionEndpoint: '/api/protected-create-encrypted-session',

              // You can set a policy id to sponsor the gas fees for your users
              ethereumProviderPolicyId: process.env.NEXT_PUBLIC_POLICY_ID,
            }
          }}

          // This is the callback that will be called when the user connects or disconnects
          onConnect={(params) => {
            console.log('onConnect', params);
          }}
          onDisconnect={() => {
            console.log('onDisconnect');
          }}

          options={{
            // You can customize the logo of your app
            logo: (<CustomLogo />),

            // Set the auth providers you want to use
            authProviders: [
              AuthProvider.GUEST,
              AuthProvider.EMAIL,
              AuthProvider.GOOGLE,
              AuthProvider.TWITTER,
              AuthProvider.FACEBOOK,
              AuthProvider.WALLET,
            ],

            // Set the chain id you want to use, by default it will use the first chain
            initialChainId: polygonAmoy.id,

            // Skip the email verification, useful for testing
            skipEmailVerification: true,

            // Other useful options
            overlayBlur: 2.5,
            hideTooltips: true,
          }}

          // Set the theme of the OpenfortKit
          theme="retro"
        >
          {children}
        </OpenfortKitProvider>
      </QueryClientProvider>
    </WagmiProvider >
  );
};

```

## OpenfortKitButton

The button component that will allow your users to connect to Openfort.

To learn more about the `OpenfortKitButton` component, go to the [button configuration page](/docs/guides/react/configuration/button).

```jsx

function App() {
  return (
    <div>
      <OpenfortKitButton />
    </div>
  );
};

```


# OpenfortKitProvider Configuration


Openfort Kit Provider is the main component that you will use to wrap your application. It will provide the context to all the components that need to interact with the Openfort Kit.

It has the following props:

- `publishableKey`: The Openfort publishable key. You can get it from the [Openfort dashboard](https://dashboard.openfort.xyz/developers/api-keys).
- `walletConfig`: Configuration for the Fort wallet. It is explained in the [Wallet Configuration](#wallet-configuration) section.
- `theme`: The theme to be used, default is 'auto'. Learn more about themes in the [Custom UI](/docs/guides/react/custom-ui) guide.
- `mode`: The theme mode to be used, default is 'auto'.
- `customTheme`: Custom theme configuration.
- `options`: Additional configuration options. It is explained in the [Options Configuration](#options-configuration) section.
- `onConnect`: Callback function to be called on connect.
- `onDisconnect`: Callback function to be called on disconnect.
- `debugMode`: Enable or disable debug mode, default is false.

## Options Configuration

In this section we will describe the most important properties of the `options` object.

### Auth Providers

The `authProviders` property is an array of `AuthProvider` authentication providers.
Currently, the following providers are supported:
- Guest
- Email
- Wallet
- Google
- Facebook
- Twitter

Social login like Google, Facebook, and Twitter require some additional configuration to let Openfort know about your app. You can find more information in the [Social login](/docs/guides/dashboard/social-login) guide.

### Disclaimer

There are two ways to configure the disclaimer, you can either set the terms of service and privacy policy URLs:

- `privacyPolicyUrl`: The privacy policy URL.
- `termsOfServiceUrl`: The terms of service URL.

or customize the disclaimer component:

- `disclaimer`: A disclaimer to be shown in the wallet.

### Other options

- `skipEmailVerification`: Skip email verification. Useful for testing.
- `enforceSupportedChains`: This will enforce the supported chains, it will open the modal until the user selects a supported chain.
- `logo`: The logo to be shown in the wallet.
- `openfortUrlOverrides`: The Openfort URL overrides.
- `hideBalance`: Hide the balance in the wallet.
- `hideTooltips`: Hide the tooltips in the wallet.
- `hideRecentBadge`: Hide the recent badge in the wallet.
- `walletConnectCTA`: Show the WalletConnect CTA as a link, modal or both.
- `avoidLayoutShift`: Avoid layout shift when the wallet is loaded.
- `embedGoogleFonts`: Embed Google Fonts in the wallet.
- `truncateLongENSAddress`: Truncate long ENS addresses.
- `walletConnectName`: The name to be used for WalletConnect.
- `reducedMotion`: Enable reduced motion.
- `bufferPolyfill`: Enable buffer polyfill.
- `customAvatar`: Custom avatar component.
- `initialChainId`: The initial chain ID.
- `overlayBlur`: The overlay blur.

## Wallet Configuration

In this section we will describe the properties of the `walletConfig` object.

### How will the user sign transactions?

There are two ways to configure the signer, you can either use the **embedded signer** - a non-custodial signer provided by Openfort - or have the user sign transactions with a **web3 provider**.

### Embedded Signer

If you are using the embedded signer, you will need to set the following properties:

- `createEmbeddedSigner`: Set to `true` to use the embedded signer.
- `embeddedSignerConfiguration`: The configuration for the embedded signer. Explained in the [following](#embedded-signer-configuration) section.

### Embedded Signer Configuration

The most important properties of the `embeddedSignerConfiguration` object are:

- `shieldPublishableKey`: This is the publishable key of the shield. You can get it from the [Openfort dashboard](https://dashboard.openfort.xyz/developers/api-keys).

- `recoveryMethod`: The recovery method you want to use. Currently, the following methods are supported:
  - `RecoveryMethod.AUTOMATIC`
  - `RecoveryMethod.PASSWORD`

  If you need help deciding which method to use, check the [embedded signer](/docs/guides/react/wallets/embedded-signer#decide-a-recovery-method) guide.

- `ethereumProviderPolicyId`: Optional policy ID when they use the Embedded Signer. This can be used to sponsor the gas fees for your users. Create one using [Openfort dashboard](/docs/guides/dashboard/sponsor-rules). Learn more about [sponsoring gas fees](/docs/guides/react/wallets/usage#sponsor-gas-fees).

### Automatic Recovery

If you use automatic recovery, you will need a **backend service** to create an encryption session for the user. This endpoint should be protected and only accessible by the user who is requesting the encryption session (i.e. the user who is logging in). 

For example, in a Next.js API route, you can create an endpoint like this:
<CH.Code>
```ts protected-create-encryption-session.ts

  req: NextApiRequest,
  res: NextApiResponse
) {
    const session = await openfort.registerRecoverySession('YOUR_SHIELD_PUBLISHABLE_KEY', 'YOUR_SHIELD_SECRET_KEY', 'YOUR_SHIELD_ENCRYPTION_SHARE')
    res.status(200).send({
        session: session,
    });
}
```
```ts openfortAdminConfig.ts

const openfort = new Openfort('YOUR_OPENFORT_SECRET_KEY');

```
</CH.Code>

In the `embeddedSignerConfiguration` you will need to specify one of the following properties:

- `createEncryptedSessionEndpoint`: the URL of the endpoint you created
- `getEncryptedSession`: the function that will return the encrypted session.

{/* TODO: ADD EXAMPLES */}

### Password Recovery

If you use password recovery, you can set the `shieldEncryptionKey` property with the encryption key to encrypt the recovery data.

You can also create a backend service, the same way as with automatic recovery instead of setting the `shieldEncryptionKey` property.

{/* TODO: ADD EXAMPLES */}

### Web3 Provider

If you don't want to use the embedded signer, you can use a web3 provider. You will need to enable `AuthProvider.Wallet` in the `authProviders` array, and make the users sign transactions with their web3 provider:

- `linkWalletOnSignUp`: This will ensure that the user links their wallet on sign up.


# Wagmi configuration


Openfort Kit uses [wagmi](https://wagmi.sh/) internally and therefore it's possible to use hooks from wagmi to fetch data such as info about the connected account.

Here is an example of how you can set up the wagmi configuration:

```jsx
const config = createConfig(
  getDefaultConfig({
    // Your dApps chains
    chains: [mainnet],
    transports: {
      // RPC URL for each chain
      [mainnet.id]: http(
        `https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_ID}`,
      ),
    },

    // Required API Keys
    walletConnectProjectId: process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID,

    // Required App Info
    appName: "Your App Name",

    // Optional App Info
    appDescription: "Your App Description",
    appUrl: "https://openfort.xyz", // your app's url
    appIcon: "https://openfort.xyz/logo.png", // your app's icon, no bigger than 1024x1024px (max. 1MB)
  }),
);
```


# Hooks


Openfort Kit provides a set of hooks to interact with the Openfort SDK. These hooks are designed to make it easier to integrate Openfort into your React application.

## useStatus

The `useStatus` hook provides the current status of the Openfort SDK. The status can be one of the following:

- `LOADING`: The SDK is loading
- `CONNECTED`: The user is connected
- `DISCONNECTED`: The user is disconnected
- `NEEDS_RECOVERY`: The SDK needs the recovery phrase to be entered.
- `DISCONNECTED_WITH_ADDRESS`: The SDK is disconnected with an address. This can happen when the user has connected to a Web3 wallet without connecting to Openfort.

It also provides helpful boolean values to check the status, like `isConnected` or `isLoading`.

```jsx

function App() {
  const { status, isConnected, isLoading } = useStatus()
}
```

## useUser

Hook to get the current user. It returns the following properties:

- `user`: The user object.
- `getAccessToken`: A function to get the access token.

```jsx

function App() {
  const { user, getAccessToken } = useUser()
}
```

The user object contains combines the user's information with the Openfort player `id`:

```json
{
  "id": "pla_ff54b031-a878-4ca2-9cf5-ae190f921e9b",
  "object": "player",
  "createdAt": 1691658234,
  "linkedAccounts": [
    {
      "provider": "email",
      "email": "jaume@openfort.xyz",
      "disabled": false,
      "updatedAt": 1691658234
    }
  ]
}
```

To get the `address` of the user, you would use [wagmi](https://wagmi.sh/react/api/hooks)'s `useAccount` hook:

```jsx

function App() {
  const { address } = useAccount();
}
```

## useProviders

Hook to get the providers. It returns the following properties:

- `linkedProviders`: An array of providers that the user has linked. If user is not connected, the array will be empty.
- `allProviders`: An array of all providers.
- `availableProviders`: An array of providers that the user can link. (All providers except the ones that are already linked)

```jsx

function App() {
  const { linkedProviders, availableProviders, allProviders } = useProviders();
}
```

## useWallets

Hook to get the wallets liked by the user and available on the current device. It returns the following properties:

- `wallets`: An array of wallets linked by the user.
- `currentWallet`: The current active wallet.
- `setActiveWallet`: A function to set the active wallet.

```jsx

function App() {
  const { wallets, setActiveWallet, currentWallet } = useWallets()
}
```

## useLogout

Hook to logout the user. It returns a function that you can call to logout the user.

```jsx

function App() {
  const logout = useLogout();
}
```

## useModal

Hook for controlling the modal. It returns the following functions:

- `setOpen`: Sets the modal open state.
- `openWallets`: Opens the wallets page.
- `openProviders`: Opens the providers page. (Only available if the user is connected)
- `openSwitchNetworks`: Opens the switch networks page. (Only available if the user is connected)

```jsx

function App() {
  const { openSwitchNetworks, setOpen, openProviders, openWallets } = useModal();
}
```

## useChains

Hook to get the chains set in the wagmi configuration. It returns an array of chains.

```jsx

function App() {
  const chains = useChains();
}
```

## useChainIsSupported

Hook to check if a chain is supported. It returns a function that you can call to check if a chain is supported.

```jsx

function App() {
  const chains = useChains();
  const chainIsSupported = useChainIsSupported(chains?.[0]?.id);
}
```

## useIsMounted

Helper hook to check if the component is mounted. It returns a boolean value. Useful for ssr apps.

```jsx

function App() {
  const isMounted = useIsMounted();
}
```


# Embedded signer


<Header />

<Decide />

<Automatic />

<UserBased />

<Pregenerate />


# Funding wallets


<Funding />


# Overview


<WalletsOverview />


# Usage


Openfort Kit uses [wagmi](https://wagmi.sh/) internally and therefore it's possible to use hooks from wagmi to fetch data such as info about the connected account. Below there is an example of `useAccount` wagmi hook in use.

### Getting user address

```jsx

const MyComponent = () => {
  const { address } = useAccount()

  return <div>Your address is: {address}</div>
}
```

## Openfort Smart Wallet

When using the wallet provided by Openfort Embedded signer, you can sponsor gas fees, send batch transactions, use session keys, and more. Below is an example of how to use the wallet in your React app.

### Sponsoring Transactions

Openfort Smart Wallet allows you to sponsor gas fees for your users. Making it easier for them to interact with your app.

1. Create a [gas policy](/docs/guides/dashboard/gas-sponsorship) on the [Openfort Dashboard](https://dashboard.openfort.xyz/policies/).

2. Set up the [provider configuration](/docs/guides/react/configuration/provider) with the embedded signer.

3. Set the `ethereumProviderPolicyId` in the `embeddedSignerConfiguration` object.

4. That's it! Your users will now have their gas fees sponsored.

More information about sponsoring gas fees can be found [here](/docs/guides/dashboard/gas-sponsorship).

### Sending Batch Transactions

Openfort Smart Wallet support sending a batch of transactions in a single, atomic submission to the network.

| Library | Method |
|---------|--------|
| Wagmi | Use the [`useWriteContracts` hook.](https://wagmi.sh/react/api/hooks/useWriteContracts#usewritecontracts) |
| Viem | [`sendCalls` action](https://viem.sh/experimental/eip5792/sendCalls) |

### Using Session Keys

<SessionKeys />

| Library | Method |
|---------|--------|
| Viem | [Use the `wallet_grantPermissions` action](https://viem.sh/experimental/erc7715/grantPermissions) |

## Using another wallet

If you are using another wallet you will need to check if they have your desired functionality.

| Library | Method |
|---------|--------|
| Wagmi | Use the [`getCapabilities` hook.](https://wagmi.sh/core/api/actions/getCapabilities) |
| Viem | [`getCapabilities` action](https://viem.sh/experimental/eip5792/getCapabilities) |


# Quickstart


**[Openfort Kit](https://www.npmjs.com/package/@openfort/openfort-kit) is the easiest way to onboard your users onchain.**

<OpenfortKitTheme  />

You will get out of the box support for:
1. Simple UX — Give users a simple, attractive experience.
2. Multiple login methods - Email, Social, WalletConnect, and more.
3. Non-custodial embedded signer - Secure, self-custodied signing without complexity
4. Connection with Web3 wallets
5. Beautiful Themes - Predesigned themes or full customization

## 1. Install

Start by installing [Openfort Kit](https://www.npmjs.com/package/@openfort/openfort-kit) and its peer dependencies using your package manager of choice:

<Tabs
scrollable
size="small"
type="underlined"
defaultActiveId="npm"
>
<TabPanel id="npm" label="npm">
  
```sh Terminal
npm install @openfort/openfort-kit wagmi viem@^2.22.0 @tanstack/react-query
```
</TabPanel>
<TabPanel id="yarn" label="yarn">
  
```sh Terminal
yarn add @openfort/openfort-kit wagmi viem@^2.22.0 @tanstack/react-query
```
</TabPanel>
<TabPanel id="pnpm" label="pnpm">
  
```sh Terminal
pnpm install @openfort/openfort-kit wagmi viem@^2.22.0 @tanstack/react-query
```
</TabPanel>
</Tabs>

{/* 
## 2. Set your auth providers
Navigate to the **auth providers** page on the [Openfort dashboard](https://dashboard.openfort.xyz) by selecting your project and then clicking Auth providers Methods in the side bar in the [players page](https://dashboard.openfort.xyz/players). Select the account types you'd like users to be able to login with. For more information on how to enable social logins, check out the [dashboard docs](/docs/guides/dashboard/social-login). */}

## 2. Get your API keys
In the [API keys](https://dashboard.openfort.xyz/developers/api-keys) section of [Openfort dashboard](https://dashboard.openfort.xyz), you will find:
   - **Publishable Key**: Safe to expose in client-side environment
   - **Secret Key**: Must be kept secure and used only server-side

To generate non-custodial wallets:
1. Scroll to the Shield section and click **Create Shield keys**
2. **Store the encryption share** safely when it appears (you'll only see it once)
3. You'll receive:
   - **Shield Publishable Key**: Safe for client-side use
   - **Shield Secret Key**: Keep secure, server-side only

## 3. Set up providers.

Set up providers for Wagmi, TanStack Query, and OpenfortKit.

To set up a config for Wagmi, we will use Wagmi's `createConfig` function with `@openfort/openfort-kit`'s `getDefaultConfig` function. This automatically sets up the Wagmi instance to support all chains and transports supported by Openfort. If you need more configuration go to the [Wagmi configuration guide](/docs/guides/react/configuration/wagmi).

To set up `OpenfortKitProvider` we will need the publishable key from the Openfort dashboard, and the wallet configuration. More information on the wallet configuration can be found [here](/docs/guides/react/configuration/provider).

```tsx Providers.tsx
'use client'

const config = createConfig(
  getDefaultConfig({
    appName: 'OpenfortKit demo',
    walletConnectProjectId: "YOUR_WALLET_CONNECT_PROJECT_ID",
    chains: [polygonAmoy],
    ssr: true, // Enable server-side rendering if needed
  })
);

const queryClient = new QueryClient()

  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <OpenfortKitProvider
          // Set the publishable key of your OpenfortKit account. This field is required.
          publishableKey={"YOUR_PUBLISHABLE_KEY"}

          // Set the wallet configuration. In this example, we will be using the embedded signer.
          walletConfig={{
            createEmbeddedSigner: true,

            embeddedSignerConfiguration: {
              shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",

              // Set the recovery method you want to use, in this case we will use the password recovery method
              recoveryMethod: RecoveryMethod.PASSWORD,

              // With password recovery we can set the encryption key to encrypt the recovery data
              // This way we don't have a backend to store the recovery data
              shieldEncryptionKey: "YOUR_SHIELD_ENCRYPTION_SHARE"!,
            }
          }}
        >
          {children}
        </OpenfortKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  )
}

```

Wrap your app in the `Providers` component.

```tsx App.tsx

  return (
    <Providers>
      {/* Your app content */}
    </Providers>
  )
}
```

## 4. You're good to go!
Once you've configured your app, you can now use `OpenfortKitButton` to onboard your users.

```tsx page.tsx

function App() {
  return (
    <div>
      <OpenfortKitButton />
    </div>
  );
};

```

## 5. Next steps

Now that you've set up Openfort Kit, you can explore more features and customization options:

- [Configuration](/docs/guides/react/configuration)
- [Customization](/docs/guides/react/customization)


# White Label


## Openfort-js

To customize the look and feel of the Openfort login screen, you will need to use `openfort-js` to create a custom login screen.

With `openfort-js`, you will have access to `openfort` object and you will interact with it to customize the login screen, configure your signer and more.

To get started go to the Javascript documentation and follow the instructions to install `openfort-js` in your project.

<div className="not-prose max-w-sm">
  <Link
    href={`/guides/getting-started`}
  >
    <GlassPanel title="Javascript" icon="/docs/img/icons/libraries/javascript-icon">
      Customize the look and feel of the Openfort login screen with `openfort-js`.
    </GlassPanel>
  </Link>
</div>


# Backend wallet with Rest API


You can also request Openfort's REST API directly to use backend wallets. When requesting the REST API directly, you must set certain headers on your requests.

<StepHikeCompact>

  <StepHikeCompact.Step step={1}>
    <StepHikeCompact.Details title="Get your API Keys">

    [Open your project](https://dashboard.openfort.xyz) in the Openfort Dashboard and grab your secret key from the [project settings](https://dashboard.openfort.xyz/developers/api-keys).

    All API requests must be authenticated using your secret key. Include it in the Authorization header using Basic auth.

    </StepHikeCompact.Details>

    <StepHikeCompact.Code>

```bash Terminal
# Export your secret key as an environment variable

# Test the API connection
curl https://api.openfort.xyz/v1/tokens \
  -u "$YOUR_SECRET_KEY:"
```

    </StepHikeCompact.Code>

  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={2}>
    <StepHikeCompact.Details title="Create a backend wallet">

   Backend wallet (`dac`) can be used for escrow, minting, and transferring assets. Create a new custodial Backend wallet using the API.

    The response will include the backend wallet ID (starts with `dac_`) and its blockchain address.

    </StepHikeCompact.Details>

    <StepHikeCompact.Code>

```bash Terminal
curl https://api.openfort.xyz/v1/settings/developer_accounts \
  -u "$YOUR_SECRET_KEY:" \
  -d name="Transfer Account"
```

    </StepHikeCompact.Code>

  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={3}>
    <StepHikeCompact.Details title="Add a contract to Openfort">

    Add your token contract to Openfort. This example uses a simple ERC-20 contract with transfer functionality.

    Save the returned contract ID (starts with `con_`) for the next step.

    </StepHikeCompact.Details>

    <StepHikeCompact.Code>

```bash Terminal
curl https://api.openfort.xyz/v1/contracts \
  -u "$YOUR_SECRET_KEY:" \
  -d chainId=80002 \
  -d address="0x2522F4Fc9aF2E1954a3D13f7a5B2683A00a4543A" \
  -d abi=[
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "to",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          }
        ],
        "name": "transfer",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
      }
    ] \
  -d name="Example Token"
```

    </StepHikeCompact.Code>

  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={4}>
    <StepHikeCompact.Details title="Create a Transfer Transaction">

    Create a transaction intent to transfer tokens using your backend wallet. Replace:
    - `dac_...` with your Backend wallet ID
    - `con_...` with your contract ID
    - `pla_...` with the recipient's player ID
    - The amount with your desired transfer amount in wei (the example shows 1 token with 18 decimals)

    Setting `optimistic=true` means the response will be returned after simulation but before on-chain confirmation.

    </StepHikeCompact.Details>

    <StepHikeCompact.Code>

```bash Terminal
curl https://api.openfort.xyz/v1/transaction_intents \
  -u "$YOUR_SECRET_KEY:" \
  -d chainId=80002 \
  -d 'account=dac_...' \
  -d optimistic=true \
  -d 'interactions[0][contract]=con_....' \
  -d 'interactions[0][functionName]=transfer' \
  -d 'interactions[0][functionArgs][0]=pla_...' \
  -d 'interactions[0][functionArgs][1]=1000000000000000000'
```

    </StepHikeCompact.Code>

  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={5}>
    <StepHikeCompact.Details title="Check Transaction Status">

    You can check the status of your transaction using the transaction intent ID returned in the previous step.

    The response will include the transaction hash and status once the transaction is processed.

    </StepHikeCompact.Details>

    <StepHikeCompact.Code>

```bash Terminal
curl https://api.openfort.xyz/v1/transaction_intents/tin_... \
  -u "$YOUR_SECRET_KEY:"
```

    </StepHikeCompact.Code>

  </StepHikeCompact.Step>

</StepHikeCompact>


# Backend wallet with SDK (Node.js)


You can use backend wallets via Openfort's NodeJS Server SDK (or .net). Follow the instructions below to configure your desired integration.

<StepHikeCompact>

  <StepHikeCompact.Step step={1}>
    <StepHikeCompact.Details title="Set up Openfort Node.js SDK">

    [Open your project](https://dashboard.openfort.xyz) in the Openfort Dashboard.

    The latest version of the Openfort Node.js server-side SDK supports Node.js versions 14+.

    </StepHikeCompact.Details>

    <StepHikeCompact.Code>

```bash Terminal
mkdir openfort-tutorial
cd openfort-tutorial
npm init -y
npm install @openfort/openfort-node --save
touch index.js
```

    </StepHikeCompact.Code>

  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={2}>
    <StepHikeCompact.Details title="Declare Openfort Environment Variables">

    After your project is ready, grab your secret_key from the [project settings](https://dashboard.openfort.xyz/developers/api-keys).

    Create a `.env` file and populate it with your project's secret key.

    </StepHikeCompact.Details>

    <StepHikeCompact.Code>

```text .env
YOUR_SECRET_KEY=sk_test_...
```

```json package.json
{
  "name": "node",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "node index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@openfort/openfort-node": "^0.6.10"
  }
}
```

    </StepHikeCompact.Code>

  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={3}>
    <StepHikeCompact.Details title="Create a backend wallet">

    Backend wallet (`dac`) can be used for escrow, minting, and transferring assets. You can create a new custodial backend wallet or add your own external account by providing a signature and address.

    </StepHikeCompact.Details>

    <StepHikeCompact.Code>

```js index.js
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(process.env.YOUR_SECRET_KEY);

const main = async () => {
  // Create a new custodial backend wallet
  const developerAccount = await openfort.settings.createDeveloperAccount({
    name: "Minting Account"
  });
  
  console.log("Success! Here is your backend wallet id: " + developerAccount.id);
};

main().then(() => process.exit(0));
```

    </StepHikeCompact.Code>

  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={4}>
    <StepHikeCompact.Details title="Add a contract to Openfort">

    We'll use a simple [ERC-721](https://eips.ethereum.org/EIPS/eip-721) contract on the [Polygon Amoy network](https://www.oklink.com/amoy/).

    Once added, Openfort will return a contract id that starts with `con_`.

    </StepHikeCompact.Details>

    <StepHikeCompact.Code>

```bash Terminal
curl https://api.openfort.xyz/v1/contracts \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d chainId=80002 \
  -d address="0x2522F4Fc9aF2E1954a3D13f7a5B2683A00a4543A" \
  -d abi=[
      {
      "inputs": [
        {
          "internalType": "address",
          "name": "_to",
          "type": "address"
        }
      ],
      "name": "mint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
      }
    ] \
  -d name="Simple NFT"
```

    </StepHikeCompact.Code>

  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={5}>
    <StepHikeCompact.Details title="Mint an NFT using the backend wallet">

    Use your backend wallet to mint an NFT. The wallet will be used to pay for gas fees.

    Make sure to replace the contract id with your own.

    </StepHikeCompact.Details>

    <StepHikeCompact.Code>

```js index.js
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(process.env.YOUR_SECRET_KEY);

const main = async () => {
  const developerAccount = await openfort.settings.createDeveloperAccount({
    name: "Minting Account"
  });
  
  const contractId = "con_...";
  const chainId = 80002;
  const optimistic = false;
  const tokenId = '1'; // Token ID to mint, should be unique
  
  const interaction_mint = {
    contract: contractId,
    functionName: "mint",
    functionArgs: [developerAccount.address, tokenId],
  };

  const transactionIntent = await openfort.transactionIntents.create({
    "account": developerAccount.id,
    "chainId": chainId,
    "optimistic": optimistic,
    "interactions": [interaction_mint]
  });
  
  console.log("Success! Here is your transactionIntent id: " + transactionIntent.id);
};

main().then(() => process.exit(0));
```

    </StepHikeCompact.Code>

  </StepHikeCompact.Step>

  <StepHikeCompact.Step step={6}>
    <StepHikeCompact.Details title="Run the script">

        You're all set! Run the development server on your Terminal.

        You can check the transaction details in your [dashboard](https://dashboard.openfort.xyz/dashboard).

    </StepHikeCompact.Details>
    <StepHikeCompact.Code>

```bash Terminal
npm run dev
```

    </StepHikeCompact.Code>

  </StepHikeCompact.Step>

</StepHikeCompact>


# User Session (JWT/Authorization)


## Getting a user's access token from a request

When your app frontend sends a request to your server, you should include the current user's access token in the Authorization header of the request. This allows your backend to securely identify the requesting user and gate API routes based on their authentication status, their user ID, and more.

<Admonition type='info'>
This guide assumes you have already configured your frontend to including users' access tokens in requests to your server. If this is not the case, please begin with the [frontend authorization guide](/docs/guides/javascript/auth/user-sessions).
</Admonition>

When your server receives a request, the location of the user's access token depends on whether your app uses local storage (the default) or cookies to manage user sessions:

- If using **local storage** to store a user's session, the access token will be passed in the Authorization header of the request.
- If using **cookies** to store a user's session, the access token will be passed in the openfort-token cookie on the request.

For example, in [NextJS](https://nextjs.org/), you might extract the auth token from a `NextApiRequest` as follows:

<Tabs
scrollable
size="small"
type="underlined"
defaultActiveId="localstorage"
>
    <TabPanel id="localstorage" label="Using local storage">
```ts
const accessToken = req.headers.authorization.replace('Bearer ', '');
```
    </TabPanel>
    <TabPanel id="cookies" label="Using cookies">
```ts
const accessToken = req.cookies['openfort-token'];
```
    </TabPanel>
</Tabs>

## Verifying the user's access token
Once you've obtained the user's access token from a request, you should verify the token against Openfort's verification key for your app to confirm that the token was issued by Openfort and the user referenced by the player Id in the token is truly authenticated.

The access token is a standard ES256 JWT and the verification key is a standard Ed25519 public key. You can verify the access token against the public key using the [official supported libraries](/docs/libraries) library or using a third-party library for managing tokens.

### When using Openfort auth

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="nodejs"
>
    <TabPanel id="nodejs" label="Node">
```ts
const openfort = new Openfort(process.env.OPENFORT_SK);

const authSession = openfort.iam.verifyAuthToken("USER_AUTH_TOKEN");
```
    </TabPanel>
    <TabPanel id="csharp" label=".Net">
```csharp
using Openfort.SDK.Model;

class Program
{
  static async Task Main()
  {
    var client = new Openfort.SDK.OpenfortClient("sk_test_...");
    var authSession = await client.Iam.VerifyAuthToken("USER_AUTH_TOKEN");
  }
}
```
    </TabPanel>
</Tabs>

### When using a third-party auth

When using a third-party auth provider, you can either verify the token using the provider's SDK or use Openfort's SDK to verify the token.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="nodejs"
>
    <TabPanel id="nodejs" label="Node">
```ts
const openfort = new Openfort(process.env.OPENFORT_SK);

const authSession = openfort.iam.verifyOAuthToken({
      provider: 'firebase', // one of "google" | "twitter" | "facebook" | "discord" | "epic_games" | "accelbyte" | "firebase" | "lootlocker" | "playfab" | "supabase" | "custom" | "oidc";
      token: "USER_AUTH_TOKEN",
      tokenType: 'idToken', // either "idToken" | "customToken"
    });
```
    </TabPanel>
</Tabs>


# Backend wallets


Backend wallets are externally-owned accounts that your application controls to manage on-chain operations. They act as trusted intermediaries that can handle various automated tasks and workflows in your application.

<Admonition type='tip'>
As a developer, you can also use smart wallet as a backend wallet (some benefits include the batching of transactions), please refer to our guide on how to create [smart wallets](/docs/guides/javascript/smart-wallet/connected-wallets) and use as backend wallets.
</Admonition>

## Why use backend wallets?

Backend wallets enable your application to:
- Automate on-chain operations
- Manage digital assets programmatically
- Handle complex user interactions
- Control asset distribution and collection

## How they work

Backend wallets operate directly from your server, allowing you to programmatically execute transactions based on your application's logic. For example, in a gaming application, you could use a backend wallet to automatically distribute rewards when players complete challenges. Or in a marketplace application, you could use it to handle escrow during peer-to-peer trades.

## Getting started

To start using backend wallets in your application:
1. Create your wallet through the [Openfort dashboard](https://dashboard.openfort.xyz)
2. Set up policies to define transaction rules
3. Integrate the wallet into your application logic using our API


# Pregenerating an embedded wallet


You can pregenerate non-custodial wallet associated with a given account, like an email address or social login, without requiring the user to login. You can even send assets to the wallet before the user logs in to your app for the first time. Once the user associated with the account logs in, they will be able to access the pregenerated wallet and any assets sent to them. To pregenerate wallets, use one of the supported backend SDKs:

A user can easily claim their pregenerated wallet simply by logging into your app with one of its linked accounts.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="nodejs"
>
<TabPanel id="nodejs" label="Node">

```ts server.ts
// Set your secret key. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.openfort.xyz/developers/api-keys
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);

const notifications = await openfort.iam.createAuthPlayer(
{ 
  thirdPartyUserId: "user id",
  thirdPartyProvider: 'provider name', // Id of the provider of the user
  preGenerateEmbeddedAccount: true
  chainId: 4337,
  metadata: {
    name: "Jaume"
    }
},
{
  shieldAuthProvider: '', // ShieldAuthProvider.OPENFORT or ShieldAuthProvider.CUSTOM
  apiKey: '', // Shield publishable key
  apiSecret: '', // Shield secret key
  encryptionPart: '' // Shield encryption share
})
```

</TabPanel>
<TabPanel id="csharp" label=".Net">

```csharp Program.cs
using Openfort.SDK;
using Openfort.SDK.Model;
const openfort = new OpenfortClient(YOUR_SECRET_KEY);

const notifications = await openfort.Iam.CreateAuthPlayer(
  new CreateAuthPlayerRequest(
    ThirdPartyUserId = "user id",
    ThirdPartyProvider = 'provider name', // Id of the provider of the user
    PreGenerateEmbeddedAccount = true,
    ChainId = 4337, 
  ),
  new PreGenerateEmbeddedAccountsConfiguration(
    ShieldAuthProvider = ShieldAuthProvider.OPENFORT, // ShieldAuthProvider.OPENFORT or ShieldAuthProvider.CUSTOM
    ApiKey = '', // Shield publishable
    ApiSecret = '', // Shield secret key
    EncryptionPart = '' // Shield encryption share
  )
);
```

</TabPanel>
</Tabs>

  In the body of the request:

- `thirdPartyUserId`: the user's account id.
- `thirdPartyProvider`: the provider used: custom, supabase, oidc, etc.
- `preGenerateEmbeddedAccount`: boolean with the value **true**.

A successful response will include the new user object along with their user's ID (`playerID`), like below:

```bash
{
"id": "pla_ff54b031-a878-4ca2-9cf5-ae190f921e9b",
"object": "player",
"createdAt": 1691658234,
"linkedAccounts": [
  {
    "provider": "email",
    "email": "jaume@openfort.xyz",
    "disabled": false,
    "updatedAt": 1691658234
  }
]
}
```


# Security & Trust at Openfort
Protecting your users' data with rigorous security measures and industry best practices.

<Security />


# Setting up your server environment


You can pregenerate wallets associated with a given account, like an email address or social login, without requiring the user to login. You can even send assets to the wallet before the user logs in to your app for the first time.

Once the user associated with the account logs in, they will be able to access the pregenerated wallet and any assets sent to them.

To pregenerate an embedded wallet, use one of the supported backend SDKs:

## Get your API keys

To start, go to the [Openfort Dashboard](https://dashboard.openfort.xyz) and select your desired project from the dropdown at the top. Then, navigate to the Developers page > API Keys tab for your app. Then grab you secret key.

<Admonition type='info'>

Your app secret is a sensitive value that gives you permission to manage Openfort from your server. Do not expose it outside of your backend server.

</Admonition>

Once you've retrieved your API keys, you can begin interacting with Openfort's API in one of two ways: using the server-side SDKs, or querying Openfort's REST API directly.

## Server SDKs

These libraries includes helpful utilities around verifying access tokens issued by Openfort and interacting with Openfort's API to query and 
You can visit the [SDK reference documentation](/docs/reference/api/introduction?lang=ts) to learn more about the available SDKs and how to use them in your server-side application.

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="nodejs"
>
<TabPanel id="nodejs" label="Node">

```ts server.ts
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);
```
</TabPanel>
<TabPanel id="csharp" label=".Net">

```csharp Program.cs
using Openfort.SDK;
using Openfort.SDK.Model;
const openfort = new OpenfortClient(YOUR_SECRET_KEY);
```
</TabPanel>
</Tabs>

## Using the REST API

You can visit the [API reference documentation](/docs/reference/api/introduction) to learn more.

For example, in a JavaScript fetch request, your headers should look like:

```js
headers: {
    'Authorization': `Bearer sk_test_...`,
}
```


# Using backend wallets


## Create wallet

Backend wallets can be created through our dashboard or API. You can either create a new wallet or add an existing one.

### Using the Dashboard
Navigate to the [Openfort dashboard](https://dashboard.openfort.xyz) and create a new developer account.

### Using the API
You can create or add backend wallets through our API:

<Tabs
  scrollable
  size="small"
  type="rounded-pills"
  defaultActiveId="javascript"
>
<TabPanel id="javascript" label="Node">

```ts
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);

const settings = await openfort.settings.createDeveloperAccount()
```

</TabPanel>
<TabPanel id="bash" label="curl">

```bash
curl https://api.openfort.xyz/v1/settings/developer_accounts \
  -u "$YOUR_SECRET_KEY:" \
  -d address="0x..." \
  -d signature="0x..." \
  -d name="My Backend Wallet"
```

</TabPanel>
</Tabs>

## Transactions

To execute a transaction from your backend wallet:

<Tabs
  scrollable
  size="small"
  type="rounded-pills"
  defaultActiveId="javascript"
>
<TabPanel id="javascript" label="Node">

```ts
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);

const transactionintents = await openfort.transactionIntents.create({
  account: 'dac_...', // Your backend wallet ID
  chainId: 80002,
  policy: 'pol_...', // Optional: Policy ID for gas sponsorship
  optimistic: true,
  interactions: {
    contract: 'con_....',
    functionName: 'transfer',
    functionArgs: ['recipient_address', 'amount']
  }
})
```

</TabPanel>
<TabPanel id="bash" label="curl">

```bash
curl https://api.openfort.xyz/v1/transaction_intents \
  -u "$YOUR_SECRET_KEY:" \
  -d chainId=80002 \
  -d 'account=dac_...' \
  -d optimistic=true \
  -d 'interactions[0][contract]=con_....' \
  -d 'interactions[0][functionName]=transfer' \
  -d 'interactions[0][functionArgs][0]=recipient_address' \
  -d 'interactions[0][functionArgs][1]=amount'
```

</TabPanel>
</Tabs>

<Admonition type="info">
For gas sponsorship, make sure to set up appropriate policies with account_functions rules. Learn more about [creating policy sponsors](/docs/guides/dashboard/sponsor-rules).
</Admonition>

### Checking transaction status

You can monitor the status of transactions through our webhook system or by querying the API:

<Tabs
  scrollable
  size="small"
  type="rounded-pills"
  defaultActiveId="javascript"
>
<TabPanel id="javascript" label="Node">

```ts
const transactionIntent = await openfort.transactionIntents.retrieve('tin_...');
console.log(transactionIntent.status);
```

</TabPanel>
<TabPanel id="bash" label="curl">

```bash
curl https://api.openfort.xyz/v1/transaction_intents/tin_... \
  -u "$YOUR_SECRET_KEY:"
```

</TabPanel>
</Tabs>

<Accordion
  type="default"
  chevronAlign="left"
  size="medium"
  defaultActiveId='minting'
  className="text-zinc-500 dark:text-white"
>
  <div className="border-b dark:border-zinc-700 py-3">
    <Accordion.Item
      header={<span className="dark:text-zinc-100 text-zinc-900 font-medium">Minting NFTs with a backend wallet</span>}
      id="minting"
    >
      In this example, we'll use a backend wallet to mint an NFT to a player's account:

      <Tabs
        scrollable
        size="small"
        type="rounded-pills"
        defaultActiveId="javascript"
      >
      <TabPanel id="javascript" label="Node">

      ```ts
      const Openfort = require('@openfort/openfort-node').default;
      const openfort = new Openfort(YOUR_SECRET_KEY);

      const transactionintents = await openfort.transactionIntents.create({
        account: 'dac_...', // Your backend wallet ID
        chainId: 80002,
        policy: 'pol_...', // Policy for gas sponsorship
        optimistic: true,
        interactions: {
          contract: 'con_....',
          functionName: 'mint',
          functionArgs: ['pla_...'] // Player ID receiving the NFT
        }
      })
      ```

      </TabPanel>
      <TabPanel id="bash" label="curl">

      ```bash
      curl https://api.openfort.xyz/v1/transaction_intents \
        -u "$YOUR_SECRET_KEY:" \
        -d chainId=80002 \
        -d 'account=dac_...' \
        -d optimistic=true \
        -d 'interactions[0][contract]=con_....' \
        -d 'interactions[0][functionName]=mint' \
        -d 'interactions[0][functionArgs][0]=pla_...'
      ```

      </TabPanel>
      </Tabs>
    </Accordion.Item>
  </div>

  <div className="border-b dark:border-zinc-700 py-3">
    <Accordion.Item
      header={<span className="dark:text-zinc-100 text-zinc-900 font-medium">Transferring Assets</span>}
      id="transferring"
    >
      Here's how to transfer assets from your backend wallet to another account:

      <Tabs
        scrollable
        size="small"
        type="rounded-pills"
        defaultActiveId="javascript"
      >
      <TabPanel id="javascript" label="Node">

      ```ts
      const Openfort = require('@openfort/openfort-node').default;
      const openfort = new Openfort(YOUR_SECRET_KEY);

      const transactionintents = await openfort.transactionIntents.create({
        account: 'dac_...', // Your backend wallet ID
        chainId: 80002,
        policy: 'pol_...', // Policy for gas sponsorship
        optimistic: true,
        interactions: {
          contract: 'con_....',
          functionName: 'transfer',
          functionArgs: ['pla_...', '1000000000000000000'] // Player ID and amount (1 token)
        }
      })
      ```

      </TabPanel>
      <TabPanel id="bash" label="curl">

      ```bash
      curl https://api.openfort.xyz/v1/transaction_intents \
        -u "$YOUR_SECRET_KEY:" \
        -d chainId=80002 \
        -d 'account=dac_...' \
        -d optimistic=true \
        -d 'interactions[0][contract]=con_....' \
        -d 'interactions[0][functionName]=transfer' \
        -d 'interactions[0][functionArgs][0]=pla_...' \
        -d 'interactions[0][functionArgs][1]=1000000000000000000'
      ```

      </TabPanel>
      </Tabs>
    </Accordion.Item>
  </div>

  <div className="border-b dark:border-zinc-700 py-3">
    <Accordion.Item
      header={<span className="dark:text-zinc-100 text-zinc-900 font-medium">Implementing Escrow System</span>}
      id="escrow"
    >
      This example shows how to implement an escrow system using a backend wallet:

      1. First, check the player's NFT inventory:

      <Tabs
        scrollable
        size="small"
        type="rounded-pills"
        defaultActiveId="javascript"
      >
      <TabPanel id="javascript" label="Node">

      ```ts
      const Openfort = require('@openfort/openfort-node').default;
      const openfort = new Openfort(YOUR_SECRET_KEY);

      const inventory = await openfort.inventories.getPlayerNftInventory({
        player: 'pla_...',
        contract: 'con_...',
      })
      ```

      </TabPanel>
      <TabPanel id="bash" label="curl">

      ```bash
      curl https://api.openfort.xyz/v1/accounts/acc_.../inventory/nft \
        -u "$YOUR_SECRET_KEY:" \
        -d 'contract=con_...'
      ```

      </TabPanel>
      </Tabs>

      2. Then, transfer the asset to the escrow wallet:

      <Tabs
        scrollable
        size="small"
        type="rounded-pills"
        defaultActiveId="javascript"
      >
      <TabPanel id="javascript" label="Node">

      ```ts
      const transactionintents = await openfort.transactionIntents.create({
        chainId: 80002,
        optimistic: false,
        player: 'pla_...', // Player ID
        policy: 'pol_...', // Policy for gas sponsorship
        interactions: {
          contract: 'con_...',
          functionName: "transferFrom",
          functionArgs: ['pla_...', 'dac_...', '10'], // From player to escrow wallet, token ID 10
        }
      });
      ```

      </TabPanel>
      <TabPanel id="bash" label="curl">

      ```bash
      curl https://api.openfort.xyz/v1/transaction_intents \
        -u "$YOUR_SECRET_KEY:" \
        -d chainId=80002 \
        -d optimistic=false \
        -d 'player=pla_...' \
        -d 'policy=pol_...' \
        -d 'interactions[0][contract]=con_...' \
        -d 'interactions[0][functionName]=transferFrom' \
        -d 'interactions[0][functionArgs][0]=pla_...' \
        -d 'interactions[0][functionArgs][1]=dac_...' \
        -d 'interactions[0][functionArgs][2]=10'
      ```

      </TabPanel>
      </Tabs>
    </Accordion.Item>
  </div>
</Accordion>

<Admonition type='info' label='Webhooks'>
To keep your application in sync with blockchain events, Openfort provides [webhooks](/docs/guides/server/webhooks) for various events including transaction status changes and asset transfers.
</Admonition>

## Signature

Coming soon


# Verifying a webhook payload
Listen for events on your Openfort account.

Webhook payloads must be verified before they are trusted and used on your server. This is done by verifying a signature sent with your webhook.

<Admonition type='tip'>
Your endpoint must return a 2xx (status code 200-299) response for the webhook to be marked as delivered. Any other statuses (including 3xx) are considered failed deliveries.
</Admonition>

## Using Openfort Node SDK

Use the [Openfort SDK's](https://www.npmjs.com/package/@openfort/openfort-node) `constructWebhookEvent` method to verify an incoming webhook. Pass in the request body and the signature header. As an example, you can verify a webhook using the code below:

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="typescript"
>
<TabPanel id="typescript" label="Node">

```ts
app.post(
  '/webhook',
  express.raw({ type: 'application/json' }),
  async (req: Request, _res: Response) => {
    const openfort = new Openfort('OPENFORT_SECRET_KEY')
    try {
      const event = await openfort.constructWebhookEvent(
        req.body.toString(),
        req.headers['openfort-signature']
      )
      switch (event.type) {
        case "transaction_intent.succeeded":
          console.log(`TransactionIntent ID: ${event.data.id}`)
          break
        case "transaction_intent.failed":
          console.log(`TransactionIntent ID: ${event.data.id}`)
          break
        default:
          console.log(`Unhandled event type ${event.type}`);
      }
    } catch (e) {
      console.error((e as Error).message)
    }
  }
)
```
</TabPanel>
<TabPanel id="dotnet" label=".Net">
```csharp
[HttpPost("webhook")]
public async Task<IActionResult> Webhook()
{
    var json = await new StreamReader(HttpContext.Request.Body).ReadToEndAsync();
    WebHookEvent openfortEvent;
    try
    {
        openfortEvent = client.ConstructWebhookEvent(
            json,
            Request.Headers["openfort-signature"]
        );
        // Handle the webhook event
        var type = openfortEvent.Type;
        var transactionIntent = openfortEvent.Data;
        Console.WriteLine($"Webhook notification: {openfortEvent} found");
    }
    catch (Exception e)
    {
        Console.WriteLine($"Something failed {e}");
        return BadRequest();
    }

    var transactionIntent = openfortEvent.Data;
    Console.WriteLine($"TransactionIntent ID: {transactionIntent.Id}");

    return Ok();
}
```
</TabPanel>
</Tabs>

## Webhook object

The webhook object contains the following fields:

```json
{
  "data": {
    "id": "tin_c502d628-5bb3-42f2-b8f5-62ba4d71df3a",
    "createdAt": 1689869074,
    "object": "transactionIntent",
    "etc":"..."
  },
  "type": "transaction_intent.succeeded",
  "date": 1689869074
}
```

Where the `type` will be one of the following:
- `transaction_intent.succeeded`: The transaction intent has arrived on-chain and is confirmed.
- `transaction_intent.failed`: The transaction intent has arrived on-chain and is reverted.
- `transaction_intent.cancelled`: The transaction intent parameters were not met.
- `transaction_intent.broadcast`: The transaction intent was broadcasted.
- `balance. project`: The project balance.
- `balance.contract`: The contract balance.
- `balance.dev_account`: The balance of your backend wallet.

The `data` will be a [transaction intent object](https://www.openfort.xyz/docs/reference/api/get-a-transaction-intent-object).

<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href={`/guides/dashboard/webhooks`}
    key={'webhooks'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Webhooks via the dashboard'>
        {'Use your dashboard to register webhooks.'}
      </GlassPanel>
  </Link>
</div>


# Email and Password
Allow users to sign in with a password connected to their email 

Allow users to sign in with a password connected to their email address in your Unity game.

<Admonition type='note'>

You can update the server sending email notifications and the email templates through your dashboard. Visit the guide on how to [update password authentication](/docs/guides/dashboard/password/custom-smtp) to learn more.

</Admonition>

## Setting up authentication

First, create a manager class to handle Openfort authentication:

```csharp
using Openfort.OpenfortSDK;
using Openfort.OpenfortSDK.Model;

public class OpenfortAuthManager : MonoBehaviour 
{
    private OpenfortSDK openfort;
    
    private async void Start()
    {
        if (OpenfortSDK.Instance != null)
        {
            openfort = OpenfortSDK.Instance;
        }
        openfort = await OpenfortSDK.Init("YOUR_OPENFORT_PUBLISHABLE_KEY");
    }
}
```

## Sign up a new user

To register a new user with email and password:

```csharp
public class OpenfortAuthManager : MonoBehaviour 
{
    // ... previous code ...

    public async Task SignUpNewUser(string email, string password)
    {
        try 
        {
            await openfort.SignUpWithEmailPassword(email, password);
            Debug.Log("User signed up successfully");
        }
        catch (Exception e)
        {
            Debug.LogError($"Error signing up user: {e.Message}");
        }
    }

    // Optional: Send email verification
    public async Task RequestEmailVerification(string email)
    {
        try 
        {
            await openfort.RequestEmailVerification(email);
            Debug.Log("Verification email sent");
        }
        catch (Exception e)
        {
            Debug.LogError($"Error sending verification email: {e.Message}");
        }
    }
}
```

## Log in a user

To authenticate an existing user:

```csharp
public class OpenfortAuthManager : MonoBehaviour 
{
    // ... previous code ...

    public async Task LogInUser(string email, string password)
    {
        try 
        {
            var response = await openfort.LogInWithEmailPassword(email, password);
            Debug.Log("User logged in successfully");
            
            // The response contains:
            // - response.player: Player information
            // - response.token: Authentication token
            // - response.refreshToken: Token for refreshing authentication
            
            // Store these tokens as needed for your game
        }
        catch (Exception e)
        {
            Debug.LogError($"Error logging in: {e.Message}");
        }
    }
}
```

### Authentication response

Upon successful authentication, you'll receive a response containing:

```json
{
  "player": {
      "id": "pla_cc9ed2b7-c5f5-4c43-8dca-c4b104ba1762",
      "object": "player",
      "createdAt": 1710976453,
      "linkedAccounts": [
          {
              "provider": "email",
              "disabled": false,
              "verified": true,
              "email": "hello@example.com"
          }
      ]
  },
  "token": "eyJhbGci...",
  "refreshToken": "eyJhbGci..."
}
```

## Log out

To log out a user:

```csharp
await openfort.Logout();
```

## Password reset flow

For implementing a password reset flow in your Unity game:

```csharp
public class OpenfortAuthManager : MonoBehaviour 
{
    // ... previous code ...

    public async Task RequestPasswordReset(string email)
    {
        try 
        {
            await openfort.RequestResetPassword(email);
            Debug.Log("Password reset email sent");
        }
        catch (Exception e)
        {
            Debug.LogError($"Error requesting password reset: {e.Message}");
        }
    }

    public async Task ResetPassword(string email, string newPassword, string verificationState)
    {
        try 
        {
            await openfort.ResetPassword(email, newPassword, verificationState);
            Debug.Log("Password reset successfully");
        }
        catch (Exception e)
        {
            Debug.LogError($"Error resetting password: {e.Message}");
        }
    }
}
```

## UI integration example

Here's a basic example of how to integrate this with Unity UI:

```csharp
public class AuthUIManager : MonoBehaviour
{
    [SerializeField] private TMP_InputField emailInput;
    [SerializeField] private TMP_InputField passwordInput;
    [SerializeField] private Button signUpButton;
    [SerializeField] private Button loginButton;
    
    private OpenfortAuthManager authManager;

    private void Start()
    {
        authManager = GetComponent<OpenfortAuthManager>();
        
        signUpButton.onClick.AddListener(HandleSignUp);
        loginButton.onClick.AddListener(HandleLogin);
    }

    private async void HandleSignUp()
    {
        await authManager.SignUpNewUser(emailInput.text, passwordInput.text);
    }

    private async void HandleLogin()
    {
        await authManager.LogInUser(emailInput.text, passwordInput.text);
    }
}
```


# External Wallet Authentication 
Authenticate users with external wallets

Connect wallets via the [Sign in With Ethereum (SIWE)](https://eips.ethereum.org/EIPS/eip-4361) standard. This authentication method is designed for users who prefer to authenticate using their external wallets. Openfort's Unity integration facilitates a secure and direct authentication process using these wallets.

## Setting up wallet authentication

First, create a manager class to handle Openfort wallet authentication:

```csharp
using UnityEngine;
using Openfort.OpenfortSDK;
using Openfort.OpenfortSDK.Model;

public class OpenfortWalletManager : MonoBehaviour 
{
    private OpenfortSDK openfort;
    
    private async void Start()
    {
        openfort = await OpenfortSDK.Init("YOUR_OPENFORT_PUBLISHABLE_KEY");
    }
}
```

## Initialize SIWE authentication

To start the SIWE (Sign in With Ethereum) process:

```csharp
public class OpenfortWalletManager : MonoBehaviour 
{
    // ... previous code ...

    public async Task InitializeSIWE(string walletAddress)
    {
        try 
        {
            await openfort.InitSIWE(new InitSiweRequest(walletAddress));
            Debug.Log("SIWE initialization successful");
        }
        catch (Exception e)
        {
            Debug.LogError($"Error initializing SIWE: {e.Message}");
        }
    }
}
```

## Verify SIWE signature

After getting the signature from the wallet, verify it to authenticate the user:

```csharp
public class OpenfortWalletManager : MonoBehaviour 
{
    // ... previous code ...

    public async Task AuthenticateWithSIWE(
        string signature, 
        string message, 
        string walletClientType, // e.g., "metamask", "coinbaseWallet"
        string connectorType)    // e.g., "wallet_connect_v2", "injected", "coinbase_wallet"
    {
        try 
        {
            var request = new AuthenticateWithSiweRequest(
                signature,
                message,
                walletClientType,
                connectorType
            );
            
            var response = await openfort.AuthenticateWithSIWE(request);
            Debug.Log("SIWE authentication successful");
            
            // The response contains:
            // - response.player: Player information
            // - response.token: Authentication token
            // - response.refreshToken: Token for refreshing authentication
            
            // Store these tokens as needed for your game
        }
        catch (Exception e)
        {
            Debug.LogError($"Error authenticating with SIWE: {e.Message}");
        }
    }
}
```

### Authentication response

Upon successful authentication, you'll receive a response containing:

```json
{
  "player": {
      "id": "pla_cc9ed2b7-c5f5-4c43-8dca-c4b104ba1762",
      "object": "player",
      "createdAt": 1710976453,
      "linkedAccounts": [
          {
              "provider": "wallet",
              "address": "0x1234567890abcdef",
              "disabled": false,
          }
      ]
  },
  "token": "eyJhbGci...",
  "refreshToken": "eyJhbGci..."
}
```

## UI integration example

Here's a basic example of how to integrate wallet authentication with Unity UI:

```csharp
public class WalletAuthUI : MonoBehaviour
{
    [SerializeField] private Button connectWalletButton;
    [SerializeField] private TMP_Text statusText;
    
    private OpenfortWalletManager walletManager;
    private string userWalletAddress;

    private void Start()
    {
        walletManager = GetComponent<OpenfortWalletManager>();
        connectWalletButton.onClick.AddListener(HandleWalletConnection);
    }

    private async void HandleWalletConnection()
    {
        statusText.text = "Connecting wallet...";
        
        try 
        {
            // First initialize SIWE
            await walletManager.InitializeSIWE(userWalletAddress);
            
            // After getting signature from wallet (implementation depends on your wallet integration)
            string signature = await GetWalletSignature();
            string message = await GetSIWEMessage();
            
            // Authenticate
            await walletManager.AuthenticateWithSIWE(
                signature,
                message,
                "metamask", // or your chosen wallet
                "injected" // or your chosen connector type
            );
            
            statusText.text = "Wallet connected!";
        }
        catch (Exception e)
        {
            statusText.text = "Connection failed: " + e.Message;
        }
    }
}
```


# Guest Mode
Enable users to quickly start using your application without registration

<Admonition type='note'>

User data and embedded wallets from guest sessions cannot be merged into an existing user account — guest accounts can only be upgraded into a new user account. If a guest user wants to log in with an existing account, you must delete the guest user session first.

</Admonition>

Use the `OnSignUpGuest` method from the Openfort SDK to create a guest account:

```csharp
    public async void OnSignUpGuest()
    {
        loadingPanel.SetActive(true);
        registerButton.interactable = false;
        statusTextLabel.text = $"Logging In As Guest ...";
        try
        {
            AuthResponse authResponse = await openfort.SignUpGuest();
            accessToken = authResponse.Token;
            await SetAutomaticRecoveryMethod();
            loginPanel.SetActive(false);
            statusTextLabel.text = $"Logged In As Guest";
            loggedinPanel.SetActive(true);
        }
        catch (System.Exception)
        {
            loginPanel.SetActive(false);
            registerPanel.SetActive(true);
        }
        signinButton.interactable = true;
        loadingPanel.SetActive(false);
    }
```

Upon successful registration, you'll receive a response containing the player information and authentication tokens:

```json
{
  "player": {
    "id": "pla_...",
    "object": "player",
    "createdAt": 1234567890,
    "linkedAccounts": []
  },
  "token": "eyJhbG...",
  "refreshToken": "eyJhbG..."
}
```

### Upgrade a guest user to a logged-in user
Simply call [link method](/docs/guides/javascript/auth/user-management/linking) to enable the guest user to upgrade their account to a logged-in account using any authentication method of their choice.


# Social Login (OAuth)


Create a script with the following code and bind it to an object.

The SDK exports a method called `AuthenticateWithOAuth` that implements the pooling OAuth flow. The method takes an `OAuthInitRequest` object as a parameter. The object contains the provider, the redirect URL, and the pooling option.

```csharp    
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Openfort.OpenfortSDK;
using Openfort.OpenfortSDK.Model;

public class InitOpenfort : MonoBehaviour
{
    private OpenfortSDK openfort;

    async void Start()
    {
        string publishableKey = "YOUR_OPENFORT_PUBLISHABLE_KEY";
        openfort = await OpenfortSDK.Init(publishableKey);
    }

    public async void OnGoogleClicked()
    {
      OAuthInitRequest request = new OAuthInitRequest()
        {
            Provider = OAuthProvider.FACEBOOK,
            UsePooling = false,
            Options = new OAuthInitRequestOptions()
            {
                RedirectTo = "mygame://callback"
            },
        };
        await openfort.AuthenticateWithOAuth(request);
    }
}
```
Openfort is now accessible from anywhere via Openfort.Instance.

<Admonition type="caution">
Standalone Windows applications do not support window deep linking from a web browser to the application. Modify the request above to:
```csharp
OAuthInitRequest request = new OAuthInitRequest()
  {
      Provider = OAuthProvider.FACEBOOK,
  };
```
</Admonition>

  ## Android, iOS and macOS

  ### Android setup

  On Android, we utilize [Chrome Custom Tabs](https://developer.chrome.com/docs/android/custom-tabs/) (if available) to seamlessly connect gamers to your Openfort wallet from within the game.

<Admonition type="info">
**UNITY VERSIONS BELOW 2021.3**

To check if Chrome Custom Tabs are available, older Unity versions may require a specific Gradle plugin version.
For example, on Unity 2019.4, you must upgrade from 3.4.* to 3.4.3 (see Android's blog post):
1. In Unity go to Build Settings -> Player Settings -> Android -> Publishing Settings -> Enable Custom Base Gradle Template under the Build section
2. Open the newly generated Assets/Plugins/Android/baseProjectTemplate.grade file
3. Update classpath `com.android.tools.build:gradle:3.4.0` to classpath `com.android.tools.build:gradle:3.4.3`
</Admonition>

1. In Unity go to **Build Settings** -> **Player Settings** -> **Android** -> **Publishing Settings** -> Enable **Custom Main Manifest** and **Custom Main Gradle Template** under the **Build** section
2. Open the newly generated `Assets/Plugins/Android/AndroidManifest.xml` file. Add the following code inside the `<application>` element:

``` xml
<activity
  android:name="com.openfort.unity.RedirectActivity"
  android:exported="true" >
  <intent-filter android:autoVerify="true">
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.DEFAULT" />
    <category android:name="android.intent.category.BROWSABLE" />
    <data android:scheme="mygame" android:host="callback" />
  </intent-filter>
</activity>
```

3. Open the newly generated `Assets/Plugins/Android/mainTemplate.gradle` file. Add the following code inside `dependencies` block:

<Admonition type="info">
For this version of the Chrome Custom Tabs to work, the compileSdkVersion must be at least 33. This is usually the same value as the targetSdkVersion, which you can set in **Build Settings** -> **Player Settings** -> **Android** -> **Other Settings** -> **Target API Level**.
</Admonition>

**Proguard**

If you enable **Minify** in your project settings, you will need to add a custom Proguard file to your project.

1. In Unity go to **Build Settings** -> **Player Settings** -> **Android** -> **Publishing Settings** -> Enable **Custom Proguard File** under the **Build** section
2. Open the newly generated Assets/Plugins/Android/proguard-user.txt file. Add the following code inside the `<application>` element

``` txt
-dontwarn com.openfort.**
-keep class com.openfort.** { *; }
-keep interface com.openfort.** { *; }

-dontwarn androidx.**
-keep class androidx.** { *; }
-keep interface androidx.** { *; }
```

The application will now open when the device processes any link that starts with `mygame://callback`.

### iOS setup

1. In Unity go to **Build Settings** -> **Player Settings** -> **iOS** -> **Other Settings** -> **Supported URL schemes**.
2. Increment the **Size** number.
3. Add your URL scheme in the **Element** field, e.g. if the deeplink URL is `mygame://callback`, add the scheme `mygame` to the field.

Uppon successful authentication, the SDK will return a token that can be used to authenticate the user in your application.

```json response.json
{
  "player": {
      "id": "pla_cc9ed2b7-c5f5-4c43-8dca-c4b104ba1762",
      "object": "player",
      "createdAt": 1710976453,
      "linkedAccounts": [
          {
              "provider": "facebook",
              "disabled": false,
              "externalUserId": "2"
          }
      ]
  },
  "token": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImNmODNlMTM1N2VlZmI4YmRmMTU0Mjg1MGQ2NmQ4MDA3ZDYyMGU0MDUwYjU3MTVkYzgzZjRhOTIxZDM2Y2U5Y2U0N2QwZDEzYzVkODVmMmIwZmY4MzE4ZDI4NzdlZWMyZjYzYjkzMWJkNDc0MTdhODFhNTM4MzI3YWY5MjdkYTNlIn0.eyJhdWQiOiJwcm9fOGY3ZTM1NTktMjhkNy00MWE2LTgxNGMtMjU0OTkzZTdkNjFkLXRlc3QiLCJleHAiOjE3MTA5ODI2MDIsImlhdCI6MTcxMDk3OTAwMiwiaXNzIjoib3BlbmZvcnQueHl6Iiwic2lkIjoiMzhhMDdmMzktMTUxOS00MjE0LWJmNmMtNzI0Zjg0ZDBiZGQwIiwic3ViIjoicGxhX2NjOWVkMmI3LWM1ZjUtNGM0My04ZGNhLWM0YjEwNGJhMTc2MiJ9.EcFtS__GwyxJu1S3tO7jMBbTCIJCpqsoNxxJrqILrKjNl2N5-SIMG2z_s2Vs8ztG6KAVy6zIp6P9GzfD7s4JiA",
  "refreshToken": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImNmODNlMTM1N2VlZmI4YmRmMTU0Mjg1MGQ2NmQ4MDA3ZDYyMGU0MDUwYjU3MTVkYzgzZjRhOTIxZDM2Y2U5Y2U0N2QwZDEzYzVkODVmMmIwZmY4MzE4ZDI4NzdlZWMyZjYzYjkzMWJkNDc0MTdhODFhNTM4MzI3YWY5MjdkYTNlIn0.eyJzaWQiOiIzOGEwN2YzOS0xNTE5LTQyMTQtYmY2Yy03MjRmODRkMGJkZDAiLCJpYXQiOjE3MTA5NzkwMDIsImV4cCI6MTcxMzU3MTAwMn0.koNd4eoevBQQR3-z0CMGL5qVzOURZEeAgjvrHMRloLgDbScS2Qbi4W-vf2fE0fYOWUIAHnAq7cDABNwSQrEvSQ"
}
```


# Third-party authentication
Integrate with existing auth providers and backends

Openfort's embedded signers are fully compatible with any authentication provider that supports JWT-based, stateless authentication. This guide will show you how to integrate third-party authentication providers in your Unity game.

Follow the guide on how to [configure third party auth](/docs/guides/dashboard/external-auth) to learn more.
The supported loginMethods are `'accelbyte'`, `'custom'`, `'firebase'`, `'supabase'`, `'lootlocker'`, `'playfab'`, `'telegramMiniApp'` and `'oidc'`.

## Basic Setup

First, create a manager class to handle Openfort authentication:

```csharp
using UnityEngine;
using Openfort.OpenfortSDK;
using Openfort.OpenfortSDK.Model;

public class OpenfortAuthManager : MonoBehaviour 
{
    private OpenfortSDK openfort;
    
    private async void Start()
    {
        openfort = await OpenfortSDK.Init("YOUR_OPENFORT_PUBLISHABLE_KEY");
    }
}
```

## Authenticate with third-party provider

Here's how to authenticate using a third-party provider:

<Admonition type='note'>

To make these instructions concrete, this guide uses [Firebase](https://firebase.com) as a sample third party auth provider that you can integrate alongside Openfort.

</Admonition>

```csharp
public class OpenfortAuthManager : MonoBehaviour 
{
    // ... previous code ...

    public async Task AuthenticateWithProvider(string token)
    {
        try 
        {
            var request = new ThirdPartyProviderRequest(
                ThirdPartyOAuthProvider.Firebase, // Or other provider
                token,
                TokenType.IdToken    // Or TokenType.CustomToken
            );
            
            var response = await openfort.AuthenticateWithThirdPartyProvider(request);
            Debug.Log("Third-party authentication successful");
            
            // Handle successful authentication
            HandleAuthenticationSuccess(response);
        }
        catch (Exception e)
        {
            Debug.LogError($"Authentication error: {e.Message}");
        }
    }

    private void HandleAuthenticationSuccess(PlayerResponse response)
    {
        // response.id contains the player ID
        // response.linkedAccounts contains the linked provider accounts
        Debug.Log($"Authenticated player ID: {response.Id}");
    }
}
```

### Authentication response

Upon successful authentication, you'll receive a response containing:

```json
{
  "id": "pla_cc9ed2b7-c5f5-4c43-8dca-c4b104ba1762",
  "object": "player",
  "createdAt": 1710976453,
  "linkedAccounts": [
      {
          "provider": "firebase",
          "disabled": false,
          "externalUserId": "2"
      }
  ]
}
```

## Example

<div className="grid md:grid-cols-12 gap-4 not-prose">
  {examples.map((x) => (
    <div className="col-span-4" key={x.href}>
      <Link href={x.href} passHref>
        <GlassPanel icon={'/docs/img/icons/github-icon-light'} hasLightIcon={true} title={x.name}>
          {x.description}
        </GlassPanel>
      </Link>
    </div>
  ))}
</div>

  {
    name: 'Firebase Auth w/ Unity Android',
    description: 'An integration with Google Play Games using Firebase Auth as a third party auth provider.',
    href: 'https://github.com/openfort-xyz/sample-unity-firebaseauth-embedded-signer'
  }
]


# User Session Management
Using Openfort Auth to onboard new users.

Here's a complete example of managing sessions in Unity:

```csharp
using UnityEngine;
using Openfort.OpenfortSDK;
using Openfort.OpenfortSDK.Model;

public class SessionManager : MonoBehaviour 
{
    private OpenfortSDK openfort;
    
    private async void Start()
    {
        openfort = await OpenfortSDK.Init("YOUR_OPENFORT_PUBLISHABLE_KEY");
    }

    // Get the current access token
    public async Task<string> GetAccessToken()
    {
        try 
        {
            string accessToken = await openfort.GetAccessToken();
            return accessToken;
        }
        catch (Exception e)
        {
            Debug.LogError($"Error getting access token: {e.Message}");
            return null;
        }
    }

    // Using the access token for API requests
    public async Task MakeAuthenticatedRequest(string endpoint)
    {
        try 
        {
            string accessToken = await GetAccessToken();
            
            // Example using UnityWebRequest
            using (UnityWebRequest request = UnityWebRequest.Get(endpoint))
            {
                request.SetRequestHeader("Authorization", $"Bearer {accessToken}");
                await request.SendWebRequest();
                
                if (request.result == UnityWebRequest.Result.Success)
                {
                    string response = request.downloadHandler.text;
                    // Handle response
                }
            }
        }
        catch (Exception e)
        {
            Debug.LogError($"API request failed: {e.Message}");
        }
    }

    // Logout functionality
    public async Task LogoutUser()
    {
        try 
        {
            await openfort.Logout();
            Debug.Log("User logged out successfully");
            
            // Additional cleanup if needed
            // For example, return to login screen
            SceneManager.LoadScene("LoginScene");
        }
        catch (Exception e)
        {
            Debug.LogError($"Logout error: {e.Message}");
        }
    }
}
```


# Create and recover signers
Create and manage embedded wallets for your users

## Understanding embedded signers
To create wallets for your users during the login flow, you need to configure the embedded signer. The configuration depends on your chosen recovery method, so it's important to decide on your recovery strategy first.

**Make sure to wait for the embedded state ready before using the embedded signer. Learn more about [how to check the embedded state](/docs/guides/javascript/use-openfort#waiting-for-ready).**

## Decide a recovery method

Recovering the embedded signer is needed when a user logs into a new device or when the embedded signer is lost.

Openfort embedded signers have two core recovery modes: automatic recovery and user-based recovery. At a high-level, this setting modulates how the embedded signer's recovery share is encrypted and stored.

- **[Automatic recovery](/docs/guides/javascript/embedded-signer/recovery#automatic-recovery)**: The recovery share is encrypted with a combination of project entropy and Openfort's entropy. When logging into a new device, users can immediately access their embedded signer.
<Admonition type='tip' label={`Shield configuration`}>
Before configuring the automatic recovery, generate your project's **publishable and secret shield keys** and store the **encryption share**. Learn about the differrent API keys [here](/docs/api-keys#shield-secret-and-publishable-keys).
</Admonition>

- **[User-based recovery](/docs/guides/javascript/embedded-signer/recovery#user-based-recovery):** The recovery share is encrypted by **user-provided entropy**. When logging into a new device, users must enter in their password to recover the embedded signer on the new device. Once the embedded signer has been recovered on a device, users will not need to enter their password on that devices again.

### Automatic recovery

It is worth noting that while **automatic recovery** makes for smooth user UX (without needing to set up a recovery system upfront when logging in), it comes with tradeoffs. Notably, the root of trust with is in the user’s authentication token. This means access to the auth token grants access to the wallet. Accordingly, this token must be properly secured at all times.

When using automatic recovery, **Shield** generates a password that is used for the encryption of the recovery share. The full encryption key can only be accessed if the decryption request includes the user's auth token.

<Admonition type='caution' label={`Encryption share`}>
When using **automatic recovery**, its very important to ensure that the `encryption share` should not be available from the client side of the application. 
</Admonition>

**From your backend**, you should have an endpoint that generates an encryption session for the user. This endpoint should be protected and only accessible by the user who is requesting the encryption session (i.e. the user who is logging in). 

<Admonition type='note'>
An encryption session is requested every time `configureEmbeddedSigner` is called. The encryption session is only valid for **a single use**.
</Admonition>

For example, in a Next.js API route, you can create an endpoint like this:
<CH.Code>
```ts protected-create-encryption-session.ts

  req: NextApiRequest,
  res: NextApiResponse
) {
    const session = await openfort.registerRecoverySession('YOUR_SHIELD_PUBLISHABLE_KEY', 'YOUR_SHIELD_SECRET_KEY', 'YOUR_SHIELD_ENCRYPTION_SHARE')
    res.status(200).send({
        session: session,
    });
}
```
```ts openfortAdminConfig.ts

const openfort = new Openfort('YOUR_OPENFORT_SECRET_KEY');

```
</CH.Code>

Once we've secured the backend we setup the client side:

<Tabs
scrollable
size="small"
type="underlined"
defaultActiveId="openfort-auth"
>
<TabPanel id="openfort-auth" label="Openfort auth">
<CH.Code>
```csharp openfortManager.cs
using System;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Networking;
using Openfort.OpenfortSDK;
using Openfort.OpenfortSDK.Model;
using static Clients.Shield;

public class EmbeddedSignerManager : MonoBehaviour 
{
    private OpenfortSDK openfort;

    // Setup with Openfort authentication
    public async Task SetupAutomaticRecoveryWithOpenfort(string email, string password)
    {
        try 
        {
            // Sign up the user
            AuthResponse response = await openfort.SignUpWithEmailPassword(email, password);
            string token = response.Token;
            
            // Get encryption session from your backend
            string encryptionSession = await GetEncryptionSession();
            
            // Configure the signer
            int chainId = 80002; // Polygon Amoy testnet
            ShieldAuthentication shieldConfig = new ShieldAuthentication(
                ShieldAuthType.Openfort, 
                token
            )
            {
                EncryptionSession = encryptionSession
            };

            EmbeddedSignerRequest request = new EmbeddedSignerRequest(chainId, shieldConfig);
            await openfort.ConfigureEmbeddedSigner(request);
            
            Debug.Log("Automatic recovery setup complete");
        }
        catch (Exception e)
        {
            Debug.LogError($"Error setting up automatic recovery: {e.Message}");
        }
    }
}
```
```csharp encryptionSession.cs
using System;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Networking;

public class EncryptionSessionManager
{
    public static async Task<string> GetEncryptionSession()
    {
        string url = "https://your-api-endpoint.com/api/protected-create-encryption-session";
        
        using (UnityWebRequest webRequest = UnityWebRequest.Post(url, "{}"))
        {
            webRequest.SetRequestHeader("Content-Type", "application/json");

            var operation = webRequest.SendWebRequest();

            while (!operation.isDone)
                await Task.Yield();

            if (webRequest.result != UnityWebRequest.Result.Success)
            {
                Debug.LogError($"Failed to create encryption session: {webRequest.error}");
                throw new Exception("Failed to create encryption session");
            }

            string jsonResponse = webRequest.downloadHandler.text;
            SessionResponse response = JsonUtility.FromJson<SessionResponse>(jsonResponse);
            return response.session;
        }
    }
}

[Serializable]
public class SessionResponse
{
    public string session;
}
```
</CH.Code>
</TabPanel>
<TabPanel id="third-party-auth" label="Third party auth">
This example will showcase **Firebase** as the third-party auth provider. You can replace it with any other [third-party auth provider](/docs/guides/unity/auth/external-auth).
<CH.Code>
```csharp openfortManager.cs
using System;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Networking;
using Openfort.OpenfortSDK;
using Openfort.OpenfortSDK.Model;
using static Clients.Shield;

public async Task SetupAutomaticRecoveryWithThirdParty(string idToken)
    {
        try 
        {
            // Authenticate with third-party provider
            await openfort.AuthenticateWithThirdPartyProvider(
                new ThirdPartyProviderRequest(
                    ThirdPartyOAuthProvider.Firebase, 
                    idToken, 
                    TokenType.IdToken
                )
            );

            // Get encryption session from your backend
            string encryptionSession = await GetEncryptionSession();
            
            // Configure the signer
            int chainId = 80002;
            ShieldAuthentication shieldConfig = new ShieldAuthentication(
                ShieldAuthType.Openfort, 
                idToken, 
                "firebase", 
                "idToken"
            )
            {
                EncryptionSession = encryptionSession
            };

            EmbeddedSignerRequest request = new EmbeddedSignerRequest(chainId, shieldConfig);
            await openfort.ConfigureEmbeddedSigner(request);
            
            Debug.Log("Third-party automatic recovery setup complete");
        }
        catch (Exception e)
        {
            Debug.LogError($"Error setting up third-party automatic recovery: {e.Message}");
        }
    }
```
```csharp encryptionSession.cs
using System;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Networking;

public class EncryptionSessionManager
{
    public static async Task<string> GetEncryptionSession()
    {
        string url = "https://your-api-endpoint.com/api/protected-create-encryption-session";
        
        using (UnityWebRequest webRequest = UnityWebRequest.Post(url, "{}"))
        {
            webRequest.SetRequestHeader("Content-Type", "application/json");

            var operation = webRequest.SendWebRequest();

            while (!operation.isDone)
                await Task.Yield();

            if (webRequest.result != UnityWebRequest.Result.Success)
            {
                Debug.LogError($"Failed to create encryption session: {webRequest.error}");
                throw new Exception("Failed to create encryption session");
            }

            string jsonResponse = webRequest.downloadHandler.text;
            SessionResponse response = JsonUtility.FromJson<SessionResponse>(jsonResponse);
            return response.session;
        }
    }
}

[Serializable]
public class SessionResponse
{
    public string session;
}
```
</CH.Code>
</TabPanel>
</Tabs>

<Admonition type='tip'>
We recommend enabling user-based recovery for users. This is especially important to enforce as the value of assets in a user's wallet grows.
</Admonition>

---

### User-based recovery

**Password recovery**

Require that users set a password when the wallet is created, enforcing password-based recovery from the start.

If encrypted by user-provided entropy, **only the user can decrypt the recovery share**. Openfort never sees or the user's password. Therefore, if you're not planning to ever user the automatic recovery mode, you can use the `encryption share` in the client side of the application. 

<Tabs
scrollable
size="small"
type="underlined"
defaultActiveId="openfort-auth"
>
<TabPanel id="openfort-auth" label="Openfort auth">
```csharp
using Openfort.OpenfortSDK;
using Openfort.OpenfortSDK.Model;
public class openfortManager: MonoBehaviour 
{
    private OpenfortSDK Openfort;
    private async void AuthAndSetPassordRecoveryMethod(string email, string password, string recoveryPassword)
    {
        AuthResponse response = await Openfort.SignUpWithEmailPassword(email, password);
        string token = response.Token;
        int chainId = 80002;
        ShieldAuthentication shieldConfig = new ShieldAuthentication(ShieldAuthType.Openfort, token);
        EmbeddedSignerRequest request = new EmbeddedSignerRequest(chainId, shieldConfig, recoveryPassword);
        await Openfort.ConfigureEmbeddedSigner(request);
    }
}
```
    </TabPanel>
<TabPanel id="third-party-auth" label="Third party auth">
This example will showcase **Firebase** as the third-party auth provider. You can replace it with any other third-party auth provider [supported by Openfort](/docs/guides/javascript/auth/external-auth) or with [Custom Auth](/docs/guides/javascript/auth/custom-auth).
```csharp
using Openfort.OpenfortSDK;
using Openfort.OpenfortSDK.Model;
public class openfortManager: MonoBehaviour 
{
    private OpenfortSDK Openfort;
    private async void AuthAndSetPassordRecoveryMethod(string token, string recoveryPassword)
    {
        await Openfort.AuthenticateWithThirdPartyProvider(new ThirdPartyProviderRequest(ThirdPartyOAuthProvider.Firebase, token, TokenType.IdToken));
        int chainId = 80002;
        ShieldAuthentication shieldConfig = new ShieldAuthentication(ShieldAuthType.Openfort, token, "firebase", "idToken");
        EmbeddedSignerRequest request = new EmbeddedSignerRequest(chainId, shieldConfig, recoveryPassword);
        await Openfort.ConfigureEmbeddedSigner(request);
    }
}
```
    </TabPanel>
</Tabs>

---

## Pregeneration
Openfort also allows you to pregenerate embedded wallets for your users, even before they first login to your game. Please see our [pregeneration guide](/docs/guides/server/pregenerate-wallets) for more.


# Sign messages with the embedded signer 


## Prerequisites
Before implementing message signing:
- Ensure Openfort's `embeddedState` is `ready`
- Verify the user is properly authenticated
- Have an embedded signer configured

## Message Signing

To request a signature from a user, use the `SignMessage` method. This implements the EIP-191 [personal_sign](https://docs.metamask.io/wallet/reference/personal_sign/) standard.

```csharp
using UnityEngine;
using System;
using System.Threading.Tasks;
using Openfort.OpenfortSDK;
using Openfort.OpenfortSDK.Model;

public class MessageSigningManager : MonoBehaviour 
{
    private OpenfortSDK openfort;

    public async Task SignBasicMessage(string message)
    {
        try 
        {
            var signMessageRequest = new SignMessageRequest(message);
            var signature = await openfort.SignMessage(signMessageRequest);
            Debug.Log($"Message signed successfully. Signature: {signature}");
            return signature;
        }
        catch (Exception e)
        {
            Debug.LogError($"Error signing message: {e.Message}");
            throw;
        }
    }
}
```

## Typed Data Signing

For signing EIP-712 typed data, use the `SignTypedData` method. This implements the [eth_signTypedData_v4](https://docs.metamask.io/wallet/reference/eth_signtypeddata_v4/) standard.

```csharp
public class MessageSigningManager : MonoBehaviour 
{
    // ... previous code ...

    public async Task SignTypedData(
        Dictionary<string, object> domain,
        Dictionary<string, object[]> types,
        Dictionary<string, object> value)
    {
        try 
        {
            var request = new SignTypedDataRequest(domain, types, value);
            var signature = await openfort.SignTypedData(request);
            Debug.Log($"Typed data signed successfully. Signature: {signature}");
            return signature;
        }
        catch (Exception e)
        {
            Debug.LogError($"Error signing typed data: {e.Message}");
            throw;
        }
    }
}
```

### Example of Typed Data Structure

```csharp
// Example of structured data for signing
public void CreateAndSignTypedData()
{
    var domain = new Dictionary<string, object>
    {
        { "name", "My Game" },
        { "version", "1" },
        { "chainId", 1 },
        { "verifyingContract", "0x1234567890123456789012345678901234567890" }
    };

    var types = new Dictionary<string, object[]>
    {
        { "Person", new[] 
            {
                new { name = "name", type = "string" },
                new { name = "score", type = "uint256" }
            }
        }
    };

    var value = new Dictionary<string, object>
    {
        { "name", "Alice" },
        { "score", 100 }
    };

    SignTypedData(domain, types, value);
}
```

## Examples

<div className="grid md:grid-cols-12 gap-4 not-prose">
  {examples.map((x) => (
    <div className="col-span-4" key={x.href}>
      <Link href={x.href} passHref>
        <GlassPanel icon={'/docs/img/icons/github-icon-light'} hasLightIcon={true} title={x.name}>
          {x.description}
        </GlassPanel>
      </Link>
    </div>
  ))}
</div>

  {
    name: 'Unity Sample Android Embedded Signer',
    description: 'An integration with Google Play Games using Firebase Auth as a third party auth provider to create a non-custodial embedded signer.',
    href: 'https://github.com/openfort-xyz/sample-unity-firebaseauth-embedded-signer',
  },
  {
    name: 'Unity Sample WebGL Embedded Signer',
    description: 'An integration with Openfort Auth with non-custodial embedded signer.',
    href: 'https://github.com/openfort-xyz/sample-unity-webgl-embedded-signer',
  }
]


# Create and recover signers
Get embedded state

There are **two** essential steps to configure Openfort's embedded wallets in your Unity application:
1. Configure the embedded signer
2. Wait for the embedded signer to be ready

## Embedded Signer Configuration

The Openfort SDK provides methods to configure a non-custodial embedded signer for blockchain interactions and transaction signing in your Unity game.

Here's how to implement the configuration:

```csharp
using UnityEngine;
using System;
using System.Threading.Tasks;
using Openfort.OpenfortSDK;
using Openfort.OpenfortSDK.Model;

public class OpenfortManager : MonoBehaviour
{
    private OpenfortSDK openfort;
    
    private async void Start()
    {
        try 
        {
            openfort = await OpenfortSDK.Init("YOUR_OPENFORT_PUBLISHABLE_KEY");
        }
        catch (Exception e)
        {
            Debug.LogError($"Initialization error: {e.Message}");
        }
    }

    public async Task ConfigureEmbeddedWallet(string authToken, string password = null)
    {
        try 
        {
            int chainId = 80002; // Polygon Amoy testnet
            
            // Create shield authentication configuration
            var shieldAuth = new ShieldAuthentication(
                ShieldAuthType.Openfort, // or ShieldAuthType.Custom for third-party auth
                authToken
            );

            // Create the embedded signer request
            var request = new EmbeddedSignerRequest(
                chainId,
                shieldAuth,
                password // Optional: for user-based recovery
            );

            // Configure the embedded signer
            await openfort.ConfigureEmbeddedSigner(request);
            Debug.Log("Embedded signer configured successfully");
        }
        catch (Exception e)
        {
            Debug.LogError($"Configuration error: {e.Message}");
            throw;
        }
    }
}
```

### Configuration Parameters

The `EmbeddedSignerRequest` takes the following parameters:
| Parameter | Description |
|-----------|-------------|
| chainId | The blockchain network identifier. See [supported chains](/docs/chains) |
| shieldAuth | Authentication configuration including auth type and token |
| password | Optional: Recovery password for user-based recovery |

The `ShieldAuthentication` configuration includes:
| Parameter | Description |
|-----------|-------------|
| auth | Either `ShieldAuthType.Openfort` or `ShieldAuthType.Custom` |
| token | The access or ID token for user verification |

## Checking Embedded Signer State

The embedded signer goes through several states during initialization. It's crucial to wait for the proper state before using the signer.

### Embedded States

| State | Value | Description |
|-------|-------|-------------|
| NONE | 0 | Initial SDK state |
| UNAUTHENTICATED | 1 | Before user authentication |
| EMBEDDED_SIGNER_NOT_CONFIGURED | 2 | Before signer configuration |
| CREATING_ACCOUNT | 3 | Creating new account for chainID |
| READY | 4 | Signer ready for use |

Here's how to check the embedded signer state:

```csharp
public class OpenfortManager : MonoBehaviour
{
    private OpenfortSDK openfort;

        public async UniTask<EmbeddedState> GetEmbeddedState()
    {
        return await GetOpenfortImpl().GetEmbeddedState();
    }
}
```


# Integrate Firebase with Openfort in Unity
Learn how you can create your game in Firebase with a blockchain integration with Openfort.

## Overview

[Firebase](https://firebase.google.com/) is Google's all-encompassing app development platform, providing game developers with an array of backend tools powered by Google Cloud.

Within Unity, we've integrated the Firebase SDK to facilitate backend functionalities. Coupled with the [Google Play Games plugin for Unity](https://github.com/playgameservices/play-games-plugin-for-unity), it ensures a secure and efficient login for Android users.

The integration is further enhanced with the [Openfort Firebase extension](https://extensions.dev/extensions/openfort/firestore-openfort-transactions), which incorporates the [Openfort SDK](https://github.com/openfort-xyz/openfort-node). This enables Unity clients to directly leverage Openfort's blockchain capabilities, allowing for sophisticated blockchain interactions within the gaming environment.

## Application Workflow

<div align="center">
  <img
    alt="Integration workflow"
    src="https://blog-cms.openfort.xyz/uploads/firebase_integration_workflow_f549a770b3.png"
    width="100%"
    height="100%"
  />
</div>

## Prerequisites

- Sign in to [dashboard.openfort.xyz](http://dashboard.openfort.xyz) and create a new project.
- You need a [Google Play Developer account](https://support.google.com/googleplay/android-developer/answer/6112435?hl=en).
- You need a [Google Cloud project](https://developers.google.com/workspace/guides/create-project).
- Clone or download the repository and open it with Unity [2021.3](https://unity.com/releases/editor/qa/lts-releases?version=2021.3).
  When opening the project, select ***Ignore*** on this popup:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_03a708cc91.png?updated_at=2023-11-07T18:41:24.181Z"
      alt='ignore popup'
    />
  </div>

  Once opened, you will see some reference errors. We will solve this in the next step by importing the Firebase SDK.
- Follow the [Firebase-Unity setup guide](https://firebase.google.com/docs/unity/setup?hl=es-419).
  On [step 4](https://firebase.google.com/docs/unity/setup?hl=es-419#add-sdks), you just need to 
  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_1_7d8a33fb8d.png?updated_at=2023-11-07T18:41:24.676Z"
      alt='    />
  </div>

  Do it one by one and disable ***ExternalDependencyManager*** folder before importing:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_2_352fc42325.png?updated_at=2023-11-07T18:41:37.181Z"
      alt='    />
  </div>

  Most reference errors should be solved by now. If `UnityEditor.iOS.Extensions.Xcode` error is still standing, select ***Firebase.Editor*** asset, disable ***Validate References*** and choose ***Apply***:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_3_9ea2133564.png?updated_at=2023-11-07T18:41:46.887Z"
      alt='resolve packages'
    />
  </div>

- Create a keystore
  Follow this [guide](https://docs.unity3d.com/Manual/android-keystore-create.html) to create a new keystore for the Unity project.
- Find SHA1 certificate fingerprint
  You need to extract the certificate fingerprint from the created keystore. Follow this [video tutorial](https://www.youtube.com/watch?v=lDXE4lfM0aQ) on how to do it, it also covers the creation of the keystore.

  This is the command that you will need to run:
  ```shell
  keytool -list -v -keystore "path/to/your/keystore" -alias "your_key_alias"
  ```

## Set up Firebase

### Add Google sign-in provider

Go to the [Firebase console](https://console.firebase.google.com/?hl=es-419), select your project and select ***Authentication***:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_4_e8b0d867f8.png?updated_at=2023-11-07T18:41:47.295Z"
    alt='setup authentication firebase'
  />
</div>

After selecting ***Get started***, select ***Google*** as a sign-in provider:

<div align="center">
  <img
    width="80%"
    height="80%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_6_eacbe66a92.png?updated_at=2023-11-07T18:41:38.487Z"
    alt='choose the auth method'
  />
</div>

Activate ***Enable*** toggle, choose a public-facing name and select ***Save***:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_7_4b75cbc33e.png?updated_at=2023-11-07T18:41:40.678Z"
    alt='setup google'
  />
</div>

A popup will appear. Copy the ***Web client ID*** and the ***Web client secret*** somewhere safe and choose ***Done***. You will see your Google provider enabled:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_8_7d2b07af1c.png?updated_at=2023-11-07T18:41:29.178Z"
    alt='enabled google'
  />
</div>

Select the provider and choose ***Project Settings***. Under ***Your apps*** section select ***Add fingerprint*** and add your [SHA1 certificate fingerprint](https://github.com/openfort-xyz/firebase-extension-unity-sample/tree/main#find-sha1-certificate-fingerprint). Then choose ***Save***:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_26_0877bd3b91.png?updated_at=2023-11-07T18:41:44.183Z"
    alt='add fingerprint'
  />
</div>

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_27_9505073e7c.png?updated_at=2023-11-07T18:41:29.584Z"
    alt='certificate for SHA1'
  />
</div>

### Add Google Play sign-in provider

Select ***Add new provider*** and choose ***Google Play***:

<div align="center">
  <img
    width="80%"
    height="80%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_9_7c803a1a83.png?updated_at=2023-11-07T18:41:36.279Z"
    alt='Choose Google Play'
  />
</div>

Activate ***Enable*** toggle, enter the credentials you just saved and choose ***Save***:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_10_3cd041e888.png?updated_at=2023-11-07T18:41:33.579Z"
    alt='Play games setup'
  />
</div>

Both ***Google*** and ***Google Play*** sign-in providers are ready:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_11_0a946e50ff.png?updated_at=2023-11-07T18:41:31.578Z"
    alt='auth providers'
  />
</div>

### Install Openfort Extension

Go to the [Firebase Extensions Hub](https://extensions.dev/extensions/openfort/firestore-openfort-transactions) and choose ***Install in Firebase console***:

<div align="center">
  <img
    width="80%"
    height="80%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_37_663d8ce948.png?updated_at=2023-11-07T18:41:43.778Z"
    alt='extension hub'
  />
</div>

Choose your project to continue:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_38_129ce9d653.png?updated_at=2023-11-07T18:41:44.982Z) 

Set up your billing profile and follow the instructions until you need to insert the [Openfort API Secret key](https://dashboard.openfort.xyz/developers/api-keys) and choose ***Create secret***. Also set *Cloud Firestore* to ***Sync***:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_39_97fd67c417.png?updated_at=2023-11-09T04:43:58.995Z"
    alt='configure extension'
  />
</div>

Finally choose ***Install extension***. After 3-5 minutes you will see the extension installed:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_41_9c8adab805.png?updated_at=2023-11-07T18:41:46.977Z)

Now select ***Get started*** and under ***How this extension works*** section find ***Configure Openfort webhooks***. Copy the URL:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_42_c9e5cfa74b.png?updated_at=2023-11-07T18:41:46.182Z"
    alt='setup webhook'
  />
</div>

## Set up Openfort

### [Add webhook](https://dashboard.openfort.xyz/webhooks)

Choose ***Add webhook***:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_40_47d93997bf.png?updated_at=2023-11-07T18:41:38.486Z)

Paste the webhook URL you got from the Firebase extension and leave the *Type* as it is. Choose ***Add webhook***:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_44_f0baf395ee.png?updated_at=2023-11-07T18:41:44.581Z)

### [Add a Contract](https://dashboard.openfort.xyz/contracts/new)

Choose ***Add contract***:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_45_dff8dbd5d9.png?updated_at=2023-11-09T04:23:43.095Z)

This sample requires a contract to run. We use [0xbed6a05ce8719bc00db1cc81a814192c82be1bb1](https://mumbai.polygonscan.com/address/0xbed6a05ce8719bc00db1cc81a814192c82be1bb1) (NFT contract deployed in 80002 Amoy). You can use the same for this tutorial:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_46_05a8645885.png?updated_at=2023-11-09T04:25:24.000Z) 

### [Add a Policy](https://dashboard.openfort.xyz/policies/new)

Choose ***Add policy***:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_47_e043788f2d.png?updated_at=2023-11-09T04:27:17.395Z)

We aim to cover gas fees for users. Set a new gas policy:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_48_3cd0914ae9.png?updated_at=2023-11-09T04:31:49.793Z)

Now, add a rule so our contract uses this policy:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_49_74f55004ba.png?updated_at=2023-11-09T04:31:50.888Z)

## Set up Google Play

> **Reminder:** Use the same Google account you used for setting up your Firebase app.

### Create a new app
Go to [Play Console](https://play.google.com/console) and create a new app. Enter app details (it's important you select ***Game***), confirm policies and select ***Create app***:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_12_0487318190.png?updated_at=2023-11-07T18:41:44.580Z)

Under ***Grow --> Play Games Services --> Setup and management --> Configuration***, select ***Create new Play Games Services project*** and choose your Firebase project as the cloud project. Then select ***Use***:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_13_5ad11592ff.png?updated_at=2023-11-07T18:41:47.787Z)

### Add credentials

#### Add Android OAuth client credential

Under ***Credentials*** section choose ***Add credential***:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_14_7e4b6cb5d1.png?updated_at=2023-11-07T18:41:46.982Z)

Select ***Android***:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_15_a46a653f09.png?updated_at=2023-11-07T18:41:46.784Z"
    alt='add android credential'
  />
</div>

Scroll down and select ***Create OAuth client***:

<div align="center">
  <img
    width="70%"
    height="70%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_16_27ab5da789.png?updated_at=2023-11-07T18:41:33.186Z"
    alt='create OAuth client'
  />
</div>

Choose ***Create OAuth Client ID***:

<div align="center">
  <img
    width="70%"
    height="70%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_17_c6d544e6c4.png?updated_at=2023-11-07T18:41:31.682Z"
    alt='create OAuth client popup'
  />
</div>

This will open the Google Cloud console. Now select ***Android*** as *Application type*, enter a *Name* and fill the *Package name* with the **Unity app package name** (found in the Android Platform Player Settings):

<div align="center">
  <img
    width="70%"
    height="70%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_19_72b69ccb8c.png?updated_at=2023-11-07T18:41:46.678Z"
    alt='setup client id gcp'
  />
</div>

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_20_e3286e880c.png?updated_at=2023-11-07T18:41:47.076Z)

Enter your [SHA1 certificate fingerprint](https://github.com/openfort-xyz/firebase-extension-unity-sample/tree/main#find-sha1-certificate-fingerprint) and choose ***CREATE***:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_21_b1c2c44246.png?updated_at=2023-11-07T18:41:34.781Z"
    alt='verify SHA1 create'
  />
</div>

Now you can download the JSON and choose ***OK***:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_22_ee531ceeba.png?updated_at=2023-11-07T18:41:36.781Z"
    alt='download JSON'
  />
</div>

Go back to the Google Play console, select ***Done*** and choose your newly created Android OAuth client. Then select ***Save changes***:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_23_5ff3dc73de.png?updated_at=2023-11-07T18:41:44.877Z)

#### Add Game server/Web OAuth client credential

Go back to ***Configuration*** and select ***Add credential***:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_24_b44fc158b9.png?updated_at=2023-11-07T18:41:44.287Z)

Choose ***Game server***, refresh OAuth clients, select ***Web client (auto created by Google Service)*** (it was created automatically during [this process](https://github.com/openfort-xyz/firebase-extension-unity-sample/tree/main#add-google-sign-in-provider)) and select ***Save changes***:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_25_1f76c7f29a.png?updated_at=2023-11-07T18:41:45.679Z)

Finally copy the ***OAuth client ID***:

<div align="center">
  <img
    width="70%"
    height="70%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_28_ecba674180.png?updated_at=2023-11-07T18:41:30.082Z"
    alt='copy the oauth client'
  />
</div>

## Set up Unity project

> **Reminder:** Make sure ***Android*** is selected as a platform in ***Build settings***. 

Go to ***Window --> Google Play Games --> Setup --> Android setup***:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_30_818b8cbf6d.png?updated_at=2023-11-07T18:41:35.884Z)

Paste the ***Game server OAuth client ID*** you just copied under ***Client ID***:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_31_421e75f3b2.png?updated_at=2023-11-07T18:41:32.077Z"
    alt='setup google play games'
  />
</div>

Go to the [Google Play console](https://play.google.com/console) and on your app's configuration select ***Get resources***:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_32_52815075fc.png?updated_at=2023-11-07T18:41:44.377Z)

Copy the Android (XML):

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_33_6690691229.png?updated_at=2023-11-07T18:41:38.876Z)

In Unity, paste it in ***Resources Definition*** and then select ***Setup***:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_31_421e75f3b2.png?updated_at=2023-11-07T18:41:32.077Z"
    alt='setup google play games'
  />
</div>

Finally, go to the [Firebase console](https://console.firebase.google.com/?hl=es-419) and under your app configuration, download the ***google-services.json***:

![Alt text](https://blog-cms.openfort.xyz/uploads/firebase_extension_unity_img_36_5048e220db.png?updated_at=2023-11-07T18:41:46.980Z)

Import it in your Unity project ***Assets*** folder to make sure every credential is up to date.

## Test on Android

Upon building and running the game on an Android device, the registration/login process is automated via Google Play Games, resulting in a streamlined user experience.

## Conclusion

Upon completing the above steps, your Unity game will be fully integrated with Openfort and Firebase. Always remember to test every feature before deploying to guarantee a flawless player experience.

## Get support
If you found a bug or want to suggest a new [feature/use case/sample], please [file an issue](https://github.com/openfort-xyz/firebase-extension-unity-sample/issues).

If you have questions, comments, or need help with code, we're here to help:
- on Twitter at https://twitter.com/openfortxyz
- on Discord: https://discord.com/invite/t7x7hwkJF4
- by email: support+youtube@openfort.xyz

{/* Finish with a video. This also appears in the Sidebar via the "tocVideo" metadata */}

<div className="video-container">
  <iframe
    src="https://www.youtube-nocookie.com/embed/3DOZhuqKdG0"
    frameBorder="1"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>


# Integrate PlayFab in Unity
Learn how you can create your game in PlayFab with smart wallets.

## Overview
[PlayFab](https://playfab.com/) is a backend service provided by Microsoft for game developers, offering tools for live game management, all powered by Azure's cloud infrastructure.

In this sample we use PlayFab's email & password authentication method to register a new user or log in with an existing one. Once authenticaded we use PlayFab's user identity token to create a non-custodial account using [Embedded Smart Accounts](https://www.openfort.xyz/blog/embedded-smart-accounts).

Moreover, by integrating the [Openfort SDK](https://github.com/openfort-xyz/openfort-node) into Azure Functions, we establish a seamless connection to PlayFab. Unity clients using the PlayFab Unity SDK can tap into these functions, accessing the full range of Openfort features within the game environment.

## Application Workflow

<div align="center">
    <img
      width="100%"
      height="100%"
      src="https://blog-cms.openfort.xyz/uploads/playfab_integration_workflow_43cf69904d.png?updated_at=2024-10-17T11:56:43.141Z"
      alt='Openfort PlayFab integration workflow'
    />
</div>

## Prerequisites
+ [Create a PlayFab account and title](https://learn.microsoft.com/en-us/gaming/playfab/gamemanager/quickstart)
+ Set up your Azure development environment:
    + [Configure your environment](https://learn.microsoft.com/en-us/azure/azure-functions/create-first-function-vs-code-node?pivots=nodejs-model-v4#configure-your-environment)
    + [Sign in to Azure](https://learn.microsoft.com/en-us/azure/azure-functions/create-first-function-vs-code-node?pivots=nodejs-model-v4#sign-in-to-azure)
    + [Create a function app](https://learn.microsoft.com/en-us/azure/azure-functions/create-first-function-vs-code-node?pivots=nodejs-model-v4#create-the-function-app-in-azure)
+ [Sign in to dashboard.openfort.xyz](http://dashboard.openfort.xyz) and create a new project
+ Download or clone the [sample project](https://github.com/openfort-xyz/playfab-unity-sample): 
    + Open [unity-client](https://github.com/openfort-xyz/playfab-unity-sample/tree/main/unity-client) with Unity
    + Open [azure-backend](https://github.com/openfort-xyz/playfab-unity-sample/tree/main/azure-backend) with VS Code

## Set up Openfort

1. #### [Add PlayFab as a provider](https://dashboard.openfort.xyz/players/auth/providers)

   Add your PlayFab title and choose ***Save***:
   <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/playfab_integration_provider_750b4ed963.png?updated_at=2024-03-20T08:07:36.965Z"
      alt='PlayFab provider'
    />
   </div>

2. #### [Create Shield Keys](https://dashboard.openfort.xyz/developers/api-keys)
   In order to create secure non-custodial accounts for our players, we need to create [Shield Keys](https://www.openfort.xyz/docs/api-keys#shield-secret-and-publishable-keys):

   <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/playfab_integration_1_a_fd65cb50f3.png?updated_at=2024-10-17T10:03:12.057Z"
      alt='playfab_integration_1_a_fd65cb50f3'
    />
   </div>

   After the creation, it's very important you save **Shield Encryption Share Key**, you will need it later:

   <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/playfab_integration_1_b_b57537dc82.png?updated_at=2024-10-17T10:03:12.650Z"
      alt='playfab_integration_1_b_b57537dc82'
    />
   </div> 

3. #### [Add a Contract](https://dashboard.openfort.xyz/contracts)
   This sample requires a contract to run. We use [0x51216BFCf37A1D2002A9F3290fe5037C744a6438](https://sepolia.etherscan.io/address/0x51216BFCf37A1D2002A9F3290fe5037C744a6438) (NFT contract deployed in Sepolia - 11155111). You can use the same to ease up things:

   <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/playfab_integration_1_95cbd5e3b9.png?updated_at=2024-10-17T09:13:44.426Z"
      alt='playfab_integration_1_95cbd5e3b9'
    />
   </div>

4. #### [Add a Policy](https://dashboard.openfort.xyz/policies/new)
   We aim to cover gas fees for users. Set a new gas policy:

   <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/playfab_integration_2_dc0ec65caa.png?updated_at=2024-10-17T09:13:44.439Z"
      alt='playfab_integration_2_dc0ec65caa'
    />
   </div>

   Now, add a rule to make our contract benefit from it:

   <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/playfab_integration_3_8c21c821c5.png?updated_at=2024-10-17T09:13:44.439Z"
      alt='playfab_integration_3_8c21c821c5'
    />
   </div>

## Deploy Azure Backend
Open [azure-backend](https://github.com/openfort-xyz/playfab-unity-sample/tree/main/azure-backend) with VS Code and sign in to Azure:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/playfab_integration_4_7deea77cf3.png?updated_at=2024-10-17T09:22:01.129Z"
    alt='playfab_integration_4_7deea77cf3'
  />
</div>

Ensure your Function App (here, it's "openfort-playfab") is listed:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/playfab_integration_5_6d5e73b886.png?updated_at=2024-10-17T09:22:01.428Z"
    alt='playfab_integration_5_6d5e73b886'
  />
</div>

In the terminal, run:
```
npm install
```

In the explorer, right-click on a function and select ***Deploy to Function App***:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/playfab_integration_6_ffc63d55ed.png?updated_at=2024-10-17T09:22:01.628Z"
    alt='playfab_integration_6_ffc63d55ed'
  />
</div>

Next, choose your Function App:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/playfab_integration_7_977d0a46c8.png?updated_at=2024-10-17T09:22:00.931Z"
    alt='playfab_integration_7_977d0a46c8'
  />
</div>

Then, click on ***Deploy***:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/playfab_integration_8_1119fa1634.png?updated_at=2024-10-17T09:22:01.232Z"
    alt='playfab_integration_8_1119fa1634'
  />
</div>

Navigate to your [Azure Portal](https://portal.azure.com/#home) and open your Function App. You should see all the functions listed:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/playfab_integration_9_fb12c55de4.png?updated_at=2024-10-17T09:29:35.428Z"
    alt='playfab_integration_9_fb12c55de4'
  />
</div>

Click on any function and select ***Get Function Url***:

<div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/playfab_integration_10_c4ebde5781.png?updated_at=2024-10-17T09:29:35.242Z"
    alt='playfab_integration_10_c4ebde5781'
  />  
</div>

Subsequently, add this URL (along with all others) to PlayFab to enable access to our Azure Functions from within PlayFab.

## Set up PlayFab Title

1. #### Register Azure Functions
    Visit the [PlayFab developer dashboard](https://developer.playfab.com/), choose your title, and click on ***Automation***:

    <div align="center">
      <img
        width="50%"
        height="50%"
        src="https://blog-cms.openfort.xyz/uploads/playfab_integration_11_5615028c17.png?updated_at=2024-10-17T09:36:46.329Z"
        alt='playfab_integration_11_5615028c17'
      />  
    </div>

    Our functions are already registered. To do the same, click ***Register function*** and provide the function name along with its URL:

    <div align="center">
      <img
        width="50%"
        height="50%"
        src="https://blog-cms.openfort.xyz/uploads/playfab_integration_12_644b97fdaf.png?updated_at=2024-10-17T09:36:45.831Z"
        alt='playfab_integration_12_644b97fdaf'
      />  
    </div>

    Repeat this for all deployed functions.

## Set up Azure Backend

Our Azure backend requires environment variables from both PlayFab and Openfort. Let's configure them.

1. #### Add Openfort Environment Variables
    - Navigate to the [Azure Portal](https://portal.azure.com/#home) and select your Function App.
    - Under ***Settings --> Environment variables***, click ***Add***:
      
    <div align="center">
      <img
        width="50%"
        height="50%"
        src="https://blog-cms.openfort.xyz/uploads/playfab_integration_13_c828ed6ed8.png?updated_at=2024-10-17T09:45:44.934Z"
        alt='playfab_integration_13_c828ed6ed8'
      />  
    </div>

    - Provide the following details:
      + Name: `OF_API_KEY`
      + Value: [Retrieve the **API Secret key**](https://dashboard.openfort.xyz/developers/api-keys)
    
    - Add another application setting:
      + Name: `OF_SHIELD_PUB_KEY`
      + Value: [Retrieve the **Shield Publishable Key**](https://dashboard.openfort.xyz/developers/api-keys)
    
    - Add another application setting:
      + Name: `OF_SHIELD_SECRET_KEY`
      + Value: [Retrieve the **Shield Secret Key**](https://dashboard.openfort.xyz/developers/api-keys)

    - Add another application setting:
      + Name: `OF_SHIELD_ENCRYPTION_SHARE`
      + Value: It's the **Shield Encryption Share Key** you saved before.
    
    - Add another application setting:
      + Name: `OF_NFT_CONTRACT`
      + Value: [Retrieve the **Contract API ID**](https://dashboard.openfort.xyz/contracts)

    - Add another application setting:
      + Name: `OF_SPONSOR_POLICY`
      + Value: [Retrieve the **Policy API ID**](https://dashboard.openfort.xyz/policies)

    - And another application setting:
      + Name: `OF_CHAIN_ID`
      + Value: 11155111

2. #### Add PlayFab Environment Variables
    - Visit the [PlayFab developer dashboard](https://developer.playfab.com/), select your title, and navigate to ***Settings wheel --> Title settings***:

      <div align="center">
        <img
        width="50%"
        height="50%"
        src="https://blog-cms.openfort.xyz/uploads/playfab_integration_14_5bc8927522.png?updated_at=2024-10-17T11:03:15.964Z"
        alt='playfab_integration_14_5bc8927522'
        />  
      </div>

    - In the ***API Features*** section, copy your ***Title ID***:

      <div align="center">
        <img
        width="50%"
        height="50%"
        src="https://blog-cms.openfort.xyz/uploads/playfab_integration_15_711115c4a8.png?updated_at=2024-10-17T11:03:16.150Z"
        alt='playfab_integration_15_711115c4a8'
        />  
      </div>

    - Under ***Secret Keys***, note down your ***Secret key***:

      <div align="center">
        <img
        width="50%"
        height="50%"
        src="https://blog-cms.openfort.xyz/uploads/playfab_integration_16_56663676c7.png?updated_at=2024-10-17T11:03:16.644Z"
        alt='playfab_integration_16_56663676c7'
        />  
      </div>
 
    - Return to the [Azure Portal](https://portal.azure.com/#home) and choose your Function App.
    - Under ***Settings --> Environment variables***, click ***Add***:
      + Name: `PLAYFAB_TITLE_ID`
      + Value: [Your Title ID]

    - Add another application setting:
      + Name: `PLAYFAB_SECRET_KEY`
      + Value: [Your Secret Key]

  After adding all the environment variables, your configuration panel should look like the following. Confirm your changes by clicking ***Save***:

  <div align="center">
    <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/playfab_integration_17_6748a73edf.png?updated_at=2024-10-17T11:06:47.553Z"
    alt='playfab_integration_17_6748a73edf'
    />  
  </div>

## Set up Unity Client

This Unity sample project is already equipped with:
+ [PlayFab Unity SDK](https://github.com/PlayFab/UnitySDK)
+ [Openfort SDK](https://github.com/openfort-xyz/openfort-csharp-unity)

To begin, open [unity-client](https://github.com/openfort-xyz/playfab-unity-sample/tree/main/unity-client) with Unity:

1. #### Configure PlayFab SDK
    - Navigate to the ***Project*** tab.
    - Search for `PlayFabSharedSettings` and input your PlayFab ***Title ID***:

    <div align="center">
      <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/playfab_integration_18_591d3cad7d.png?updated_at=2024-10-17T11:13:05.455Z"
      alt='playfab_integration_18_591d3cad7d'
      />  
    </div>

2. #### Configure Openfort SDK

    - Open the *Login scene* and add the **API Publishable Key** and the **Shield Publishable Key** to the *OpenfortController* config section:

    <div align="center">
      <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/playfab_integration_19_24bc025e75.png?updated_at=2024-10-17T11:13:05.251Z"
      alt='playfab_integration_19_24bc025e75'
      />  
    </div>

## Test in Editor

Play ***Login*** scene, opt for ***Register***, provide an email and password, then click ***Register*** again. This scene should appear:

<div align="center">
  <img
  width="50%"
  height="50%"
  src="https://blog-cms.openfort.xyz/uploads/playfab_integration_20_f934393700.png?updated_at=2024-10-17T11:20:35.838Z"
  alt='playfab_integration_20_f934393700'
  />  
</div>

Select ***Mint***. After a brief period, you should see a representation of your newly minted NFT:

<div align="center">
  <img
  width="50%"
  height="50%"
  src="https://blog-cms.openfort.xyz/uploads/playfab_integration_21_8213efd860.png?updated_at=2024-10-17T11:20:36.645Z"
  alt='playfab_integration_21_8213efd860'
  />  
</div>

In the [Openfort Players dashboard](https://dashboard.openfort.xyz/players), a new player entry should be visible. On selecting this player:

<div align="center">
  <img
  width="50%"
  height="50%"
  src="https://blog-cms.openfort.xyz/uploads/playfab_integration_22_1b307cda7e.png?updated_at=2024-10-17T11:20:36.654Z"
  alt='playfab_integration_22_1b307cda7e'
  />  
</div>

You'll notice that a `mint` transaction has been successfully processed:

<div align="center">
  <img
  width="50%"
  height="50%"
  src="https://blog-cms.openfort.xyz/uploads/playfab_integration_23_eca707b92d.png?updated_at=2024-10-17T11:27:27.546Z"
  alt='playfab_integration_23_eca707b92d'
  />  
</div>

Additionally, by choosing your **Sepolia Wallet Address**, the explorer will open and by selecting ***NFT Transfers*** tab you'll see the transaction is further confirmed:

<div align="center">
  <img
  width="50%"
  height="50%"
  src="https://blog-cms.openfort.xyz/uploads/playfab_integration_24_f29150e8b8.png?updated_at=2024-10-17T11:27:28.651Z"
  alt='playfab_integration_24_f29150e8b8'
  />  
</div>

<div align="center">
  <img
  width="50%"
  height="50%"
  src="https://blog-cms.openfort.xyz/uploads/playfab_integration_25_8aa4b7ec6a.png?updated_at=2024-10-17T11:27:28.239Z"
  alt='playfab_integration_25_8aa4b7ec6a'
  />  
</div>

## Conclusion

Upon completing the above steps, your Unity game will be fully integrated with Openfort and PlayFab. Always remember to test every feature before deploying to guarantee a flawless player experience.

## Get support
If you found a bug or want to suggest a new [feature/use case/sample], please [file an issue](https://github.com/openfort-xyz/playfab-unity-sample/issues).

If you have questions, comments, or need help with code, we're here to help:
- on Twitter at https://twitter.com/openfortxyz
- on Discord: https://discord.com/invite/t7x7hwkJF4
- by email: support+youtube@openfort.xyz

{/* Finish with a video. This also appears in the Sidebar via the "tocVideo" metadata */}

<div className="video-container">
  <iframe
    src="https://www.youtube-nocookie.com/embed/D_Ezeb4-U08"
    frameBorder="1"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>


# Integrate Unity Gaming Services (UGS) in Unity
Learn how you can create your game in Unity Gaming Services with a blockchain integration with Openfort.

## Overview
This is a sample project to showcase the Openfort integration with [Unity Gaming Services](https://unity.com/solutions/gaming-services), a complete service ecosystem for Unity live games.

The sample includes:
  - [**`ugs-backend`**](https://github.com/openfort-xyz/ugs-unity-game-services-sample/tree/main/ugs-backend)
    
    A .NET Core project with [Cloud Code C# modules](https://docs.unity.com/ugs/en-us/manual/cloud-code/manual/modules#Cloud_Code_C#_modules) that implement [Openfort C# SDK](https://www.nuget.org/packages/Openfort.SDK/1.0.21) methods. Hosted in UGS.

  - [**`unity-client`**](https://github.com/openfort-xyz/ugs-unity-game-services-sample/tree/main/unity-client)

    A Unity sample game that connects to ``ugs-backend`` through [Cloud Code](https://docs.unity.com/ugs/manual/cloud-code/manual). It uses [Openfort Unity SDK](https://github.com/openfort-xyz/openfort-csharp-unity) to deserialize its responses.  

The sample uses [Unity Authentication](https://docs.unity.com/ugs/en-us/manual/authentication/manual/get-started) to sign in as a new anonymous player. It then [creates an Openfort player](https://github.com/openfort-xyz/ugs-unity-game-services-sample/blob/ab1a5f69346910c18ea88579f6fce81cdcde489a/ugs-backend/CloudCodeModules/PlayersModule.cs#L31) and a [custodial account](https://github.com/openfort-xyz/ugs-unity-game-services-sample/blob/ab1a5f69346910c18ea88579f6fce81cdcde489a/ugs-backend/CloudCodeModules/PlayersModule.cs#L38) using Openfort and it [links it](https://github.com/openfort-xyz/ugs-unity-game-services-sample/blob/ab1a5f69346910c18ea88579f6fce81cdcde489a/ugs-backend/CloudCodeModules/PlayersModule.cs#L43) to the Unity player. Then the player can frictionlessly [mint an NFT](https://github.com/openfort-xyz/ugs-unity-game-services-sample/blob/ab1a5f69346910c18ea88579f6fce81cdcde489a/ugs-backend/CloudCodeModules/MintingModule.cs#L26).

## Application Workflow

<div align="center">
  <img
    alt="Integration workflow"
    src="https://blog-cms.openfort.xyz/uploads/ugs_integration_workflow_c592a871cf.png"
    width="100%"
    height="100%"
  />
</div>

## Prerequisites
+ **Get started with Openfort**
  + [Sign in](https://dashboard.openfort.xyz/login) or [sign up](https://dashboard.openfort.xyz/register) and create a new dashboard project

+ **Get started with UGS**
  + [Complete basic prerequisites](https://docs.unity.com/ugs/manual/overview/manual/getting-started#Prerequisites)
  + [Create a project](https://docs.unity.com/ugs/manual/overview/manual/getting-started#CreateProject)

## Setup Openfort dashboard
  + [Add a Contract](https://dashboard.openfort.xyz/contracts/new)
    
    This sample requires a contract to run. We use [0xbed6a05ce8719bc00db1cc81a814192c82be1bb1](https://mumbai.polygonscan.com/address/0xbed6a05ce8719bc00db1cc81a814192c82be1bb1) (NFT contract deployed in 80002 Amoy). You can use this for the guide:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_4_9397f3633b.png?updated_at=2023-12-14T15:59:33.808Z"
      alt='Contract Info'
    />
    </div>

  + [Add a Policy](https://dashboard.openfort.xyz/policies/new)
    
    We aim to cover gas fees for users. Set a new gas policy:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_5_ab3d8ad48d.png?updated_at=2023-12-14T15:59:33.985Z"
      alt='Gas Policy'
    />
    </div>

    Now, add a rule so our contract uses this policy:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_6_6727e69146.png?updated_at=2023-12-14T15:59:33.683Z"
      alt='Policy Rule'
    />
    </div>

## Set up [`ugs-backend`](https://github.com/openfort-xyz/ugs-unity-game-services-sample/tree/main/ugs-backend)

- ### Set Openfort dashboard variables

  Open the [solution](https://github.com/openfort-xyz/ugs-unity-game-services-sample/blob/main/ugs-backend/CloudCodeModules.sln) with your preferred IDE, open [``SingletonModule.cs``](https://github.com/openfort-xyz/ugs-unity-game-services-sample/blob/main/ugs-backend/CloudCodeModules/CloudCodeModules.csproj) and fill in these variables:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_1_6001ca1099.png?updated_at=2023-12-13T17:45:19.990Z"
      alt='Singleton Module'
    />
    </div>

  - [Retrieve the **Secret key**](https://dashboard.openfort.xyz/developers/api-keys)
  - [Retrieve the **Contract API ID**](https://dashboard.openfort.xyz/contracts)
  - [Retrieve the **Policy API ID**](https://dashboard.openfort.xyz/policies)

- ### Package Code
  Follow [the official documentation steps](https://docs.unity.com/ugs/en-us/manual/cloud-code/manual/modules/getting-started#Package_code).
- ### Deploy to UGS
  Follow [the official documentation steps](https://docs.unity.com/ugs/en-us/manual/cloud-code/manual/modules/getting-started#Deploy_a_module_project).

## Set up [``unity-client``](https://github.com/openfort-xyz/ugs-unity-game-services-sample/tree/main/unity-client)

Follow the [official documentation steps](https://docs.unity.com/ugs/manual/authentication/manual/get-started#Link_your_project) to link the ``unity-client`` to your UGS Project ID.

## Test in Editor
Play the **Main** scene and click ***Sign in*** button. After some authentication-related logs, this panel should appear:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/playfab_opensea_img_32_35f675ded4.png?updated_at=2023-11-19T11:06:40.788Z"
      alt='Game Scene'
    />
</div>

Select ***Mint***. After a brief period, you should see a representation of your newly minted NFT:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_3_181e80ff26.png?updated_at=2023-12-14T10:02:43.778Z"
      alt='Mint Panel'
    />
</div>

In the [Openfort Players dashboard](https://dashboard.openfort.xyz/players), a new player entry should be visible. On selecting this player:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/playfab_opensea_img_34_706b0d267e.png?updated_at=2023-11-19T11:06:46.177Z"
      alt='Player Entry'
    />
</div>

You'll notice that a `mint` transaction has been successfully processed:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_7_75cf7a4264.png?updated_at=2023-12-14T16:05:01.500Z"
      alt='Mint Transaction'
    />
</div>

Additionally, by choosing your **Amoy Account** and viewing ***NFT Transfers***, the transaction is further confirmed:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_8_6b345bd148.png?updated_at=2023-12-14T16:05:00.991Z"
      alt='Etherscan'
    />
</div>

Keep in mind that the sample is designed so a player can mint only once. By default, UGS Authentication will use the same player per device. If you want to sign in with a new player check the ***Clear Session Token*** in ***AuthController***:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_2_b0fae3ec75.png?updated_at=2023-12-14T09:56:42.591Z"
      alt='Clear Session Token'
    />
</div>

## Conclusion

Upon completing the above steps, your Unity game will be fully integrated with Openfort and UGS. Always remember to test every feature before deploying to guarantee a flawless player experience.

For a deeper understanding of the underlying processes, check out the [tutorial video](https://youtu.be/PHNodBmbEfA). 

## Get support
If you found a bug or want to suggest a new [feature/use case/sample], please [file an issue](https://github.com/openfort-xyz/ugs-unity-game-services-sample/issues).

If you have questions, or comments, or need help with code, we're here to help:
- on Twitter at https://twitter.com/openfortxyz
- on Discord: https://discord.com/invite/t7x7hwkJF4
- by email: support+youtube@openfort.xyz

{/* Finish with a video. This also appears in the Sidebar via the "tocVideo" metadata */}

<div className="video-container">
  <iframe
    src="https://www.youtube-nocookie.com/embed/Anl9X253RC8"
    frameBorder="1"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>


# Game ads in Unity to pay for gas fees
Learn how to use game Ads to pay for gas fees

## Overview

This sample project showcases the Openfort integration with [Unity LevelPlay](https://docs.unity.com/monetization-dashboard/en-us/manual/UnityLevelPlay).

The sample includes:
  - [**`ugs-backend`**](https://github.com/openfort-xyz/iap-unity-sample/tree/main/ugs-backend)
    
    A .NET Core project with [Cloud Code C# modules](https://docs.unity.com/ugs/en-us/manual/cloud-code/manual/modules#Cloud_Code_C#_modules) that implement [Openfort C# SDK](https://www.nuget.org/packages/Openfort.SDK/1.0.21) methods. Needs to be hosted in Unity Gaming Services.

  - [**`unity-client`**](https://github.com/openfort-xyz/iap-unity-sample/tree/main/unity-client)

    A Unity sample game that connects to ``ugs-backend`` through [Cloud Code](https://docs.unity.com/ugs/manual/cloud-code/manual). It uses [Openfort Unity SDK](https://github.com/openfort-xyz/openfort-csharp-unity) to have full compatibility with `ugs-backend` responses.

## Application Workflow

<div align="center">
  <img
    alt="Integration workflow"
    src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample_workflow_7b897e13de.png"
    width="100%"
    height="100%"
  />
</div>

## Prerequisites
+ **Get started with Openfort**
  + [Sign in](https://dashboard.openfort.xyz/login) or [sign up](https://dashboard.openfort.xyz/register) and create a new dashboard project

+ **Get started with UGS**
  + [Complete basic prerequisites](https://docs.unity.com/ugs/manual/overview/manual/getting-started#Prerequisites)

+ **Get started with ironSource**:
  + [Sign up](https://developers.is.com/ironsource-mobile/air/sign-up-ironsource/) on the ironSource website

## Set up Openfort dashboard
  
  + [Add an NFT contract](https://dashboard.openfort.xyz/contracts/new)
    
    This sample requires an NFT contract to run. We use [0xbed6a05ce8719bc00db1cc81a814192c82be1bb1](https://mumbai.polygonscan.com/address/0xbed6a05ce8719bc00db1cc81a814192c82be1bb1) (contract deployed in 80002 Amoy). You can use it for this tutorial too:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_4_9397f3633b.png?updated_at=2023-12-14T15:59:33.808Z"
      alt='Contract Info'
    />
    </div>
  
  + [Add an ERC20 contract](https://dashboard.openfort.xyz/contracts/new)
    
    This sample also requires an ERC20 contract to run. You can [deploy a standard one](https://thirdweb.com/thirdweb.eth/TokenERC20) and then add it to the Openfort dashboard following the same logic as above.

  + [Add a Full Sponsor Policy](https://dashboard.openfort.xyz/policies/new)
    
    We aim to cover gas fees for our players when they mint the NFT (if they have watched the ad video). Set a new gas policy for that:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_5_ab3d8ad48d.png?updated_at=2023-12-14T15:59:33.985Z"
      alt='Gas Policy'
    />
    </div>

    Add a rule so the NFT contract uses this policy:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_6_6727e69146.png?updated_at=2023-12-14T15:59:33.683Z"
      alt='NFT Policy Rule'
    />
    </div>

    Add also a rule for the ERC20 contract, as we want to send some ERC20 tokens to the player to be able to test the sample:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_22_aec7863428.png?updated_at=2023-12-31T16:02:32.817Z"
      alt='ERC20 Policy Rule'
    />
    </div>

  + [Add a Fixed Charge Policy](https://dashboard.openfort.xyz/policies/new)

    The players will be charged with 1 in-game ERC20 token when they decide not to watch the ad:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample18_2b75d93690.png?updated_at=2024-01-14T18:31:55.626Z"
      alt='Fixed charge policy'
    />
    </div>

    Add a rule so the policy applies to the NFT contract:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_6_6727e69146.png?updated_at=2023-12-14T15:59:33.683Z"
      alt='NFT Policy Rule'
    />
    </div>

  + [Add a Backend wallett](https://dashboard.openfort.xyz/accounts)

    Enter a name and choose ***Add account***:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_23_74b85444b2.png?updated_at=2023-12-31T16:09:09.921Z"
      alt='Developer account'
    />
    </div>

    This will automatically create a custodial wallet that we'll use to send the ERC20 tokens to the players. **IMPORTANT: Transfer a good amount of tokens from the created ERC20 contract to this wallet to facilitate testing**.

## Set up ironSource

- ### Get Unity Cloud keys

  Before going into ironSource, go to the [Unity Cloud dashboard](https://cloud.unity.com/) and open ***Unity Ads Monetization*** using *Shortcuts*:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample19_7bf501e9a9.png?updated_at=2024-01-14T21:56:19.185Z"
      alt='Unity Cloud dashboard: Unity Ads Monetization'
    />
  </div>
  
  - #### Create a LevelPlay Service Account

    Now go to the ***API management*** section and choose ***Create LevelPlay Service Account***:

    <div align="center">
      <img
        width="50%"
        height="50%"
        src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample12_c2ec3e5dd7.png?updated_at=2024-01-08T17:25:19.881Z"
        alt='Unity Cloud dashboard: Create LevelPlay Service Account'
      />
    </div>

    Copy and save the ***Key ID*** and the ***Secret key*** somewhere safe and choose ***Done***:

    <div align="center">
      <img
        width="50%"
        height="50%"
        src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample13_adb919080c.png?updated_at=2024-01-08T17:25:19.985Z"
        alt='Unity Cloud dashboard: Copy LevelPlay Service Account credentials'
      />
    </div>

  - #### Get Monetization Stats API Access

    Copy and save the API Key. Choose ***Create API Key*** if it's not already there:

    <div align="center">
      <img
        width="50%"
        height="50%"
        src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample31_1139cc3e32.png?updated_at=2024-01-14T22:10:25.975Z"
        alt='Unity Cloud dashboard: copy Monetization Stats API key'
      />
    </div>
  
  - #### Get Organization Core ID

    Copy and save the Organization Core ID:

    <div align="center">
      <img
        width="50%"
        height="50%"
        src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample32_07789b5094.png?updated_at=2024-01-14T22:10:08.028Z"
        alt='Unity Cloud dashboard: copy Organization Core ID'
      />
    </div>

- ### Create an ironSource LevelPlay app
  Go to the [ironSource dashboard](https://platform.ironsrc.com/partners/dashboard) and under the *LevelPlay* section, choose ***Add app*** and enter your app details:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample1_a6eae902d4.png?updated_at=2024-01-08T15:23:19.695Z"
      alt='ironSource: new app'
    />
  </div>

  Select the following settings and choose ***Add app***:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample2_07485439ba.png?updated_at=2024-01-08T15:31:25.290Z"
      alt='ironSource: app details'
    />
  </div>

  Activate ***Rewarded Video*** as an ad unit and choose ***Continue***:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample3_2acaeaa57e.png?updated_at=2024-01-08T15:36:02.386Z"
      alt='ironSource: activate ad units'
    />
  </div>

- ### Set up SDK Networks
  In the *Available Networks* panel select ***Unity Ads***:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample4_549e6a7164.png?updated_at=2024-01-08T15:48:55.693Z"
      alt='ironSource: available networks'
    />
  </div>

  Enable the ***Unity bidder auto-setup*** option, add all the credentials from the [*Get Unity Cloud keys* section](https://github.com/openfort-xyz/unity-ad-sample#get-unity-cloud-keys) and choose ***Save***:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample5_41d6ab375c.png?updated_at=2024-01-08T17:32:19.205Z"
      alt='ironSource: adding Unity Ads'
    />
  </div> 

  *Unity Ads* will have appeared as a new available network. Choose ***Setup***:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample14_d57379d965.png?updated_at=2024-01-08T17:49:05.283Z"
      alt='ironSource: setup Unity Ads'
    />
  </div>

  Because we enabled the *Unity bidder auto-setup* option, now you can choose ***Add bidder***:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample15_eecec77e16.png?updated_at=2024-01-08T17:49:05.583Z"
      alt='ironSource: add bidder'
    />
  </div>

  The needed information from Unity will be automatically retrieved. Choose ***Save***:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample16_5141cc4b35.png?updated_at=2024-01-08T17:49:05.590Z"
      alt='ironSource: save app'
    />
  </div>

## Set up Unity Cloud

Thanks to the *Unity bidder auto-setup* option, a new project has been automatically created in the [Unity Cloud dashboard](https://cloud.unity.com/). Now your LevelPlay Service Account needs to have some admin roles over this newly created project. Go to ***Administration --> Service accounts*** and choose your account:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample20_9dea7b262c.png?updated_at=2024-01-14T21:56:23.784Z"
      alt='Set up Unity Cloud: service account'
    />
  </div>

Scroll down and choose ***Manage project roles***:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample21_50cb464fa0.png?updated_at=2024-01-14T21:56:23.788Z"
      alt='Set up Unity Cloud: manage project roles'
    />
  </div>

Select your project and choose ***Next***:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample22_980d7e7834.png?updated_at=2024-01-14T21:56:23.877Z"
      alt='Set up Unity Cloud: select project'
    />
  </div>

In the *Admin* dropdown select:

+ ***Player Resource Policy Editor***
+ ***Project Resource Policy Editor***
+ ***Unity Environments Admin***

In the *LiveOps* dropdown select:

+ ***Cloud Code Script Publisher***
+ ***Triggers Configuration Editor***
+ ***Leaderboards Admin***
+ ***Cloud Code Editor***

Choose ***Save***:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample23_b8f548f685.png?updated_at=2024-01-14T21:56:23.983Z"
      alt='Set up Unity Cloud dashboard: add roles'
    />
  </div>

## Set up [`ugs-backend`](https://github.com/openfort-xyz/iap-unity-sample/tree/main/ugs-backend)

- ### Set Openfort dashboard variables

  Open the [solution](https://github.com/openfort-xyz/iap-unity-sample/blob/main/ugs-backend/CloudCodeModules.sln) with your preferred IDE, open [``SingletonModule.cs``](https://github.com/openfort-xyz/iap-unity-sample/blob/main/ugs-backend/CloudCodeModules/SingletonModule.cs) and fill in these variables:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample24_bbba67daca.png?updated_at=2024-01-14T21:56:19.781Z"
      alt='Singleton Module'
    />
    </div>

  - `OfApiKey`: [Retrieve the **Openfort secret key**](https://dashboard.openfort.xyz/developers/api-keys)
  - `OfNftContract`: [Retrieve the **NFT contract API ID**](https://dashboard.openfort.xyz/contracts)
  - `OfGoldContract`: [Retrieve the **ERC20 contract API ID**](https://dashboard.openfort.xyz/contracts)
  - `OfFullSponsorPolicy`: [Retrieve the **Full Sponsor Policy API ID**](https://dashboard.openfort.xyz/policies)
  - `OfChargeErc20Policy`: [Retrieve the **Fixed Charge Policy API ID**](https://dashboard.openfort.xyz/policies)
  - `OfDevAccount`: [Retrieve the **Developer Account API ID**](https://dashboard.openfort.xyz/accounts)

- ### Package Code
  Follow [the official documentation steps](https://docs.unity.com/ugs/en-us/manual/cloud-code/manual/modules/getting-started#Package_code).
- ### Deploy to UGS
  Follow [the official documentation steps](https://docs.unity.com/ugs/en-us/manual/cloud-code/manual/modules/getting-started#Deploy_a_module_project).

## Set up [``unity-client``](https://github.com/openfort-xyz/iap-unity-sample/tree/main/unity-client)

In Unity go to *Edit --> Project Settings --> Services* and link the ``unity-client`` to your UGS Project:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample25_61a831c3fe.png?updated_at=2024-01-14T21:56:23.781Z"
      alt='Services settings'
    />
</div>

Select your *Environment*:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample26_230b3e9819.png?updated_at=2024-01-14T21:56:22.480Z"
      alt='UGS environment'
    />
</div>

Under *Assets --> Scripts --> Controllers* open the ***AdsController.cs***:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample27_45abf61c4b.png?updated_at=2024-01-14T21:56:14.982Z"
      alt='AdsController.cs'
    />
</div>

Fill the **``appKey``** variable with the *ironSource LevelPlay app key* and save the script:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample29_731247fac0.png?updated_at=2024-01-14T21:56:24.804Z"
      alt='ironSource LevelPlay app key'
    />
</div>

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample28_0ead9e68e7.png?updated_at=2024-01-14T21:56:19.186Z"
      alt='ironSource LevelPlay app key'
    />
</div>

## Build to Android

In Unity go to [*Android Player settings*](https://docs.unity3d.com/Manual/class-PlayerSettingsAndroid.html) and make sure *Other Settings* looks like this:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_7_e6ec7eb903.png?updated_at=2023-12-28T07:47:59.386Z"
      alt='Android Player settings'
    />
</div>

Also, make sure to sign the application with a [Keystore](https://docs.unity3d.com/Manual/android-keystore-create.html) in *Publishing Settings*:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_8_ecae38df0e.png?updated_at=2023-12-28T07:47:59.307Z"
      alt='Application Signing'
    />
</div>

Return to *Build Settings* and choose ***Build***:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_ads_sample30_2b8dbf10b8.png?updated_at=2024-01-14T22:13:25.912Z"
      alt='Build'
    />
</div>

Send and run the *.apk* on your device. 

## Conclusion

Upon completing the above steps, your Unity game will be fully integrated with Openfort and [Unity LevelPlay](https://docs.unity.com/monetization-dashboard/en-us/manual/UnityLevelPlay). Always remember to test every feature before deploying to guarantee a flawless player experience.

For a deeper understanding of the underlying processes, check out the [tutorial video](https://www.youtube.com/watch?v=vjjvDILS-DU). 

## Get support
If you found a bug or want to suggest a new [feature/use case/sample], please [file an issue](https://github.com/openfort-xyz/iap-unity-sample/issues).

If you have questions, or comments, or need help with code, we're here to help:
- on Twitter at https://twitter.com/openfortxyz
- on Discord: https://discord.com/invite/t7x7hwkJF4
- by email: support+youtube@openfort.xyz

{/* Finish with a video. This also appears in the Sidebar via the "tocVideo" metadata */}

<div className="video-container">
  <iframe
    src="https://www.youtube-nocookie.com/embed/vjjvDILS-DU"
    frameBorder="1"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>


# Integrate Android In-App Purchases (IAP) in Unity
Learn how you can integrate IAP in your game in Unity and UGS.

## Overview

This sample project showcases the Openfort integration with Android [In-App Purchasing](https://docs.unity3d.com/Packages/com.unity.purchasing@4.10/manual/Overview.html) in Unity.

The sample includes:
  - [**`ugs-backend`**](https://github.com/openfort-xyz/iap-unity-sample/tree/main/ugs-backend)
    
    A .NET Core project with [Cloud Code C# modules](https://docs.unity.com/ugs/en-us/manual/cloud-code/manual/modules#Cloud_Code_C#_modules) that implement [Openfort C# SDK](https://www.nuget.org/packages/Openfort.SDK/1.0.21) methods. Needs to be hosted in Unity Gaming Services.

  - [**`unity-client`**](https://github.com/openfort-xyz/iap-unity-sample/tree/main/unity-client)

    A Unity sample game that connects to ``ugs-backend`` through [Cloud Code](https://docs.unity.com/ugs/manual/cloud-code/manual). It uses [Openfort Unity SDK](https://github.com/openfort-xyz/openfort-csharp-unity) to have full compatibility with `ugs-backend` responses.

## Application Workflow

<div align="center">
  <img
    alt="Integration workflow"
    src="https://blog-cms.openfort.xyz/uploads/unity_iap_sample_workflow_7f84b68e28.png"
    width="100%"
    height="100%"
  />
</div>

## Workflow

1. [Sign in as a new anonymous player](https://github.com/openfort-xyz/iap-unity-sample/blob/main/unity-client/Assets/Scripts/Controllers/AuthController.cs#L44)
2. [Create an Openfort player](https://github.com/openfort-xyz/iap-unity-sample/blob/main/ugs-backend/CloudCodeModules/PlayersModule.cs#L59) and a [custodial account](https://github.com/openfort-xyz/iap-unity-sample/blob/main/ugs-backend/CloudCodeModules/PlayersModule.cs#L66)
3. [Save the Openfort player's information](https://github.com/openfort-xyz/iap-unity-sample/blob/main/ugs-backend/CloudCodeModules/PlayersModule.cs#L72) to the Unity player's dashboard
4. [Initialize Unity In-App Purchasing service](https://github.com/openfort-xyz/iap-unity-sample/blob/main/unity-client/Assets/Scripts/Controllers/ShopController.cs#L44)
5. Now the player can [purchase a consumable or a non-consumable in-app product](https://github.com/openfort-xyz/iap-unity-sample/blob/main/unity-client/Assets/Scripts/Controllers/ShopController.cs#L74)
6. [If the consumable purchase is successful](https://github.com/openfort-xyz/iap-unity-sample/blob/main/unity-client/Assets/Scripts/Controllers/ShopController.cs#L124), some [ERC20 tokens will be transferred](https://github.com/openfort-xyz/iap-unity-sample/blob/main/ugs-backend/CloudCodeModules/TransferModule.cs#L31) to its account
7. [If the non-consumable purchase is successful](https://github.com/openfort-xyz/iap-unity-sample/blob/main/unity-client/Assets/Scripts/Controllers/ShopController.cs#L127), the player will [mint an NFT](https://github.com/openfort-xyz/iap-unity-sample/blob/main/ugs-backend/CloudCodeModules/MintingModule.cs#L25)
8. The player can also [retrieve their ERC20 token balance](https://github.com/openfort-xyz/iap-unity-sample/blob/main/unity-client/Assets/Scripts/Controllers/InventoryController.cs#L56) and [NFT inventory](https://github.com/openfort-xyz/iap-unity-sample/blob/main/unity-client/Assets/Scripts/Controllers/InventoryController.cs#L24)

## Prerequisites
+ **Get started with Openfort**
  + [Sign in](https://dashboard.openfort.xyz/login) or [sign up](https://dashboard.openfort.xyz/register) and create a new dashboard project

+ **Get started with UGS**
  + [Complete basic prerequisites](https://docs.unity.com/ugs/manual/overview/manual/getting-started#Prerequisites)
  + [Create a project](https://docs.unity.com/ugs/manual/overview/manual/getting-started#CreateProject)

+ **Get started with Google Play Console**
  + [Create and set up your app](https://support.google.com/googleplay/android-developer/answer/9859152?hl=en)

## Setup Openfort dashboard
  
  + [Add an NFT contract](https://dashboard.openfort.xyz/contracts/new)
    
    This sample requires an NFT contract to run. We use [0xbed6a05ce8719bc00db1cc81a814192c82be1bb1](https://mumbai.polygonscan.com/address/0xbed6a05ce8719bc00db1cc81a814192c82be1bb1) (contract deployed in 80002 Amoy). You can use it for this tutorial too:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_4_9397f3633b.png?updated_at=2023-12-14T15:59:33.808Z"
      alt='Contract Info'
    />
    </div>
  
  + [Add an ERC20 contract](https://dashboard.openfort.xyz/contracts/new)
    
    This sample also requires an ERC20 contract to run. You can [deploy a standard one](https://thirdweb.com/thirdweb.eth/TokenERC20) and then add it to the Openfort dashboard following the same logic as above.

  + [Add a Policy](https://dashboard.openfort.xyz/policies/new)
    
    We aim to cover gas fees for our users when they mint the NFT. Set a new gas policy for that:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_5_ab3d8ad48d.png?updated_at=2023-12-14T15:59:33.985Z"
      alt='Gas Policy'
    />
    </div>

    Add a rule so the NFT contract uses this policy:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_6_6727e69146.png?updated_at=2023-12-14T15:59:33.683Z"
      alt='NFT Policy Rule'
    />
    </div>

    Add also a rule for the ERC20 contract:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_22_aec7863428.png?updated_at=2023-12-31T16:02:32.817Z"
      alt='ERC20 Policy Rule'
    />
    </div>

  + [Add a Backend wallet](https://dashboard.openfort.xyz/accounts)

    Enter a name and choose ***Add account***:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_23_74b85444b2.png?updated_at=2023-12-31T16:09:09.921Z"
      alt='Developer account'
    />
    </div>

    This will automatically create a custodial wallet that we'll use to send the ERC20 tokens to the players. **IMPORTANT: Transfer a good amount of tokens from the created ERC20 contract to this wallet to facilitate testing**.

## Set up [`ugs-backend`](https://github.com/openfort-xyz/iap-unity-sample/tree/main/ugs-backend)

- ### Set Openfort dashboard variables

  Open the [solution](https://github.com/openfort-xyz/iap-unity-sample/blob/main/ugs-backend/CloudCodeModules.sln) with your preferred IDE, open [``SingletonModule.cs``](https://github.com/openfort-xyz/iap-unity-sample/blob/main/ugs-backend/CloudCodeModules/SingletonModule.cs) and fill in these variables:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_2_b14ed6e743.png?updated_at=2023-12-31T16:17:12.709Z"
      alt='Singleton Module'
    />
    </div>

  - `OfApiKey`: [Retrieve the **Openfort secret key**](https://dashboard.openfort.xyz/developers/api-keys)
  - `OfNftContract`: [Retrieve the **NFT contract API ID**](https://dashboard.openfort.xyz/contracts)
  - `OfGoldContract`: [Retrieve the **ERC20 contract API ID**](https://dashboard.openfort.xyz/contracts)
  - `OfSponsorPolicy`: [Retrieve the **Policy API ID**](https://dashboard.openfort.xyz/policies)
  - `OfDevAccount`: [Retrieve the **backend wallet API ID**](https://dashboard.openfort.xyz/accounts)

- ### Package Code
  Follow [the official documentation steps](https://docs.unity.com/ugs/en-us/manual/cloud-code/manual/modules/getting-started#Package_code).
- ### Deploy to UGS
  Follow [the official documentation steps](https://docs.unity.com/ugs/en-us/manual/cloud-code/manual/modules/getting-started#Deploy_a_module_project).

## Set up [``unity-client``](https://github.com/openfort-xyz/iap-unity-sample/tree/main/unity-client)

In Unity go to *Edit --> Project Settings --> Services* and link the ``unity-client`` to your UGS Project:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_16_c1ac7c4b45.png?updated_at=2023-12-28T15:52:03.478Z"
      alt='Services settings'
    />
</div>

Select your *Environment*:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_17_e60d56f379.png?updated_at=2023-12-28T15:52:03.577Z"
      alt='UGS environment'
    />
</div>

Now make sure *In-App Purchasing* is enabled and *Current Targeted Store* is set to ***Google Play***. Then follow the instructions to set the **Google Play License Key** to your UGS project:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_18_3c78605c09.png?updated_at=2023-12-28T15:52:03.586Z"
      alt='Google Play License Key'
    />
</div>

Your UGS project dashboard should look like this:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_19_6802cc268e.png?updated_at=2023-12-28T15:52:04.490Z"
      alt='License key in UGS dashboard'
    />
</div>

## Test in Editor

Play the **Main** scene and you should see the sign-in panel:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_20_8940611454.png?updated_at=2024-01-02T12:23:00.990Z"
      alt='Sign in panel'
    />
</div>

Choose ***Sign in***. The first time it will create a new player but the next time it will sign in as the same player. After some authentication-related logs, this panel should appear:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_3_478298f237.png?updated_at=2023-12-27T11:22:46.793Z"
      alt='Game Scene'
    />
</div>

Here you have two options:
+ Purchase ERC20 tokens (x10)
+ Purchase NFT

By clicking any of them, a *Fake Store* panel will pop up, letting you confirm or cancel the purchase:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_4_a04e9420ed.png?updated_at=2023-12-27T15:44:43.689Z"
      alt='Game Scene'
    />
</div>

If you confirm, after a brief period you should see the *Transaction successful* message:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_5_ac991ecb2a.png?updated_at=2023-12-27T15:48:49.186Z"
      alt='Game Scene'
    />
</div>

You can then click on the inventory icon to see the representation of your on-chain assets:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_6_fd93f3f3a2.png?updated_at=2023-12-27T15:51:49.900Z"
      alt='Game Scene'
    />
</div>

In the [Openfort Players dashboard](https://dashboard.openfort.xyz/players), a new player entry should be visible. On selecting this player:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/playfab_opensea_img_34_706b0d267e.png?updated_at=2023-11-19T11:06:46.177Z"
      alt='Player Entry'
    />
</div>

You'll notice that a `mint` transaction has been successfully processed:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_7_75cf7a4264.png?updated_at=2023-12-14T16:05:01.500Z"
      alt='Mint Transaction'
    />
</div>

Additionally, by choosing your **Amoy Account** and viewing ***NFT Transfers***, the transaction is further confirmed:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_8_6b345bd148.png?updated_at=2023-12-14T16:05:00.991Z"
      alt='Etherscan'
    />
</div>

## Build App Bundle

In Unity go to [*Android Player settings*](https://docs.unity3d.com/Manual/class-PlayerSettingsAndroid.html) and make sure *Other Settings* looks like this:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_7_e6ec7eb903.png?updated_at=2023-12-28T07:47:59.386Z"
      alt='Android Player settings'
    />
</div>

Also, make sure to sign the application with a [Keystore](https://docs.unity3d.com/Manual/android-keystore-create.html) in *Publishing Settings*:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_8_ecae38df0e.png?updated_at=2023-12-28T07:47:59.307Z"
      alt='Application Signing'
    />
</div>

Then go to *Build Settings*, check ***Build App Bundle (Google Play)*** and choose ***Build***:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_9_6d1e1a5636.png?updated_at=2023-12-28T07:52:15.586Z"
      alt='Build'
    />
</div>

## Set up Google Play Console

- ### Create internal release

  On your [Google Play Console](https://play.google.com/console/u/0/developers/7556582789169418933?onboardingflow=signup) app, go to *Release --> Testing --> Internal testing --> Testers* and select or create an email list with the emails that will test your app. Then choose ***Create new release***:

  <div align="center">
      <img
        width="50%"
        height="50%"
        src="https://blog-cms.openfort.xyz/uploads/iap_sample_10_f700f82ef1.png?updated_at=2023-12-28T15:07:32.491Z"
        alt='New release'
      />
  </div>

  Upload the `.aab` file and then choose ***Next***:

  <div align="center">
      <img
        width="50%"
        height="50%"
        src="https://blog-cms.openfort.xyz/uploads/iap_sample_11_06459575df.png?updated_at=2023-12-28T15:07:33.382Z"
        alt='Upload build'
      />
  </div>

  If needed, solve pending errors and warnings and then choose ***Save and publish***:

  <div align="center">
      <img
        width="50%"
        height="50%"
        src="https://blog-cms.openfort.xyz/uploads/iap_sample_12_da52624cb6.png?updated_at=2023-12-28T15:07:32.481Z"
        alt='Save and publish'
      />
  </div>
  
- ### Import IAP catalog

  On your [Google Play Console](https://play.google.com/console/u/0/developers/7556582789169418933?onboardingflow=signup) app, go to *Monetize --> Products --> In-app products* and choose ***Import***:

  <div align="center">
      <img
        width="50%"
        height="50%"
        src="https://blog-cms.openfort.xyz/uploads/iap_sample_13_04a57f78c6.png?updated_at=2023-12-28T15:07:32.484Z"
        alt='Create product'
      />
  </div>

  Upload the [``GooglePlayProductCatalog.csv``](https://github.com/openfort-xyz/iap-unity-sample/blob/main/unity-client/Assets/GooglePlayProductCatalog.csv) file (which contains all the in-app products) and choose ***Import***:

  <div align="center">
        <img
          width="50%"
          height="50%"
          src="https://blog-cms.openfort.xyz/uploads/iap_sample_14_9a114af583.png?updated_at=2023-12-28T15:07:32.397Z"
          alt='Import products'
        />
  </div>

  You should see all the products have been created:

  <div align="center">
        <img
          width="50%"
          height="50%"
          src="https://blog-cms.openfort.xyz/uploads/iap_sample_15_45877d642d.png?updated_at=2023-12-28T15:07:32.278Z"
          alt='Products created'
        />
  </div>

## Test in Android

Once the internal testing release is published, you have two options to test:

- Build and run the .apk directly to your device ([if the *version number* is the same as in the internal release](https://docs.unity3d.com/Packages/com.unity.purchasing@4.10/manual/Testing.html)).
- Download the app from Google Play through the internal testing link:

<div align="center">
      <img
        width="50%"
        height="50%"
        src="https://blog-cms.openfort.xyz/uploads/iap_sample_21_f41d2c851f.png?updated_at=2023-12-28T16:06:28.194Z"
        alt='Internal testing link'
      />
  </div>

## Conclusion

Upon completing the above steps, your Unity game will be fully integrated with Openfort and Unity In-App Purchasing service. Always remember to test every feature before deploying to guarantee a flawless player experience.

For a deeper understanding of the underlying processes, check out the [tutorial video](https://youtu.be/8Pw4VUyWVY8). 

## Get support
If you found a bug or want to suggest a new [feature/use case/sample], please [file an issue](https://github.com/openfort-xyz/iap-unity-sample/issues).

If you have questions, or comments, or need help with code, we're here to help:
- on Twitter at https://twitter.com/openfortxyz
- on Discord: https://discord.com/invite/t7x7hwkJF4
- by email: support+youtube@openfort.xyz

{/* Finish with a video. This also appears in the Sidebar via the "tocVideo" metadata */}

<div className="video-container">
  <iframe
    src="https://www.youtube-nocookie.com/embed/8Pw4VUyWVY8"
    frameBorder="1"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>


# In-App (IAP) Purchases in Unity
Learn how you can integrate IAP in your game in Unity and UGS.

## Overview

*Disclaimer: Openfort is not responible of such integration to be approved by Apple and/or Google*

This sample project showcases the Openfort advanced & compliant integration with [In-App Purchasing](https://docs.unity3d.com/Packages/com.unity.purchasing@4.10/manual/Overview.html) in Unity. The objective of this integration sample is to implement and showcase a **crypto In-App Purchasing system** compliant with the [rules/guidelines]() companies like Apple have set for this type of purchases in mobile apps.

## Specifications

The sample includes:
  - [**`ugs-backend`**](https://github.com/openfort-xyz/iap-unity-sample/tree/main/ugs-backend)
    
    A .NET Core project with [Cloud Code C# modules](https://docs.unity.com/ugs/en-us/manual/cloud-code/manual/modules#Cloud_Code_C#_modules) that implement [Openfort C# SDK](https://www.nuget.org/packages/Openfort.SDK/1.0.21) methods. Needs to be hosted in Unity Gaming Services.

  - [**`unity-client`**](https://github.com/openfort-xyz/iap-unity-sample/tree/main/unity-client)

    A Unity sample game that connects to ``ugs-backend`` through [Cloud Code](https://docs.unity.com/ugs/manual/cloud-code/manual). It uses [Openfort Unity SDK](https://github.com/openfort-xyz/openfort-csharp-unity) to have full compatibility with `ugs-backend` responses.

## Application Workflow

<div align="center">
    <img
      width="100%"
      height="100%"
      src="https://blog-cms.openfort.xyz/uploads/unity_iap_advanced_sample_workflow_d04f0d70f6.png?updated_at=2024-02-14T17:24:18.292Z"
      alt='Openfort In-App Purchase Advanced Sample workflow'
    />
</div>

## Prerequisites
+ **Get started with Openfort**
  + [Sign in](https://dashboard.openfort.xyz/login) or [sign up](https://dashboard.openfort.xyz/register) and create a new dashboard project

+ **Get started with UGS**
  + [Complete basic prerequisites](https://docs.unity.com/ugs/manual/overview/manual/getting-started#Prerequisites)
  + [Create a project](https://docs.unity.com/ugs/manual/overview/manual/getting-started#CreateProject)

+ **Get started with Google Play Console**
  + [Create and set up your app](https://support.google.com/googleplay/android-developer/answer/9859152?hl=en)

+ **Get started with Apple Developer Account**
  + [Set up everything needed for Apple development](https://developer.apple.com/help/account/)
  + Make sure to [sign the Paid Apps agreement](https://developer.apple.com/help/app-store-connect/manage-agreements/sign-and-update-agreements) and fill tax and banking details as it's needed for testing IAP.

## Setup Openfort dashboard
  
  + [Add an NFT contract](https://dashboard.openfort.xyz/contracts/new)
    
    This sample requires an NFT contract to run. We use [0xbed6a05ce8719bc00db1cc81a814192c82be1bb1](https://mumbai.polygonscan.com/address/0xbed6a05ce8719bc00db1cc81a814192c82be1bb1) (contract deployed in 80002 Amoy). You can use it for this tutorial too:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_4_9397f3633b.png?updated_at=2023-12-14T15:59:33.808Z"
      alt='Contract Info'
    />
    </div>
  
  + [Add an ERC20 contract](https://dashboard.openfort.xyz/contracts/new)
    
    This sample also requires an ERC20 contract to run. You can [deploy a standard one](https://thirdweb.com/thirdweb.eth/TokenERC20) and then add it to the Openfort dashboard following the same logic as above.

  + [Add a Policy](https://dashboard.openfort.xyz/policies/new)
    
    We aim to cover gas fees for our users when they mint the NFT. Set a new gas policy for that:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_5_ab3d8ad48d.png?updated_at=2023-12-14T15:59:33.985Z"
      alt='Gas Policy'
    />
    </div>

    Add a rule so the NFT contract uses this policy:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_6_6727e69146.png?updated_at=2023-12-14T15:59:33.683Z"
      alt='NFT Policy Rule'
    />
    </div>

    Add also a rule for the ERC20 contract:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_22_aec7863428.png?updated_at=2023-12-31T16:02:32.817Z"
      alt='ERC20 Policy Rule'
    />
    </div>

  + [Create two backend wallets](https://dashboard.openfort.xyz/accounts)

      <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_23_74b85444b2.png?updated_at=2023-12-31T16:09:09.921Z"
      alt='Backend wallet'
    />
    </div>

    1. Enter a name (treasure account) and click ***Add account***. This will automatically create a custodial wallet that we'll use to transfer the ERC20 tokens to the players. **IMPORTANT: Transfer a good amount of tokens from the created ERC20 contract to this wallet to facilitate testing**.
    2. Enter a name (minting account) and click ***Add account***. This will automatically create a custodial wallet that the players will transfer the NFTs to when they choose the sell them. They'll get rewarded from the Treasury Dev Account afterwards.

## Set up [`ugs-backend`](https://github.com/openfort-xyz/iap-unity-sample/tree/main/ugs-backend)

- ### Set Openfort dashboard variables

  Open the [solution](https://github.com/openfort-xyz/iap-unity-sample/blob/main/ugs-backend/CloudCodeModules.sln) with your preferred IDE, open [``SingletonModule.cs``](https://github.com/openfort-xyz/iap-unity-sample/blob/main/ugs-backend/CloudCodeModules/SingletonModule.cs) and fill in these variables:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_iap_advanced_sample1_9ab5bedd91.png?updated_at=2024-02-13T23:41:17.097Z"
      alt='Singleton Module'
    />
    </div>

  - `OfApiKey`: [Retrieve the **Openfort secret key**](https://dashboard.openfort.xyz/developers/api-keys)
  - `OfNftContract`: [Retrieve the **NFT contract API ID**](https://dashboard.openfort.xyz/contracts)
  - `OfGoldContract`: [Retrieve the **ERC20 contract API ID**](https://dashboard.openfort.xyz/contracts)
  - `OfSponsorPolicy`: [Retrieve the **Policy API ID**](https://dashboard.openfort.xyz/policies)
  - `OfDevTreasuryAccount`: [Retrieve the **Treasury Developer Account API ID**](https://dashboard.openfort.xyz/accounts)
  - `OfDevMintingAccount`: [Retrieve the **Minting Developer Account API ID**](https://dashboard.openfort.xyz/accounts)

- ### Package Code
  Follow [the official documentation steps](https://docs.unity.com/ugs/en-us/manual/cloud-code/manual/modules/getting-started#Package_code).

- ### Deploy to UGS
  Follow [the official documentation steps](https://docs.unity.com/ugs/en-us/manual/cloud-code/manual/modules/getting-started#Deploy_a_module_project).

- ### Add a currency to UGS project
  Follow [the official documentation steps](https://docs.unity.com/ugs/en-us/manual/economy/manual/add-currency) to add a currency to your game:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_iap_advanced_sample2_7de4fc0554.png?updated_at=2024-02-13T23:51:37.496Z"
      alt='UGS currency'
    />
    </div>

## Set up [``unity-client``](https://github.com/openfort-xyz/iap-unity-sample/tree/main/unity-client)

In Unity go to *Edit --> Project Settings --> Services* and link the ``unity-client`` to your UGS Project:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_16_c1ac7c4b45.png?updated_at=2023-12-28T15:52:03.478Z"
      alt='Services settings'
    />
</div>

Select your *Environment*:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_17_e60d56f379.png?updated_at=2023-12-28T15:52:03.577Z"
      alt='UGS environment'
    />
</div>

Now make sure *In-App Purchasing* is enabled and *Current Targeted Store* is set to ***Google Play***. Then follow the instructions to set the **Google Play License Key** to your UGS project:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_18_3c78605c09.png?updated_at=2023-12-28T15:52:03.586Z"
      alt='Google Play License Key'
    />
</div>

Your UGS project dashboard should look like this:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/iap_sample_19_6802cc268e.png?updated_at=2023-12-28T15:52:04.490Z"
      alt='License key in UGS dashboard'
    />
</div>

**Apple AppStore** doesn't need this *license key configuration* so if you're targeting **iOS** you're good to go. 

## Android deployment

  + ### Build App Bundle

    In Unity go to [*Android Player settings*](https://docs.unity3d.com/Manual/class-PlayerSettingsAndroid.html) and make sure *Other Settings* looks like this:

    <div align="center">
        <img
          width="50%"
          height="50%"
          src="https://blog-cms.openfort.xyz/uploads/iap_sample_7_e6ec7eb903.png?updated_at=2023-12-28T07:47:59.386Z"
          alt='Android Player settings'
        />
    </div>

    Also, make sure to sign the application with a [Keystore](https://docs.unity3d.com/Manual/android-keystore-create.html) in *Publishing Settings*:

    <div align="center">
        <img
          width="50%"
          height="50%"
          src="https://blog-cms.openfort.xyz/uploads/iap_sample_8_ecae38df0e.png?updated_at=2023-12-28T07:47:59.307Z"
          alt='Application Signing'
        />
    </div>

    Then go to *Build Settings*, check ***Build App Bundle (Google Play)*** and choose ***Build***:

    <div align="center">
        <img
          width="50%"
          height="50%"
          src="https://blog-cms.openfort.xyz/uploads/iap_sample_9_6d1e1a5636.png?updated_at=2023-12-28T07:52:15.586Z"
          alt='Build'
        />
    </div>

  + ### Set up Google Play Console

    - #### Create internal release

      On your [Google Play Console](https://play.google.com/console/u/0/developers/7556582789169418933?onboardingflow=signup) app, go to *Release --> Testing --> Internal testing --> Testers* and select or create an email list with the emails that will test your app. Then choose ***Create new release***:

      <div align="center">
          <img
            width="50%"
            height="50%"
            src="https://blog-cms.openfort.xyz/uploads/iap_sample_10_f700f82ef1.png?updated_at=2023-12-28T15:07:32.491Z"
            alt='New release'
          />
      </div>

      Upload the `.aab` file and then choose ***Next***:

      <div align="center">
          <img
            width="50%"
            height="50%"
            src="https://blog-cms.openfort.xyz/uploads/iap_sample_11_06459575df.png?updated_at=2023-12-28T15:07:33.382Z"
            alt='Upload build'
          />
      </div>

      If needed, solve pending errors and warnings and then choose ***Save and publish***:

      <div align="center">
          <img
            width="50%"
            height="50%"
            src="https://blog-cms.openfort.xyz/uploads/iap_sample_12_da52624cb6.png?updated_at=2023-12-28T15:07:32.481Z"
            alt='Save and publish'
          />
      </div>
    
    - #### Import IAP catalog

      On your [Google Play Console](https://play.google.com/console/u/0/developers/7556582789169418933?onboardingflow=signup) app, go to *Monetize --> Products --> In-app products* and choose ***Import***:

      <div align="center">
          <img
            width="50%"
            height="50%"
            src="https://blog-cms.openfort.xyz/uploads/iap_sample_13_04a57f78c6.png?updated_at=2023-12-28T15:07:32.484Z"
            alt='Create product'
          />
      </div>

      Upload the [``GooglePlayProductCatalog.csv``](https://github.com/openfort-xyz/iap-unity-sample/blob/main/unity-client/Assets/GooglePlayProductCatalog.csv) file (which contains all the in-app products) and choose ***Import***:

      <div align="center">
            <img
              width="50%"
              height="50%"
              src="https://blog-cms.openfort.xyz/uploads/iap_sample_14_9a114af583.png?updated_at=2023-12-28T15:07:32.397Z"
              alt='Import products'
            />
      </div>

      You should see all the products have been created:

      <div align="center">
            <img
              width="50%"
              height="50%"
              src="https://blog-cms.openfort.xyz/uploads/iap_sample_15_45877d642d.png?updated_at=2023-12-28T15:07:32.278Z"
              alt='Products created'
            />
      </div>

  + ### Testing

    Once the internal testing release is published, you have two options to test:

    - Build and run the .apk directly to your device ([if the *version number* is the same as in the internal release](https://docs.unity3d.com/Packages/com.unity.purchasing@4.10/manual/Testing.html)).
    - Download the app from Google Play through the internal testing link:

    <div align="center">
          <img
            width="50%"
            height="50%"
            src="https://blog-cms.openfort.xyz/uploads/iap_sample_21_f41d2c851f.png?updated_at=2023-12-28T16:06:28.194Z"
            alt='Internal testing link'
          />
      </div>

## iOS deployment

  + ### Xcode: Build & Archive & Upload
    In Unity go to *File --> Build Settings* and choose ***Build And Run***:

    <div align="center">
          <img
            width="50%"
            height="50%"
            src="https://blog-cms.openfort.xyz/uploads/unity_iap_advanced_sample3_40c42ce5e4.png?updated_at=2024-02-14T00:26:54.820Z"
            alt='Build to Xcode'
          />
      </div>

    This will automatically open Xcode. If you encounter a `signing error`, select your development team and enable ***Automatically manage signing***:

    <div align="center">
          <img
            width="50%"
            height="50%"
            src="https://blog-cms.openfort.xyz/uploads/unity_iap_advanced_sample4_9e12130585.png?updated_at=2024-02-14T00:34:32.096Z"
            alt='Build to Xcode: error'
          />
      </div>

      Start the building process again **(cmd + B)** and when completed, go to ***Product --> Archive***:

      <div align="center">
          <img
            width="50%"
            height="50%"
            src="https://blog-cms.openfort.xyz/uploads/unity_iap_advanced_sample5_f10cfb74a1.png?updated_at=2024-02-14T00:41:32.549Z"
            alt='Build to Xcode: archive'
          />
      </div>

      After completing, choose ***Distribute App***:

      <div align="center">
          <img
            width="50%"
            height="50%"
            src="https://blog-cms.openfort.xyz/uploads/unity_iap_advanced_sample6_85f8e46b54.png?updated_at=2024-02-14T00:47:23.087Z"
            alt='Build to Xcode: Distribute app'
          />
      </div>

      Select ***TestFlight & App Store*** to enable both internal and external testing and choose ***Distribute***:

      <div align="center">
          <img
            width="50%"
            height="50%"
            src="https://blog-cms.openfort.xyz/uploads/unity_iap_advanced_sample7_7b3068a974.png?updated_at=2024-02-14T01:15:28.984Z"
            alt='Build to Xcode: distribute'
          />
      </div>

      The app will be uploaded to **App Store Connect**:

      <div align="center">
          <img
            width="50%"
            height="50%"
            src="https://blog-cms.openfort.xyz/uploads/unity_iap_advanced_sample8_f5a647899b.png?updated_at=2024-02-14T01:15:28.680Z"
            alt='Build to Xcode: complete'
          />
      </div>

  + ### Set up App Store Connect app
    
    Go to [App Store Connect Apps](https://appstoreconnect.apple.com/apps), choose your newly uploaded app and under **Distribution --> In-App Purchases** add the purchases:

    <div align="center">
        <img
          width="50%"
          height="50%"
          src="https://blog-cms.openfort.xyz/uploads/unity_iap_advanced_sample9_8bfb82b934.png?updated_at=2024-02-14T01:15:30.097Z"
          alt='Build to Xcode: in-app purchases'
        />
    </div>

    Remember to fill the same *Product ID* as you have set in your **Unity IAP Catalog**. Do it for all your products:

    <div align="center">
        <img
          width="50%"
          height="50%"
          src="https://blog-cms.openfort.xyz/uploads/unity_iap_advanced_sample10_bace0d3453.png?updated_at=2024-02-14T01:15:29.278Z"
          alt='Build to Xcode: catalog'
        />
    </div>

    Go to the *TestFlight section* and choose ***Manage Missing Compliance*** for your build:

    <div align="center">
        <img
          width="50%"
          height="50%"
          src="https://blog-cms.openfort.xyz/uploads/unity_iap_advanced_sample11_c1f23d62a9.png?updated_at=2024-02-14T01:15:29.089Z"
          alt='Build to Xcode: catalog'
        />
    </div>
  
  + ### Testing

    Go to *Internal Testers* ([add testers](https://developer.apple.com/help/app-store-connect/test-a-beta-version/add-testers-to-builds/)) and you should see your build ready to be tested:

    <div align="center">
          <img
            width="50%"
            height="50%"
            src="https://blog-cms.openfort.xyz/uploads/unity_iap_advanced_sample12_2db9d9b6f4.png?updated_at=2024-02-14T01:15:29.491Z"
            alt='Build to Xcode: testers'
          />
      </div>

    Open the TestFlight in the iOS device where your tester Apple ID is configured and test the app!

## Conclusion

Upon completing the above steps, your Unity game will be fully integrated with Openfort and Unity In-App Purchasing service. Always remember to test every feature before deploying to guarantee a flawless player experience.

For a deeper understanding of the underlying processes, check out the [tutorial video](https://www.youtube.com/watch?v=37yAu7YQXhg). 

## Get support
If you found a bug or want to suggest a new [feature/use case/sample], please [file an issue](https://github.com/openfort-xyz/samples/issues).

If you have questions, or comments, or need help with code, we're here to help:
- on Twitter at https://twitter.com/openfortxyz
- on Discord: https://discord.com/invite/t7x7hwkJF4
- by email: support+youtube@openfort.xyz

{/* Finish with a video. This also appears in the Sidebar via the "tocVideo" metadata */}

<div className="video-container">
  <iframe
    src="https://www.youtube-nocookie.com/embed/37yAu7YQXhg"
    frameBorder="1"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>


# Add reCAPTCHA in your Unity game
Learn how to use use CAPTCHA to block bot behaviour

## Overview
This is a sample project to showcase the Openfort integration with [Google reCAPTCHA V3](https://developers.google.com/recaptcha/docs/v3), a system to help you protect your sites from fraudulent activities, spam, and abuse. In this sample, we will activate reCAPTCHA verification every time the user tries to perform a key action like authenticating or minting an NFT. 

The sample includes:
  - [**`ugs-backend`**](https://github.com/openfort-xyz/unity-recaptcha-sample/tree/main/ugs-backend)
    
    Some [Cloud Code JS scripts](https://docs.unity.com/ugs/en-us/manual/cloud-code/manual/scripts) to interact with the Openfort API from UGS BaaS.

  - [**`unity-client`**](https://github.com/openfort-xyz/unity-recaptcha-sample/tree/main/unity-client)

    A Unity sample game that connects to ``ugs-backend`` through [Cloud Code Client SDK](https://docs.unity.com/ugs/manual/cloud-code/manual). It uses [Openfort Unity SDK](https://github.com/openfort-xyz/openfort-csharp-unity) to have full compatibility with ``ugs-backend`` responses.

## Workflow diagram

<div align="center">
    <img
      width="100%"
      height="100%"
      src="https://blog-cms.openfort.xyz/uploads/unity_recaptcha_sample_workflow_9d3da01894.png"
      alt='Openfort Unity reCAPTCHA V3 Sample Workflow'
    />
    </div>

## Prerequisites
+ **Get started with Openfort**
  + [Sign in](https://dashboard.openfort.xyz/login) or [sign up](https://dashboard.openfort.xyz/register) and create a new dashboard project

+ **Get started with UGS**
  + [Complete basic prerequisites](https://docs.unity.com/ugs/manual/overview/manual/getting-started#Prerequisites)
  + [Create a project](https://docs.unity.com/ugs/manual/overview/manual/getting-started#CreateProject)

+ **Get started with GitHub Pages**
  + [Create a repository for your site](https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site#creating-a-repository-for-your-site)
  + [Create your site](https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site#creating-your-site)

## Setup Openfort dashboard
  + [Add a Contract](https://dashboard.openfort.xyz/contracts/new)
    
    This sample requires an NFT contract to run. We use [0xbed6a05ce8719bc00db1cc81a814192c82be1bb1](https://mumbai.polygonscan.com/address/0xbed6a05ce8719bc00db1cc81a814192c82be1bb1) (NFT contract deployed in 80002 Amoy). You can use it for this tutorial:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_4_9397f3633b.png?updated_at=2023-12-14T15:59:33.808Z"
      alt='Contract Info'
    />
    </div>

  + [Add a Policy](https://dashboard.openfort.xyz/policies/new)
    
    We aim to cover gas fees for users. Set a new gas policy:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_5_ab3d8ad48d.png?updated_at=2023-12-14T15:59:33.985Z"
      alt='Gas Policy'
    />
    </div>

    Now, add a rule so our contract uses this policy:

    <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_6_6727e69146.png?updated_at=2023-12-14T15:59:33.683Z"
      alt='Policy Rule'
    />
    </div>

## Set up reCAPTCHA V3

Go to [reCAPTCHA v3 Admin Console](https://www.google.com/recaptcha/admin) to register a new site. Choose ***Switch to create a classic key*** if the option is available:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_recaptcha_sample1_011de519f7.png?updated_at=2024-02-02T14:36:18.691Z"
      alt='Set up reCAPTCHA V3: Switch to create a classic key'
    />
    </div>

Enter a ***Label*** name, select the ***reCAPTCHA type*** and enter your GitHub Pages URL as a ***Domain***:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_recaptcha_sample2_536c95791f.png?updated_at=2024-02-02T14:36:19.493Z"
      alt='Set up reCAPTCHA V3: Fill options'
    />
    </div>

Accept the terms of service and choose ***Submit***:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_recaptcha_sample3_12771b8ee4.png?updated_at=2024-02-02T14:36:19.586Z"
      alt='Set up reCAPTCHA V3: Submit'
    />
    </div>

Copy the ***Site Key*** and the ***Secret Key*** and save them somewhere safe:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_recaptcha_sample4_01a863dd6e.png?updated_at=2024-02-02T14:36:21.176Z"
      alt='Set up reCAPTCHA V3: Copy keys'
    />
    </div>

## Set up [`ugs-backend`](https://github.com/openfort-xyz/ugs-unity-game-services-sample/tree/main/ugs-backend)

- ### Fill in environment variables

  + [Retrieve the **API Secret key**](https://dashboard.openfort.xyz/developers/api-keys) and fill in the [``openfortApiKey``](https://github.com/openfort-xyz/unity-recaptcha-sample/blob/55f91101ff4eae301b6d8c98458023c6b3b34d6e/ugs-backend/CreateOpenfortPlayer.js#L5) variable.
  + [Use the same **API Secret key**](https://dashboard.openfort.xyz/developers/api-keys) to fill the [``openfortApiKey``](https://github.com/openfort-xyz/unity-recaptcha-sample/blob/55f91101ff4eae301b6d8c98458023c6b3b34d6e/ugs-backend/MintNft.js#L5) variable.
  + [Retrieve the **NFT Contract API ID**](https://dashboard.openfort.xyz/contracts) and fill in the [``nftContractId``](https://github.com/openfort-xyz/unity-recaptcha-sample/blob/55f91101ff4eae301b6d8c98458023c6b3b34d6e/ugs-backend/MintNft.js#L9C11-L9C25) variable.
  + [Retrieve the **Policy API ID**](https://dashboard.openfort.xyz/policies) and fill in the [``policyId``](https://github.com/openfort-xyz/unity-recaptcha-sample/blob/55f91101ff4eae301b6d8c98458023c6b3b34d6e/ugs-backend/MintNft.js#L10C11-L10C19) variable.
  + Fill in the [``secretKey``](https://github.com/openfort-xyz/unity-recaptcha-sample/blob/55f91101ff4eae301b6d8c98458023c6b3b34d6e/ugs-backend/VerifyReCaptcha.js#L6) with your **reCAPTCHA secret key**.

- ### Deploy to UGS
  Follow [the official documentation steps](https://docs.unity.com/ugs/en-us/manual/cloud-code/manual/scripts/getting-started#Deploy_a_Cloud_Code_script) to deploy each and all of the Cloud Code scripts.

## Set up [``unity-client``](https://github.com/openfort-xyz/ugs-unity-game-services-sample/tree/main/unity-client)

- ### Link to UGS project
  Follow the [official documentation steps](https://docs.unity.com/ugs/manual/authentication/manual/get-started#Link_your_project) to link the ``unity-client`` to your UGS Project.

- ### Fill in needed variables
  On the [Main scene](https://github.com/openfort-xyz/unity-recaptcha-sample/tree/main/unity-client/Assets/Scenes), select the *ReCaptchaController* game object and fill in your **reCAPTCHA site key**:

  <div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_recaptcha_sample5_ad65b1ce5b.png?updated_at=2024-02-02T14:36:19.490Z"
      alt='Set up Unity client: Fill in reCAPTCHA site key'
    />
    </div>

## Build to WebGL

> **IMPORTANT:** You need to build this sample to the root folder of the GitHub Pages repository.

In Unity go to *File --> Build Settings*, select *Web* platform and choose ***Build***:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_recaptcha_sample6_d388084266.png?updated_at=2024-02-02T14:36:16.787Z"
      alt='Build to WebGL'
    />
    </div>

Find your GitHub Pages repository root folder and choose ***Select Folder***:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_recaptcha_sample7_735cd4abc0.png?updated_at=2024-02-02T14:36:15.587Z"
      alt='Build to WebGL: Select folder'
    />
    </div>

After the build is completed, go to your GitHub Pages repository URL and you should see the *Sign in* panel:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_recaptcha_sample8_c283fc6617.png?updated_at=2024-02-02T14:36:19.482Z"
      alt='Build to WebGL: Sign in panel'
    />
    </div>

Open the browser console to check that reCAPTCHA V3 is loaded and ready:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_recaptcha_sample9_f55bb4e5a2.png?updated_at=2024-02-02T14:36:21.283Z"
      alt='Build to WebGL: reCAPTCHA ready'
    />
    </div>

Click the ***Sign in*** button and after some authentication-related logs, the *Mint* panel should appear. In the console logs, we should see a positive reCAPTCHA verification score. Because we passed the reCAPTCHA verification, an Openfort player should have been created:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_recaptcha_sample10_97c88ae6ee.png?updated_at=2024-02-02T14:36:21.617Z"
      alt='Build to WebGL: positive score'
    />
</div>

If you click the ***Mint*** button, the game will go through another reCAPTCHA verification. After a brief period, you should see the *NFT minted* panel with the Openfort player account address in a button:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/unity_recaptcha_sample11_86ae061a30.png?updated_at=2024-02-05T11:21:12.597Z"
      alt='Build to WebGL: NFT minted'
    />
</div>

Click on the ***Address*** button to open Etherscan and see that the transaction is confirmed:

<div align="center">
    <img
      width="50%"
      height="50%"
      src="https://blog-cms.openfort.xyz/uploads/ugs_integration_8_6b345bd148.png?updated_at=2023-12-14T16:05:00.991Z"
      alt='Etherscan'
    />
</div>

## Code walkthrough

All this is thanks to the [**``ReCaptcha.jslib plugin``**](https://github.com/openfort-xyz/unity-recaptcha-sample/blob/main/unity-client/Assets/Plugins/WebGL/ReCaptcha.jslib) located in the Unity client, which allows the execution of reCAPTCHA V3 from the client. The ``.jslib`` methods are called from the [**``ReCaptchaController.cs``**](https://github.com/openfort-xyz/unity-recaptcha-sample/blob/main/unity-client/Assets/Scripts/ReCaptchaController.cs).

Then, when reCAPTCHA V3 gets the response token from the execution, we validate it in the backend through [**``VerifyReCaptcha.js``**](https://github.com/openfort-xyz/unity-recaptcha-sample/blob/main/ugs-backend/VerifyReCaptcha.js)

## Conclusion

Upon completing the above steps, your Unity game will be fully integrated with Openfort and Google reCAPTCHA V3. Always remember to test every feature before deploying to guarantee a flawless player experience.

## Get support
If you found a bug or want to suggest a new [feature/use case/sample], please [file an issue](https://github.com/openfort-xyz/unity-recaptcha-sample/issues).

If you have questions, or comments, or need help with code, we're here to help:
- on Twitter at https://twitter.com/openfortxyz
- on Discord: https://discord.com/invite/t7x7hwkJF4
- by email: support+youtube@openfort.xyz


# Integrate Unity WebGL on Telegram mini-app
Learn how you can integrate WebGL on Telegram mini-app

## Overview
Use Unity WebGL to create a mini-game and integrate it into a Telegram mini-app.

<Admonition type='tip'>
Building a new app? Check out the [Unity sample project](https://github.com/openfort-xyz/openfort-csharp-unity/tree/main/sample), a scene that demonstrates how to integrate Unity WebGL on Telegram mini-app. The scene is called `Telegram` and is located in the `Scenes` folder.
</Admonition>

## Prerequisites
Openfort SDK is set up in your Unity project. If not, follow the [quickstart guide](/docs/guides/unity/quickstart).
This project uses WebGL, so make sure you also have [set up WebGL](/docs/guides/unity/webgl).

## Configuration

### Telegram mini-app setup

+ Create a Telegram bot and get the bot token. Follow the [official guide](https://core.telegram.org/bots#6-botfather) to create a bot and get the token.

+ [Configure your project providers](https://dashboard.openfort.xyz/players/auth/providers)
  Enable the Telegram provider and add the bot username and bot token.

  <div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/2025_01_20_12_48_33_fcb40b590d.jpg?updated_at=2025-01-20T11:50:42.131Z"
    alt='Contract Info'
  />
  </div>
  
  Enable the Telegram (Mini-app) provider and add the bot token.

  <div align="center">
  <img
    width="50%"
    height="50%"
    src="https://blog-cms.openfort.xyz/uploads/2025_01_20_12_48_39_67bcb69b01.jpg?updated_at=2025-01-20T11:50:51.897Z"
    alt='Contract Info'
  />
  </div>

+ Import the [telegram mini app](https://www.jsdelivr.com/package/npm/@telegram-apps/sdk) SDK in your HTML template file. If you are using the Openfort SDK, you can add the script in the `index.html` file in Assets>WebGLTemplates>Openfort.

  ```html
  <script src="https://cdn.jsdelivr.net/npm/@telegram-apps/sdk@1.1.3/dist/index.iife.js"></script>
  ```
  This will expose a function `telegramApps.sdk.retrieveLaunchParams()` that will return the launch parameters from the Telegram mini-app.

+ Add a [Json library file](https://docs.unity3d.com/Manual/webgl-interactingwithbrowserscripting.html) `Telegram.jslib`. This file will serve as a bridge between the Unity script and the Telegram SDK.

  ```csharp Telegram.jslib
  mergeInto(LibraryManager.library, {
      InitTelegramApp: function () {
          const telegramSDK = telegramApps.sdk;
          try {
              // Retrieve launch parameters from Telegram
              const launchParams = telegramSDK.retrieveLaunchParams();

              var bufferSize = lengthBytesUTF8(launchParams.initDataRaw) + 1;
              var buffer = _malloc(bufferSize);
              stringToUTF8(launchParams.initDataRaw, buffer, bufferSize);
              return buffer
          } catch (error) {
              console.error('Error initializing app:', error);
          }
          return "";
      },
  });

  ```

+ Import the InitTelegramApp function in your Unity script.

  ```csharp Telegram.cs
  using System.Runtime.InteropServices;

  public class Telegram : MonoBehaviour
  {
      [DllImport("__Internal")]
      private static extern string InitTelegramApp();

      void Start()
      {
          string initData = InitTelegramApp();
          Debug.Log("Init data: " + initData);
      }
  }
  ```

+ Authenticate with Telegram mini app token using the Openfort SDK.

  ```csharp Telegram.cs
  using System.Runtime.InteropServices;
  using Openfort.OpenfortSDK;

  public class Telegram : MonoBehaviour
  {
      [DllImport("__Internal")]
      private static extern string InitTelegramApp();

      [SerializeField]
      string projectPublishableKey;

      [SerializeField]
      string shieldPublishableKey;

      [SerializeField]
      string shieldEncryptionShare;

      void Start()
      {
          openfort = await OpenfortSDK.Init(
              projectPublishableKey,
              shieldPublishableKey,
              shieldEncryptionShare
          );

          string initData = InitTelegramApp();
          Debug.Log("Init data: " + initData);

          ThirdPartyOAuthRequest request = new ThirdPartyOAuthRequest(
              ThirdPartyOAuthProvider.TelegramMiniApp,
              telegramAuth,
              TokenType.IdToken
          );
      }
  }
  ```
  
  Using Telegram mini-app as a third-party provider, your token is the Telegram mini-app initData. You can use this token to authenticate with the Openfort SDK.

<Admonition type='note'>
Using the Telegram mini-app as a third-party provider, `openfort.GetAccessToken()` is not available. Your access token is the Telegram mini-app initData.
</Admonition>


# Use Token Bound Accounts
Learn how to use token bound accounts

In this guide you'll find how to implement a token bound account based on a game character. This guide implements the backend code necessary to use token bound accounts in your game. It uses the [Openfort Node SDK](https://www.npmjs.com/package/@openfort/openfort-node). Architecture of the solution proposed in this guide:

<div align="center">
  <img
    alt="using-token-bound-accounts"
    src="https://blog-cms.openfort.xyz/uploads/Group_349_48e9e86864.svg"
    width="100%"
    height="100%"
  />
</div>

<Admonition type="note">

For a genereral overview of token bound accounts, see the [Token Bound Accounts](https://www.openfort.xyz/blog/technical-dive-combining-token-bound-account-tba-with-account-abstraction-aa) blog post.
You can find the complete code of this guide in the [openfort samples GitHub](https://github.com/openfort-xyz/samples/tree/main/ERC6551-token-bound-accounts).

</Admonition>

## Prerequisites

When interacting with smart wallets through Openfort, 
### 1. Import the NFT contract

Token bound accounts are based on the ownership of a non-fungible token. In this guide, we'll use a contract, deployed at in [Polygon Amoy](https://mumbai.polygonscan.com/) at [0x380...AC0](https://mumbai.polygonscan.com/address/0xbed6a05ce8719bc00db1cc81a814192c82be1bb1).

<Tabs
scrollable
size="small"
type="underlined"
defaultActiveId="dashboard"
>
    <TabPanel id="dashboard" label="Dashboard">

    Add a new contract by clicking the `Add contract` button in the [Asset contracts](https://dashboard.openfort.xyz/contracts) section, then enter:
        - The name of the contract (it can be any name you want; the name is only for identification purposes)
        - The network (`chainId`) where the smart contract is located: 80002.
        - The address of the contract.
        - Because the contract is verified in the block explorer, there's no need to provide an ABI manually.

    <div align="center">
        <img
        alt="DashboardAddContract"
        src="https://blog-cms.openfort.xyz/uploads/adding_contract_dashboard_09dce2f83c.png"
        width="60%"
        height="60%"
        />
    </div>

    </TabPanel>
     <TabPanel id="api" label="API">
    <Tabs
    scrollable
    size="small"
    type="rounded-pills"
    defaultActiveId="js"
    >
    <TabPanel id="cli" label="curl">

    ```bash command-line
    curl https://api.openfort.xyz/v1/contracts \
        -H "Authorization: Bearer $YOUR_SECRET_KEY" \
        -d name="SimpleNFT" \
        -d address="0xbed6a05ce8719bc00db1cc81a814192c82be1bb1" \
        -d chainId="80002"
    ```

    </TabPanel>
    <TabPanel id="js" label="Node">

    ```ts server.ts
    const openfort = new Openfort(process.env.YOUR_SECRET_KEY);
    const SimpleNFT = await openfort.contracts.create({
        name: "SimpleNFT",
        address: "0xbed6a05ce8719bc00db1cc81a814192c82be1bb1",
        chainId: chainId,
    });
    ```

    </TabPanel>
  </Tabs>
  </TabPanel>

</Tabs>

### 2. Set up gas sponsoring

<Tabs
scrollable
size="small"
type="underlined"
defaultActiveId="dashboard"
>
    <TabPanel id="dashboard" label="Dashboard">

    Add a new policy by clicking the `Add policy` button in the [Policies page](https://dashboard.openfort.xyz/policies), then enter:
        - The name of the policy (it can be any name you want; the name is only for identification purposes)
        - The network (`chainId`) where the smart contract is located: 80002.
        - As a fee sponsorship strategy, leave `pay gas for user`.
        - Under policy rules, create two rules:
            - 1st rule:
                - Leave `contract_functions` under Rule model.
                - Under Contract, select the contract you imported in the previous step.
                - Under Function name, select `All functions`.
            - 2nd rule:
                - Choose `account_functions` under Rule model.

    <div align="center">
        <img
        alt="GasPolicy"
        src="https://blog-cms.openfort.xyz/uploads/create_sponsor_7a1583a724.png"
        width="50%"
        height="50%"
        />
    </div>

    </TabPanel>
    <TabPanel id="api" label="API">
  <Tabs
  scrollable
  size="small"
  type="rounded-pills"
  defaultActiveId="js"
  >
    <TabPanel id="cli" label="curl">

    ```bash command-line
    curl https://api.openfort.xyz/v1/policies \
        -H "Authorization: Bearer $YOUR_SECRET_KEY" \
        -d name="Trial sponsor" \
        -d chainId="80002" \
        -d "strategy[sponsorSchema]=pay_for_user"
    ```

    Use the policy id to create policy rules and use the previously imported contract.

    ```bash command-line
    curl https://api.openfort.xyz/v1/policies/:id/policy_rules \
        -H "Authorization: Bearer $YOUR_SECRET_KEY" \
        -d type="contract_functions" \
        -d functionName="All functions" \
        -d contract="con_..."
    ```

    ```bash command-line
    curl https://api.openfort.xyz/v1/policies/:id/policy_rules \
        -H "Authorization: Bearer $YOUR_SECRET_KEY" \
        -d type="account_functions"
    ```

    </TabPanel>
    <TabPanel id="js" label="Node">

    ```ts server.ts
    const policy = await openfort.policies.create({
        name: "test",
        chainId: 80002,
        strategy: {
            sponsorSchema: SponsorSchema.PayForUser,
        },
    });

    await openfort.policyRules.create({
        contract: SimpleNFT.id,
        type: PolicySchema.ContractFunctions,
        policy: policy.id,
        functionName: "All functions",
    });

    await openfort.policyRules.create({
        type: PolicySchema.AccountFunctions,
        policy: policy.id,
    });
    ```

    </TabPanel>
    </Tabs>
    </TabPanel>
</Tabs>

## Create the character NFT

As you know, to create a token bound account, you need to first know what NFT will be used to define the ownership of the account.
Because in this guide we start from scratch, we'll also mint that NFT, but you could potentially use any NFT that you already own. If you want to use your own NFT, skip to the next section.

We'll use a regular Openfort account to mint it. We start by creating an Openfort player and a regular Openfort account.

```ts server.ts
const upgradeable_account = await openfort.accounts.create({
  chainId: chainId,
});
const player_upgradeable = upgradeable_account.player.id;
```

Then, we define the mint function interaction and create a `transactionIntent` using the gas sponsoring `policy` we created in the previous step.

```ts server.ts
const interactionsMintOwnerNFT: Interaction[] = [
  {
    contract: SimpleNFT.id,
    functionName: 'mint',
    functionArgs: [player_upgradeable.id],
  },
]
const transactionIntentSimpleNFT = await openfort.transactionIntents.create({
  player: player_upgradeable.id,
  interactions: interactionsMintOwnerNFT,
  policy: policy.id,
  chainId: chainId,
  optimistic: false,
})
```

And we're all set! The character NFT is minted and owned by the `player_upgradeable`'s account.

## Create a token bound account

Now that we have the NFT that will defined the ownership of the account, we can create a token bound account. Note that when creating the token bound account, we need to specify:

- The `externalOwnerAddress` field: the address that currently owns the character NFT.
- The `tokenContract` field: the address of the NFT contract.
- The `tokenId` field: the token id of the character NFT.
- The `accountType` field: specified that the account to be created is a token bound account.

We start off by creating a new player and then assign a new counterfactual token bound account to it:

```ts server.ts
const player_6551 = await openfort.players.create({
  name: '6551 account',
})
const account = await openfort.accounts.create({
  player: player_6551.id,
  chainId: chainId,
  accountType: DataAccountTypes.Erc6551,
  tokenContract: SimpleNFT.id,
  tokenId: simpleOwnerNFTTokenId,
  externalOwnerAddress: upgradeable_account.address,
})
```

## Transferring the character NFT

You can send the character NFT to another account by calling the `safeTransferFrom` function of the NFT contract.
This function takes the address of the current owner, the address of the new owner, and the token id as arguments.

In this case, we'll transfer the character NFT to the previously `account` ownerAddress. This is because Openfort accounts come, by default, with a managed signer.
Sending the NFT to the account ownerAddress allows a regular EOA to control the account.

```ts server.ts
const interactionsExecCall: Interaction[] = [
  {
    contract: SimpleNFT.id,
    functionName: 'approve',
    functionArgs: [ownerAddress, simpleOwnerNFTTokenId],
  },
  {
    contract: SimpleNFT.id,
    functionName: 'safeTransferFrom',
    functionArgs: [
      player_upgradeable.id,
      account.ownerAddress,
      simpleOwnerNFTTokenId,
    ],
  },
]
const transactionIntentTransferOwnerNFT =
  await openfort.transactionIntents.create({
    player: player_upgradeable.id,
    interactions: interactionsExecCall,
    policy: policy.id,
    chainId: chainId,
    optimistic: false,
  })
```

## Minting an asset into the character NFT

You can easily mint assets into the token bound account and even use it to mint assets.
Here we interact with the same simple NFT contract to mint an NFT into the token bound account.

```ts server.ts
const interactionsMintNFT: Interaction[] = [
  {
    contract: SimpleNFT.id,
    functionName: 'mint',
    functionArgs: [player_6551.id],
  },
]
const transactionIntentSimpleNFT6551 = await openfort.transactionIntents.create(
  {
    player: player_6551.id,
    interactions: interactionsMintNFT,
    policy: policy.id,
    chainId: chainId,
    optimistic: false,
  }
)
```


# Using session keys
How to create a gaming session keys.

In-game keys are specialized access tools assigned with specific in-game permissions, tailored for enhancing gaming experiences. Examples include:

- A key that grants access only to specific game levels or areas.
- A key that allows the use of up to 1000 in-game currency units.
- A key that remains valid for 3 days before expiring.

Moreover, these permissions can be combined to create more tailored experiences, such as a key that grants access to certain game levels, allows the spending of up to 1000 in-game currency units, and expires after 3 days.

The potential applications for automated in-game actions are vast, including:

- Automatic renewal of subscriptions or in-game passes.
- Execution of predefined strategies or actions when certain in-game conditions are met.
- Automatic management of in-game assets or resources, such as restocking supplies or managing in-game property.

<Admonition type="note">

For a general overview of session keys, see the [Session keys](https://www.openfort.xyz/blog/technical-dive-session-keys) post. For more information about how to use the session key endpoints, you can visit our [API documentation](/docs/reference/api/create-a-session-key).

</Admonition>

### API

There are two types of session keys in Openfort: client session keys and server session keys. 
- **Client session keys** are created on the client side and are used to mint assets with a player's smart account. 
- **Server session keys** are created on the client by a key pair and send the address computed to the server.

## Configuration

This section will guide you through the process of registering a session key and using it to mint an asset with a player's smart account. 

    <Tabs
    scrollable
    size="tiny"
    type="pills"
    defaultActiveId="client"
    >
      <TabPanel id="client" label="Client session key">

      <Admonition type="tip">
      Check out our sample registering a session key with an account with a self-custodial signer: [GitHub source](https://github.com/openfort-xyz/openfort-js/tree/main/examples/apps/auth-sample).
      </Admonition>

  ### 1. Create a session key

  After you have authenticated your user with your regular authentication system, you can create a session key for them.
  To create a session key, you need to generate a key pair on the client-side and send the address computed from the public key to your server.

  Using one of the official Openfort [client libraries](/docs/libraries) everything is handled for you.

  1. Install the client-side library:

  Open `Packages/manifest.json` and add these lines:

  ```json
  "com.openfort.sdk": "https://github.com/openfort-xyz/openfort-csharp-unity.git",
  "com.unity.nuget.newtonsoft-json": "3.0.1",
  "com.cysharp.unitask": "https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask#2.3.3"
  ```

  2. Initialize Openfort and create a session key:

  ```csharp client.cs
  using Openfort.OpenfortSDK;
  using Openfort.OpenfortSDK.Model;

  public class LoginSceneManager : MonoBehaviour
  {
    private OpenfortSDK openfort;
    private SessionKey sessionKey;
    private void Start()
    {
      openfort = await Openfort.Init("YOUR_OPENFORT_PUBLISHABLE_KEY");
      sessionKey = openfort.ConfigureSessionKey();
    }
  }
  ```

  </TabPanel>

<TabPanel id="server" label="Server session key">

  ### 1. Create a session key

  Using [ethers](https://www.npmjs.com/package/ethers), you can create a key pair on the server side of you application.

  ```ts
  const sessionKey = ethers.Wallet.createRandom();
  ```

  The parameter `sessionKey` contains the address that you will need to register.

  </TabPanel>
  </Tabs>

  After creating the session key, you can go ahead and register it.

  ### 2. Register a session key - <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Server side</span> <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Client side</span>

  To register a session key, first send the address from the session key to your server.
  You can get the address from the session key object created above like this:

  ```csharp client.cs
  string address  = sessionKey.Address;
  ```

  Then, from your server you can make a request to the Openfort API or use one of our [server libraries](/docs/libraries) to register the session key.

  Install Openfort in your server-side and initialize it with your secret key.

  <Tabs
    scrollable
    size="small"
    type="rounded-pills"
    defaultActiveId="node"
  >
  <TabPanel id="node" label="Node">
  ```bash command-line
  npm install @openfort/openfort-node
  ```

  Initialize '@openfort/openfort-node' with your secret key.

  ```ts server.ts
    const openfort = new Openfort('sk_test_...');
  ```

  </TabPanel>
  <TabPanel id="net" label=".Net">
  ```bash command-line
  dotnet add package Openfort.SDK
  ```

  Initialize 'Openfort.SDK' with your secret key.

  ```csharp server.cs
  using Openfort.SDK;
  using Openfort.SDK.Model;

  var openfort = new OpenfortClient("sk_test_...");
  ```
  </TabPanel>
  </Tabs>

  The created session key would be valid since the 25th of May 2023 at 7:50 GMT (timestamp `1685001000`) and last for 1 hour (timestamp `1685001000`).
  For a useful resource to calculate timestamps online, visit [UNIX Timestamp](https://www.unixtimestamp.com/).

  Note how the `externalOwnerAddress` parameter is used to indicate the address of owner of the account that will be created under the specified player. It's only necessary to specify this parameter when the player is doesn't yet have an account in that chain.

  Also, note how a `policy` is used to indicate the policy that will be used to sponsor the gas fees of the transaction to register the session key.

  In this example `externalOwnerAddress` is used to indicate the address of the owner of the account that will be created under the specified player.

  Register the session key using Openfort:

  <Tabs
    scrollable
    size="small"
    type="rounded-pills"
    defaultActiveId="node"
  >
  <TabPanel id="bash" label="curl">

  ```bash command-line
  curl https://api.openfort.xyz/v1/sessions \
    -H "Authorization: Bearer $YOUR_SECRET_KEY" \
    -d player=pla_... \
    -d address="0x76e6...9341" \
    -d chainId=80002 \
    -d validUntil=1685004600 \
    -d validAfter=0 \
    -d externalOwnerAddress="0x41e6...9341" \
    -d policy=pol_...
  ```

  </TabPanel>
  <TabPanel id="node" label="Node">

  ```ts server.ts
  const sessionKeyAddress = '0x76e6...9341'
  const policyId = 'pol_...'
  const playerId = 'pla_...'
  const validUntil = 1685001000
  const validAfter = 0
  const chainId = 80002
  const externalOwnerAddress = '0x41e6...9341'

  const playerSession = await openfort.sessions.create({
    player: playerId,
    address: sessionKeyAddress,
    chainId: chainId,
    validUntil: validUntil,
    validAfter: validAfter,
    policy: policyId,
    externalOwnerAddress: externalOwnerAddress,
  })
  ```

  </TabPanel>
  </Tabs>

  After registering the session key, you can see it in the dashboard under the player's page.

  <div align="center">
    <img
      alt="DashboardRegisterSessionKey"
      src="https://blog-cms.openfort.xyz/uploads/dashboard_session_keys_931c5a570a.png"
      width="70%"
      height="70%"
    />
  </div>

  ### 3. Sign the session key - <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Client side</span>

  The owner of the account of the player needs then to authorize the new session key.

  To do so, it needs to sign the `userOperationHash` from the `nextAction` object returned by the API call to register the session key.

  `nextAction` response object from transaction_intents

  ```json
  "nextAction": {
      "type": "sign_with_wallet",
      "payload": {
          "signableHash": "0x91b4efe3648c79467f7b50aa9bb1b4eae383a52dd6d741d39ece29ed2ef8362d"
      }
  },
  ```

  Once the content of the `nextAction` parameter above is signed by the owner signer of the account,
  it has to be sent to Openfort using the endpoint `/v1/sessions/:id/signature` as shown below:

  Sign and send the session key registration:

  <Tabs
    scrollable
    size="small"
    type="rounded-pills"
    defaultActiveId="unity"
  >
  <TabPanel id="bash" label="curl">

  ```bash command-line
  curl https://api.openfort.xyz/v1/sessions/ses_.../signature \
    -H "Authorization: Bearer $YOUR_PUBLISHABLE_KEY" \
    -d signature="xyz..."
  ```

  </TabPanel>

  <TabPanel id="unity" label="Unity">

  ```csharp client.cs
  await Openfort.SendSignatureSessionRequest(
    playerSession.id,
    SIGNED_USED_OP_HASH
  );
  ```
  </TabPanel>
  </Tabs>

  ### 4. Using the session key - <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Server side</span> <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Client side</span>

  After the session key is registered, it can be used to authenticate requests from the player.
  Whenever you create a transaction intent from your backend, a signature will be needed from the session key or owner of the players' smart account.

  Create a transaction intent:

  <Tabs
    scrollable
    size="small"
    type="rounded-pills"
    defaultActiveId="node"
  >
  <TabPanel id="bash" label="curl">

  ```bash command-line
  curl https://api.openfort.xyz/v1/transaction_intents \
    -H "Authorization: Bearer $YOUR_SECRET_KEY" \
    -d player=pla_... \
    -d address="0x76e6...9341" \
    -d chainId=80002 \
    -d policy=pol_...
  ```

  </TabPanel>
  <TabPanel id="node" label="Node">

  ```ts server.ts
  const playerId = 'pla_...'
  const policyId = 'pol_...'
  const contractId = 'con_...'
  const chainId = 80002
  const optimistic = true

  const interaction: Interaction = {
    contract: contractId,
    functionName: 'mint',
    functionArgs: [playerId],
  }
  const transactionIntent = await openfort.transactionIntents.create({
    player: playerId,
    chainId: chainId,
    optimistic: optimistic,
    interactions: [interaction],
    policy: policyId,
  })
  ```

  </TabPanel>
  </Tabs>

  After creating the transaction intent, the session key will need to sign the nextAction `userOperationHash` and send it to Openfort.

  To do so, pass the `userOperationHash` to the `sendSignatureTransactionIntentRequest` method of the Openfort client library.
  Load session key and sign a transaction intent:

  ```csharp client.cs
  await Openfort.SendSignatureTransactionIntentRequest(
    collectResponseJSON.data.id,
    userOperationHash
  );
  ```

  ### 5. Revoke a session key - <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Client side</span> <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Server side</span>

  The owner of the account can always revoke the session key.

  To do so, it needs to sign the `userOperationHash` from the `nextAction` object returned by the API call to revoke the session key.

  Create a transaction intent:

  <Tabs
    scrollable
    size="small"
    type="rounded-pills"
    defaultActiveId="node"
  >
  <TabPanel id="bash" label="curl">

  ```bash command-line
  curl https://api.openfort.xyz/v1/sessions/revoke \
    -H "Authorization: Bearer $YOUR_SECRET_KEY" \
    -d player=pla_... \
    -d address="0x76e6...9341" \
    -d chainId=80002 \
    -d policy=pol_...
  ```

  </TabPanel>
  <TabPanel id="node" label="Node">

  ```ts server.ts
  const playerId = 'pla_...'
  const policyId = 'pol_...'
  const chainId = 80002
  const sessionKeyAddress = '0x76e6...9341'

  const revokeSession = await openfort.sessions.revoke({
    player: playerId,
    address: sessionKeyAddress,
    chainId: chainId,
    optimistic: true,
    policy: policyId,
  })
  ```

  </TabPanel>
  </Tabs>

  Sign the transaction to revoke the session key and remove from client side:

  ```csharp client.cs
  var openfortTransactionResponse =
    await openfort.sendSignatureTransactionIntentRequest(
      revokeResponseJSON.data.id,
      userOperationHash
    );
  ```

  {/* Finish with a video. This also appears in the Sidebar via the "tocVideo" metadata */}

  <div className="video-container">
    <iframe
      src="https://www.youtube-nocookie.com/embed/rh2E02PATlU"
      frameBorder="1"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowFullScreen
    ></iframe>
  </div>


# Using smart wallets


Smart wallets in Openfort are your primary interface for blockchain interactions. Once an embedded signer is set up, a smart wallet is automatically created and associated for your user.

<Admonition type="tip">
There is no need to use the EIP1193 provider directly. Instead, use the Openfort SDK to interact with the smart wallet.
</Admonition>

## Getting an EIP-1193 provider

All of Openfort's wallets can 
To get a wallet's EIP-1193 provider, use the openfort `getEthereumProvider` method:

```csharp
public class OpenfortManager : MonoBehaviour
{
    private OpenfortSDK openfort;

      public async UniTask<Provider> GetEthereumProvider(EthereumProviderRequest request)
      {
          return await GetOpenfortImpl().GetEthereumProvider(request);
      }
    }
```


# Requesting signatures and transactions


To use smart wallets, you could use the EIP1193 provider or use a backend. This guide teaches how to make different requests to the smart wallet with the backend and Unity (it's easier to do so in the context of gaming because no need to encode transactions with Unity).

## Sign message

To sign message with the smart wallet simply call the Openfort's `signMessage` or `signTypedData` method like so:

```csharp
SignMessageRequest signMessageRequest = new SignMessageRequest("Hello World!");
string signature = await openfort.SignMessage(signMessageRequest);
```

## Transactions

### 1. Create a transaction- <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Server side</span>

Create a request to your backend to create a transaction. In the body of the request:
- Include the `player` that signs the transaction.
- Include the `policy` that interacts with the contract for gas. If non-existent the user will need to have gas tokens.
- Include `optimistic` if you want the transactions to be confirmed faster.

Depending on the type of transaction you're creating you'll define `interactions`. The `interactions` field is an array of objects that contain the information of the contract to interact with, the function to call, and the arguments to pass to the function.
- the interactions field contains the `contract` that has previously been added to Openfort.
- the `functionName` defines the function to call from within the contract. 
- If there exist more than one function with the same name, the `functionArgs` will be used to determine which function to call. 

<Tabs
scrollable
size="medium"
type="underlined"
defaultActiveId="dashboard"
>
<TabPanel id="dashboard" label="Simple">

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="terminal"
>
<TabPanel id="terminal" label="curl">

```bash command-line
curl https://api.openfort.xyz/v1/transaction_intents \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d player="pla_..." \
  -d policy="pol_..." \
  -d chainId=80002 \
  -d optimistic=true \
  -d "interactions[0][contract]"="con_..." \
  -d "interactions[0][functionName]"="mint" \
  -d "interactions[0][functionArgs][0]"="0x63B7...484f"
```

</TabPanel>
<TabPanel id="nodejs" label="Node">

```ts server.ts
// Set your secret key. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.openfort.xyz/developers/api-keys
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);

const playerId = "pla_...";
const contractId = "con_...";
const policyId = "pol_...";
const chainId = 80002;
const optimistic = false;

const interaction_mint = {
  contract: contractId,
  functionName: "mint",
  functionArgs: [playerId],
};

await openfort.transactionIntents.create({
    "player":playerId,
    "chainId":chainId,
    "optimistic":optimistic,
    "interactions":[interaction_mint],
    "policy":policyId
  });
```

</TabPanel>
<TabPanel id="csharp" label=".Net">

```csharp Program.cs
string policyId = "pol_...";
string contractId = "con_...";
string playerId = "pla_...";
int chainId = 80002;
bool optimistic = false;

var interactionMint = new Interaction
(
  contract: contractId,
  functionName: "mint",
  functionArgs: new List<object> { playerId }
);

var transactionIntentRequest = new CreateTransactionIntentRequest
    (
        player: playerId,
        chainId: chainId,
        policy: policyId,
        optimistic: optimistic,
        interactions: new List<Interaction> { interactionMint }
    );
await client.TransactionIntents.Create(transactionIntentRequest);
```

</TabPanel>
</Tabs>

</TabPanel>
<TabPanel id="native" label="Native">

Send the value of native tokens in the smallest denomination of the native currency i.e. wei (10^18) and as a `string`.

<Admonition type="tip">

The `to` parameter accepts:
- any valid account `address` e.g. 0x680d2719F09B23F644c136Ab7336D42b6a76AdcC
- a player `id` e.g. pla_...
- an account `id` e.g. acc_...

</Admonition>

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="terminal"
>
<TabPanel id="terminal" label="curl">

```bash command-line
curl https://api.openfort.xyz/v1/transaction_intents \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d player="pla_..." \
  -d policy="pol_..." \
  -d chainId=80002 \
  -d optimistic=true \
  -d "interactions[0][value]=1000" \
  -d "interactions[0][to]=pla_..."
``` 

</TabPanel>
<TabPanel id="nodejs" label="Node">

```ts server.ts
// Set your secret key. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.openfort.xyz/developers/api-keys
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);

const playerId = "pla_...";
const policyId = "pol_...";
const chainId = 80002;
const optimistic = false;

const interaction_transfer = {
  value: "100",
  to: playerId
};

await openfort.transactionIntents.create({
    "player":playerId,
    "chainId":chainId,
    "optimistic":optimistic,
    "interactions":[interaction_transfer],
    "policy":policyId
  });
```

</TabPanel>
<TabPanel id="csharp" label=".Net">

```csharp Program.cs
string policyId = "pol_...";
string playerId = "pla_...";
int chainId = 80002;
bool optimistic = false;

var interactionTransfer = new Interaction
(
  value: "100",
  to: playerId
);

var transactionIntentRequest = new CreateTransactionIntentRequest
    (
        player: playerId,
        chainId: chainId,
        policy: policyId,
        externalOwnerAddress: null!,
        optimistic: optimistic,
        confirmationBlocks: 0,
        interactions: new List<Interaction> { interactionTransfer}
    );
await client.TransactionIntents.Create(transactionIntentRequest);
```

</TabPanel>
</Tabs>

<Admonition type="info">

The `policy` used to sponsor a transaction that sends native tokens should have the `account_functions` policy rule.

</Admonition>

For a useful resource for computing the Wei, you can visit the [wei calculator](https://eth-converter.com/).

</TabPanel>
<TabPanel id="batch" label="Batch">

Smart accounts support batching transactions, allowing multiple actions to be rolled into one. This feature significantly simplifies Web3 interactions for your users. For example, instead of executing `approve()` and then `transfer()`, your user can perform both in a single transaction.

Batching transactions offers several key benefits:
- Users only wait for one transaction to complete instead of multiple.
- Users save on gas fees.
- If any transaction in the batch fails, the entire batch reverts, preventing users from ending up in an inconsistent state. This characteristic is known as "atomicity."

Fore security reasons, there is a limit of 9 interactions per transaction intent.

<Admonition type="tip">

To execute a batch transaction, you can send a transaction intent with **multiple interactions**, and each interaction will be executed in the order they are received.

</Admonition>

<Admonition type="note">

Openfort systems check the contract's ABI to find a function signature based on the `functionName` that you provide and the number of `functionArgs`.

In the case that, in your contract, you have multiple functions with the same `functionName` and number of arguments, you can also include the `functionName` together with the argument types e.g. mint(address)

</Admonition>

<Tabs
scrollable
size="small"
type="rounded-pills"
defaultActiveId="terminal"
>
<TabPanel id="terminal" label="curl">

```bash command-line
curl https://api.openfort.xyz/v1/transaction_intents \
  -H "Authorization: Bearer $YOUR_SECRET_KEY" \
  -d player="pla_...", \
  -d policy="pol_..." \
  -d chainId=80002 \
  -d optimistic=true \
  -d "interactions[0][contract]=con_..." \
  -d "interactions[0][functionName]=mint" \
  -d "interactions[0][functionArgs][0]=0x63B7...484f" \
  -d "interactions[1][contract]=con_..." \
  -d "interactions[1][functionName]=transfer" \
  -d "interactions[1][functionArgs][0]=0x32B7...213d"
```

</TabPanel>
<TabPanel id="nodejs" label="Node">

```ts server.ts
// Set your secret key. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.openfort.xyz/developers/api-keys
const Openfort = require('@openfort/openfort-node').default;
const openfort = new Openfort(YOUR_SECRET_KEY);

const playerId = "pla_...";
const contractId = "con_...";
const policyId = "pol_..."; 
const chainId = 80002;
const optimistic = false;

const interaction_mint = {
  contract: contractId,
  functionName: "mint",
  functionArgs: [playerId],
};
const interaction_transfer = {
  contract: contractId,
  functionName: "transfer",
  functionArgs: [playerId],
};

await openfort.transactionIntents.create({
    "player":playerId,
    "chainId":chainId,
    "optimistic":optimistic,
    "interactions":[interaction_mint, interaction_transfer],
    "policy":policyId
  });
```

</TabPanel>
<TabPanel id="csharp" label=".Net">

```csharp Program.cs
string policyId = "pol_...";
string contractId = "con_...";
string playerId = "pla_...";
int chainId = 80002;
bool optimistic = false;

var interactionMint = new Interaction
(
  contract: contractId,
  functionName: "mint",
  functionArgs: new List<object> { playerId }
);

var interactionTransfer = new Interaction
(
  contract: contractId,
  functionName: "transfer",
  functionArgs: new List<object> { playerId }
);

var transactionIntentRequest = new CreateTransactionIntentRequest
    (
        player: playerId,
        chainId: chainId,
        policy: policyId,
        externalOwnerAddress: null!,
        optimistic: optimistic,
        confirmationBlocks: 0,
        interactions: new List<Interaction> { interactionMint, interactionTransfer}
    );
await client.TransactionIntents.Create(transactionIntentRequest);
```

</TabPanel>
</Tabs>

</TabPanel>
</Tabs>

### 2. Sign the transaction with the embedded signer. - <span className='mr-2 dark:bg-gray-400/10 dark:text-gray-400 font-medium bg-gray-200 text-gray-600 rounded-sm p-1 text-xs'>Client side</span>
Use the `nextAction` returned by the backend to sign the transaction with the embedded signer.

The transaction will be automatically signed and broadcasted by using the `sendSignatureTransactionIntentRequest` method.

```csharp
private async void Mint() {
  // your backend that creates a mint request
  var webRequest = UnityWebRequest.Post("https://your-backend.com/api/mint", "");
  webRequest.SetRequestHeader("Authorization", "Bearer " + AccessToken);
  webRequest.SetRequestHeader("Content-Type", "application/json");
  webRequest.SetRequestHeader("Accept", "application/json");
  await SendWebRequestAsync(webRequest);

  Debug.Log("Mint request sent");
  if (webRequest.result != UnityWebRequest.Result.Success) {
    Debug.Log("Mint Failed: " + webRequest.error);
    return;
  }

  var responseText = webRequest.downloadHandler.text;
  Debug.Log("Mint Response: " + responseText);
  var responseJson = JsonConvert.DeserializeObject < RootObject > (responseText);
  var id = responseJson.Data.Id;
  if (responseJson.Data.NextAction == null) {
    Debug.Log("No Next Action");
    return;
  }

  var nextAction = responseJson.Data.NextAction.Payload.UserOpHash;

  Debug.Log("Next Action: " + nextAction);
  // This example assumes you have already checked that Openfort 'embeddedState' is 
  // `ready` and the user is `authenticated`
  var intentResponse = await Openfort.SendSignatureTransactionIntentRequest(id, nextAction);
  Debug.Log("Intent Response: " + intentResponse);
}

private Task SendWebRequestAsync(UnityWebRequest webRequest) {
  TaskCompletionSource < bool > tcs = new TaskCompletionSource < bool > ();
  webRequest.SendWebRequest().completed += _ => {
    switch (webRequest.result) {
    case UnityWebRequest.Result.Success:
      tcs.SetResult(true);
      break;
    default:
      tcs.SetException(new Exception(webRequest.error));
      break;
    }
  };
  return tcs.Task;
}
```

## Examples

<div className="grid md:grid-cols-12 gap-4 not-prose">
  {examples.map((x) => (
    <div className="col-span-4" key={x.href}>
      <Link href={x.href} passHref>
        <GlassPanel icon={'/docs/img/icons/github-icon-light'} hasLightIcon={true} title={x.name}>
          {x.description}
        </GlassPanel>
      </Link>
    </div>
  ))}
</div>

  {
    name: 'Unity Sample Android',
    description: 'An integration with Google Play Games using Firebase Auth as a third party auth provider to create a non-custodial embedded signer.',
    href: 'https://github.com/openfort-xyz/sample-unity-firebaseauth-embedded-signer',
  },
  {
    name: 'Unity Sample WebGL',
    description: 'An integration with Openfort Auth with non-custodial embedded signer.',
    href: 'https://github.com/openfort-xyz/sample-unity-webgl-embedded-signer',
  }
]


# Quickstart: Unity Integration


GlassPanel,
  IconPanel,
  Button,
  IconChevronRight,
} from '@/components/ui'

## 1. Install the Openfort SDK

### Prerequisites
The Unity SDK requires:
- [UniTask](https://github.com/Cysharp/UniTask) package (version 2.3.3)
- Installation of git-lfs from [git-lfs.github.com](https://git-lfs.github.com/)

There are two ways to install the SDK:

<Tabs
scrollable
size="small"
type="underlined"
defaultActiveId="upm"
>
<TabPanel id="upm" label="UPM">
Since .dll files are stored on Git Large File Storage, you must download and install git-lfs from [here](https://git-lfs.github.com/).
1. Open the Package Manager
2. Click the add + button and select "Add package from git URL..."
Enter https://github.com/openfort-xyz/openfort-csharp-unity.git?path=/src/Packages/OpenfortSDK and click 'Add'

</TabPanel>
<TabPanel id="manifest" label="manifest.json">
  
Since .dll files are stored on Git Large File Storage, you must download and install git-lfs from [here](https://git-lfs.github.com/).
1. Open your project's Packages/manifest.json file
2. Add "com.openfort.sdk": "https://github.com/openfort-xyz/openfort-csharp-unity.git?path=/src/Packages/OpenfortSDK" in the dependencies block

</TabPanel>
</Tabs>

## 2. Set your auth providers
1. Navigate to the **auth providers** page on the [Openfort dashboard](https://dashboard.openfort.xyz)
2. Click Auth providers Methods in the side bar in the [players page](https://dashboard.openfort.xyz/players)
3. Configure the methods you want users to be able to login with

## 3. Get your [API keys](/docs/api-keys)
In the [API keys](https://dashboard.openfort.xyz/developers/api-keys) section, you'll find:
   - **Publishable Key**: Safe to expose in client-side environment
   - **Secret Key**: Must be kept secure and used only server-side

To generate non-custodial wallets:
1. Scroll to the Shield section and click **Create Shield keys**
2. **Store the encryption share** safely when it appears (you'll only see it once)
3. You'll receive:
   - **Shield Publishable Key**: Safe for client-side use
   - **Shield Secret Key**: Keep secure, server-side only

## 4. Initialize Openfort in your Unity project
Create a new script to manage the Openfort integration:

```csharp
using Openfort.OpenfortSDK;
using Openfort.OpenfortSDK.Model;

public class OpenfortManager: MonoBehaviour {
    private OpenfortSDK openfort;
    const string PublishableKey = "YOUR_OPENFORT_PUBLISHABLE_KEY";
    const string ShieldApiKey = "YOUR_SHIELD_PUBLISHABLE_KEY";
    const string ShieldEncryptionShare = "YOUR_SHIELD_ENC_SHARE";
    
    private async void Start()
    {
        openfort = await OpenfortSDK.Init(PublishableKey, ShieldApiKey, ShieldEncryptionShare);
    }
}
```

<Admonition type='note' label={`Note for WebGL Projects`}>
If you're developing for WebGL, check out the additional setup steps in the [Unity WebGL documentation](/docs/guides/unity/webgl).
</Admonition>

## 5. You're ready to build!
With Openfort configured in your Unity project, you can now:
- [Implement user authentication](/docs/guides/unity/auth/email)
- [Handle signatures](/docs/guides/unity/embedded-signer/sign-messages)

For a complete example of Openfort integration in Unity, check out our [sample projects](https://github.com/openfort-xyz/openfort-csharp-unity/tree/main/sample).


# Browse sample projects
Resources for getting started building with Openfort.

GlassPanel,
  IconPanel,
  Button,
  IconChevronRight,
} from '@/components/ui'

Explore the library of sample projects using Openfort.

Find even more samples in our [GitHub repository](https://github.com/openfort-xyz/samples#readme).

## Samples
<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href={`https://github.com/openfort-xyz/sample-unity-webgl-embedded-signer`}
    key={'webgl-embedded-signer'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='WebGL'>
        {'Openfort Auth Sample in a Unity WebGL project.'}
      </GlassPanel>
  </Link>

  <Link
    href={`https://github.com/openfort-xyz/sample-unity-android-embedded-signer`}
    key={'android-embedded-signer'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Android'>
        {'Template for integrating Openfort into a Android project.'}
      </GlassPanel>
  </Link>

  <Link
    href={`https://github.com/openfort-xyz/openfort-csharp-unity/tree/main/sample`}
    key={'auth-sample'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Unity'>
        {'Unity sample with Openfort Auth and embedded signers.'}
      </GlassPanel>
  </Link>

</div>

## Backend

<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href={`/guides/resources/backend/playfab`}
    key={'user-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='PlayFab'>
        {'Template for integrating Openfort into a PlayFab backend.'}
      </GlassPanel>
  </Link>

    <Link
    href={`/guides/resources/backend/firebase-extension`}
    key={'user-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Firebase'>
        {'Template for integrating Openfort into a Firebase backend.'}
      </GlassPanel>
  </Link>

    <Link
    href={`/guides/resources/backend/unity-gaming-services`}
    key={'user-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Unity Gaming Service'>
        {'Template for integrating Openfort into a UGS backend.'}
      </GlassPanel>
  </Link>

</div>

## Miscellaneous
<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href={`/guides/resources/apple-iap-unity`}
    key={'user-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='In-app Purchases'>
        {'Use In-App Purchase (IAP) to buy assets in your mobile game.'}
      </GlassPanel>
  </Link>

  <Link
    href={`https://github.com/openfort-xyz/openfort-fc-frames-demo`}
    key={'user-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Farcaster Frame'>
        {'Build Frames and make transactions onchain with Openfort.'}
      </GlassPanel>
  </Link>

  <Link
    href={`https://github.com/openfort-xyz/lost-dungeon`}
    key={'user-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Open source Lost Dungeon'>
        {'Discover how Lost Dungeon (Openfort game) is built.'}
      </GlassPanel>
  </Link>

</div>

Implemented your own library or an example you'd like to share? Send a link to your code to support@openfort.xyz and we'll be happy to add it to the list!


# Security & Trust at Openfort
Protecting your users' data with rigorous security measures and industry best practices.

<Security />


# Unity SDK Troubleshooting
The Openfort SDK for Unity helps you integrate your game.

## Platform and Compatibility

### Q: Can I test the SDK using the Unity Editor for Android and iOS?
A: Yes, you can test the SDK using the Unity Editor for Android and iOS on both Mac and Windows. However, be aware that:
- Native Android and iOS WebViews cannot run in the editor.
- The macOS WebView is used for the Mac Unity Editor.
- The Windows WebView is used for the Windows Unity Editor.

For the most accurate testing, we recommend using an actual device or emulator.

### Q: Do you support IL2CPP for Windows?
A: Currently, we do not support IL2CPP on the Windows platform.

### Q: I'm getting "Webview is not supported on this platform." How do I fix this?
A: This error suggests that the WebView is not properly set up for your target platform. Ensure that you've correctly installed and configured the WebView plugin for your specific platform. If the issue persists, check our documentation for platform-specific setup instructions.

## Installation and Setup

### Q: I'm getting "The type or namespace name 'Shared' does not exist in the namespace 'VoltstroStudios.UnityWebBrowser' (are you missing an assembly reference?)". How do I fix this?
A: This error often occurs when large files like `.dll` are not properly downloaded. To resolve this:
1. Download and install git-lfs from [https://git-lfs.com/](https://git-lfs.com/)
2. Clone the repository again or pull the latest changes.

If the issue persists, ensure that all project dependencies are correctly installed and that your Unity version is compatible with the SDK.

## Authentication and Login

### Q: Can I log in using a WebView instead of opening the browser?
A: The SDK primarily uses the system browser for authentication due to security considerations. However, if you have specific requirements for using a WebView, please contact our support team to discuss potential alternatives.

### Q: Why is the in-app browser used for login on mobile and not a WebView?
A: The in-app browser is used for enhanced security, especially for single sign-on (SSO) purposes:
- It runs on a separate process from the hosting game, preventing the game from accessing or modifying its content.
- It's more resistant to malicious code injection.
- WebViews, in contrast, can be more easily controlled by the hosting game, making them potentially less secure for authentication processes.

### Q: On iOS, when using AuthenticateWithOAuth login function, I get an alert asking: "[My Game] Wants to Use 'openfort.sdk' to Sign in". Can I modify or remove this alert?
A: This alert is system-generated by iOS when using `ASWebAuthenticationSession` for secure authentication. Unfortunately, it cannot be removed or modified as it's triggered by the operating system. You can find more information about this in the [Apple Developer Documentation](https://developer.apple.com/documentation/authenticationservices/aswebauthenticationsession).

## Functionality

### Q: Can I use the Unity SDK for crafting (burn and mint) assets?
A: Yes, the SDK supports various blockchain operations, including minting and burning assets. For specific implementation details, please refer to our documentation on asset management or contact our support team for guidance.

## Troubleshooting

### Q: I'm getting "TimeoutException: Exceed Timeout:00:01:00". What does this mean?
A: This exception occurs when a function call takes longer than the default timeout of one minute to return a response. To resolve this:
1. Check the bottom of the stack trace or logs to identify the specific function causing the timeout.
2. If needed, you can customize the timeout duration using the `SetCallTimeout` function.
3. Ensure your network connection is stable and that you're not experiencing unusually high latency.


# WebGL Setup


Openfort's Unity SDK leverages an iframe to secure the key material for a user's embedded wallet. Given the use of an iframe, we recommend testing builds with Openfort's Unity SDK in the browser, or on a non-WebGL platform in the Unity editor.

<Admonition type="tip">

Watch this [demo](https://github.com/openfort-xyz/sample-unity-webgl-embedded-signer) of setting up the Openfort SDK in a Unity Project!

</Admonition>

To configure settings for your WebGL build to work with Openfort, go to your Project Settings in the Unity editor. Next, select Player and navigate to WebGL. Set the following values:

- **In Resolution and Presentation**, select `openfort`.

<div align="center">
  <img
    alt="unity-webgl-template"
    src="https://blog-cms.openfort.xyz/uploads/webgl_template_3147c927c2.png"
    width="80%"
    height="80%"
  />
</div>

- In **Other Settings/Optimization, managed stripping level** to **minimal**
<div align="center">
  <img
    alt="unity-stripping"
    src="https://blog-cms.openfort.xyz/uploads/stripping_unity_c848e1df33.png"
    width="80%"
    height="80%"
  />
</div>


# Dashboard
Get up and running with SDKs, API keys, and integration tools.

**Use Openfort's [dashboard](https://dashboard.openfort.xyz) to manage your apps, retrieve your API keys, and manage the administrators for your account.**

Openfort is a hosted platform which makes it very simple to get started without needing to manage any infrastructure.

## Guides
<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href={`/guides/dashboard/ecosystem/`}
    key={'dsahboard-branding'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Customization'>
        {'Use your ecosystem branding'}
      </GlassPanel>
  </Link>

    <Link
    href={`/guides/dashboard/team`}
    key={'dsahboard-team'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Manage team'>
        {'Invite others to collaborate and manage their permissions.'}
      </GlassPanel>
  </Link>

  <Link
    href={`/guides/dashboard/gas-sponsorship`}
    key={'user-accounts'}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Gas sponsorship'>
        {'Sponsor your users gas fees'}
      </GlassPanel>
  </Link>

</div>


# Ecosystem wallet


GlassPanel,
  IconPanel,
  Button,
  IconChevronRight,
} from '@/components/ui'

Openfort **ecosystem wallets** is designed to help you create your ideal wallet and make it **interoperable across multiple games and applications**. With ecosystem you can move assets between different apps and can easily prove ownership of, sign messages, or send transactions.

<Admonition type="tip">

Check out the [live demo](https://rapidfire.sample.openfort.xyz/) of using an ecosystem wallet!

</Admonition>

<Admonition type="note">

Ecosystem wallets are whitelabel and allow you to own the entire developer experience. **In short, you own the _npm package_ the developer installs.**

</Admonition>

### Features

| Feature                                   | Status |
|-------------------------------------------|--------|
| Sign in with email                        | ✅      |
| Sign in with OAuth                        | ✅      |
| Sign in with Third-Party Auth             | ✅      |
| Embedded wallet creation                  | ✅      |
| Embedded wallet recovery                  | ✅      |
| Embedded wallet signatures & transactions | ✅      |
| Embedded wallet key | Native smart wallets                      | ✅      |
| Gas sponsorship                           | ✅      |
| Session keys                              | ✅      |
| Social recovery                           | ✅      |

{/* ## Use cases

Operating across multiple Openfort accounts is common practice for many projects. Consider the following scenarios:

| SCENARIO | DESCRIPTION |
|---|---|
| **Token-based projects** | Create separate smart accounts for each project onboarded to use the same assets and tokens. |
| **Ecosystem Wallet** | Create separate smart accounts for each independent project looking to use your wallet branding. |
| **Ecosystem ID** | Manage wallets and identities, represented in the different games you control under a brand. | */}

{/* ## Choose your Ecosystem type
When using ecosystem you must onboard each independent project  that signs up to use your authentication solution. 

|  | STANDARD | CUSTOM |
|---|---|---|
| Integration effort | Lowest | Significantly higher |
| Integration method | API or OAuth | API |
| Onboarding | Openfort | Platform or Openfort |
| User can access the Dashboard? | Yes, full Dashboard | No |
| User support provided by | Platform and Openfort | Platform |
| Automatic updates for new compliance requirements | Yes | No |
| Ideal for platforms | With experienced online businesses as users | With significant engineering resources to dedicate to a fully white-labeled experience |
 */}
{/* 
You can use Ecosystems to:
- Gain a **holistic view** of your entire ecosystem includind players, transactions and any game you onboarded.
- Manage **ecosystem parameters** like ecosystem assets, gas policies or player database in one single dashboard. 
- Offer a **unified login experience** for your ecosystem projects.
- Incorporate **smart wallet** capabilities in your chain. */}

## Get started

Check out these popular guides to get started.

<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href={`/guides/ecosystem/getting-started`}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Create your ecosystem wallet'>
        {'Step by step guide to create your own wallet.'}
      </GlassPanel>
  </Link>

    <Link
    href={`/guides/ecosystem/libraries`}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Wallet connectors'>
        {'Using an ecosystem wallet with popular wallet connectors.'}
      </GlassPanel>
  </Link>

      <Link
    href={`/guides/ecosystem/web-app-wagmi`}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Wallet connectors'>
        {'Integrate an ecosystrem wallet with WAGMI.'}
      </GlassPanel>
  </Link>

</div>

## Templates

<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href="https://github.com/openfort-xyz/ecosystem-sample"
    key="ecosystem-sample"
    className="col-span-12 md:col-span-4"
  >
    <GlassPanel title="Ecosystem Sample" icon="/docs/img/icons/github-icon-light" hasLightIcon={true}>
      Complete sample including auth, transactions and session keys.
    </GlassPanel>
  </Link>

    <Link
    href="https://github.com/openfort-xyz/ecosystem-wallet-expo-example"
    key="ecosystem-expo"
    className="col-span-12 md:col-span-4"
  >
    <GlassPanel title="Expo with Ecosystem" icon="/docs/img/icons/github-icon-light" hasLightIcon={true}>
      Sample how to integrate ecosystem wallet with Expo.
    </GlassPanel>
  </Link>
</div>


# Quickstart


GlassPanel,
  IconPanel,
  Button,
  IconChevronRight,
} from '@/components/ui'

**The [Openfort JS SDK](https://www.npmjs.com/package/@openfort/openfort-js) is a low level library that allows you to build custom login flows, request signatures and more.**

<Admonition type='tip' label='Want to start building right away?'>
  If you're looking to quickly integrate **OpenfortKit** into your app, check out our [React](/docs/guides/react) guides.
</Admonition>

You will get out of the box support for:
1. Multiple login methods
2. Bare-meteal API access to customize your own UI
3. Non-custodial embedded signer
4. Account abtraction compatioble accounts and infrastructure

Check out the [starter repos](/docs/guides/javascript/resources) for templates for integrating Openfort with various libaries, frameworks and use cases.

## 1. Install the Openfort SDK

Install the latest version of the [Openfort JS SDK](https://www.npmjs.com/package/@openfort/openfort-js) using your package manager of choice:

<Admonition type='note' label='Prerequisites'>
In order to integrate Openfort, you project must:
- a **Node v20** (Active LTS version) or **higher**. 
- a [minimum TypeScript version of 5](https://github.com/microsoft/TypeScript/releases/tag/v5.0.2)
</Admonition>

<Tabs
scrollable
size="small"
type="underlined"
defaultActiveId="npm"
>
<TabPanel id="npm" label="npm">
  
```sh Terminal
npm install @openfort/openfort-js@latest
```
</TabPanel>
<TabPanel id="yarn" label="yarn">
  
```sh Terminal
yarn add @openfort/openfort-js@latest
```
</TabPanel>
<TabPanel id="pnpm" label="pnpm">
  
```sh Terminal
pnpm install @openfort/openfort-js@latest
```
</TabPanel>
</Tabs>

## 2. Set your auth providers
Navigate to the **auth providers** page on the [Openfort dashboard](https://dashboard.openfort.xyz) by selecting your project and then clicking Auth providers Methods in the side bar in the [players page](https://dashboard.openfort.xyz/players). Select the account types you'd like users to be able to login with. For more information on how to enable social logins, check out the [dashboard docs](/docs/guides/dashboard/social-login).

## 3. Get your [API keys](/docs/api-keys)
In the [API keys](https://dashboard.openfort.xyz/developers/api-keys) section, you'll find:
   - **Publishable Key**: Safe to expose in client-side environment
   - **Secret Key**: Must be kept secure and used only server-side

To generate non-custodial wallets:
1. Scroll to the Shield section and click **Create Shield keys**
2. **Store the encryption share** safely when it appears (you'll only see it once)
3. You'll receive:
   - **Shield Publishable Key**: Safe for client-side use
   - **Shield Secret Key**: Keep secure, server-side only

## 4. Import Openfort into your app
In your project, 
Concretely, the Openfort SDK needs to be instantiated only once.

```ts server.ts

const openfort = new Openfort({
  baseConfiguration: {
    publishableKey: "YOUR_OPENFORT_PUBLISHABLE_KEY",
  },
  shieldConfiguration: {
    shieldPublishableKey: "YOUR_SHIELD_PUBLISHABLE_KEY",
  }
});
```

## 5. You're good to go!
Once you've configured your app, you can now use `openfort` throughout to access the Openfort SDK.

Check out our [starter repo](https://github.com/openfort-xyz/openfort-js/tree/main/examples/apps/auth-sample) to see what a simple end-to-end integration looks like, or read on to learn how you can use Openfort to:

- [Log your users in](/docs/guides/javascript/auth).
- [Request signatures](/docs/guides/javascript/embedded-signer/sign-messages).


# Overview React Native


GlassPanel,
  IconPanel,
  Button,
  IconChevronRight,
} from '@/components/ui'

The [Openfort React Native SDK]() is a React Native library client for Openfort that allows you to add secure authentication, non-custodial embedded wallets, and powerful account abstraction into your application.

### Features

| Feature                                   | Status |
|-------------------------------------------|--------|
| Sign in with email                        | ✅      |
| Sign in with OAuth                        | ✅      |
| Sign in with wallets (SIWE)               | ✅      |
| Sign in with Third-Party Auth             | ✅      |
| Sign in with Farcaster (SIWF)             | 🚧      |
| Embedded wallet creation                  | ✅      |
| Embedded wallet recovery                  | ✅      |
| Embedded wallet signatures & transactions | ✅      |
| Embedded wallet key | Native smart wallets                      | ✅      |
| Gas sponsorship                           | ✅      |
| Session keys                              | ✅      |
| Social recovery                           | ✅      |

## Get started

Check out these popular guides to get started.

<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href={`/guides/react-native/quickstart`}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Setting up the SDK'>
        {'Setting up and importing a project'}
      </GlassPanel>
  </Link>

  <Link
    href={`/guides/react-native/recover`}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Embedded wallet'>
        {'Create an embedded wallet'}
      </GlassPanel>
  </Link>

</div>

## Templates

Check out these popular samples to get started.

<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href="https://github.com/openfort-xyz/react-native-auth-sample"
    className="col-span-12 md:col-span-4"
  >
    <GlassPanel title="React Native Sample" icon="/docs/img/icons/github-icon-light" hasLightIcon={true}>
      Check our React Native sample
    </GlassPanel>
  </Link>

    <Link
    href="https://github.com/openfort-xyz/sample-telegram"
    className="col-span-12 md:col-span-4"
  >
    <GlassPanel title="Telegram sample" icon="/docs/img/icons/github-icon-light" hasLightIcon={true}>
      Integrate a mini-app with Telegram
    </GlassPanel>
  </Link>

</div>


# Using Openfort from your server 
Get up and running with SDKs, API keys, and integration tools.

Openfort's client-side SDKs, like [`@openfort/openfort-js`](https://www.npmjs.com/package/@openfort/openfort-js), allow you to securely authenticate your users, connect their wallets, and create embedded wallets for them in your application frontend.

In addition to these SDKs, you can also use **Openfort from your server** to secure and manage your application. See the guides below for some common flows.

## Get started
<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href="/guides/server/dev"
    key="dev-accounts"
    className="col-span-12 md:col-span-4"
  >
    <GlassPanel title="Backend wallets">
      Create backend wallets for your application.
    </GlassPanel>
  </Link>

  <Link
    href="/guides/server/access-token"
    key="token-verification"
    className="col-span-12 md:col-span-4"
  >
    <GlassPanel title="Verification">
      Verify the authenticity of a user's access token.
    </GlassPanel>
  </Link>

  <Link
    href="/guides/server/pregenerate-wallets"
    key="signer-pregeneration"
    className="col-span-12 md:col-span-4"
  >
    <GlassPanel title="Wallet pregeneration">
      Generate wallets for users before they sign up.
    </GlassPanel>
  </Link>

</div>

## SDKs and API reference
<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href="/reference/api/introduction?lang=ts"
    key="nodejs"
    className="col-span-12 md:col-span-4"
  >
    <GlassPanel title="NodeJS" icon="/docs/img/icons/libraries/node" hasLightIcon={true}>
      NodeJS SDK for interacting with Openfort's infrastructure.
    </GlassPanel>
  </Link>

  <Link
    href="/reference/api/introduction?lang=csharp"
    key="csharp"
    className="col-span-12 md:col-span-4"
  >
    <GlassPanel title="C#" icon="/docs/img/icons/libraries/c-sharp-icon" hasLightIcon={true}>
      C# SDK for interacting with Openfort's infrastructure.
    </GlassPanel>
  </Link>

  <Link
    href="/reference/api/introduction?lang=csharp"
    key="api-reference"
    className="col-span-12 md:col-span-4"
  >
    <GlassPanel title="API reference" icon="/docs/img/icons/api-icon" hasLightIcon={true}>
      API reference for interacting with Openfort's infrastructure.
    </GlassPanel>
  </Link>

</div>


# Overview Unity


GlassPanel,
  IconPanel,
  Button,
  IconChevronRight,
} from '@/components/ui'

The [Openfort Unity SDK](https://github.com/openfort-xyz/openfort-csharp-unity) is a Unity library client for Openfort that allows you to add secure authentication, non-custodial embedded wallets, and powerful UX infrastructure into your game.

## Features

| Feature                                   | Status |
|-------------------------------------------|--------|
| Sign in with email                        | ✅      |
| Sign in with OAuth                        | ✅      |
| Sign in with guest mode                        | ✅      |
| Sign in with Third-Party Auth             | ✅      |
| Embedded wallet creation                  | ✅      |
| Embedded wallet recovery                  | ✅      |
| Embedded wallet signatures & transactions | ✅      |
| Native smart wallets                      | ✅      |
| Gas sponsorship                           | ✅      |
| Session keys                              | ✅      |
| Compatible with Telegram mini-apps        | ✅      |

## Supported platforms

- Windows (64-bit)
- macOS (minimum version 12.5)
- Android (minimum version 5.1)
- iOS (minimum version 15.2)

<Admonition type="note" label='SUPPORTED UNITY VERSIONS'>
- Unity 2021.3 or newer for Windows, macOS, Android and iOS
- Unity 2019.4 or newer for macOS, Android, and iOS. Windows isn't supported on Unity versions from 2019.4 up through 2021.2.

</Admonition>

<Admonition type="note" label='TARGET PLATFORM VS UNITY EDITOR PLATFORM'>
We have added compilation flags to the Unity SDK to ensure that specific Unity editors can only build certain platform targets. Please note that the table below indicates which editor you can use to build a platform target, but it does not determine whether you can run the SDK in that editor.

For example, the SDK allows you to build iOS games using a macOS Unity Editor, but you cannot use the Windows Unity Editor.

| Target Platform | Windows Unity Editor | macOS Unity Editor |
|-----------------|:---------------------:|:-------------------:|
| Windows         | ✅                   | ❌                 |
| macOS           | ❌                   | ✅                 |
| Android         | ✅                   | ✅                 |
| iOS             | ❌                   | ✅                 |
| Web             | ✅                    | ✅                 |

</Admonition>

## Get started

Check out these popular guides to get started.

<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href={`/guides/unity/quickstart`}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Setting up the SDK'>
        {'Setting up and importing a project'}
      </GlassPanel>
  </Link>

  <Link
    href={`/guides/unity/webgl`}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='WebGL'>
        {'Using embedded wallets with WebGL'}
      </GlassPanel>
  </Link>

  <Link
    href={`/guides/unity/embedded-signer/recovery`}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Embedded wallet'>
        {'Create an embedded wallet'}
      </GlassPanel>
  </Link>

</div>

## Templates

Check out these popular samples to get started.

<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href="https://github.com/openfort-xyz/openfort-csharp-unity/tree/main/sample"
    className="col-span-12 md:col-span-4"
  >
    <GlassPanel title="Unity Sample" icon="/docs/img/icons/github-icon-light" hasLightIcon={true}>
      Check our latest Unity sample
    </GlassPanel>
  </Link>

    <Link
    href=""
    className="col-span-12 md:col-span-4"
  >
    <GlassPanel title="Telegram sample" icon="/docs/img/icons/github-icon-light" hasLightIcon={true}>
      Integrate a WebGL game with Telegram
    </GlassPanel>
  </Link>

</div>


# Architecture


Openfort's smart contracts are [open source](https://github.com/openfort-xyz/openfort-contracts). Moreover, Openfort is buit on public goods infrastructure like the [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) or [ERC-6551](https://eips.ethereum.org/EIPS/eip-6551) standards. We choose open source tools which are scalable and make them simple to use.

Openfort is not a 1-to-1 mapping of any wallet solution you've seen. While we offer many of the features that other solutions have, we go much further than anyone else because: (1) We're based on smart accounts not EOAs, and (2) we build the server stack so you don't have to worry about the reliability of the infrastructure.

## Architecture

Openfort consists of modules that allow you to plug-and-play the tools to achieve your success.

Our infrastructure orchestrates everything under the hood to make the development and maintenance easy. The 4 key components we take care of are:

- **Smart accounts**: We offer optimized and diverse set of smart accounts to fit your needs. [Types of smart accounts](https://github.com/openfort-xyz/openfort-contracts).
- **Embedded Signers**: Signers create non-custodial wallets for your users. [Embedded wallet](/docs/guides/javascript/wallets).
- **Bundlers/RPCs**: We built a Meta Bundler Network to ensure reliable access to the blockchain. If one fails, another takes over.
- **Paymasters**: We built the most customizable paymasters to configure granular rate limits and policies for gas sponsoring, through either our API or dashboard.
- **Backend wallets**: These are externally-owned accounts to be used internally to manage the projects flows and experience. They can execute logic like escrow for competition or sending a minted asset to a user after winning a competition.

<div align="center">
  <img
    alt="Openfort Architecture"
    src="https://blog-cms.openfort.xyz/uploads/Group_295_min_3ec4bfb35f.png"
    width="100%"
    height="100%"
  />
  <label>Diagram of Openfort architecture</label>
</div>

Our goal at Openfort is to make _all_ of smart accounts easy to use and invisible to the user. That doesn't mean you can't enjoy all the benefits of it. If you're a app developer, you'll probably be familiar with the integrations we offer. If you're a blockchain developer it means you'll probably be able to use every inch of features and benefits we offer. In either scenario Openfort helps you build you weekend hackathon or your ambitious AAA game.


# Authentication


Openfort provides a comprehensive suite of authentication features to ensure secure and flexible user access to your platform. Here's a summary of the key authentication capabilities:

<div align="center">
  <img
    alt="Picture of ecosystems and wallet"
    src="https://blog-cms.openfort.xyz/uploads/auth_90f116d585.png?updated_at=2025-01-22T17:48:15.843Z"
    width="80%"
    height="80%"
  />
</div>

### OAuth Login

Implement OAuth-based authentication flows to allow users to sign in using their accounts from popular social media platforms or other OAuth providers. This method enhances user convenience and can increase sign-up rates.

### Password Auth

Set up secure password-based authentication. Always salt and pepper passwords before hashing to enhance security against brute-force attacks.

### SIWE (Sign-In with Ethereum)

Enable users with existing Ethereum wallets to authenticate seamlessly using the Sign-In with Ethereum (SIWE) protocol. This feature bridges the gap between traditional web applications and blockchain-based identities.

### User Sessions

Manage the lifecycle and security of user sessions effectively. Implement secure session identifiers, enforce HTTPS for all sessions, and set appropriate expiration times to maintain a balance between security and user experience.

### Custom Auth

Integrate third-party authentication providers or custom authentication systems alongside Openfort's embedded wallets. This flexibility allows you to maintain your existing authentication stack while adding blockchain capabilities.

### Guest Access

Enable temporary guest accounts for users who want to explore your platform without full registration. Configure guest user permissions and create dedicated homepages or experiences for these temporary users.

### Account Linking

Connect multiple authentication methods to a single user account. This feature allows users to access their account through various identity providers while maintaining a unified profile within your application.


# Backend Wallets


Openfort provides powerful backend wallet APIs that allow developers to provision and manage wallets directly from their server-side applications. These backend wallets offer a robust set of features for creating, controlling, and automating blockchain interactions at scale.

<div align="center">
  <img
    alt="Picture of ecosystems and wallet"
    src="https://blog-cms.openfort.xyz/uploads/backend_f8a8eff4b8.png?updated_at=2025-01-22T17:48:15.720Z"
    width="80%"
    height="80%"
  />
</div>

### Direct Backend Control

Unlike user-centric embedded wallets, backend wallets are designed to be controlled directly by your application's backend. This allows for programmatic wallet management and transaction execution without requiring user intervention. Backend wallets are ideal for scenarios where you need to manage wallets at scale or automate blockchain interactions.

### Multi-chain Support

Openfort's backend wallets support multiple blockchain networks, including Ethereum and all EVM-compatible chains. This multi-chain functionality allows developers to create and manage wallets across various networks from a single API interface, simplifying cross-chain operations and expanding the reach of their applications.

### Flexible Wallet Types

Developers can choose between using Externally Owned Accounts (EOAs) or Smart Contract wallets, depending on their specific requirements. This flexibility allows for customized wallet architectures that best suit the needs of the application and its users.

### State Synchronization

Backend wallets offer seamless state synchronization between your application and the blockchain. Through webhook integrations, developers can register event listeners for transaction status updates and incoming fund notifications. This feature ensures that your application remains up-to-date with on-chain events in real-time.

### Policy Engine

A powerful policy engine is included with backend wallets, enabling developers to implement granular control over wallet actions. This engine allows for the definition of specific rules, such as setting allowlisted contracts or recipients, imposing maximum transfer amounts, and enforcing other custom restrictions on wallet usage.

### High-Performance Infrastructure

Backend wallets are built on globally distributed infrastructure, designed to provide high availability and low latency. This robust architecture ensures that your application can reliably manage wallets and execute transactions at scale, with optimal performance across different geographical regions.


# Ecosystem Wallets


Openfort's ecosystem wallets provide a comprehensive solution for creating interoperable wallets across multiple games and applications within a unified ecosystem. These wallets offer advanced features that enhance user experience and simplify asset management for both players and developers.

<div align="center">
  <img
    alt="Picture of ecosystems and wallet"
    src="https://blog-cms.openfort.xyz/uploads/Whitelabel_wallet_design_6df94dcb9b.png?updated_at=2024-10-16T17:55:48.044Z"
    width="80%"
    height="80%"
  />
</div>

### Use with Web3 Libraries

Ecosystem wallets can be seamlessly integrated with popular web3 libraries, allowing developers to configure their ecosystem to be displayed in any wallet-compatible web3 library. This feature supports integration with tools like Wagmi and RainbowKit, enabling developers to incorporate ecosystem wallet functionality into existing projects while maintaining familiar development workflows. This compatibility ensures that ecosystem wallets can be easily recognized and utilized across various platforms and applications.

### Wallet UI Customization

Developers have the flexibility to customize the appearance and user interface of their ecosystem wallets. This feature allows for the creation of a branded and cohesive user experience across all applications within the ecosystem. By tailoring the wallet's look and feel, developers can ensure that it aligns with their overall design aesthetic and provides a seamless integration with their games or applications.

### Ecosystem Paymaster

The ecosystem paymaster functionality allows developers to manage gas fee rules for transactions within their ecosystem. This feature is part of the gas sponsorship capabilities offered by Openfort's smart wallet technology. By implementing ecosystem-wide policies for gas fees, developers can create a more user-friendly experience, potentially subsidizing or optimizing transaction costs across multiple applications within their ecosystem.

### Create Wallet Button

Openfort's ecosystem SDK simplifies the process of adding wallet creation functionality to applications with a single button. This feature streamlines the onboarding process for users, allowing them to create a unified wallet that works across all games and applications within the ecosystem. The Create Wallet Button leverages Openfort's embedded wallet creation capabilities, enabling a frictionless entry point for new users.

### Dashboard Setup

Ecosystem wallets can be customized and managed through a single, comprehensive dashboard. This centralized management tool allows developers to configure various aspects of their ecosystem, including wallet features, security settings, and integration parameters. The dashboard provides a user-friendly interface for developers to oversee and adjust their ecosystem's functionality, ensuring efficient management of the entire wallet infrastructure across multiple applications.


# Embedded Wallets


Openfort's embedded wallets provide a seamless way to integrate blockchain functionality into your application without requiring users to manage their own wallets. These wallets offer a range of features to enhance user experience and security, allowing for omchain interactions.

<div align="center">
  <img
    alt="Picture of ecosystems and wallet"
    src="https://blog-cms.openfort.xyz/uploads/aa_0ecf15a58e.png?updated_at=2025-01-22T17:48:15.829Z"
    width="80%"
    height="80%"
  />
</div>

### Embedded Signer

The embedded signer functionality allows for advanced signing capabilities directly within your application. Users can securely sign transactions and messages without leaving your app's interface. This feature decouples signing from the user's identity, offering a more secure and flexible transaction process. It seamlessly integrates with authentication, allowing users to approve transactions without worrying about key management.

### Export Keys

For users who want more control over their assets, Openfort provides a secure method to 
### Smart Wallet

Openfort's smart wallet feature enables advanced interactions with smart contracts, including gas sponsorship and transaction batching. The smart account layer leverages ERC-4337 standards to provide features like gasless transactions, automated batch transactions, and heightened security, all while keeping user assets secure. These smart accounts are decoupled from the signer, offering flexibility for users to control their assets independently.

### Session Keys

Session keys, also referred to as scoped preapproved transactions, provide a secure way to create temporary private keys for signing transactions. This feature enables popupless preapproved transactions, enhancing both security and usability. It's particularly useful for specific gaming or trading sessions where temporary authorized access is required.

### Sign Messages

Openfort's embedded wallets handle various message signing workflows to authenticate users or sign off-chain data. This feature allows users to sign transactions without pop-ups, with all operations happening locally on their front-end and securely. It supports different types of message signing, ensuring compatibility with various protocols.

### Security Shield

Openfort enhances the security of signing operations with additional layers of protection. The platform offers non-custodial accounts by design, ensuring that only the rightful owner can access and sign transactions. This security model is crucial for maintaining user trust and protecting digital assets.

### State Management

Openfort efficiently manages signer states to keep your application in sync with blockchain interactions. This feature is part of the overall smart account management, allowing for seamless integration with various blockchain operations. It enables developers to track transaction status, manage nonce values, and handle pending and confirmed transactions effectively.


# Infrastructure


Openfort provides robust infrastructure to support the seamless integration of blockchain functionalities into your applications. With features like REST APIs, SDKs, webhooks, and abstraction infrastructure, developers can efficiently manage their applications while providing a smooth user experience.

<div align="center">
  <img
    alt="Picture of ecosystems and wallet"
    src="https://blog-cms.openfort.xyz/uploads/whitelabel_dashboard_ef523dc779.png?updated_at=2024-09-19T13:25:55.077Z"
    width="80%"
    height="80%"
  />
</div>

### REST API

Openfort's REST API supports a wide range of endpoints that allow developers to manage their applications directly from their servers. These endpoints enable actions such as searching, creating, and deleting users with simple API calls. The API is designed to handle complex blockchain interactions effortlessly, providing developers with the tools to integrate wallet and user management functionalities into their backend systems.

### Backend SDK

For applications with a backend, Openfort offers a dedicated SDK that simplifies interaction with its REST API. This SDK allows developers to easily access API endpoints, enabling streamlined integration of features like user management, wallet creation, and transaction handling. By using the SDK, developers can reduce the complexity of implementing blockchain functionality in their backend environments.

### Webhooks

Openfort includes built-in webhooks that notify your servers whenever specific user actions occur within your application. Developers can configure events such as user creation, login, or wallet creation and set up a destination URL to receive these notifications. The webhook system ensures near real-time updates for critical events, enabling developers to automate workflows and enhance application responsiveness.

### Dashboard

The Openfort Dashboard serves as a centralized hub for managing applications. It allows administrators to retrieve API keys, configure features, and oversee account settings. From the dashboard, developers can create new apps, customize wallet configurations, and monitor key metrics about users and transactions. This intuitive interface simplifies the management of blockchain infrastructure across multiple applications.

### Account Abstraction Infrastructure

Openfort provides account abstraction infrastructure by deploying paymasters and bundlers to support smart wallet compatibility from day one. This infrastructure enables advanced features like gasless transactions and transaction batching while maintaining compatibility with ERC-4337 standards. Developers can leverage this abstraction layer to simplify user onboarding and optimize transaction workflows.

### Chain Abstraction Infrastructure

Openfort offers chain abstraction infrastructure through the deployment of vaults, invoices, and proof systems. This setup allows developers to implement chain-abstracted balances from the start, enabling seamless multi-chain support for wallets and transactions. By abstracting chain-specific complexities, Openfort ensures a consistent experience across different blockchain networks.


# Browse sample repos
Resources for getting started building with Openfort.

GlassPanel,
  IconPanel,
  Button,
  IconChevronRight,
} from '@/components/ui'

Find even more samples in our [GitHub repository](https://github.com/openfort-xyz/samples#readme).

## Starter repos

Explore the library of sample projects using Openfort.

<div className="grid grid-cols-12 gap-6 not-prose">
{
  [
    {
      title: 'Openfort Kit Sample',
      description: 'Openfort Kit is the easiest way to onboard your users onchain.',
      href: 'https://github.com/openfort-xyz/openfort-kit/tree/main/examples'
    },
    {
      title: 'Openfort JS Sample',
      description: 'Openfort Auth Sample in a NextJS project.',
      href: 'https://github.com/openfort-xyz/openfort-js/tree/main/examples/apps/auth-sample'
    },
    {
      title: 'Expo starter repo',
      description: 'Template for integrating openfort into a bare Expo (vanilla React Native) app',
      href: 'https://github.com/openfort-xyz/react-native-auth-sample'
    },
    {
      title: 'Wagmi starter repo',
      description: 'Wagmi sample with embedded signer.',
      href: 'https://github.com/openfort-xyz/openfort-js/tree/main/examples/apps/wallet-libraries/vite-wagmi'
    },
    {
      title: 'Third-party auth starter repo',
      description: 'Third-party auth with embedded signer.',
      href: 'https://github.com/openfort-xyz/embedded-wallet-firebase-auth-sample-nextjs'
    },
    {
      title: 'Unity starter repo',
      description: 'Using Unity SDK with Openfort.',
      href: 'https://github.com/openfort-xyz/openfort-csharp-unity/tree/main/sample'
    },
    {
      title: 'Unity WebGL starter repo',
      description: 'Integration of Openfort with a WebGL build.',
      href: 'https://github.com/openfort-xyz/openfort-csharp-unity/tree/main/sample/Assets/WebGLTemplates'
    },
    {
      title: 'Ecosystem wallet starter repo',
      description: 'Example of an ecosystem wallet with embedded signer.',
      href: 'https://github.com/openfort-xyz/ecosystem-sample'
    }
  ].map((data)=> (
    <Link
      href={data.href}
      key={data.title}
      className={'col-span-12 md:col-span-4'}>
        <GlassPanel title={data.title}>
          {data.description}
        </GlassPanel>
    </Link>
  ))
}

</div>


# Welcome to Openfort
Openfort features

Openfort builds secure wallet infrastructure and user authentication to enable better Web3 products. We provide embedded wallet solutions and ecosystem wallet capabilities that allow applications to seamlessly integrate digital asset functionality for users, businesses, and automated systems.

Use Openfort's client-side SDKs to authenticate users, create embedded wallets, manage transactions, and build ecosystem wallets that work across multiple applications. Leverage server-side capabilities to securely control digital assets at the application level directly from your backend.

<div className="grid grid-cols-12 gap-6 not-prose">
  <Link
    href={`https://dashboard.openfort.xyz/`}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Create a new project'>
        {'Get API keys and start building'}
      </GlassPanel>
  </Link>

    <Link
    href={`https://create-next-app.openfort.xyz/`}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Try our demo'>
        {'Sign in to our demo account'}
      </GlassPanel>
  </Link>

  <Link
    href={`https://discord.com/invite/t7x7hwkJF4`}
    className={'col-span-12 md:col-span-4'}>
      <GlassPanel title='Join our community'>
        {'Get support and share your projects'}
      </GlassPanel>
  </Link>
</div>

## Using Openfort
Openfort enables:
- **User Authentication** —Openfort helps developers implement secure user authentication regardless of their Web3 experience. Our libraries support both connecting existing wallets and creating embedded wallets for new users.
- **Wallet Infrastructure** —Developers can access Openfort's robust wallet APIs from their backend using server-side integration to manage cross-chain wallets for various use cases.
- **Ecosystem Wallets** —Create and manage whitelabel wallets that work seamlessly across multiple games and applications within your ecosystem. Move assets between different apps, prove ownership, sign messages, and send transactions with a unified experience.

---

## Product Principles

It is our goal to provide an architecture that any large-scale company would design for themselves,
and then provide tooling around that architecture that is easy-to-use for indie-developers and small teams.

We use a series of principles to ensure that scalability and usability are never mutually exclusive:

### Everything works in isolation

Each system must work as a standalone tool with as few moving parts as possible.
The litmus test for this is: "Can a user run this product with nothing but a Postgres database?"

### Everything is integrated

Openfort is composable. Even though every product works in isolation, each product on the platform needs to 10x the other products.
For integration, each tool should expose an API and Webhooks.

### Everything is extensible

We're deliberate about adding a new tool, and prefer instead to extend an existing one.
This is the opposite of many cloud providers whose product offering expands into niche use-cases. We provide _primitives_ for developers, which allow them to achieve any goal.
Less, but better.

### Everything is portable

To avoid lock-in, we make it easy to migrate in and out. Our cloud offering is compatible with our self-hosted product.
We use existing standards to increase portability (like pg_dump and CSV files). If a new standard emerges which competes with a "Openfort" approach, we will deprecate the approach in favor of the standard.
This forces us compete on experience. We aim to be the best Postgres hosting service.

### Build for developers

"Developers" are a specific profile of user: they are _builders_.
When assessing impact as a function of effort, developers have a large efficiency due to the type of products and systems they can build.
As the profile of a developer changes over time, Openfort will continue to evolve the product to fit this evolving profile.


# Entity Addresses
Check out the addresses used by Openfort

<Addresses />


# Using AI-powered IDEs with our docs


<AiTooling />


# API keys


<ApiKeys />


# Supported Chains
Openfort supported blockchains

<Chains />


# Openfort Documentation
Openfort is an infrastructure provider built for web3 gaming.

Button,
  GlassPanel,
  IconBackground,
  IconChevronRight,
  IconPanel,
  IconPlay,
  TextLink,
} from '@/components/ui'

<div className="flex flex-col">

  <div>
    <div className="max-w-xl pb-2">
      ## Products
    </div>

    <div className="grid grid-cols-12 gap-6 not-prose [&_svg]:text-orange-600 [&_svg]dark:text-orange-600">
      {products.map((product) => {
        return (
          <Link href={product.href} key={product.title}  className={product.span ?? 'col-span-12 md:col-span-4'}>
              <GlassPanel {...product} icon={<HomeMenuIconPicker icon={product.icon} width={18} height={18} />} background={true} showIconBg={true} showLink={false}>
                {product.description}
              </GlassPanel>

          </Link>
        )
      })}
    </div>

    <div className="flex flex-col lg:grid grid-cols-12 gap-6 py-12 border-b">

      <div className="col-span-4 flex flex-col gap-1 [&_h2]:m-0 [&_h3]:m-0">

        <div className="md:max-w-xs 2xl:max-w-none">
          <div className="flex items-center gap-3 mb-3 text-orange-600 dark:text-brand">
            ## Client Libraries
          </div>
        </div>

      </div>

      <div className="grid col-span-8 grid-cols-12 gap-6 not-prose">
        {clientLibraries.map((product) => {
          return (
            <Link href={product.href} key={product.title}  className={product.span ?? 'col-span-6 md:col-span-4'}>
                <IconPanel
                  {...product}
                  icon={<HomeMenuIconPicker icon={product.icon} width={18} height={18} />}
                  background={true}
                  showIconBg={true}
                  showLink={false}
                >
                  {product.description}
                </IconPanel>

            </Link>
          )
        })}
      </div>
    </div>

    <div className="flex flex-col lg:grid grid-cols-12 gap-6 py-12 border-b">

      <div className="col-span-4 flex flex-col gap-1 [&_h2]:m-0 [&_h3]:m-0">

        <div className="md:max-w-xs 2xl:max-w-none">
          <div className="flex items-center gap-3 mb-3 text-orange-600 dark:text-brand">

            ## Server Libraries
          </div>
        </div>

      </div>

      <div className="grid col-span-8 grid-cols-12 gap-6 not-prose">
        {serverLibraries.map((product) => {
          return (
            <Link href={product.href} key={product.title}  className={product.span ?? 'col-span-6 md:col-span-4'}>
                <IconPanel
                  {...product}
                  icon={<HomeMenuIconPicker icon={product.icon} width={18} height={18} />}
                  background={true}
                  showIconBg={true}
                  showLink={false}
                >
                  {product.description}
                </IconPanel>

            </Link>
          )
        })}
      </div>
    </div>

    {/* <div className="flex flex-col lg:grid grid-cols-12 gap-6 py-12 border-b dark:border-zinc-700">

      <div className="col-span-4 flex flex-col gap-1 [&_h2]:m-0">

        ## Integrate with Openfort

        <TextLink
          label="Explore more resources"
          url="/guides/resources"
          className="no-underline text-brand text-sm"
        />
      </div>

      <div className="grid col-span-8 grid-cols-12 gap-6 not-prose">
        {migrationGuides.map((product) => {
          return (
            <Link
              href={product.href}
              key={product.title}
               className={product.span ?? 'col-span-6 md:col-span-4'}>
                <IconPanel {...product} background={true} showIconBg={true} showLink={false}>
                  {product.description}
                </IconPanel>

            </Link>
          )
        })}
      </div>

    </div> */}

  </div>

  <div className="flex flex-col gap-6 py-12 border-b dark:border-zinc-700">

    <div className="col-span-4 flex flex-col gap-1 [&_h2]:m-0 [&_h3]:m-0">

      ### Additional resources

    </div>

    <div className="grid grid-cols-12 gap-6 not-prose">
      {additionalResources.map((product) => {
        return (
          <Link
            href={product.href}
            key={product.title}
            className={product.span ?? 'col-span-12 md:col-span-6 lg:col-span-3'}>
              <GlassPanel {...product} icon={<HomeMenuIconPicker icon={product.icon} width={18} height={18} />} background={false}>
                {product.description}
              </GlassPanel>

          </Link>
        )
      })}
    </div>

  </div>
{/* distributeddd
distributed */}
  {/* <div className="flex flex-col lg:grid grid-cols-12 gap-6 py-12">

    <div className="col-span-4 flex flex-col gap-1 [&_h2]:m-0 [&_h3]:m-0">

      <div className="md:max-w-xs 2xl:max-w-none">
        <div className="flex items-center gap-3 mb-3 text-orange-600 dark:text-orange-400">
          <IconBackground>
            <HomeMenuIconPicker icon="self-hosting" width={18} height={18} />
          </IconBackground>
          ### Migrate to Openfort
        </div>
        <p className="text-zinc>-900 text-sm">
          Get started with self-hosting Supabase.
        </p>
        <TextLink
          label="More on Self-Hosting"
          url="/guides/self-hosting"
          className="no-underline text-orange-600 text-sm"
        />
      </div>

    </div>

      <div className="grid col-span-8 grid-cols-12 gap-6 not-prose">
        {migrationGuides.map((product) => {
          return (
            <Link
              href={product.href}
              key={product.title}
               className={product.span ?? 'col-span-6 md:col-span-4'}>
                <IconPanel {...product} background={true} showIconBg={true} showLink={false}>
                  {product.description}
                </IconPanel>

            </Link>
          )
        })}
      </div>

  </div> */}

</div>

  {
    title: 'Embedded wallets',
    icon: 'client-side',
    hasLightIcon: true,
    href: '/guides/react',
    description:
      'Add and manage email and password, OAuth, and mobile logins to your project to onboard user with an open-source non-custodial embedded smart wallet.',
  },
  {
    title: 'Ecosystem wallets',
    icon: 'infrastructure',
    hasLightIcon: true,
    href: '/guides/ecosystem',
    description:
      'Create your own cross-app ecosystem wallet SDK. A brandable set of SDKs and APIs with non-custodial signer management and smart accounts to power your chain.',
  },
    {
   title: 'Server',
    icon: 'server-side',
    hasLightIcon: true,
    href: '/guides/server',
    description:
      'Built-in infrastructure send transaction on-chain with webhook noticication and server-side logic coupled with embedded signer pre-generation.',
  },
]

  {
    title: 'Firebase Auth',
    icon: '/docs/img/icons/firebase-icon',
    href: 'https://github.com/openfort-xyz/samples/tree/main/firebase-wagmi-nextjs',
  },
  {
    title: 'Web3Auth',
    icon: '/docs/img/icons/web3auth-icon',
    href: 'https://github.com/openfort-xyz/samples/tree/main/web3auth-nextjs',
  },
  {
    title: 'Next Auth',
    icon: '/docs/img/icons/nextjs-icon',
    href: 'https://github.com/openfort-xyz/samples/tree/main/ssv-social-nextjs',
  },
]

  {
    title: 'Node.js',
    icon: 'reference-nodejs',
    href: 'reference/api/introduction?lang=ts',
  },
  {
    title: 'C#',
    icon: 'reference-csharp',
    href: 'reference/api/introduction?lang=csharp',
  },
]

  {
    title: 'React',
    icon: 'reference-react',
    href: '/guides/react',
  },
  {
    title: 'React Native',
    icon: 'reference-react-native',
    href: '/guides/javascript/react-native',
    // href: 'https://github.com/openfort-xyz/react-native-auth-sample',
  },
  {
    title: 'Unity',
    icon: 'reference-unity',
    href: '/guides/unity',
  },
  {
    title: 'JavaScript',
    icon: 'reference-javascript',
    href: '/guides/getting-started',
  },
  // {
  //   title: 'Unreal Engine',
  //   icon: 'reference-unreal-engine',
  //   href: 'reference/unreal-engine',
  // },
]

  {
    title: 'API Reference',
    description:
      'Manage your Openfort projects and organizations and interact directly on-chain.',
    icon: 'reference-api',
    href: 'reference/api/introduction',
  },
  {
    title: 'Security',
    description: 'Learn more about security and compliance of Openfort.',
    icon: 'home',
    href: 'security',
  },
  {
    title: 'Blockchains',
    description: 'Supported networks and chains.',
    icon: 'platform',
    href: 'chains',
  },
  {
    title: 'White Label',
    description: 'Customize the look and feel of Openfort using the openfort-js library.',
    icon: 'integrations',
    href: '/guides/getting-started',
  },
]


# Openfort SDKs
Libraries and tools for interacting with your Openfort integration.

The recommended way to interact with the Openfort API is by using one of our official SDKs.

<ServerLibraries />

<ClientLibraries />


# Security & Trust at Openfort
Protecting your users' data with rigorous security measures and industry best practices.

<Security />

