# Analyze images
Source: https://dev.writer.com/api-guides/analyze-images



With the `vision` endpoint, you can analyze single or multiple images with a prompt. [Palmyra Vision](/home/models#palmyra-vision) allows you to ask questions about an image, generate captions, compare images, and more.

<Warning>The `/vision` endpoint will be available in versions 2.1+ of the [Writer SDKs](/api-guides/sdks).</Warning>

<Note>
  You need an API key to access the Writer API. Get an API key by following the steps in the [API quickstart](/api-guides/quickstart).

  We recommend setting the API key as an environment variable in a `.env` file with the name `WRITER_API_KEY`.
</Note>

## Vision endpoint

**Endpoint:** `POST /v1/vision`

<CodeGroup>
  ```bash cURL
  curl -X POST \
    'https://api.writer.com/v1/vision' \
    -H 'Content-Type: application/json' \
    -H "Authorization: Bearer $WRITER_API_KEY" \
    --data-raw '{
      "model": "palmyra-vision",
      "prompt": "What's the difference between the image {{image_1}} and the image {{image_2}}?",
      "variables": [
        {"name": "image_1", "file_id": "f1234"},
        {"name": "image_2", "file_id": "f5678"}
      ]
    }'
  ```

  ```python Python
  from writerai import Writer

  client = Writer()

  response = client.vision.analyze(
    model="palmyra-vision",
    prompt="What's the difference between the image {{image_1}} and the image {{image_2}}?",
    variables=[{"name": "image_1", "file_id": "f1234"}, {"name": "image_2", "file_id": "f5678"}]
  )

  print(response.data)
  ```

  ```javascript JavaScript
  import { Writer } from "writer-sdk";

  const client = new Writer();

  const response = await client.vision.analyze({
    model: "palmyra-vision",
    prompt: "What's the difference between the image {{image_1}} and the image {{image_2}}?",
    variables: [{ name: "image_1", file_id: "f1234" }, { name: "image_2", file_id: "f5678" }]
  });

  console.log(response.data);
  ```
</CodeGroup>

### Request body

The request body is a JSON object with the following fields:

| Parameter             | Type   | Description                                                                                                                                                                                                                         |
| --------------------- | ------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `model`               | string | The model to use for the analysis. Must be `palmyra-vision`.                                                                                                                                                                        |
| `prompt`              | string | The prompt to use for the analysis. The prompt must include the names of the images you're analyzing, referencing them as `{{name}}`. For example: `What's the difference between the image {{image_1}} and the image {{image_2}}?` |
| `variables`           | array  | An array of image variables with a `name` and `file_id`.                                                                                                                                                                            |
| `variables[].name`    | string | The name of the image. You must use the same name in the prompt, referencing it as `{{name}}`.                                                                                                                                      |
| `variables[].file_id` | string | The File ID of the uploaded image. You must upload the image to Writer before passing it to the Vision endpoint. Learn how to [upload images below](#upload-images).                                                                |

### Response format

The response is a JSON object with a `data` field that contains the analysis results as a string.

```json
{
    "data": "The analysis results"
}
```

## Example: Extract text from an image

This example shows how to extract text from an image using the `vision` endpoint.

### Upload an image

Before you can analyze an image, you need to upload it to Writer.

The following code samples demonstrate how to upload an image and print the File ID. You need the File ID to pass to the Vision endpoint.

<CodeGroup>
  ```bash cURL
  curl -X POST 'https://api.writer.com/v1/files' \
    -H 'Content-Type: image/jpeg' \
    -H 'Content-Disposition: attachment; filename=handwriting.jpg' \
    -H "Authorization: Bearer $WRITER_API_KEY" \
    --data-binary "@path/to/file/handwriting.jpg"
  ```

  ```python Python
  from pathlib import Path
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  file_ = client.files.upload(
    content=Path("path/to/file/handwriting.jpg"),
    content_disposition="attachment; filename=handwriting.jpg",
    content_type="image/jpeg"
  )

  print(file_.id)
  ```

  ```javascript JavaScript
  import fs from 'fs';
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `api_key` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const file = await client.files.upload({
    content: fs.createReadStream("path/to/file/handwriting.jpg"),
    "Content-Disposition": "attachment; filename=handwriting.jpg",
    "Content-Type": "image/jpeg"
  });

  console.log(file.id)
  ```
</CodeGroup>

Learn more about [uploading and managing files](/api-guides/files).

### Generate a caption with the Vision endpoint

Once you have the File IDs for any images you want to analyze, you can pass them to the Vision endpoint along with a prompt.

The prompt must include the names of the images you're analyzing, referencing them as `{{name}}`, where `name` is the name you provided in the `variables` array. For example: `Extract the text from the image {{name}}.` If you include files in the `variables` array that you don't include in the prompt, the API returns an error.

The following code sample shows the API call to extract text from an image.

<CodeGroup>
  ```bash cURL
  curl -X POST \
    'https://api.writer.com/v1/vision' \
    -H 'Content-Type: application/json' \
    -H "Authorization: Bearer $WRITER_API_KEY" \
    --data '{
      "model": "palmyra-vision",
      "prompt": "Extract the text from the image {{handwriting}}.",
      "variables": [{"name": "handwriting", "file_id": "f1234"}]
    }'
  ```

  ```python Python
  from writerai import Writer

  client = Writer()

  response = client.vision.analyze(
    model="palmyra-vision",
    prompt="Extract the text from the image {{handwriting}}.",
    variables=[{"name": "handwriting", "file_id": "f1234"}]
  )

  print(response.data)
  ```

  ```javascript JavaScript
  import { Writer } from "writer-sdk";

  const client = new Writer();

  const response = await client.vision.analyze({
    model: "palmyra-vision",
    prompt: "Extract the text from the image {{handwriting}}.",
    variables: [{ name: "handwriting", file_id: "f1234" }]
  });

  console.log(response.data);
  ```
</CodeGroup>

## Next steps

* Learn how to analyze images during a chat completion with the [Vision tool](/api-guides/vision-tool).


# API Keys
Source: https://dev.writer.com/api-guides/api-reference/api-keys

Learn how to create, manage, and delete API keys.

This guide will help you create and manage API keys for the Writer API.

All actions are performed in [AI Studio](https://app.writer.com/aistudio).

## About API keys

The Writer API uses token authentication for API requests. API keys are used as tokens, which you pass in the `Authorization` header of your requests:

```
Authorization: Bearer <api-key>
```

### API agents and API keys

Writer API keys are attached to AI Studio API agents.

API permissions and scopes are set at the agent level. Within an API-based agent, you can create multiple API keys that share the permissions of the agent. To create keys with different permissions, create multiple API agents.

## Create an API agent

1. From the [AI Studio home page](https://app.writer.com/aistudio), click on **Build an agent**. ![Select Build an app from the AI Studio home page](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/api/build-an-agent.png)
2. Select **API** as the agent type. ![Select API as the agent type](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/api/start-building.png)
3. Click on the agent's name to rename it to something description, and provide a **short description** of your agent to help you keep track of what it does. ![Rename the agent and provide a short description](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/api/rename-agent.png)

## Create an API key

Each API agent has a default API key, called `Production`. To create additional API keys:

1. Navigate to the API application. From the [AI Studio home page](https://app.writer.com/aistudio), click on **API Keys** in the navigation menu. ![Select API Keys from the AI Studio home page](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/api/select-api-keys.png)
2. Click on **Generate a new key**. ![Click Generate a new key](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/api/generate-key.png)
3. Give the key a name and click **Generate**.
4. To see the API key value, click on **Reveal key** next to the key name. ![Click Reveal key to see the API key value](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/api/reveal-key-cropped.png)

<Info>
  Store the API key in a secure location. We recommend using a `.env` file to store the key.
</Info>

## See your API agents and API keys

1. From the [AI Studio home page](https://app.writer.com/aistudio), click on **API Keys** in the navigation menu.
2. Click on an individual agent's tile to navigate to the agent. ![Click on an individual agent's tile to navigate to the agent](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/api/app-navigation.png)
3. To see the API key value, click on **Reveal key** next to the key name.

## Manage API agent permissions

API permissions are set at the agent level. To manage API agent permissions:

1. From the [AI Studio home page](https://app.writer.com/aistudio), click on **API Keys** in the navigation menu.
2. Click on an individual application's tile to navigate to the application.
3. Under **Capabilities**, toggle to enable or disable a specific capability for the API key. ![Toggle to enable or disable a specific capability for the API key](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/api/enable-capability.png)
   <Info>Capabilities map to Writer API endpoints. Click **Read more** in the API Documentation column to learn more about the specific endpoints.</Info>

## Delete an API agent

To delete an API agent:

1. From the [AI Studio home page](https://app.writer.com/aistudio), click on **API Keys** in the navigation menu.
2. Click on the dropdown menu (**...**) next to the agent you want to delete, and select **Delete**. ![Click on the dropdown menu (...) next to the agent you want to delete, and select Delete](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/api/delete-app.png)
3. Confirm the deletion by clicking **Delete**.

## Delete an API key

To delete an API key:

1. From the [AI Studio home page](https://app.writer.com/aistudio), click on **API Keys** in the navigation menu.
2. Click on an individual application's tile to navigate to the application.
3. Click on the dropdown menu (**...**) next to the key you want to delete, and select **Revoke**. ![Click on the dropdown menu (...) next to the key you want to delete, and select Revoke](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/api/delete-key.png)
4. Confirm the deletion by clicking **Revoke key**.


# Application details
Source: https://dev.writer.com/api-guides/api-reference/application-api/application-details

get /v1/applications/{application_id}
Retrieves detailed information for a specific no-code agent (formerly called no-code applications), including its configuration and current status.

<Info>No-code applications are now called [no-code agents](/no-code/introduction). The [Applications API](api-guides/api-reference/application-api/applications), which you can use to programmatically interact with no-code agents, still uses the term `application` to minimize breaking changes.</Info>


# Retrieve all jobs
Source: https://dev.writer.com/api-guides/api-reference/application-api/application-jobs

get /v1/applications/{application_id}/jobs
Retrieve all jobs created via the async API, linked to the provided application ID (or alias).

<Info>No-code applications are now called [no-code agents](/no-code/introduction). The [Applications API](api-guides/api-reference/application-api/applications), which you can use to programmatically interact with no-code agents, still uses the term `application` to minimize breaking changes.</Info>


# Generate from application
Source: https://dev.writer.com/api-guides/api-reference/application-api/applications

post /v1/applications/{application_id}
Generate content from an existing no-code agent (formerly called no-code applications) with inputs.

<Info>No-code applications are now called [no-code agents](/no-code/introduction). The [Applications API](api-guides/api-reference/application-api/applications), which you can use to programmatically interact with no-code agents, still uses the term `application` to minimize breaking changes.</Info>


# Generate from application (async)
Source: https://dev.writer.com/api-guides/api-reference/application-api/generate-application-job

post /v1/applications/{application_id}/jobs
Generate content asynchronously from an existing no-code agent (formerly called no-code applications) with inputs.

<Info>No-code applications are now called [no-code agents](/no-code/introduction). The [Applications API](api-guides/api-reference/application-api/applications), which you can use to programmatically interact with no-code agents, still uses the term `application` to minimize breaking changes.</Info>


# Retrieve graphs
Source: https://dev.writer.com/api-guides/api-reference/application-api/get-application-graphs

get /v1/applications/{application_id}/graphs
Retrieve Knowledge Graphs associated with a no-code agent that has chat capabilities.

<Info>No-code applications are now called [no-code agents](/no-code/introduction). The [Applications API](api-guides/api-reference/application-api/applications), which you can use to programmatically interact with no-code agents, still uses the term `application` to minimize breaking changes.</Info>


# Retrieve a single job
Source: https://dev.writer.com/api-guides/api-reference/application-api/get-single-async-job

get /v1/applications/jobs/{job_id}
Retrieves a single job created via the Async API.

<Info>No-code applications are now called [no-code agents](/no-code/introduction). The [Applications API](api-guides/api-reference/application-api/applications), which you can use to programmatically interact with no-code agents, still uses the term `application` to minimize breaking changes.</Info>


# List applications
Source: https://dev.writer.com/api-guides/api-reference/application-api/list-applications

get /v1/applications
Retrieves a paginated list of no-code agents (formerly called no-code applications) with optional filtering and sorting capabilities.

<Info>No-code applications are now called [no-code agents](/no-code/introduction). The [Applications API](api-guides/api-reference/application-api/applications), which you can use to programmatically interact with no-code agents, still uses the term `application` to minimize breaking changes.</Info>


# Retry job execution
Source: https://dev.writer.com/api-guides/api-reference/application-api/post-retry-async-job

post /v1/applications/jobs/{job_id}/retry
Re-triggers the async execution of a single job previously created via the Async api and terminated in error.

<Info>No-code applications are now called [no-code agents](/no-code/introduction). The [Applications API](api-guides/api-reference/application-api/applications), which you can use to programmatically interact with no-code agents, still uses the term `application` to minimize breaking changes.</Info>


# Associate graphs
Source: https://dev.writer.com/api-guides/api-reference/application-api/put-application-graphs

put /v1/applications/{application_id}/graphs
Updates the Knowledge Graphs listed and associates them with the no-code agent to be used.

<Info>No-code applications are now called [no-code agents](/no-code/introduction). The [Applications API](api-guides/api-reference/application-api/applications), which you can use to programmatically interact with no-code agents, still uses the term `application` to minimize breaking changes.</Info>


# Chat completion
Source: https://dev.writer.com/api-guides/api-reference/completion-api/chat-completion

post /v1/chat
Generate a chat completion based on the provided messages. The response shown below is for non-streaming. To learn about streaming responses, see the [chat completion guide](/api-guides/chat-completion).



# List models
Source: https://dev.writer.com/api-guides/api-reference/completion-api/list-models

get /v1/models



# Text generation
Source: https://dev.writer.com/api-guides/api-reference/completion-api/text-generation

post /v1/completions



# Error handling
Source: https://dev.writer.com/api-guides/api-reference/error-handling



<Info>
  This table outlines the HTTP status codes you may encounter when using the
  API, along with descriptions to help you understand and troubleshoot issues.
</Info>

| Error code | Description                                                                                                                                                               |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **400**    | **Bad request error:** Indicates an issue with the format or content of your request. This error may also encompass other 4XX status errors not specifically listed here. |
| **401**    | **Authentication error:** There's an issue with your API key, or it's missing from your request headers resulting in unauthorized access.                                 |
| **403**    | **Permission error:** Your API key doesn't have permission to access the requested resource.                                                                              |
| **404**    | **Model not found error:** The specified model couldn't be found. This may be due to an incorrect URL or model ID.                                                        |
| **429**    | **Rate limit exceeded:** You have exceeded the allotted number of requests per time period for your account. Please wait and try your request again later.                |
| **500**    | **API error:** An unexpected error occurred within our systems. If this persists, contact support for further assistance.                                                 |
| **503**    | **Service unavailable:** The server is currently unable to handle the request due to a temporary overload or maintenance. Please retry your request after some time.      |
| **504**    | **Timeout error:** The server didn't receive a timely response from an upstream server. Please retry your request after some time.                                        |

**Best practices**

<CardGroup>
  <Card title="Validate requests" icon="check">
    Ensure that all requests are correctly formatted and include all necessary
    parameters and authentication information before sending them to the server. You can check the [API reference](/api-guides/api-reference) for the correct information.
  </Card>

  <Card title="Check API key" icon="key">
    Ensure that you are using a valid API key, specific to either the API/SDK or Writer Framework. Use the [API Quickstart](/api-guides/quickstart) for the former and the [Writer Framework Quickstart](/framework/quickstart) for the latter.
  </Card>

  <Card title="Check for firewalls" icon="fire">
    Ensure that firewalls or security settings are not blocking the Writer API or your application or service using the Writer API or SDK.
  </Card>

  <Card title="Monitor and log errors" icon="monitor-waveform">
    Continuously monitor and log errors on your side to identify patterns or
    recurring issues that may require changes to your application or further
    investigation.
  </Card>
</CardGroup>


# Delete file
Source: https://dev.writer.com/api-guides/api-reference/file-api/delete-file

delete /v1/files/{file_id}



# Download file
Source: https://dev.writer.com/api-guides/api-reference/file-api/download-file

get /v1/files/{file_id}/download



# Retry failed files
Source: https://dev.writer.com/api-guides/api-reference/file-api/files-retry

post /v1/files/retry



# List files
Source: https://dev.writer.com/api-guides/api-reference/file-api/get-all-files

get /v1/files



# Retrieve file
Source: https://dev.writer.com/api-guides/api-reference/file-api/get-file

get /v1/files/{file_id}



# Upload file
Source: https://dev.writer.com/api-guides/api-reference/file-api/upload-files

post /v1/files



# Add file to graph
Source: https://dev.writer.com/api-guides/api-reference/kg-api/add-file-to-graph

post /v1/graphs/{graph_id}/file
Add a file to a Knowledge Graph.



# Create graph
Source: https://dev.writer.com/api-guides/api-reference/kg-api/create-graph

post /v1/graphs
Create a new Knowledge Graph.



# Delete graph
Source: https://dev.writer.com/api-guides/api-reference/kg-api/delete-graph

delete /v1/graphs/{graph_id}
Delete a Knowledge Graph.



# List graphs
Source: https://dev.writer.com/api-guides/api-reference/kg-api/list-graphs

get /v1/graphs
Retrieve a list of Knowledge Graphs.



# Question
Source: https://dev.writer.com/api-guides/api-reference/kg-api/question

post /v1/graphs/question
Ask a question to specified Knowledge Graphs.



# Remove file from graph
Source: https://dev.writer.com/api-guides/api-reference/kg-api/remove-file-from-graph

delete /v1/graphs/{graph_id}/file/{file_id}
Remove a file from a Knowledge Graph.



# Retrieve graph
Source: https://dev.writer.com/api-guides/api-reference/kg-api/retrieve-graph

get /v1/graphs/{graph_id}
Retrieve a Knowledge Graph.



# Update graph
Source: https://dev.writer.com/api-guides/api-reference/kg-api/update-graph

put /v1/graphs/{graph_id}
Update the name and description of a Knowledge Graph.



# Rate limits
Source: https://dev.writer.com/api-guides/api-reference/rate-limits



<Info>
  For custom rate limits please **[contact our sales team](https://go.writer.com/contact-sales)**.
</Info>

To ensure optimal service performance and fairness in resource allocation, our endpoints enforce the following rate limits.

1. **RPM (requests per minute)**: 400
2. **TPM (token per min)**: 25,000

## Best practices

<AccordionGroup>
  <Accordion title="Monitor request rates" icon="monitor-waveform">
    Implement mechanisms in your applications to track and regulate the
    frequency of your requests to stay within the prescribed limits.
  </Accordion>

  <Accordion title="Adaptive retry strategies" icon="rotate-right">
    In cases where you exceed these limits, employ adaptive retry strategies
    with exponential backoff to handle retries efficiently and reduce the
    likelihood of consecutive limit breaches.
  </Accordion>

  <Accordion title="Response to HTTP 429 status codes" icon="code">
    Prepare to handle HTTP 429 (too many requests) responses by pausing or
    slowing down request rates.
  </Accordion>
</AccordionGroup>


# Medical comprehend
Source: https://dev.writer.com/api-guides/api-reference/tool-api/comprehend-medical

post /v1/tools/comprehend/medical
Analyze unstructured medical text to extract entities labeled with standardized medical codes and confidence scores.



# Context-aware text splitting
Source: https://dev.writer.com/api-guides/api-reference/tool-api/context-aware-splitting

post /v1/tools/context-aware-splitting
Splits a long block of text (maximum 4000 words) into smaller chunks while preserving the semantic meaning of the text and context between the chunks.



# Parse PDF
Source: https://dev.writer.com/api-guides/api-reference/tool-api/pdf-parser

post /v1/tools/pdf-parser/{file_id}
Parse PDF to other formats.



# Analyze images
Source: https://dev.writer.com/api-guides/api-reference/vision-api/analyze-images

post /v1/vision
Submit images and a prompt to generate an analysis of the images.



# Invoke no-code agents via the API
Source: https://dev.writer.com/api-guides/applications



<Info>No-code applications are now called [no-code agents](/no-code/introduction). The [Applications API](api-guides/api-reference/application-api/applications), which you can use to programmatically interact with no-code agents, still uses the term `application` to minimize breaking changes.</Info>

The Applications API allows you to turn deployed [no-code agents](/no-code/introduction) into microservices, which can also be used as tools in [tool calling](/api-guides/applications-tool-calling). Business users can define inputs, prompts, and outputs, and developers can then add them to other applications, UIs, or services.

This guide shows how to use the `/applications` endpoint to generate content from no-code agents.

If you do not have a deployed no-code agent, follow the guides to build an agent with [text generation](/no-code/text-generation) or [research](/no-code/research) capabilities in AI Studio.

<Warning>
  The `/applications` endpoint supports only agents with [text generation](/no-code/text-generation) and [research](/no-code/research) capabilities. It does not support [chat](/no-code/chat) agents.
</Warning>

<Note>
  You need an API key to access the Writer API. Get an API key by following the steps in the [API quickstart](/api-guides/quickstart).

  We recommend setting the API key as an environment variable in a `.env` file with the name `WRITER_API_KEY`.
</Note>

## Endpoint overview

**URL:** `POST https://api.writer.com/v1/applications/{application_id}`

<Warning>
  Using the `/applications` endpoint will result in charges for **model usage**. See the [pricing page](/home/pricing) for more information.
</Warning>

<CodeGroup>
  ```bash cURL
  curl 'https://api.writer.com/v1/applications/<application-id>' \
  -X POST \
  -H 'Content-Type: application/json' \
  -H "Authorization: Bearer $WRITER_API_KEY" \
  --data-raw '{
    "inputs": [
      {
        "id": "Product description",
        "value": [
          "Terra running shoe"
        ]
      }
    ]
  }'
  ```

  ```python Python
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  response = client.applications.generate_content(
      application_id="<application-id>",
      inputs=[
          {
              "id": "Product description",
              "value": ["Terra running shoe"]
          }
      ]
  )

  print(response.suggestion)
  ```

  ```javascript JavaScript
  import { Writer } from 'writer-sdk';

  // Initialize the client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const response = await client.applications.generateContent(
      "<application-id>",
      {
          inputs: [
              {
                  id: "Product description",
                  value: ["Terra running shoe"]
              }
          ]
      }
  );

  console.log(response.suggestion);
  ```
</CodeGroup>

### Path parameters

| Parameter        | Type   | Description                                                                                                                                                                                                                                                                                                                                                         |
| ---------------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `application_id` | string | The ID of the deployed agent. You can find this in the URL of the agent in AI Studio: `https://app.writer.com/aistudio/organization/<organization-id>/applications/<application-id>`. You can also use the [List applications](/api-guides/api-reference/application-api/list-applications) endpoint to get the list of deployed agents and see the application ID. |

### Request body

Below are the required and commonly used optional parameters for the `/applications` endpoint.

| Parameter        | Type           | Description                                                                                                                                                                                                                                                                                              |
| ---------------- | -------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `inputs`         | array          | Input values matching the agent's defined input fields. The input structure depends on the agent capabilities.                                                                                                                                                                                           |
| `inputs[].id`    | string         | The name of the input field. For research, the input id is always `query`.                                                                                                                                                                                                                               |
| `inputs[].value` | array\[string] | An array containing values of the input field. You can pass multiple values for a single input field. If the input field is a file, the value should be the `file_id` from an uploaded file, such as `["1234-abcd-1234"]`. Learn more about how to upload files with the [Files API](/api-guides/files). |

```json
{
  "inputs": [
    {
      "id": "string",
      "value": ["string"]
    }
  ]
}
```

See the [applications endpoint reference](/api-guides/api-reference/application-api/applications) for more information on the request body and the additional parameters you can use to control the agent.

### Response format

The response format depends on the agent capabilities and whether you set the `stream` parameter to `true` or `false`. Only agents with research support streaming responses at this time.

#### Non-streaming response

If you set the `stream` parameter to `false`, the response is delivered as a JSON object with the following parameters:

| Parameter    | Type   | Description                                                  |
| ------------ | ------ | ------------------------------------------------------------ |
| `title`      | string | The name of the output field, as defined in the application. |
| `suggestion` | string | The output of the application call.                          |

```json
{
  "title": null,
  "suggestion": "The Terra running shoe combines lightweight materials with advanced cushioning technology to deliver exceptional comfort and performance for every stride."
}
```

#### Streaming response

If you set the `stream` parameter to `true`, the response is delivered as [server-sent events](https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events). The event contains several parameters.

The content of the chunk is in the `delta` field. You can also use the `stages` field to get the stages of the research assistant application call, such as "Planning the research" or "Researching and organizing findings."

Below are the important parameters for extracting the output of the application call.

| Parameter              | Type   | Description                                           |
| ---------------------- | ------ | ----------------------------------------------------- |
| `delta`                | object | The content of the chunk.                             |
| `delta.content`        | string | The output of the application call.                   |
| `delta.stages`         | array  | The stage of the research assistant application call. |
| `delta.stages.content` | string | The content of the stage.                             |

```json
data: {'delta': {'title': None,
  'content': None,
  'stages': [{'id': 'a5d81590-0120-4404-948b-8075e3610f51',
    'content': 'Initiating a research assistant: ðŸš— Automotive assistant',
    'sources': None}]}}
```

## Example: Text generation

Agents used for [text generation](/no-code/text-generation) generate content based on the inputs provided to a specific no-code agent created in AI Studio. This is a great way to enable business users to control prompts and outputs while still allowing developers to add them to other applications, UIs, or services.

To invoke text generation, you need to provide the application ID and the required inputs to the agent. Inputs are defined in the agent within AI Studio.

### Get the text generation inputs

To see the required inputs for the agent, you can view the agent in [AI Studio](https://app.writer.com/aistudio), or you can use the [Get application](/api-guides/api-reference/application-api/application-details) endpoint to get the agent details, including the inputs.

The example below shows how to use the `Get application` endpoint to get the list of required inputs with their name and types.

<CodeGroup>
  ```bash cURL
  curl --location --request GET https://api.writer.com/v1/applications/<application-id> \
   --header "Authorization: Bearer $WRITER_API_KEY"
  ```

  ```python Python
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  application = client.applications.retrieve(
      "<application-id>",
  )

  for input_ in application.inputs:
    print(f"{input_.name}: {input_.input_type}")
  ```

  ```javascript JavaScript
  import { Writer } from 'writer-sdk';

  // Initialize the client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const application = await client.applications.retrieve("<application-id>");

  for (const input of application.inputs) {
    console.log(`${input.name}: ${input.input_type}`);
  }
  ```
</CodeGroup>

### Format the request body with the application inputs

The `inputs` parameter is an array of objects, each containing an `id` and `value` field. The `id` field is the name of the input field, and the `value` field is the value of the input field.

```json
{
  "inputs": [
    {
      "id": "Text input name",
      "value": ["Input value 1"]
    },
    {
      "id": "File input name",
      "value": ["1234-fileid-1234"]
    }
  ]
}
```

If the input field is a file, the value should be the `file_id` from an [uploaded file](/api-guides/api-reference/file-api/upload-files).

Your request body should be formatted as a JSON object with values for each input.

### Generate content from the agent

Once you've formatted the request body with the agent inputs, you can invoke the agent using the [Generate content](/api-guides/api-reference/application-api/applications) endpoint.

The examples below demonstrate calling an agent with text generation capabilities. The agent takes two text inputs: `Product description` and `Target audience`.

<CodeGroup>
  ```bash cURL
  curl --location --request POST 'https://api.writer.com/v1/applications/{application_id}' \
  --header "Authorization: Bearer $WRITER_API_KEY" \
  --data-raw '{
    "inputs": [
      {
        "id": "Product description",
        "value": ["Terra running shoe"]
      },
      {
        "id": "Target audience",
        "value": ["Runners"]
      }
    ]
  }'
  ```

  ```python Python
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  response = client.applications.generate_content(
      application_id="<application-id>",
      inputs=[
          {
              "id": "Product description",
              "value": ["Terra running shoe"]
          },
          {
              "id": "Target audience",
              "value": ["Runners"]
          }
      ]
  )

  print(response.suggestion)
  ```

  ```javascript JavaScript
  import { Writer } from 'writer-sdk';

  // Initialize the client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const response = await client.applications.generateContent(
      "<application-id>", 
      {
          inputs: [
              {
                  id: "Product description",
                  value: ["Terra running shoe"]
              },
              {
                  id: "Target audience",
                  value: ["Runners"]
              }
          ]
      }
  );

  console.log(response.suggestion);
  ```
</CodeGroup>

## Example: Research assistant

Agents with [research](/no-code/research) capabilities output a final report after performing research in stages. Because of this, they support streaming responses.

These agents take an array of inputs that contain a single item, formatted as a JSON object with `id` and `value` parameters. It also takes a `stream` parameter that is set to `false` by default.

| Parameter        | Type           | Description                                                                                       |
| ---------------- | -------------- | ------------------------------------------------------------------------------------------------- |
| `inputs`         | array          | An array of objects, each containing an `id` and `value` field.                                   |
| `inputs[].id`    | string         | The name of the input field. For research assistant applications, the input id is always `query`. |
| `inputs[].value` | array\[string] | An array containing the research query.                                                           |
| `stream`         | Boolean        | Whether to stream the response. Defaults to `false`.                                              |

The examples below demonstrate calling an agent to research hotels in San Francisco. The application streams the output as it is generated.

<CodeGroup>
  ```bash cURL
  curl --location --request POST 'https://api.writer.com/v1/applications/{application_id}' \
  --header "Authorization: Bearer $WRITER_API_KEY" \
  --data-raw '{
    "inputs": [
      {
        "id": "query", 
        "value": ["Provide a list of three hotels in San Francisco near Union Square within the price range of $100 to $200 per night"]
      }
    ],
    "stream": true
  }'
  ```

  ```python Python
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  response = client.applications.generate_content(
      application_id="<application-id>",
      inputs=[
          {
              "id": "query",
              "value": ["Provide a list of three hotels in San Francisco near Union Square within the price range of $100 to $200 per night"]
          }
      ],
      stream=True
  )

  for chunk in response:
      if chunk.delta.content:
          print(chunk.delta.content, end="", flush=True)
      else if chunk.delta.stages:
          print(chunk.delta.stages[0].content)
  ```

  ```javascript JavaScript
  import { Writer } from 'writer-sdk';

  // Initialize the client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const response = await client.applications.generateContent(
      "<application-id>", 
      { 
          inputs: [
              {
                  id: "query",
                  value: ["Provide a list of three hotels in San Francisco near Union Square within the price range of $100 to $200 per night"]
              }
          ],
          stream: true
      } 
  );

  for await (const chunk of response) {
      if (chunk.delta.content) {
          console.log(chunk.delta.content);
      } else if (chunk.delta.stages) {
          console.log(chunk.delta.stages[0].content);
      }
  }
  ```
</CodeGroup>

## Next steps

Now that you've invoked a no-code agent via the API, learn other ways you can use no-code agents via the API:

* [Run no-code agents asynchronously](/api-guides/async-applications)
* [Use no-code agents in tool calling](/api-guides/applications-tool-calling)


# Use no-code agents as tools
Source: https://dev.writer.com/api-guides/applications-tool-calling



<Info>No-code applications are now called [no-code agents](/no-code/introduction). The [Applications API](api-guides/api-reference/application-api/applications), which you can use to programmatically interact with no-code agents, still uses the term `application` to minimize breaking changes.</Info>

You can use deployed [no-code agents](/no-code/introduction) as tools in [chat completions](/api-guides/api-reference/completion-api/chat-completion) with Palmyra-X-004.

This approach allows you to:

* Use no-code agents alongside other tools
* Chain multiple no-code agents together
* Combine outputs with other API calls or business logic

If you don't have a deployed no-code agent, build one with [text generation](/no-code/text-generation) or [research](/no-code/research) capabilities in AI Studio and [deploy it](/no-code/deploying-an-agent) to get an application ID.

<Note>
  You need an API key to access the Writer API. Get an API key by following the steps in the [API quickstart](/api-guides/quickstart).

  We recommend setting the API key as an environment variable in a `.env` file with the name `WRITER_API_KEY`.
</Note>

## Tool structure

To use a no-code agent as a tool, define the tool in a `tools` array when making the request to the [chat endpoint](/api-guides/chat-completion).

The `tools` array contains an object with the following parameters:

| Parameter                        | Type   | Description                                                                                                                      |
| -------------------------------- | ------ | -------------------------------------------------------------------------------------------------------------------------------- |
| `type`                           | string | The type of tool, which is `function` for a no-code agent                                                                        |
| `function`                       | object | An object containing the tool's description and application ID                                                                   |
| `function.name`                  | string | The name of the tool                                                                                                             |
| `function.description`           | string | A description of what the tool will be used for                                                                                  |
| `function.parameters`            | object | An object containing the tool's input parameters                                                                                 |
| `function.parameters.type`       | string | The string `object`                                                                                                              |
| `function.parameters.properties` | object | An object containing the tool's parameters in the form of a [JSON schema](https://json-schema.org/). See below for more details. |
| `function.parameters.required`   | array  | An array of the tool's required parameters                                                                                       |

### function.parameters.properties

The `function.parameters.properties` object contains the tool's parameter definitions as a [JSON schema](https://json-schema.org/). The object's keys should be the names of the parameters, and the values should be objects containing the parameter's type and description.

When the model decides you should use the tool to answer the user's question, it will return the parameters that you should use when calling the function you've defined.

Below is an example of a tool definition for a no-code agent that generates product descriptions.

<CodeGroup>
  ```python Python
  tools = [
      {
          "type": "function",
          "function": {
              "name": "generate_product_description",
              "description": "A function that will invoke an agent for text-generation, specialized in generating product descriptions. Any user request asking for product descriptions should use this tool.",
              "parameters": {
                  "type": "object",
                  "properties": {
                      "product_name": {
                          "type": "string",
                          "description": "The name of the product"
                      }
                  },
                  "required": ["product_name"]
              }
          }
      }
  ]
  ```

  ```javascript JavaScript
  const tools = [
      {
          type: "function",
          function: {
              name: "generate_product_description",
              description: "A function that will invoke an AI agent for text-generation, specialized in generating product descriptions. Any user request asking for product descriptions should use this tool.",
              parameters: {
                  type: "object",
                  properties: {
                      product_name: {
                          type: "string",
                          description: "The name of the product"
                      }
                  },
                  required: ["product_name"]
              }
          }
      }
  ];
  ```
</CodeGroup>

<Note>
  To help the model understand when to use the tool, follow these best practices for the `function.description` parameter:

  * Indicate that the tool is a function that invokes a no-code agent
  * Specify the agent's purpose and capabilities
  * Describe when the tool should be used

  An example description for a tool that invokes an agent with text-generation:

  > "A function that invokes an AI agent for text-generation, specialized in generating product descriptions. Any user request asking for product descriptions should use this tool."
</Note>

### Response format

When the model decides to use a custom tool, the response from the tool call is returned in the `tool_calls` object. The `tool_calls` object contains the following fields:

| Parameter                          | Type   | Description                                                              |
| ---------------------------------- | ------ | ------------------------------------------------------------------------ |
| `tool_calls[0].id`                 | string | The ID of the tool call                                                  |
| `tool_calls[0].function`           | object | An object containing the function to call                                |
| `tool_calls[0].function.type`      | string | The type of tool, which is `function` for a no-code agent                |
| `tool_calls[0].function.name`      | string | The name of the function to call                                         |
| `tool_calls[0].function.arguments` | string | A JSON-formatted string containing the arguments to pass to the function |

Here is an example of a chat completion response that includes a tool call. In this example, the model decides to use the `generate_product_description` tool to answer the user's question, and provides the arguments to pass to the function.

```json sample response[expandable] {11}
{
"content": null,
"refusal": null,
"role": "assistant",
"graph_data": {
"sources": null,
"status": null,
"subqueries": null
},
"llm_data": null,
"tool_calls": [
{
    "id": "chatcmpl-tool-123",
    "function": {
    "arguments": "{\"product_name\": \"Terra running shoe\"}",
    "name": "generate_product_description"
    },
    "type": "function",
    "index": null
}
],
"image_data": null
}
```

## Usage example

The following example demonstrates how to use a no-code agent that performs text generation tasks as a tool in a chat completion. The example uses a hypothetical product description agent, but you can use any no-code agent in this way.

### Create a function that calls your deployed agent

First, create a function that calls your deployed agent. You will use this function if the LLM you're chatting with decides to use the tool.

The function below takes a `product_name` parameter, invokes the no-code agent with the agent's required input fields, and returns the generated product description.

If you are unfamiliar with how to invoke a no-code agent with the SDK, see the [no-code agent guide](/api-guides/applications).

<CodeGroup>
  ```python Python
  def generate_product_description(product_name):
      response = client.applications.generate_content(
          application_id="your-application-id",
          inputs=[
              {
                  "id": "Product name",
                  "value": [product_name]
              }
          ]
      )
      return response.suggestion
  ```

  ```javascript JavaScript
  async function generateProductDescription(productName) {
      const response = await client.applications.generateContent(
          "your-application-id",
          {
              inputs: [
                  {
                      id: "Product name",
                      value: [productName]
                  }
              ]
          }
      );
      return response.suggestion;
  }
  ```
</CodeGroup>

### Define your agent as a tool

Next, define your agent as a tool so the LLM knows when to use it. See the [tool structure](#tool-structure) section for more details on the tool object.

<CodeGroup>
  ```python Python
  tools = [
      {
          "type": "function",
          "function": {
              "name": "generate_product_description",
              "description": "A function that will invoke an agent for text-generation, specialized in generating product descriptions. Any user request asking for product descriptions should use this tool.",
              "parameters": {
                  "type": "object",
                  "properties": {
                      "product_name": {
                          "type": "string",
                          "description": "The name of the product"
                      }
                  },
                  "required": ["product_name"]
              }
          }
      }
  ]
  ```

  ```javascript JavaScript
  const tools = [
      {
          type: "function",
          function: {
              name: "generate_product_description",
              description: "A function that will invoke an agent for text-generation, specialized in generating product descriptions. Any user request asking for product descriptions should use this tool.",
              parameters: {
                  type: "object",
                  properties: {
                      product_name: {
                          type: "string",
                          description: "The name of the product"
                      }
                  },
                  required: ["product_name"]
              }
          }
      }
  ];
  ```
</CodeGroup>

### Use your agent as a tool in a chat completion

Add the tools array to the chat endpoint call along with your array of messages. Setting `tool_choice` to `auto` allows the model to choose when to use the no-code agent tool, based on the user's question and the description of the tool.

When the model decides to use the tool you've defined, it will indicate that in the `tool_calls` object of the response.

This example uses a non-streaming response. For a streaming implementation, and to learn more about processing custom tool call responses, see the [tool calling guide](/api-guides/tool-calling#processing-tool-calls).

<CodeGroup>
  ```python Python
  import json
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `apiKey` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  messages = [{"role": "user", "content": "Generate a description for the Terra running shoe"}]

  # Send the request
  response = client.chat.chat(
      model="palmyra-x-004",
      messages=messages,
      tools=tools,
      tool_choice="auto",
      stream=False
  )

  # Process the response
  response_message = response.choices[0].message
  # Check if the response contains tool calls,
  #and if so, call the custom function
  tool_calls = response_message.tool_calls
  if tool_calls:
      tool_call = tool_calls[0]
      tool_call_id = tool_call.id
      function_name = tool_call.function.name
      function_args = json.loads(tool_call.function.arguments)

      if function_name == "generate_product_description":
          function_response = generate_product_description(function_args["product_name"])
          
          messages.append({
              "role": "tool",
              "tool_call_id": tool_call_id,
              "name": function_name,
              "content": function_response
          })

  final_response = client.chat.chat(
      model="palmyra-x-004",
      messages=messages,
      stream=False
  )

  print(final_response.choices[0].message.content)
  # Here's a product description for the Terra running shoe: ...
  ```

  ```javascript JavaScript
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const messages = [{ role: "user", content: "Generate a description for the Terra running shoe" }];

  const response = await client.chat.chat({
      model: "palmyra-x-004",
      messages: messages,
      tools: tools,
      tool_choice: "auto",
      stream: false
  });

  const responseMessage = response.choices[0].message;
  const toolCalls = responseMessage.tool_calls;
  // Check if the response contains tool calls,
  // and if so, call the custom function
  if (toolCalls && toolCalls.length > 0) {
      const toolCall = toolCalls[0];
      const toolCallId = toolCall.id;
      const functionName = toolCall.function.name;
      const functionArgs = JSON.parse(toolCall.function.arguments);

      if (functionName === "generate_product_description") {
          const functionResponse = await generateProductDescription(
              functionArgs.product_name
          );
          
          messages.push({
              role: "tool",
              tool_call_id: toolCallId,
              name: functionName,
              content: functionResponse
          });
      }

      const finalResponse = await client.chat.chat({
          model: "palmyra-x-004",
          messages: messages,
          stream: false
      });

      console.log(finalResponse.choices[0].message.content);
      // Here's a product description for the Terra running shoe: ...
  }
  ```
</CodeGroup>

Here is the full code example:

<CodeGroup>
  ```python Python [expandable]
  import json
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `apiKey` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  def generate_product_description(product_name):
      response = client.applications.generate_content(
          application_id="your-application-id",
          inputs=[
              {
                  "id": "Product name",
                  "value": [product_name]
              }
          ]
      )
      return response.suggestion

  tools = [
      {
          "type": "function",
          "function": {
              "name": "generate_product_description",
              "description": "A function that will invoke an agent for text-generation, specialized in generating product descriptions. Any user request asking for product descriptions should use this tool.",
              "parameters": {
                  "type": "object",
                  "properties": {
                      "product_name": {
                          "type": "string",
                          "description": "The name of the product"
                      }
                  },
                  "required": ["product_name"]
              }
          }
      }
  ]

  messages = [{"role": "user", "content": "Generate a description for the Terra running shoe"}]

  # Send the request
  response = client.chat.chat(
      model="palmyra-x-004",
      messages=messages,
      tools=tools,
      tool_choice="auto",
      stream=False
  )

  # Process the response
  response_message = response.choices[0].message
  # Check if the response contains tool calls,
  #and if so, call the custom function
  tool_calls = response_message.tool_calls
  if tool_calls:
      tool_call = tool_calls[0]
      tool_call_id = tool_call.id
      function_name = tool_call.function.name
      function_args = json.loads(tool_call.function.arguments)

      if function_name == "generate_product_description":
          function_response = generate_product_description(function_args["product_name"])
          
          messages.append({
              "role": "tool",
              "tool_call_id": tool_call_id,
              "name": function_name,
              "content": function_response
          })

  final_response = client.chat.chat(
      model="palmyra-x-004",
      messages=messages,
      stream=False
  )

  print(final_response.choices[0].message.content)
  # Here's a product description for the Terra running shoe: ...
  ```

  ```javascript JavaScript [expandable]
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  async function generateProductDescription(productName) {
      const response = await client.applications.generateContent(
          "your-application-id",
          {
              inputs: [
                  {
                      id: "Product name",
                      value: [productName]
                  }
              ]
          }
      );
      return response.suggestion;
  }

  const tools = [
      {
          type: "function",
          function: {
              name: "generate_product_description",
              description: "A function that will invoke an agent for text generation, specialized in generating product descriptions. Any user request asking for product descriptions should use this tool.",
              parameters: {
                  type: "object",
                  properties: {
                      product_name: {
                          type: "string",
                          description: "The name of the product"
                      }
                  },
                  required: ["product_name"]
              }
          }
      }
  ];

  const messages = [{ role: "user", content: "Generate a description for the Terra running shoe" }];

  const response = await client.chat.chat({
      model: "palmyra-x-004",
      messages: messages,
      tools: tools,
      tool_choice: "auto",
      stream: false
  });

  const responseMessage = response.choices[0].message;
  const toolCalls = responseMessage.tool_calls;
  // Check if the response contains tool calls,
  // and if so, call the custom function
  if (toolCalls && toolCalls.length > 0) {
      const toolCall = toolCalls[0];
      const toolCallId = toolCall.id;
      const functionName = toolCall.function.name;
      const functionArgs = JSON.parse(toolCall.function.arguments);

      if (functionName === "generate_product_description") {
          const functionResponse = await generateProductDescription(
              functionArgs.product_name
          );
          
          messages.push({
              role: "tool",
              tool_call_id: toolCallId,
              name: functionName,
              content: functionResponse
          });
      }

      const finalResponse = await client.chat.chat({
          model: "palmyra-x-004",
          messages: messages,
          stream: false
      });

      console.log(finalResponse.choices[0].message.content);
      // Here's a product description for the Terra running shoe: ...
  }
  ```
</CodeGroup>

## Next steps

Now that you've defined a custom tool, learn about prebuilt tools and how to use them in your applications:

* [Ask questions to a Knowledge Graph in a chat](/api-guides/kg-chat)
* [Delegate questions to domain-specific LLMs](/api-guides/model-delegation)


# Run agents asynchronously
Source: https://dev.writer.com/api-guides/async-applications



<Info>No-code applications are now called [no-code agents](/no-code/introduction). The [Applications API](api-guides/api-reference/application-api/applications), which you can use to programmatically interact with no-code agents, still uses the term `application` to minimize breaking changes.</Info>

With asynchronous agents, your team can build and deploy [no-code agents in AI Studio](/no-code/introduction) and you can use the [async applications API](/api-guides/api-reference/application-api/generate-application-job) to generate content asynchronously or in batches.

For example, your product team can build a no-code agent that creates product description pages, and then you can use the async applications API to generate pages in batches for multiple products.

This guide helps you understand how to run async jobs. The API is similar to the [applications API](/api-guides/applications), but it allows you to process batches of requests asynchronously.

<Note>
  You need an API key to access the Writer API. Get an API key by following the steps in the [API quickstart](/api-guides/quickstart).

  We recommend setting the API key as an environment variable in a `.env` file with the name `WRITER_API_KEY`.
</Note>

## Endpoint overview

**URL:** `POST https://api.writer.com/v1/applications/{application_id}/jobs`

<CodeGroup>
  ```bash cURL
  curl 'https://api.writer.com/v1/applications/<application-id>/jobs' \
  -X POST \
  -H 'Content-Type: application/json' \
  -H "Authorization: Bearer $WRITER_API_KEY" \
  --data-raw '{
    "inputs": [
      {
        "id": "Input name",
        "value": [
          "Input value"
        ]
      }
    ]
  }'
  ```

  ```python Python
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  job_response = client.applications.jobs.create(
      application_id="<application-id>",
      inputs=[
          {
              "id": "Input name",
              "value": [
                  "Input value"
              ]
          }
      ]
  )
  ```

  ```javascript JavaScript
  import Writer from 'writer-sdk';

  // Initialize the client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const response = await client.applications.jobs.create(
    "<application-id>",
    {
      inputs: [
        {
          id: "Input name",
          value: [
            "Input value"
          ]
        }
      ]
    }
  )
  ```
</CodeGroup>

### Path parameters

| Parameter        | Type     | Description                 |
| ---------------- | -------- | --------------------------- |
| `application_id` | `string` | The ID of the no-code agent |

### Request body

The async applications API has the same request body structure as the [no-code agents API](/api-guides/applications#request-body). It should contain an array of input objects matching the no-code agent's input schema.

### Response format

A successful job creation request returns a JSON object with the following structure:

| Parameter    | Type     | Description                                                            |
| ------------ | -------- | ---------------------------------------------------------------------- |
| `job_id`     | `string` | The ID of the job                                                      |
| `status`     | `string` | The status of the job. Can be `in_progress`, `completed`, or `failed`. |
| `created_at` | `string` | The date and time the job was created                                  |

```json
{
  "job_id": "123-456-789",
  "status": "in_progress",
  "created_at": "2024-03-15T10:00:00Z"
}
```

## Usage example

The following example demonstrates using the async applications API to generate content asynchronously with a hypothetical product description generation agent.

### Create and deploy a no-code agent

First, create and deploy a no-code agent in [AI Studio](https://app.writer.com/aistudio). If you don't already have a no-code agent, follow the [text generation guide](/no-code/text-generation) to get started.

### Create an async job

Send a `POST` request with the inputs for the agent to create an async job.

<CodeGroup>
  ```bash cURL
  curl 'https://api.writer.com/v1/applications/1234-45090-534590/jobs' \
  -X POST \
  -H 'Content-Type: application/json' \
  -H "Authorization: Bearer $WRITER_API_KEY" \
  --data-raw '{
    "inputs": [
      {
        "id": "Product descriptions",
        "value": [
          "Terra running shoe",
          "Aqua swim goggles",
          "Flex yoga mat"
        ]
      }
    ]
  }'
  ```

  ```python Python
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  job = client.applications.jobs.create(
      application_id="1234-45090-534590",
      inputs=[
          {
              "id": "Product descriptions",
              "value": [
                  "Terra running shoe",
                  "Aqua swim goggles",
                  "Flex yoga mat"
              ]
          }
      ],
  )
  print(f"Created job: {job.id}")
  ```

  ```javascript JavaScript
  import Writer from 'writer-sdk';

  // Initialize the client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const job = await client.applications.jobs.create(
    "1234-45090-534590",
    {
      inputs: [
        {
          id: "Product descriptions",
          value: [
            "Terra running shoe",
            "Aqua swim goggles",
            "Flex yoga mat"
          ]
        }
      ]
    }
  );
  console.log(`Created job: ${job.id}`);
  ```
</CodeGroup>

### Check job status

Use the job ID from the creation response to check the status of your job and see the results.

<CodeGroup>
  ```bash cURL
  curl 'https://api.writer.com/v1/applications/jobs/<job-id>' \
  -H "Authorization: Bearer $WRITER_API_KEY"
  ```

  ```python Python
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  job_status = client.applications.jobs.retrieve("<job-id>")
  print(f"Job status: {job_status.status}")
  if job_status.status == "completed":
      print(f"Job results: {job_status.data.suggestion}")
  ```

  ```javascript JavaScript
  import Writer from 'writer-sdk';

  // Initialize the client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const jobStatus = await client.applications.jobs.retrieve(
    "<job-id>"
  );
  console.log(`Job status: ${jobStatus.status}`);
  if (jobStatus.status === "completed") {
    console.log(`Job results: ${jobStatus.data.suggestion}`);
  }
  ```
</CodeGroup>

The response includes the current status. If the job has completed, the results are in the `data.suggestion` field, which has the same structure as the [no-code agents API](/api-guides/applications#response-format).

```json
{
    "id": "123-456-789",
    "status": "completed",
    "application_id": "2932402-23429023894-234234234",
    "created_at": "2025-02-10T18:18:09.501223Z",
    "completed_at": "2025-02-10T18:18:14.470324Z",
    "data": {
        "title": "Social post",
        "suggestion": "# Social post\nImage: A photo of a person running in a pair of Terra running shoes.\n\nCaption:\n\nIntroducing the all-new Terra running shoe, designed to take you further than ever before. With its innovative cushioning system and durable outsole, the Terra is perfect for runners of all levels.\n\nWhether you're hitting the trails or pounding the pavement, the Terra will keep you comfortable and supported mile after mile. So what are you waiting for? Lace up a pair of Terras and start your journey today!\n\n#TerraRunningShoe #RunFurther #NeverStopExploring #GetOutside"
    },
    "error": null
}
```

### List all jobs

You can retrieve all jobs for an application to monitor batch processing:

<CodeGroup>
  ```bash cURL
  curl 'https://api.writer.com/v1/applications/<application-id>/jobs' \
  -H "Authorization: Bearer $WRITER_API_KEY"
  ```

  ```python Python
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  jobs = client.applications.jobs.list(
      application_id="<application-id>"
  )
  for job in jobs.result:
      print(f"Job {job.id}: {job.status}")
  ```

  ```javascript JavaScript
  import Writer from 'writer-sdk';

  // Initialize the client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const jobs = await client.applications.jobs.list(
    "<application-id>"
  );
  jobs.result.forEach(job => {
    console.log(`Job ${job.id}: ${job.status}`);
  });
  ```
</CodeGroup>

### Retry failed jobs

If a job fails, you can retry it using the retry endpoint:

<CodeGroup>
  ```bash cURL
  curl 'https://api.writer.com/v1/applications/jobs/<job-id>/retry' \
  -X POST \
  -H "Authorization: Bearer $WRITER_API_KEY"
  ```

  ```python Python
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  retry_response = client.applications.jobs.retry("<job-id>")
  print(f"Retried job: {retry_response.id}")
  ```

  ```javascript JavaScript
  import Writer from 'writer-sdk';

  // Initialize the client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const retryResponse = await client.applications.jobs.retry(
    "<job-id>"
  );
  console.log(`Retried job: ${retryResponse.id}`);
  ```
</CodeGroup>

## Next steps

By following this guide, you can use the async Applications API to handle large-scale tasks.

Next, learn how to enhance your no-code agents with [Knowledge Graph](/api-guides/knowledge-graph), our tool for RAG.


# Changelog
Source: https://dev.writer.com/api-guides/changelog

Stay up to date with the latest changes to the Writer API and SDKs.

<Tip>To see the latest features and major improvements across the Writer platform, check out [What's new at Writer](https://support.writer.com/article/40-whats-new-at-writer).</Tip>

<Update label="2025-04-15" description="langchain-writer supports Python 3.9">
  ## Writer LangChain integration now supports Python 3.9

  The [Writer LangChain integration](/api-guides/integrations/langchain) now supports versions of Python 3.9 and higher, as of [version 0.2.0](https://github.com/writer/langchain-writer/releases/tag/v0.2.0).
</Update>

<Update label="2025-04-10" description="Terminology updates">
  ## Terminology updates

  As part of Writer's [recent product announcement](https://writer.com/blog/writer-ai-hq), no-code applications are now called [no-code agents](/no-code/introduction). The [Applications API](api-guides/api-reference/application-api/applications), which you can use to programmatically interact with no-code agents, still uses the term `application` to minimize breaking changes.

  The guides for [invoking no-code apps](/api-guides/applications), [async applications](/api-guides/async-applications), and [using no-code apps as tools](/api-guides/applications-tool-calling) have been updated to reflect the new terminology. However, the [Applications API](/api-guides/api-reference/application-api/applications) reference documentation still reflects previous terminology.
</Update>

<Update label="2025-04-04" description="Python and Node SDK v2.1.0">
  ## Released version 2.1.0 of the Python and Node SDKs

  This release adds support for the [vision endpoint](/api-guides/api-reference/vision-api/analyze-images) and the [vision tool](/api-guides/vision-tool) for chat completions.

  It also adds streaming helper methods to process streaming responses from the chat completions endpoint.

  * [Streaming helpers in Python](https://github.com/writer/writer-python?tab=readme-ov-file#streaming-helpers)
  * [Streaming helpers in Node](https://github.com/writer/writer-node?tab=readme-ov-file#streaming-helpers)
</Update>

<Update label="2025-03-26" description="New cookbooks">
  ## New cookbooks for Palmyra models

  We've added three new [cookbooks](/api-guides/cookbooks#palmyra-models) to help you explore domain-specific Palmyra models for creative, financial, and medical use cases.

  * [Palmyra Creative](https://github.com/writer/cookbooks/blob/main/models/palmyra_creative.ipynb)
  * [Palmyra Fin](https://github.com/writer/cookbooks/blob/main/models/palmyra_fin.ipynb)
  * [Palmyra Med](https://github.com/writer/cookbooks/blob/main/models/palmyra_med.ipynb)
</Update>

<Update label="2025-03-20" description="New vision endpoint">
  ## Palmyra Vision now available via the API

  The [Palmyra Vision model](/home/models#palmyra-vision) is now available via the API with the [`/vision` endpoint](/api-guides/api-reference/vision-api/analyze-images).

  <CodeGroup>
    ```bash cURL
    curl -X POST \
      'https://api.writer.com/v1/vision' \
      -H 'Content-Type: application/json' \
      -H "Authorization: Bearer $WRITER_API_KEY" \
      --data-raw '{
        "model": "palmyra-vision",
        "prompt": "What's the difference between the image {{image_1}} and the image {{image_2}}?",
        "variables": [
          {"name": "image_1", "file_id": "f1234"},
          {"name": "image_2", "file_id": "f5678"}
        ]
      }'
    ```
  </CodeGroup>

  The `/vision` endpoint analyzes images based on a prompt. You can use the endpoint for a variety of use cases, including:

  * Extracting handwritten text
  * Interpreting charts and graphs
  * Generating product descriptions

  Find additional use cases in the [Palmyra Vision overview](https://writer.com/llms/palmyra-vision/).

  See the [vision API guide](/api-guides/analyze-images) for a detailed walkthrough of uploading images and passing them to the `/vision` endpoint, or check out the full [vision API reference](/api-guides/api-reference/vision-api/analyze-images).
</Update>

<Update label="2025-03-10" description="langchain-writer v0.1.0">
  ## Released langchain-writer v0.1.0

  * Updated tool binding to align with standard LangChain tool calling conventions.
  * Added a new `NoCodeAppTool` tool for using no-code applications as tools.
  * Added a new `LLMTool` tool for delegating to a specific Palmyra model.

  See the [guide to using the LangChain integration](/api-guides/integrations/langchain) and the [package documentation](https://github.com/writer/langchain-writer/tree/main/docs) for more details.
</Update>

<Update label="2025-03-05" description="New cookbooks">
  ## New cookbooks for tool calling and no-code applications

  We've added three new [cookbooks](/api-guides/cookbooks) to help you get started with no-code applications and tool calling.

  * [Generating content from no-code applications with the SDK](https://github.com/writer/cookbooks/blob/main/applications/application_basic_usage.ipynb)
  * [Delegating a medical question to the `palmyra-med` model](https://github.com/writer/cookbooks/blob/main/tool_calling/tool_calling_llm.ipynb)
  * [Using the Knowledge Graph chat tool](https://github.com/writer/cookbooks/blob/main/tool_calling/tool_calling_kg.ipynb)
</Update>

<Update label="2025-03-03" description="palmyra-fin">
  ## Palmyra Fin model updates

  [Palmyra Fin](/home/models#palmyra-fin), our financial model, now has a 128k context window, up from 32k.

  To use the Palmyra Fin model in the API and SDKs, use the `palmyra-fin` model ID. The `palmyra-fin-32k` model ID is now deprecated.
</Update>

<Update label="2025-02-28" description="langchain-writer v0.0.3">
  ## Released Writer LangChain integration

  We're excited to announce the first release of `langchain-writer`, the official Writer LangChain integration. This release includes:

  * The `ChatWriter` model for text generation
  * Tool calling capabilities, including the `GraphTool` for retrieving information from a Knowledge Graph
  * Additional tools like the `PDFParser` for parsing PDFs and the `WriterTextSplitter` for intelligent text splitting

  Check out the [tutorial](/api-guides/integrations/langchain) to get started and the full [integration documentation](https://github.com/writer/langchain-writer/blob/main/docs/) for more details.
</Update>

<Update label="2025-02-27" description="Python and Node SDK v2.0.0">
  ## Released version 2.0.0 of the Python and Node SDKs

  The 2.0.0 release includes new functionality for the Writer SDKs for Python and Node:

  * **Model delegation tool**: A prebuilt, remotely executed tool that lets you delegate domain-specific requests to the appropriate Palmyra model. For example, if your application has finance questions, you can use the tool to allow Palmyra X 004 to delegate these questions to Palmyra Financial. Read more in our [model delegation guide](/api-guides/model-delegation).
  * **Retrieve application details**: Retrieve details for all of your no-code applications. Programmatically retrieve application inputs rather than relying on the AI Studio UI. This pairs well with our guide on [using no-code applications as tools](/api-guides/applications).
  * **Async jobs**: Trigger no-code application content generation asynchronously and retrieve or retry the job at a later time. This is great for long-running no-code applications, such as research assistant applications. To learn more, check out the [guide on async jobs](/api-guides/async-applications).
  * **Associate Knowledge Graphs with chat applications**: Retrieve or update which Knowledge Graphs are associated with no-code chat applications.

  <Warning>
    The 2.0.0 release includes some breaking changes to the underlying models used in chat completion. This won't affect you if you are only using chat completion via the `Writer.chat.chat` method, but it will if you are importing specific types directly. See below for more details about changes in each SDK.
  </Warning>

  See the SDK repositories for the full changelogs:

  * [Python](https://github.com/writer/writer-python/releases)
  * [Node](https://github.com/writer/writer-node/releases)

  ### Python SDK

  See below for the mapping of old types to new types:

  | Old                                                 | New                                                  |
  | --------------------------------------------------- | ---------------------------------------------------- |
  | `chat_chat_params.Tool`                             | `types.shared_params.tool_param.ToolParam`           |
  | `types.Chat`                                        | `types.chat_completion.ChatCompletion`               |
  | `types.chat.ChoiceMessageGraphDataSource`           | `types.shared.source.Source`                         |
  | `types.chat.ChoiceMessageGraphDataSubquerySource`   | `types.shared.source.Source`                         |
  | `types.chat_completion_chunk.ChoiceDeltaGraphData`  | `types.shared.graph_data.GraphData`                  |
  | `types.chat_completion_chunk.Usage`                 | `types.chat_completion_usage`                        |
  | `types.chat_completion_chunk.ChoiceMessageToolCall` | `types.shared.tool_call_streaming.ToolCallStreaming` |
  | `types.question.Source`                             | `types.shared.source.Source`                         |
  | `types.question.SubquerySource`                     | `types.shared.source.Source`                         |

  Additionally:

  * The `types.chat_completion_chunk.Message` type has been moved to its own model: `types.chat_completion_message`.

  * `types.chat.ChoiceLogprobsContent`, `ChoiceLogprobsRefusal`, `ChoiceLogprobsContentTopLogprob`, and `ChoiceLogprobsRefusalTopLogprob` have all been deduplicated and replaced by a shared model `types.shared.logprobs_token.LogprobsToken`.

  ### Node SDK

  See below for the mapping of old types to new types:

  | Old                                          | New                                |
  | -------------------------------------------- | ---------------------------------- |
  | `ChatResource`                               | `Chat`                             |
  | `Chat`                                       | `ChatCompletion`                   |
  | `Chat.Choice`                                | `ChatCompletionChoice`             |
  | `Chat.Choice.Message`                        | `ChatCompletionMessage`            |
  | `Chat.Choice.Logprobs`                       | `Shared.Logprobs`                  |
  | `Chat.Choice.Logprobs.Content`               | `Shared.LogprobsToken`             |
  | `Chat.Choice.Logprobs.Refusal`               | `Shared.LogprobsToken`             |
  | `Chat.Usage`                                 | `ChatCompletionUsage`              |
  | `ChatCompletionChunk.Choice.Message`         | `ChatCompletionMessage`            |
  | `ChatCompletionChunk.Choice.Delta`           | `ChatCompletionChunk.Choice.Delta` |
  | `ChatCompletionChunk.Choice.Delta.GraphData` | `Shared.GraphData`                 |
  | `ChatCompletionChunk.Choice.Delta.ToolCall`  | `Shared.ToolCallStreaming`         |
  | `ChatCompletionChunk.Choice.Logprobs`        | `Shared.Logprobs`                  |
  | `ChatCompletionChunk.Usage`                  | `ChatCompletionUsage`              |
  | `ChatChatParams.Message.GraphData`           | `Shared.GraphData`                 |
  | `ChatChatParams.Message.ToolCall`            | `Shared.ToolCall`                  |
  | `ChatChatParams.StringToolChoice`            | `Shared.ToolChoiceString`          |
  | `ChatChatParams.JsonObjectToolChoice`        | `Shared.ToolChoiceJsonObject`      |
  | `ChatChatParams.FunctionTool`                | `Shared.ToolParam.FunctionTool`    |
  | `ChatChatParams.GraphTool`                   | `Shared.ToolParam.GraphTool`       |
  | `StreamingData`                              | `CompletionChunk`                  |
  | `Completion.Choice.LogProbs`                 | `Shared.Logprobs`                  |

  The Node SDK includes developer experience improvements from [Stainless](https://www.stainlessapi.com/), including using the native `fetch` API, resulting in zero SDK dependencies.
</Update>

<Update label="2024-12-20" description="Python SDK v1.6.1">
  ## Released version 1.6.1 of the Python SDK

  * Fixed a typing bug where the `content` field in the `File` did not accept the correct `FileTypes` values.
</Update>

<Update label="2024-12-16" description="Python SDK v1.6.0; Node SDK v1.5.0">
  ## Released Python SDK version 1.6.0 and Node SDK version 1.5.0

  * Added streaming support to the [applications content generation endpoint](/api-guides/api-reference/application-api/applications) and updated the [No-code applications guide](/api-guides/applications) to reflect this.
</Update>

<Update label="2024-11-29" description="Python SDK v.1.5.0">
  ## Released Python SDK version 1.5.0

  * Added new functionality via manual API updates
  * Fixed compatibility with the latest `httpx` 0.28.0 release
  * Improved handling of deprecated arguments (`transport`, `proxies`) to maintain backward compatibility
  * Fixed compatibility issues with Pydantic `model_dump` method when warnings are passed
  * Removed the now unused `cached-property` dependency, as we now rely on the standard library implementation for Python 3.8+
  * Enhanced logging documentation in README, adding information about the 'info' log level
  * Updated the recommended log level from 'debug' to 'info' for standard usage
  * Fixed code formatting for better readability and consistency
  * Excluded test files from `mypy` checks to avoid false positives
  * Updated internal compatibility layer for better type checking
  * Improved error handling for deprecated client configuration options
</Update>

<Update label="2024-11-14" description="Python and Node SDK v1.4.0">
  ## Released Python and Node SDK versions 1.4.0

  * Updated the default timeout on the Writer client to three minutes.
</Update>


# Generate chat completions
Source: https://dev.writer.com/api-guides/chat-completion



The [chat completion endpoint](/api-guides/api-reference/completion-api/chat-completion) allows you to create a conversation between a user and an AI-assisted chat model.

This guide introduces the chat completion endpoint and shows how to create a multi-turn conversation with an LLM, where the conversation history is preserved so the model understands the context of the conversation.

<Note>
  You need an API key to access the Writer API. Get an API key by following the steps in the [API quickstart](/api-guides/quickstart).

  We recommend setting the API key as an environment variable in a `.env` file with the name `WRITER_API_KEY`.
</Note>

## Chat completion versus text generation

The chat completion endpoint is similar to the [text generation endpoint](/api-guides/text-generation), but it is designed to handle conversations between a user and an LLM.

The chat completion endpoint can generate single messages, or create more complex conversations between a user and an LLM. The text generation endpoint is designed to generate a single text response based on a given prompt.

Additionally, the chat completion endpoint offers [tool calling](/api-guides/chat-completion), which you can use to access domain-specific LLMs, Knowledge Graphs, and custom functions.

## Endpoint overview

**URL:** `POST https://api.writer.com/v1/chat`

<Warning>
  Using the `/chat` endpoint results in charges for **model usage**. See the [pricing page](/home/pricing) for more information.
</Warning>

<CodeGroup>
  ```bash cURL
  curl --location 'https://api.writer.com/v1/chat' \
  --header 'Content-Type: application/json' \
  --header "Authorization: Bearer $WRITER_API_KEY" \
  --data '{
      "model": "palmyra-x-004",
      "temperature": 1.5,
      "messages": [
          {
              "role": "user",
              "content": "You are an expert at writing concise product descriptions for an E-Commerce Retailer"
          },
          {
              "role": "assistant",
              "content": "Okay, great I can help write these descriptions. Do you have a specific product in mind?"
          },
          {
              "role": "user",
              "content": "Please write a one sentence product description for a cozy, stylish sweater suitable for both casual and formal occasions"
          }
      ]
  }'
  ```

  ```python Python
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  chat_response = client.chat.chat(
    messages=[
      {
          "role": "user",
          "content": "You are an expert at writing concise product descriptions for an E-Commerce Retailer"
      },
      {
          "role": "assistant",
          "content": "Okay, great I can help write these descriptions. Do you have a specific product in mind?"
      },
      {
          "role": "user",
          "content": "Please write a one sentence product description for a cozy, stylish sweater suitable for both casual and formal occasions"
      }
    ],
    model="palmyra-x-004",
    temperature=1.5
  )

  print(chat_response.choices[0].message.content)
  ```

  ```javascript JavaScript
  import { Writer } from 'writer-sdk';

  // Initialize the Writer client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();  

  const chatResponse = await client.chat.chat({
    messages: [
      {
          role: "user",
          content: "You are an expert at writing concise product descriptions for an E-Commerce Retailer"
      },
      {
          role: "assistant",
          content: "Okay, great I can help write these descriptions. Do you have a specific product in mind?"
      },
      {
          role: "user",
          content: "Please write a one sentence product description for a cozy, stylish sweater suitable for both casual and formal occasions"
      }
    ],
    model: 'palmyra-x-004',
    temperature: 1.5
  });

  console.log(chatResponse.choices[0].message.content);
  ```
</CodeGroup>

### Request body

Below are the required and commonly used optional parameters for the text generation endpoint.

| Parameter            | Type    | Description                                                                                                                                                                                                                                                                                                                             |
| -------------------- | ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `model`              | string  | **Required**. The [ID of the model](/home/models) to use for the chat completion. Can be `palmyra-x-004`, `palmyra-fin`, `palmyra-med`, `palmyra-creative`, or `palmyra-x-003-instruct`.                                                                                                                                                |
| `messages`           | array   | **Required**. The conversation history.                                                                                                                                                                                                                                                                                                 |
| `messages[].role`    | string  | **Required**. The role of the message sender. Can be `user`, `assistant`, `system`, or `tool`. `system` messages are system prompts, used to provide instructions to the model. `tool` messages are the result of a [tool call](/api-guides/tool-calling#append-the-result-back-to-the-model), and contain the output of the tool call. |
| `messages[].content` | string  | **Required**. The content of the message.                                                                                                                                                                                                                                                                                               |
| `temperature`        | float   | Temperature influences the randomness in generated text. Defaults to `1`. Increase the value for more creative responses, and decrease the value for more predictable responses.                                                                                                                                                        |
| `stream`             | Boolean | A Boolean value that indicates whether to stream the response. Defaults to `false`.                                                                                                                                                                                                                                                     |

See the [chat completion endpoint reference](/api-guides/api-reference/completion-api/chat-completion) for more information on the request body and the additional parameters you can use to control the conversation.

### Response parameters

#### Non-streaming response

If you set the `stream` parameter to `false`, the response is delivered as a single JSON object. It contains several parameters describing the response, including the `choices` array, which contains the generated text.

| Parameter                    | Type   | Description                                                                        |
| ---------------------------- | ------ | ---------------------------------------------------------------------------------- |
| `model`                      | string | The ID of the model used to generate the response.                                 |
| `choices`                    | array  | An array containing one object with the generated text and additional information. |
| `choices[0].message.content` | string | The generated text.                                                                |

See the full list of response parameters in the [chat completion endpoint reference](/api-guides/api-reference/completion-api/chat-completion).

```json non-streaming response [expandable]
{
  "id": "f7aed821-58cf-4210-9d73-538b2cb8ae44",
  "object": "chat.completion",
  "choices": [
    {
      "index": 0,
      "finish_reason": "stop",
      "message": {
        "content": "Elevate your wardrobe with this versatile, cozy sweater that seamlessly transitions from casual days to formal evenings.",
        "role": "assistant",
        "tool_calls": null,
        "graph_data": {
          "sources": null,
          "status": null,
          "subqueries": null
        },
        "llm_data": null,
        "image_data": null,
        "refusal": null
      },
      "logprobs": null
    }
  ],
  "created": 1741891192,
  "model": "palmyra-x-004",
  "usage": {
    "prompt_tokens": 96,
    "total_tokens": 118,
    "completion_tokens": 22,
    "prompt_token_details": null,
    "completion_tokens_details": null
  },
  "system_fingerprint": "v1",
  "service_tier": null
}
```

#### Streaming response

If you set the `stream` parameter to `true`, the response is delivered as [server-sent events](https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events). The event contains several parameters. The content of the chunk is in the `choices[0].delta.content` parameter.

| Parameter                  | Type   | Description               |
| -------------------------- | ------ | ------------------------- |
| `choices[0].delta.content` | string | The content of the chunk. |

```json streaming response [expandable]
data: {'id': '3bb941e2-4dab-4ceb-b4e3-45a429f40c72',
 'object': 'chat.completion.chunk',
 'choices': [{'index': 0,
   'finish_reason': None,
   'message': {'content': 'This',
    'role': 'assistant',
    'tool_calls': None,
    'graph_data': {'sources': None, 'status': None, 'subqueries': None},
    'llm_data': None,
    'image_data': None,
    'refusal': None},
   'delta': {'content': 'This',
    'role': 'assistant',
    'tool_calls': None,
    'graph_data': {'sources': None, 'status': None, 'subqueries': None},
    'llm_data': None,
    'image_data': None,
    'refusal': None},
   'logprobs': None}],
 'created': 1741891257,
 'model': 'palmyra-x-004',
 'usage': None,
 'system_fingerprint': 'v1',
 'service_tier': None}
```

## Sample application

The following sample application uses the Python and JavaScript SDKs to create a command-line chatbot.

The application asks the user for input, passes the conversation history to the LLM, and streams the response from the LLM. It loops until the user enters the message `exit`.

### Set a system prompt

To guide the behavior of the assistant, you can set a system prompt by adding a message with the role `system` to the `messages` array.

For example, you can set a system prompt to have the assistant respond in a certain tone or style, or to provide additional context for the conversation. Here's a system prompt that directs the assistant to be casual and use emojis in its responses:

<CodeGroup>
  ```python Python
  system_prompt = "You are a helpful assistant that responds in a casual, friendly tone and uses emojis in your responses."

  messages = [
    {"role": "system", "content": system_prompt},
  ]
  ```

  ```javascript JavaScript
  const system_prompt = "You are a helpful assistant that responds in a casual, friendly tone and uses emojis in your responses.";

  let messages = [
    {role: "system", content: system_prompt},
  ];
  ```
</CodeGroup>

Learn about [prompting best practices](/home/prompting) to help you create effective system prompts.

### Stream chat responses

The sample application streams the responses from the LLM. Streaming improves the user experience, showing the input as it is generated and reducing the latency of the final response.

Below are the code snippets from the sample application to stream the chat responses. They use the [`stream` helper method of the `chat` endpoint](/api-guides/streaming#streaming-helpers-for-chat-completions) to print the chat responses to the console in real time.

The `stream` method also collects the final response and returns it so it can be added to the conversation history.

<CodeGroup>
  ```python Python
  # Stream the chat response to the user using the `stream` helper method
  with client.chat.stream(messages=messages, model="palmyra-x-004") as stream:
      for event in stream:
          # Check if the event is a content delta, which contains this chunk of the chat response
          if event.type == "content.delta":
              print(event.delta, end="", flush=True)
  # Collect the full response from the stream
  completion = stream.get_final_completion().choices[0].message.content
  ```

  ```javascript JavaScript
  // Stream the chat response to the user using the `stream` helper method
  const stream = client.chat.stream({
      model: 'palmyra-x-004',
      messages: messages,
    })
    // Print this chunk of the chat response to the console
    .on('content', (diff) => process.stdout.write(diff));

  // Collect the full response from the stream
  let full_message = await stream.finalChatCompletion();
  full_message = full_message.choices[0].message.content;
  ```
</CodeGroup>

### Full application

The following is the complete sample application that uses the functions defined above to stream the chat responses.

The application sets a system prompt, asks the user for an initial message, and then enters a loop to handle the conversation between the user and the LLM. It adds the user's message to the conversation history and streams the response from the LLM to the user.

The loop continues until the user enters the message `exit`.

<CodeGroup>
  ```python Python
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  end = False
  system_prompt = "You are a helpful assistant that responds in a casual, friendly tone and uses emojis in your responses."

  # Ask the user for an initial message
  input_message = "\nEnter a message for the assistant. Type 'exit' to end the conversation. > "
  initial_message = input(input_message)

  # Add the user's message to the conversation history
  messages = [{"role": "system", "content": system_prompt}, {"role": "user", "content": initial_message}]

  # Main loop to handle the conversation.
  while not end:
      # Stream the chat response to the user using the `stream` helper method
      with client.chat.stream(messages=messages, model="palmyra-x-004") as stream:
          for event in stream:
              # Check if the event is a content delta, which contains this chunk of the chat response
              if event.type == "content.delta":
                  print(event.delta, end="", flush=True)
      # Collect the full response from the stream and add it to the conversation history
      full_message = stream.get_final_completion().choices[0].message.content
      messages.append({"role": "assistant", "content": full_message})
      new_message = input(input_message)
      messages.append({"role": "user", "content": new_message})
      if new_message == "exit":
          end = True
  ```

  ```javascript JavaScript
  import { Writer } from 'writer-sdk';

  // Initialize the Writer client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();  

  // helpers for reading user input from the command line
  // ----------------------------------------------------------------------------
  const readline = await import('readline');

  // Create an interface for input and output
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  // Prompt the user for input.
  const prompt = (question) => {
    return new Promise((resolve) => {
      rl.question(question, (answer) => {
        resolve(answer);
      });
    });
  };
  // ----------------------------------------------------------------------------

  let end = false;
  let system_prompt = "You are a helpful assistant that responds in a casual, friendly tone and uses emojis in your responses.";
  let initial_message = await prompt("Enter a message for the assistant. Type 'exit' to end the conversation. > ");
  let messages = [{"role": "system", "content": system_prompt}, {"role": "user", "content": initial_message}];

  // Main loop to handle the conversation.
  while (!end) {
    // Stream the chat response to the user using the `stream` helper method
    const stream = client.chat.stream({
      model: 'palmyra-x-004',
      messages: messages,
    })
    // Print this chunk of the chat response to the console
    .on('content', (diff) => process.stdout.write(diff));

    // Collect the full response from the stream and add it to the conversation history
    let full_message = await stream.finalChatCompletion();
    full_message = full_message.choices[0].message.content;
    messages.push({role: "assistant", content: full_message});
    console.log("\n");
    let new_message = await prompt("Enter a message for the assistant. Type 'exit' to end the conversation. > ");
    messages.push({role: "user", content: new_message});
    if (new_message === "exit") {
        end = true;
    }
  }
  ```
</CodeGroup>

## Best practices

Follow these best practices to ensure that your chatbot behaves as expected:

* **Use system messages**: Including a system message can guide the behavior of the assistant, setting expectations for its tone and responsiveness.
* **Maintain context**: Ensure that all relevant parts of the conversation are included in the `messages` array to maintain context, as the model doesn't retain memory of past interactions.
* **Handle errors gracefully**: Implement [error handling](/api-guides/api-reference/error-handling) for various HTTP status codes and API-specific errors such as rate limits or malformed requests.
* **Manage conversational flow**: Regularly review the conversation's context and adjust it to keep interactions relevant and concise, especially under the model's token limit.

## Next steps

Now that you've created a chatbot, learn how to [add tool calling](/api-guides/chat-completion) to your application to enhance the functionality with domain-specific LLMs, Knowledge Graphs, and custom functions.

* [Create custom functions as tools](/api-guides/tool-calling)
* [Access information in Knowledge Graphs](/api-guides/kg-chat)
* [Delegate tasks to domain-specific LLMs](/api-guides/model-delegation)


# Split text into semantically meaningful chunks
Source: https://dev.writer.com/api-guides/context-aware-text-splitting



The [context-aware splitting endpoint](/api-guides/api-reference/tool-api/context-aware-splitting) provides intelligent text splitting capabilities for documents up to 4000 words. Unlike simple character-based splitting, context-aware splitting preserves the semantic meaning and context between chunks, making it ideal for processing long-form content while maintaining coherence.

## Use cases

* Breaking down long articles or research papers for improved readability
* Preparing content for chunked processing in RAG (Retrieval-Augmented Generation) systems
* Splitting lengthy legal documents while maintaining context around clauses and references
* Creating digestible sections of educational content while preserving logical flow
* Processing large documentation files for knowledge base creation

<Note>
  You need an API key to access the Writer API. Get an API key by following the steps in the [API quickstart](/api-guides/quickstart).

  We recommend setting the API key as an environment variable in a `.env` file with the name `WRITER_API_KEY`.
</Note>

## Endpoint overview

**URL:** `POST https://api.writer.com/v1/tools/context-aware-splitting`

<CodeGroup>
  ```bash cURL
  curl --location 'https://api.writer.com/v1/tools/context-aware-splitting' \
  --header 'Content-Type: application/json' \
  --header "Authorization: Bearer $WRITER_API_KEY" \
  --data '{
    "text": "text to split",
    "strategy": "llm_split"
  }'
  ```

  ```python Python
  import os
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  response = client.tools.context_aware_splitting(
      strategy="llm_split",
      text="text to split",
  )
  print(response.chunks)
  ```

  ```javascript JavaScript
  import Writer from 'writer-sdk';

  // Initialize the client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  async function main() {
    const response = await client.tools.contextAwareSplitting({ strategy: 'llm_split', text: 'text to split' });

    console.log(response.chunks);
  }

  main();
  ```
</CodeGroup>

### Request body

The request body includes the following parameters:

| Parameter  | Type   | Description                                                                                                                |
| ---------- | ------ | -------------------------------------------------------------------------------------------------------------------------- |
| `text`     | string | The text content to be split. The text should be fewer than 4000 words.                                                    |
| `strategy` | string | The splitting strategy to use. Options include: `llm_split`, `fast_split`, and `hybrid_split`. See below for more details. |

#### Splitting strategies

* `llm_split`: Uses an LLM for precise semantic splitting
* `fast_split`: Uses heuristic-based approach for quick splitting
* `hybrid_split`: Combines both approaches

### Response format

Returns an array of text chunks, with at least one chunk guaranteed. Each chunk maintains semantic coherence while preserving the context of the original text.

| Parameter | Type           | Description                         |
| --------- | -------------- | ----------------------------------- |
| `chunks`  | array\[string] | An array of text chunks as strings. |

```json
{
  "chunks": ["chunk1", "chunk2", "chunk3"]
}
```


# Cookbooks
Source: https://dev.writer.com/api-guides/cookbooks



[Writer Cookbooks](https://github.com/writer/cookbooks) are step-by-step guides to help you implement tasks and solve common problems using Writer. Each recipe includes code snippets, explanations, and best practices to enhance your understanding of the Writer platform.

## Featured

<CardGroup cols={3}>
  <Card title="Model delegation tool calling" icon="square-1" href="https://github.com/writer/cookbooks/blob/main/tool_calling/tool_calling_llm.ipynb">
    Use the model delegation tool to refer medical questions to the Palmyra Med model during a chat.
  </Card>

  <Card title="Knowledge Graph tool calling" icon="square-2" href="https://github.com/writer/cookbooks/blob/main/tool_calling/tool_calling_kg.ipynb">
    Access a Knowledge Graph in a chat with a Palmyra LLM.
  </Card>

  <Card title="Working with no-code agents" icon="square-3" href="https://github.com/writer/cookbooks/blob/main/applications/application_basic_usage.ipynb">
    Retrieve no-code agent metadata and generate output from them using the Writer SDK.
  </Card>
</CardGroup>

## All cookbooks

### Applications

<CardGroup cols={3}>
  <Card title="Working with no-code agents" href="https://github.com/writer/cookbooks/blob/main/applications/application_basic_usage.ipynb">
    Retrieve no-code agent metadata and generate output from them using the Writer SDK.
  </Card>

  <Card title="Knowledge Graph management" href="https://github.com/writer/cookbooks/blob/main/applications/application_graph_management.ipynb">
    Attach a Knowledge Graph to a no-code agent programmatically.
  </Card>

  <Card title="Run no-code agents asynchronously" href="https://github.com/writer/cookbooks/blob/main/applications/application_jobs_utilization.ipynb">
    Run no-code agents asynchronously and manage asynchronous jobs.
  </Card>
</CardGroup>

### Completions

<CardGroup cols={3}>
  <Card title="Text completion" href="https://github.com/writer/cookbooks/blob/main/completion/text_completion.ipynb">
    Use the Writer Python SDK for text completion tasks.
  </Card>

  <Card title="Chat completion" href="https://github.com/writer/cookbooks/blob/main/completion/chat_completion.ipynb">
    Build single-turn and multi-turn chat completions to support conversational AI applications.
  </Card>
</CardGroup>

### Knowledge Graph

<CardGroup cols={3}>
  <Card title="Knowledge Graph" href="https://github.com/writer/cookbooks/blob/main/knowledge_graph/knowledge_graph.ipynb">
    Use our RAG implementation to create, manage, and use structured data to enhance AI capabilities.
  </Card>

  <Card title="Knowledge Graph tool calling" href="https://github.com/writer/cookbooks/blob/main/tool_calling/tool_calling_kg.ipynb">
    Access a Knowledge Graph in a chat with a Palmyra LLM.
  </Card>
</CardGroup>

### Palmyra models

<CardGroup cols={3}>
  <Card title="List all models" href="https://github.com/writer/cookbooks/blob/main/models/model_retrieval.ipynb">
    List all of the Palmyra models available in the Writer API.
  </Card>

  <Card title="Palmyra Creative" href="https://github.com/writer/cookbooks/blob/main/models/palmyra_creative.ipynb">
    Use the Palmyra Creative model to generate creative content.
  </Card>

  <Card title="Palmyra Fin" href="https://github.com/writer/cookbooks/blob/main/models/palmyra_fin.ipynb">
    Use the Palmyra Fin model for financial analysis and forecasting.
  </Card>

  <Card title="Palmyra Med" href="https://github.com/writer/cookbooks/blob/main/models/palmyra_med.ipynb">
    Use the Palmyra Med model to answer medical questions and analyze medical records.
  </Card>
</CardGroup>

### Tool calling

<CardGroup cols={3}>
  <Card title="Tool calling fundamentals" href="https://github.com/writer/cookbooks/blob/main/tool_calling/tool_calling_api.ipynb">
    Learn how to use tool calling to enhance the functionality of your LLM.
  </Card>

  <Card title="LLM tool calling" href="https://github.com/writer/cookbooks/blob/main/tool_calling/tool_calling_llm.ipynb">
    Use model delegation to refer medical questions to the Palmyra Med model during a chat.
  </Card>

  <Card title="Knowledge Graph tool calling" href="https://github.com/writer/cookbooks/blob/main/tool_calling/tool_calling_kg.ipynb">
    Access a Knowledge Graph in a chat with a Palmyra LLM.
  </Card>

  <Card title="Streaming tool calls" href="https://github.com/writer/cookbooks/blob/main/tool_calling/tool_calling_streaming.ipynb">
    Use tool calling with streaming responses.
  </Card>

  <Card title="Math tool calling example" href="https://github.com/writer/cookbooks/blob/main/tool_calling/tool_calling_math.ipynb">
    Extend the capabilities of your LLM with predefined mathematical functions.
  </Card>
</CardGroup>

### Tools

<CardGroup cols={3}>
  <Card title="Medical comprehend" href="https://github.com/writer/cookbooks/blob/main/tools/medical_comprehend.ipynb">
    Analyze unstructured medical text and extract entities.
  </Card>

  <Card title="PDF parser" href="https://github.com/writer/cookbooks/blob/main/tools/pdf_parser.ipynb">
    Parse a PDF file and extract the text as text or markdown.
  </Card>

  <Card title="Context-aware text splitting" href="https://github.com/writer/cookbooks/blob/main/tools/text_splitting.ipynb">
    Split long text into semantically meaningful chunks.
  </Card>
</CardGroup>


# Manage files
Source: https://dev.writer.com/api-guides/files



The File API allows you to manage files in your account. You can upload, download, and delete files.

After you upload a file, you can use it to perform actions such as attaching it to a [Knowledge Graph](/api-guides/knowledge-graph) or using it as an input in a [no-code agent](/api-guides/applications).

This guide shows you how to perform the following actions:

* [Upload a file](#upload-a-file)
* [Get a file](#get-a-file)
* [List all files](#list-all-files)
* [Delete a file](#delete-a-file)

<Note>
  You need an API key to access the Writer API. Get an API key by following the steps in the [API quickstart](/api-guides/quickstart).

  We recommend setting the API key as an environment variable in a `.env` file with the name `WRITER_API_KEY`.
</Note>

## Upload a file

**Endpoint**: `POST /v1/files`

<Info>A file persists in your account until you [delete it](#delete-a-file).</Info>

<CodeGroup>
  ```bash cURL
  curl --location --request POST "https://api.writer.com/v1/files" \
    --header "Content-Type: text/plain" \
    --header "Content-Disposition: attachment; filename=test.txt" \
    --header "Authorization: Bearer $WRITER_API_KEY" \
    --data-binary "@/path/to/test.txt"
  ```

  ```python Python
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  file_ = client.files.upload(
    content=b"raw file contents",
    content_disposition="attachment; filename=test.txt",
    content_type="text/plain"
  )

  print(file_.id)
  ```

  ```javascript JavaScript
  import fs from 'fs';
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `api_key` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const file = await client.files.upload({
    content: fs.createReadStream("path/to/file"),
    "Content-Disposition": "attachment; filename=test.txt",
    "Content-Type": "text/plain"
  });

  console.log(file.id)
  ```
</CodeGroup>

### Request body

| Parameter             | Type     | Description                                                                                                                                                                                                                                                                  |
| --------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `content`             | `string` | The content of the file. See the [Python SDK](https://github.com/writer/writer-python?tab=readme-ov-file#file-uploads) and the [JavaScript SDK](https://github.com/writer/writer-node?tab=readme-ov-file#file-uploads) for more details about how to pass the file contents. |
| `content_disposition` | `string` | The [content disposition](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) of the file.                                                                                                                                                        |
| `content_type`        | `string` | The [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/MIME_types/Common_types) of the file. The file upload supports `txt`, `doc`, `docx`, `ppt`, `pptx`, `jpg`, `png`, `eml`, `html`, `pdf`, `srt`, `csv`, `xls`, and `xlsx` file extensions.            |

### Response format

| Field        | Type            | Description                                                |
| ------------ | --------------- | ---------------------------------------------------------- |
| `id`         | `string`        | The ID of the file.                                        |
| `created_at` | `string`        | The date and time the file was created in ISO 8601 format. |
| `name`       | `string`        | The name of the file.                                      |
| `graph_ids`  | `array[string]` | The IDs of the Knowledge Graphs the file is attached to.   |
| `status`     | `string`        | The processing status of the file.                         |

```json
{
  "id": "1862f090-a281-48f3-8838-26c1e78b605e",
  "created_at": "2024-06-24T12:34:56Z",
  "name": "test.txt",
  "graph_ids": [],
  "status": "in_progress"
}
```

## List all files

**Endpoint**: `GET /v1/files`

<CodeGroup>
  ```bash cURL
  curl --location --request GET "https://api.writer.com/v1/files" \
    --header "Authorization: Bearer $WRITER_API_KEY"
  ```

  ```python Python
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()
  page = client.files.list()

  for file in page.data:
      print(file.id, file.name, file.graph_ids, file.status)
  ```

  ```javascript JavaScript
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `api_key` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();
  const files = await client.files.list();

  for (const file of files.data) {
      console.log(file.id, file.name, file.graph_ids, file.status);
  }
  ```
</CodeGroup>

### Request body

In addition to the [pagination parameters](/api-guides/api-reference/file-api/get-all-files), this endpoint supports the following query parameters:

| Parameter  | Type     | Description                                     |
| ---------- | -------- | ----------------------------------------------- |
| `graph_id` | `string` | Filter files by the graph they are attached to. |
| `status`   | `string` | Filter files by status.                         |

### Response format

The response has the following structure:

| Field               | Type            | Description                                                |
| ------------------- | --------------- | ---------------------------------------------------------- |
| `data`              | `array[object]` | An array of file objects.                                  |
| `data[].id`         | `string`        | The ID of the file.                                        |
| `data[].created_at` | `string`        | The date and time the file was created in ISO 8601 format. |
| `data[].name`       | `string`        | The name of the file.                                      |
| `data[].graph_ids`  | `array[string]` | The IDs of the Knowledge Graphs the file is attached to.   |
| `data[].status`     | `string`        | The status of the file.                                    |
| `has_more`          | `boolean`       | Whether there are more files to fetch.                     |
| `first_id`          | `string`        | The ID of the first file in the response.                  |
| `last_id`           | `string`        | The ID of the last file in the response.                   |

```json
{
  "data": [
    {
      "id": "f1234-abcd-1234",
      "created_at": "2025-03-07T23:20:50.978908Z",
      "name": "my_file.pdf",
      "graph_ids": [],
      "status": "completed"
    },
    {
      "id": "1234-abcd-5678",
      "created_at": "2025-03-07T23:20:44.047604Z",
      "name": "my_second_file.pdf",
      "graph_ids": [],
      "status": "completed"
    }
  ],
  "has_more": false,
  "first_id": "f1234-abcd-1234",
  "last_id": "1234-abcd-5678"
}
```

## Get a file

**Endpoint**: `GET /v1/files/{fileId}`

<CodeGroup>
  ```bash cURL
  curl --location --request GET "https://api.writer.com/v1/files/<fileId>" \
    --header "Authorization: Bearer $WRITER_API_KEY"
  ```

  ```python Python
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()
  file = client.files.get("<fileId>")

  print(file.id, file.name, file.graph_ids, file.status)
  ```

  ```javascript JavaScript
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `api_key` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();
  const file = await client.files.get('<fileId>');

  console.log(file.id, file.name, file.graph_ids, file.status)
  ```
</CodeGroup>

### Path parameters

| Parameter | Description                |
| --------- | -------------------------- |
| `fileId`  | The ID of the file to get. |

### Response format

```json
{
  "id": "f1234-abcd-1234",
  "created_at": "2025-03-07T23:20:50.978908Z",
  "name": "test.txt",
  "graph_ids": [],
  "status": "completed"
}
```

## Delete a file

**Endpoint**: `DELETE /v1/files/{fileId}`

<CodeGroup>
  ```bash cURL
  curl --location --request DELETE "https://api.writer.com/v1/files/<fileId>" \
    --header "Authorization: Bearer $WRITER_API_KEY"
  ```

  ```python Python
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()
  file = client.files.delete("<fileId>")
  ```

  ```javascript JavaScript
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `api_key` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();
  const fileDeleteResponse = await client.files.delete('<fileId>');
  ```
</CodeGroup>

### Path parameters

| Parameter | Description                   |
| --------- | ----------------------------- |
| `fileId`  | The ID of the file to delete. |

### Response format

The response has the following structure:

```json
{
  "id": "f1234-abcd-1234",
  "deleted": true
}
```


# Structured output with Instructor
Source: https://dev.writer.com/api-guides/integrations/instructor



This tutorial will guide you through using Writer with [Instructor](https://useinstructor.com/), a Python library that makes it easy to get structured data like JSON from LLMs.

## Prerequisites

* Python 3.8 or higher installed
* [Poetry](https://pypi.org/project/poetry/) installed (see their [installation guide](https://python-poetry.org/docs/#installation))
* A Writer API key (follow the [Quickstart](/api-guides/quickstart) to obtain an API key)

## Getting started

To get started with Instructor, you'll need to install the library and set up your environment.

<Steps>
  <Step title="Obtain an API key">
    First, make sure that you've signed up for a Writer AI Studio account and obtained an API key. You can follow the [Quickstart](/api-guides/quickstart) to obtain an API key.
  </Step>

  <Step title="Install instructor">
    Once you've done so, install `instructor` with Writer support by running:

    ```bash
    pip install instructor[writer]
    ```
  </Step>

  <Step title="Set the `WRITER_API_KEY` environment variable">
    Make sure to set the `WRITER_API_KEY` environment variable with your Writer API key or pass it as an argument to the Writer constructor.
  </Step>
</Steps>

## Basic usage

Following is a simple example of how to use `instructor` with Writer:

```python
import instructor
from writerai import Writer
from pydantic import BaseModel

# Initialize Writer client
client = instructor.from_writer(Writer(api_key="your API key"))


class User(BaseModel):
    name: str
    age: int


# Extract structured data
user = client.chat.completions.create(
    model="palmyra-x-004",
    messages=[{"role": "user", "content": "Extract: John is 30 years old"}],
    response_model=User,
)

print(user)
#> name='John' age=30
```

This code creates a simple data model with two fields: `name` and `age`. It then uses the `instructor.from_writer` function to create a `client` object that uses the Writer API to extract structured data from a text.

## Building a data repair tool with Instructor and Writer

You can also use Instructor to do advanced data extraction and repair. In this example, you'll build a Python application that extracts structured data from text, CSV, and PDF files using Instructor and Writer. This application will:

* Parse text, CSV, and PDF files
* Extract and validate structured data using Instructor and Writer
* Output the results in CSV format

The finished code for this tutorial is available in the [API tutorials](https://github.com/writer/api-tutorials/tree/main/instructor-and-writer-tutorial) GitHub repository.

### Setting up the project

<Steps>
  <Step title="Create a new project">
    First, create a new project and set up Poetry for dependency management:

    ```bash
    mkdir instructor-and-writer-tutorial
    cd instructor-and-writer-tutorial
    poetry init -y
    ```
  </Step>

  <Step title="Add dependencies">
    Add the required dependencies to your project:

    ```bash
    poetry add instructor writer-sdk python-dotenv pydantic
    ```
  </Step>

  <Step title="Set up your environment variables">
    Create a `.env` file in your project root and add your Writer API key:

    ```
    WRITER_API_KEY=your_api_key_here
    ```
  </Step>

  <Step title="Create `main.py` file and add imports">
    Create a `main.py` file and add the following imports:

    ```python
    import asyncio
    import csv
    import json
    import os
    from typing import Annotated, Type, Iterable, List

    import instructor
    from dotenv import load_dotenv
    from pydantic import BaseModel, AfterValidator, Field
    from writerai import Writer, AsyncWriter

    load_dotenv()
    ```

    Here's what each import is used for:

    * `asyncio`: This is used to run the application on multiple files concurrently.
    * `csv`: This is used to write the extracted data to a CSV file.
    * `json`: This is used to write the extracted data to a JSON file.
    * `os`: This is used to read the files.
    * `instructor`: The `instructor` library is used for structured output.
    * `writerai`: This is the Writer Python SDK, which is used to interact with the Writer API.
    * `typing` and `pydantic`: These modules are used to define the types for fields in the `UserExtract` class defined in the next step.
    * `dotenv`: The `dotenv` module is used to load the `.env` file that contains your Writer API key.
  </Step>

  <Step title="Setting up Writer client">
    Initialize the Writer client for both synchronous and asynchronous operations:

    ```python
    writer_client = Writer()
    async_writer_client = AsyncWriter()
    ```
  </Step>
</Steps>

### Defining the data model

In order for Instructor to extract structured output, you need to define a data model using Pydantic. To define the data model, create a `UserExtract` class to represent the data you want to extract:

```python
class UserExtract(BaseModel):
    @staticmethod
    def first_last_name_validator(v):
        if v[0] != v[0].upper() or v[1:] != v[1:].lower() or not v.isalpha():
            raise ValueError("Name must contain only letters and start with uppercase letter")
        return v

    first_name: Annotated[str, AfterValidator(first_last_name_validator)] = Field(
        ..., description="The name of the user"
    )
    last_name: Annotated[str, AfterValidator(first_last_name_validator)] = Field(
        ..., description="The surname of the user"
    )
    email: str
```

This data model defines the fields that you want to extract from the files. The `first_name` and `last_name` fields are validated to ensure they start with an uppercase letter and contain only letters. In this example, the `email` field is a simple string field, though you could also use a Pydantic field to validate the email format.

### Parsing the files

With the data model defined, you can now implement file parsing. This involves creating functions to open the files and extract the text.

<Steps>
  <Step title="Create a function to handle file processing">
    Implement the main file handler function that orchestrates the entire process:

    ```python
    async def handle_file(file_path: str, response_model: Type[BaseModel], output_path: str = None) -> None:
        extension = os.path.splitext(file_path)[1]
        name = os.path.splitext(os.path.basename(file_path))[0]

        file_text = await fetch_file_text(file_path, name, extension)
        repaired_entities = await repair_data(file_text, response_model)

        print(f"Number of entities extracted from {name}{extension}: {len(repaired_entities)}")
        return generate_csv(repaired_entities, response_model, output_path)
    ```

    This function handles the file processing logic, including file type validation, text extraction, data repair, and CSV generation.
  </Step>

  <Step title="Create a function to read the files">
    Next, create a function to read the files based on the given path and extension:

    ```python
    async def fetch_file_text(file_path: str, name: str, extension: str) -> str:
        allowed_extensions = [".txt", ".csv", ".pdf"]
        if extension not in allowed_extensions:
            raise ValueError(f"File extension {extension} is not allowed. Only {', '.join(allowed_extensions)}")

        print(f"Reading {name}{extension} content...")
        with open(file_path, 'rb') as file:
            file_contents = file.read()

        return await parse_file(file_contents, name, extension)
    ```
  </Step>

  <Step title="Extract the file content">
    Next, create a function to extract the text from the files. For text files, this function simply reads the file contents. For PDFs, the function uploads the PDF using Writer's [file upload endpoint](/api-guides/api-reference/file-api/upload-files), parses the text using [PDF parsing tool](/api-guides/api-reference/tool-api/pdf-parser), and then deletes the file from Writer's servers using the [file delete endpoint](/api-guides/api-reference/file-api/delete-file):

    ```python
    async def parse_file(file_bytes_content: bytes, name: str, extension: str) -> str:
        file_text = ""

        if extension == ".pdf":
            print(f"Uploading {name}{extension} content to writer servers...")
            file = await async_writer_client.files.upload(
                content=file_bytes_content,
                content_disposition=f"attachment; filename={name + extension}",
                content_type="application/octet-stream",
            )

            print(f"Converting {name}{extension} content from PDF to text...")
            file_text = await async_writer_client.tools.parse_pdf(
                file_id=file.id,
                format="text",
            )

            print(f"Deleting {name}{extension} from writer servers...")
            await async_writer_client.files.delete(file.id)
        else:
            print(f"Converting {name}{extension} content...")
            file_text = file_bytes_content.decode("utf-8")

        return file_text
    ```
  </Step>
</Steps>

### Extracting and repairing the data

With the file content extracted, you can now implement data extraction and repair using Instructor and Writer.

<Steps>
  <Step title="Create a function to repair the data">
    Create a function to extract and repair data using Instructor:

    ```python
    async def repair_data(file_text: str, response_model: Type[BaseModel]) -> List[BaseModel]:
        instructor_client = instructor.from_writer(client=async_writer_client)

        if not issubclass(response_model, BaseModel):
            raise ValueError("Response model must be subclass of pydantic BaseModel")

        print("Extracting data featuring Instructor tools...")
        return await instructor_client.chat.completions.create(
            model="palmyra-x-004",
            response_model=Iterable[response_model],
            max_retries=5,
            messages=[
                {"role": "user", "content": f"Extract entities from {file_text}"},
            ],
        )
    ```
  </Step>

  <Step title="Implementing CSV generation">
    Add a function to save the extracted data to CSV:

    ```python
    def generate_csv(entities: List[BaseModel], response_model: Type[BaseModel], output_path: str = None) -> None:
        fieldnames = list(response_model.model_json_schema()["properties"].keys())
        file_path = f"{response_model.__name__}.csv"

        if output_path:
            file_path = output_path + file_path
            os.makedirs(os.path.dirname(file_path), exist_ok=True)

        with open(file_path, "w") as file:
            dict_writer = csv.DictWriter(file, fieldnames=fieldnames)
            dict_writer.writeheader()
            for entity in entities:
                dict_writer.writerow(json.loads(response_model(**entity.model_dump()).model_dump_json()))
    ```
  </Step>
</Steps>

### Creating the main handler

Finally, implement the main function to process multiple files concurrently:

```python
async def main():
    data = [
        ("example_data/ExampleFileTextFormat.txt", UserExtract, None),
        ("example_data/ExampleFilePDFFormat.pdf", UserExtract, "out/"),
    ]
    tasks = []

    for row in data:
        tasks.append(handle_file(row[0], row[1], row[2]))

    await asyncio.gather(*tasks)

if __name__ == "__main__":
    asyncio.run(main())
```

In this example, the input paths are hardcoded, but you could modify the application to accept input paths from the command line or a web interface, or read from a directory or database.

### Testing the application

Your data repair tool is now ready to use. To test it, follow these steps:

<Steps>
  <Step title="Create an `example_data` directory">
    Create an `example_data` directory and add some test files:

    * A text file with user information
    * A PDF file with user information

    You can use the [example data](https://github.com/writer/api-tutorials/tree/main/instructor-and-writer-tutorial/example_data) provided in the GitHub repository for this tutorial. If you provide your own, be sure to update the `main.py` file to point to the new files.
  </Step>

  <Step title="Run the application">
    Run the application:

    ```bash
    poetry run python main.py
    ```

    The application will process both files concurrently and generate CSV files containing the extracted user information.
  </Step>
</Steps>

## Conclusion

You've now seen basic and advanced usage of Writer with Instructor. To learn more about Instructor, check out the [Instructor documentation](https://python.useinstructor.com/). Structured output is a powerful feature that can help you build more accurate and reliable applications, especially combined with [tool calling](/api-guides/tool-calling).


# Using Writer with LangChain
Source: https://dev.writer.com/api-guides/integrations/langchain



The [Writer LangChain integration](https://github.com/writer/langchain-writer) allows you to leverage Writer's capabilities within the LangChain ecosystem, making it easy to build sophisticated AI applications. In this tutorial, you'll explore each component of the integration and understand how they work.

## Prerequisites

Before you begin, make sure you have:

* Python 3.9 or higher installed
* A [Writer AI Studio](https://app.writer.com/register) account
* A Writer API key. See instructions in the [API Quickstart](/api-guides/quickstart).
* Basic familiarity with Python and [LangChain concepts](https://python.langchain.com/docs/concepts/)

## Installation and setup

First, install the necessary packages:

```bash
pip install langchain-writer python-dotenv
```

Next, create a `.env` file with `WRITER_API_KEY` set to your Writer API key:

```
WRITER_API_KEY=<your-api-key>
```

## Components of the Writer LangChain integration

The `langchain-writer` package provides several key components:

1. `ChatWriter` for text generation
2. Tool calling capabilities, including:
   * `GraphTool` for Knowledge Graph integration
   * `NoCodeAppTool` for no-code applications
   * `LLMTool` for specialized model delegation
3. Additional tools like `PDFParser` for parsing PDFs and `WriterTextSplitter` for intelligent text splitting

## ChatWriter

`ChatWriter` is a LangChain chat model that provides access to Writer's AI capabilities for text generation. It supports streaming, non-streaming, batching, and asynchronous operations. You can use any of the [Palmyra chat models](/home/models) available in AI Studio.

See the [full documentation](https://github.com/writer/langchain-writer/blob/main/docs/chat_writer.md#parameters) for `ChatWriter` to learn more about the available parameters.

### Usage

This example uses `ChatWriter` to ask the Palmyra X 004 model to explain what LangChain is in plain terms.

```python
from langchain_writer import ChatWriter
from dotenv import load_dotenv

load_dotenv()

# Initialize the chat model
# These are optional parameters with default values listed here
chat = ChatWriter(
    model="palmyra-x-004",  # default model
    temperature=0.7,        # controls randomness (0-1)
    max_tokens=None,        # maximum number of tokens to generate
    timeout=None,           # request timeout
    max_retries=2          # number of retries on failure
)

# Generate a response
response = chat.invoke("Explain what LangChain is in simple terms.")
print(response.content)
```

### Streaming

Streaming allows you to receive the generated text in chunks as it's being produced. This example shows how to stream a response from the Palmyra X 004 model using synchronous streaming:

```python
from langchain_writer import ChatWriter
import asyncio
from dotenv import load_dotenv

load_dotenv()

chat = ChatWriter()

# Streaming (synchronous)
for chunk in chat.stream("Write a short poem about artificial intelligence."):
    print(chunk.content, end="")
```

You can also use asynchronous streaming with the `async for` loop and the `astream` method:

```python
from langchain_writer import ChatWriter
import asyncio
from dotenv import load_dotenv

load_dotenv()

chat = ChatWriter()

# Streaming (asynchronous)
async def async_stream():
    async for chunk in chat.astream("Write a short poem about artificial intelligence."):
        print(chunk.content, end="")

asyncio.run(async_stream())
```

### Batch processing

You can batch process multiple prompts for efficient processing. The following example batches three individual LLM invocations and runs them in parallel:

```python
from langchain_writer import ChatWriter
from dotenv import load_dotenv

load_dotenv()

chat = ChatWriter()

questions = [
    "What is a three-sentence definition of retrieval-augmented generation?",
    "When did transformer architecture first appear in the literature?",
    "What are 3 benefits of using AI to assist in software development?"
]

# Process multiple prompts in parallel
responses = chat.batch(questions)

for question, response in zip(questions, responses):
    print(f"Q: {question}")
    print(f"A: {response.content}\n")
```

Note that `batch` returns results in the same order as the inputs. You can use `batch_as_completed` to return results as they complete. Results may arrive out of order, but each includes the input index for matching.

You can also optionally set the `max_concurrency` parameter to control the number of concurrent requests, which can be useful when you want to limit the number of parallel calls to prevent overloading a server or API:

```python
responses = chat.batch(questions,
    config={"max_concurrency": 2}
)
```

See the LangChain documentation on [parallel execution](https://python.langchain.com/docs/concepts/runnables/#optimized-parallel-execution-batch) for more information.

## Tool calling

`ChatWriter` supports tool calling, which allows the model to use external functions to enhance its capabilities. Tool calling is available with Palmyra X 004 and later.

### Tool calling basics

To use tool calling, follow these steps:

1. Define a function that will be called by the model and decorate it with the `@tool` decorator.
2. Bind the tool to the chat model using the `bind_tools` method.
3. Use the tool in a chat and append the response to the messages list.
4. Execute the tool call with the arguments given by the model and append the response to the messages list.
5. Invoke the chat model with the updated messages list to receive the final response.

Here's an example of how to use tool calling:

```python
from langchain_writer import ChatWriter
from langchain_core.tools import tool
from langchain_core.messages import HumanMessage
from dotenv import load_dotenv

load_dotenv()

@tool
def get_weather(location: str) -> str:
    """Get the current weather for a location."""
    # In a real application, you would call a weather API here
    return f"The weather in {location} is sunny and 75Â°F"

chat = ChatWriter()
chat_with_tools = chat.bind_tools([get_weather])

messages = [
    HumanMessage(
        "What's the weather like in San Francisco?"
    )
]

response = chat_with_tools.invoke(messages)
messages.append(response)

for tool_call in response.tool_calls:
    selected_tool = {
        "get_weather": get_weather,
    }[tool_call["name"].lower()]
    tool_msg = selected_tool.invoke(tool_call)
    messages.append(tool_msg)

response = chat_with_tools.invoke(messages)
print(response.content)
```

### GraphTool

`GraphTool` is a LangChain tool that allows you to retrieve information from a Knowledge Graph to enhance its responses. The tool executes remotely, so you simply need to provide the IDs of the Knowledge Graph you want to use. For more details on the built-in Knowledge Graph chat tool in Writer, see the [Knowledge Graph chat support guide](/api-guides/kg-chat).

#### Usage

```python
from langchain_writer import ChatWriter
from langchain_writer.tools import GraphTool
from dotenv import load_dotenv

load_dotenv()

# Initialize the chat model
chat = ChatWriter()

# Create a graph tool with your knowledge graph ID
graph_tool = GraphTool(graph_ids=["your-knowledge-graph-id"])

# Bind the tool to the chat model
chat_with_tools = chat.bind_tools([graph_tool])

# Ask a question that can be answered using the knowledge graph
response = chat_with_tools.invoke("What information do you have about product X?")
print(response.content)
```

### NoCodeAppTool

`NoCodeAppTool` is a specialized tool that enables access to Writer's no-code applications as LLM tools. This tool allows language models to interact with pre-built applications to enhance their responses.

The tool is designed as a standard "function" type tool and requires manual execution. Unlike the `GraphTool` and `LLMTool` which are executed remotely by Writer's servers, you'll need to handle the execution of the `NoCodeAppTool` in your code.

When initializing the tool, you must provide an `app_id` (either directly or using an environment variable) that corresponds to a no-code application created in your Writer account. The tool automatically retrieves the input parameters for the app during initialization, so you don't need to specify them manually.

You can customize the tool's name (default is "No-code application") and description (default is "No-code application powered by Palmyra") to provide better context to the model. The API key is typically read from environment variables but can also be provided directly.

When working with the tool, remember that all required inputs must be provided when invoking it, or a `ValueError` will be raised. Input values can be either strings or lists of strings, depending on what the no-code application expects.

This tool is particularly useful for generating content, performing specialized data transformations, creating custom outputs based on user inputs, integrating with domain-specific applications, enhancing responses with formatted content, or leveraging pre-built applications for common tasks.

#### Usage

Here's an example of how to use the `NoCodeAppTool`:

```python
from langchain_writer import ChatWriter
from langchain_writer.tools import NoCodeAppTool
from langchain_core.messages import HumanMessage
import os
from dotenv import load_dotenv

load_dotenv()

chat = ChatWriter()

# Create a NoCodeAppTool
app_tool = NoCodeAppTool(
    app_id=os.getenv("APP_ID"), 
    name="Social post generator", 
    description="No-code app that generates social posts from product descriptions"
)

# Bind the tool ChatWriter
chat_with_tools = chat.bind_tools([app_tool])

product_description = "The Terra running shoe is a high-performance, lightweight shoe that offers a comfortable and durable experience. The shoe is also lightweight and easy to carry, making it an ideal option for runners looking for a new pair of shoes."

# Create a conversation
messages = [
    HumanMessage("Can you help me generate a social post about a new running shoe? Here is the product description:\n\n" + product_description)
]

# Get the model's response
response = chat_with_tools.invoke(messages)
messages.append(response)

# If the model requests to use the tool
if response.tool_calls:
    for tool_call in response.tool_calls:
        print("\nTool call:", tool_call)
        
        # Dynamically build the inputs dictionary from the args
        inputs = {}
        for arg in tool_call['args']:
            inputs[arg] = tool_call['args'][arg]
        
        # Execute the tool call
        try:
            tool_response = app_tool.run(tool_input={"inputs": inputs})
            messages.append(tool_response.suggestion)
        except Exception as e:
            print(f"Error running tool: {e}")
    
    # Get the final response
    try:
        final_response = chat_with_tools.invoke(messages)
        print("\nFinal response:", final_response.content)
    except Exception as e:
        print(f"Error getting final response: {e}")
else:
    print("No tool calls were requested.")
```

When providing inputs to the tool, you'll need to format them as a dictionary:

```python
# Example of providing inputs to the tool
inputs = {
    "Input name": "Input value",
    "Another input name": ["List", "of", "string", "values"]
}

# Invoke the tool with the inputs
result = app_tool.run(tool_input={"inputs": inputs})
```

### LLMTool

`LLMTool` is a specialized tool that enables delegation to specific Writer models. This tool allows language models to delegate calls to different Palmyra model types to enhance their responses.

Unlike most LangChain tools that use the standard "function" type, the `LLMTool` has a type of `llm` and is designed specifically for use within the Writer environment. Due to its remote execution nature, this tool doesn't support direct invocation through the `_run` methodâ€”attempting to call this method will raise a `NotImplementedError`.

When initializing the tool, you can specify which Palmyra model to delegate to using the `model_name` parameter. Options include general-purpose models like `palmyra-x-004`, as well as domain-specific models such as `palmyra-med` for medical content, `palmyra-fin` for financial analysis, and `palmyra-creative` for creative content generation. The default model is `palmyra-x-004`. The `description` parameter plays a crucial role in helping the model understand when to use this tool.

When the model uses the LLM tool, the execution happens remotely on Writer's servers, and the response includes additional data in the `additional_kwargs["llm_data"]` field that you can access in your application.

This tool is particularly valuable when you need specialized domain knowledge. For example, you might delegate medical questions to the `palmyra-med` model, use `palmyra-creative` for generating creative content, or leverage `palmyra-fin` for financial analysis.

#### Usage

Here's an example of how to use the `LLMTool`:

```python
from langchain_writer import ChatWriter
from langchain_writer.tools import LLMTool
from dotenv import load_dotenv

load_dotenv()

chat = ChatWriter()

# Create an LLMTool
llm_tool = LLMTool(
    model_name="palmyra-med",
    description="A medical model that can answer questions about the human body and extract ICD-10 codes."
)

# Bind the tool to the ChatWriter
chat_with_tools = chat.bind_tools([llm_tool])

# Now the model can delegate to the specialized LLM in its responses
response = chat_with_tools.invoke([
    ("system", "You are a helpful assistant with access to medical knowledge."),
    ("human", "Can you explain the symptoms of hypertension and provide the ICD-10 code?")
])

print(response.content)

# The LLM data is available in the response
print(response.additional_kwargs["llm_data"])
```

## Additional tools

### PDFParser

`PDFParser` is a document loader that uses Writer's PDF parsing capabilities to extract text from PDF documents. It converts PDFs into LangChain Document objects that can be used in your applications. For more details on the underlying API, see the [PDF parser API reference](/api-guides/api-reference/tool-api/pdf-parser).

#### Usage

Here's an example of how to use the `PDFParser`:

```python
from langchain_writer import PDFParser
from langchain_core.documents.base import Blob
from dotenv import load_dotenv

load_dotenv()

# Initialize the PDF parser with the desired output format
parser = PDFParser(output_format="markdown")  # Options: "text", "markdown"

# Load a PDF file
file = Blob.from_path("path/to/your/document.pdf")

parsed_pages = parser.parse(blob=file)
print(parsed_pages)
```

#### Output formats

The `PDFParser` supports different output formats:

* `text`: Plain text extraction
* `markdown`: Structured markdown with preserved formatting

```python
# For markdown output
markdown_parser = PDFParser(output_format="markdown")
markdown_docs = markdown_parser.load("path/to/your/document.pdf")
```

### WriterTextSplitter

`WriterTextSplitter` is a text splitter that uses Writer's context-aware splitting capabilities to divide documents into semantically meaningful chunks. This is particularly useful for preparing documents for retrieval systems. For more details on the underlying API, see the [context-aware splitting tool API reference](/api-guides/api-reference/tool-api/context-aware-splitting).

#### Usage

Here's an example of how to use the `WriterTextSplitter`:

```python
from langchain_writer import WriterTextSplitter
from dotenv import load_dotenv

load_dotenv()

# Initialize the text splitter with the desired strategy
text_splitter = WriterTextSplitter(strategy="hybrid_split")

# Long text you wish to split
text = "Long text you wish to split..."

# Split the document
chunks = text_splitter.split_text(text)

# Print the chunks
for i, chunk in enumerate(chunks):
    print(f"Chunk {i+1}: {chunk[:50]}...")
```

#### Splitting strategies

The `WriterTextSplitter` supports different splitting strategies:

* `llm_split`: Uses language model for precise semantic splitting
* `fast_split`: Uses heuristic-based approach for quick splitting
* `hybrid_split`: Combines both approaches for a balance of speed and quality

```python
# For language model-based splitting
llm_splitter = WriterTextSplitter(strategy="llm_split")

# For faster, heuristic-based splitting
fast_splitter = WriterTextSplitter(strategy="fast_split")
```

## Conclusion

In this tutorial, you've explored the LangChain integration with Writer, covering each of its components:

1. `ChatWriter` for text generation
2. Tool calling capabilities, including:
   * `GraphTool` for Knowledge Graph integration
   * `NoCodeAppTool` for no-code applications
   * `LLMTool` for specialized model delegation
3. Additional tools like `PDFParser` for parsing PDFs and `WriterTextSplitter` for intelligent text splitting

This integration provides a powerful foundation for building AI applications with Writer and LangChain. Check out the package [README](https://github.com/writer/langchain-writer) and [documentation](https://github.com/writer/langchain-writer/tree/main/docs), as well as the [LangChain Documentation](https://python.langchain.com/docs/) for more information on how to use LangChain with Writer.


# API and SDKs
Source: https://dev.writer.com/api-guides/introduction



The Writer API provides endpoints for integrating Writer generative AI technology into applications or services within your own stack.

Use the Writer API if:

* You need to integrate AI capabilities into a legacy system
* You want to build a new AI application in the framework or language of your choice
* You need more control of your application than our no-code tools and Writer Framework can provide

You can access the API endpoints directly or use our [Python and Node SDKs](/api-guides/sdks).

<CardGroup cols={2}>
  <Card title="Quickstart" icon="browser" color="currentColor" href="/api-guides/quickstart">
    Ready to get started? Head to the [Quickstart](/api-guides/quickstart) to start generating text with your first API call.
  </Card>

  <Card title="SDKs" icon="code" color="currentColor" href="/api-guides/sdks">
    Our SDKs offer convenient access to the Writer API from Python and JavaScript applications.
  </Card>
</CardGroup>


# Use a Knowledge Graph in a chat
Source: https://dev.writer.com/api-guides/kg-chat



This guide demonstrates how to send questions to a [Knowledge Graph](/api-guides/knowledge-graph) during a [chat completion](/api-guides/chat-completion). Knowledge Graph chat is a predefined tool you can use to reference a Knowledge Graph when users chat with a Palmyra LLM.

<Note>
  You need an API key to access the Writer API. Get an API key by following the steps in the [API quickstart](/api-guides/quickstart).

  We recommend setting the API key as an environment variable in a `.env` file with the name `WRITER_API_KEY`.
</Note>

## Tool structure

Knowledge Graph chat is a predefined tool supported by Palmyra-X-004 and later models, to be used with tool calling in the [chat endpoint](/api-guides/api-reference/completion-api/chat-completion). To use Knowledge Graph chat, add the following object to the `tools` array when calling the chat endpoint:

| Parameter              | Type    | Description                                                                                                                                                                                                                     |
| ---------------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`                 | string  | The type of tool. Must be `graph` for Knowledge Graph chat.                                                                                                                                                                     |
| `function`             | object  | An object containing the `graph_ids`, `description`, and `subqueries` parameters                                                                                                                                                |
| `function.graph_ids`   | array   | An array of strings containing the graph IDs you wish to reference                                                                                                                                                              |
| `function.description` | string  | A description of the graphs you are referencing. This helps the model understand when to use the Knowledge Graph tool in the chat. If there are multiple graphs, include a description for each, referencing the graph by name. |
| `function.subqueries`  | Boolean | A Boolean indicating whether to include the subqueries used by Palmyra in the response.                                                                                                                                         |

<CodeGroup>
  ```bash cURL
  "tools": [
      {
          "type": "graph",
          "function": {
              "description": "Description of the graph(s)",
              "graph_ids": [
                  "your-graph-id"
              ],
              "subqueries": true
          }
      }  
  ]
  ```

  ```python Python
  tools = [{
      "type": "graph",
      "function": {
          "description": "Description of the graph(s)",
          "graph_ids": [
              "your-graph-id"
          ],
          "subqueries": True
      }
  }]
  ```

  ```js JavaScript
  const tools = [{
      type: "graph",
      function: {
          description: "Description of the graph(s)",
          graph_ids: [
              "your-graph-id"
          ],
          subqueries: true
      }
  }]
  ```
</CodeGroup>

<Note>
  You can only pass one prebuilt tool in the `tools` array at a time. However, you can pass multiple [custom tools](/api-guides/tool-calling) in the same request.

  Prebuilt tools are:

  * Knowledge Graph tool
  * [LLM tool](/api-guides/model-delegation)
  * [Vision tool](/api-guides/vision-tool)
</Note>

### Response format

When a chat completion uses the Knowledge Graph tool, the response from the Knowledge Graph tool is in the `graph_data` object. That object contains the following fields:

| Parameter            | Type   | Description                                                                                                |
| -------------------- | ------ | ---------------------------------------------------------------------------------------------------------- |
| `sources`            | array  | An array of objects containing the source file IDs and snippets that helped the model answer the question. |
| `sources.file_id`    | string | The ID of the source file.                                                                                 |
| `sources.snippet`    | string | A snippet from the source file that helped the model answer the question.                                  |
| `status`             | string | The status of the query.                                                                                   |
| `subqueries`         | array  | An array of objects containing the subqueries used by Palmyra in the response.                             |
| `subqueries.query`   | string | The query used by Palmyra to answer the question.                                                          |
| `subqueries.answer`  | string | The answer to the question.                                                                                |
| `subqueries.sources` | array  | An array of objects containing the source file IDs and snippets that helped the model answer the question. |

The full response has the following structure.

The subqueries and sources shown are abbreviated for readability. If the `subqueries` parameter is `false`, or if the model doesn't need subqueries to answer the question, this array is be empty.

<CodeGroup>
  ```json streaming response [expandable] {12}
  {
      "id": "1234",
      "object": "chat.completion.chunk",
      "choices": [
          {
              "index": 0,
              "finish_reason": "stop",
              "delta": {
                  "content": "None of our products contain both chocolate and food coloring. The products containing chocolate are different from those containing food coloring.",
                  "role": "assistant",
                  "tool_calls": null,
                  "graph_data": {
                      "sources": [
                          {
                              "file_id": "1234",
                              "snippet": "with cocoa for an extra touch of chocolateâ€¦"
                          },
                          {
                              "file_id": "5678",
                              "snippet": "Sugar, corn syrup, artificial flavors, food coloringâ€¦"
                          }
                      ],
                      "status": "finished",
                      "subqueries": [
                          {
                              "query": "Which of our products contain food coloring?",
                              "answer": "The products that contain food coloring are...",
                              "sources": [
                                  {
                                      "file_id": "1234",
                                      "snippet": "Sugar, citric acid, artificial flavorsâ€¦"
                                  },
                                  {
                                      "file_id": "5678",
                                      "snippet": "Coffee, coconut milk, ice"
                                  }
                              ]
                          },
                          {
                              "query": "Which of our products contain chocolate?",
                              "answer": "Several products contain chocolate. These includeâ€¦",
                              "sources": [
                                  {
                                      "file_id": "1234",
                                      "snippet": "with cocoa for an extra touch of chocolateâ€¦"
                                  }
                              ]
                          }
                      ]
                  }
              },
          }
      ]
      // Other fields omitted for brevity    
  }
  ```

  ```json non-streaming response [expandable] {12}
  {
      "id": "1234",
      "object": "chat.completion",
      "choices": [
          {
              "index": 0,
              "finish_reason": "stop",
              "message": {
                  "content": "None of our products contain both chocolate and food coloring. The products containing chocolate are different from those containing food coloring.",
                  "role": "assistant",
                  "tool_calls": null,
                  "graph_data": {
                      "sources": [
                          {
                              "file_id": "1234",
                              "snippet": "with cocoa for an extra touch of chocolateâ€¦"
                          },
                          {
                              "file_id": "5678",
                              "snippet": "Sugar, corn syrup, artificial flavors, food coloringâ€¦"
                          }
                      ],
                      "status": "finished",
                      "subqueries": [
                          {
                              "query": "Which of our products contain food coloring?",
                              "answer": "The products that contain food coloring are...",
                              "sources": [
                                  {
                                      "file_id": "1234",
                                      "snippet": "Sugar, citric acid, artificial flavorsâ€¦"
                                  },
                                  {
                                      "file_id": "5678",
                                      "snippet": "Coffee, coconut milk, ice"
                                  }
                              ]
                          },
                          {
                              "query": "Which of our products contain chocolate?",
                              "answer": "Several products contain chocolate. These includeâ€¦",
                              "sources": [
                                  {
                                      "file_id": "1234",
                                      "snippet": "with cocoa for an extra touch of chocolateâ€¦"
                                  }
                              ]
                          }
                      ]
                  }
              },
          }
      ]
      // Other fields omitted for brevity    
  }
  ```
</CodeGroup>

## Usage example

The following example uses a hypothetical product information Knowledge Graph to answer a question about which food products contain both food coloring and chocolate.

### Create the tools array

First, define the `tools` array with the `type` set to `graph`. The `function` object contains the `graph_ids`, `description`, and `subqueries` parameters.

In this example, the subqueries are included in the response. Subqueries can be useful for debugging or for providing additional context to the user about how the model arrived at the answer.

<CodeGroup>
  ```bash cURL
  "tools": [
      {
          "type": "graph",
          "function": {
              "description": "Knowledge Graph containing information about Acme Inc. food products",
              "graph_ids": [
                  "6029b226-1ee0-4239-a1b0-cdeebfa3ad5a"
              ],
              "subqueries": true
          }
      }
  ]
  ```

  ```python Python
  tools = [{
      "type": "graph",
      "function": {
          "description": "Knowledge Graph containing information about Acme Inc. food products",
          "graph_ids": [
              "6029b226-1ee0-4239-a1b0-cdeebfa3ad5a"
          ],
          "subqueries": True
      }
  }]
  ```

  ```js JavaScript
  const tools = [{
      type: "graph",
      function: {
          description: "Knowledge Graph containing information about Acme Inc. food products",
          graph_ids: [
              "6029b226-1ee0-4239-a1b0-cdeebfa3ad5a"
          ],
          subqueries: true
      }
  }]
  ```
</CodeGroup>

### Send the request

Add the tools array to the chat endpoint call along with your array of messages. Setting `tool_choice` to `auto` allows the model to choose when to use the Knowledge Graph tool, based on the user's question and the description of the tool.

This example streams the response in real-time as the model generates it.

If you are unfamiliar with the chat completions endpoint or streaming vs. non-streaming responses, learn more in the [chat completion guide](/api-guides/chat-completion).

<CodeGroup>
  ```bash cURL
  curl --location 'https://api.writer.com/v1/chat' \
      --header 'Content-Type: application/json' \
      --header "Authorization: Bearer $WRITER_API_KEY" \
      --data '{
          "model": "palmyra-x-004",
          "messages": [
              {
                  "role": "user",
                  "content": "Which of our products contain both food coloring and chocolate?"
              }
          ],
          "tool_choice": "auto",
          "tools": [
              {
                  "type": "graph",
                  "function": {
                      "description": "Knowledge Graph containing information about Acme Inc. food products",
                      "graph_ids": [
                          "6029b226-1ee0-4239-a1b0-cdeebfa3ad5a"
                      ],
                      "subqueries": true
                  }
              }
          ],
          "stream": true
      }'
  ```

  ```python Python
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  messages = [{"role": "user", "content": "Which of our products contain both food coloring and chocolate?"}]

  response = client.chat.chat(
      model="palmyra-x-004", 
      messages=messages, 
      tools=tools,  # The tools array defined earlier.
      tool_choice="auto",
      stream=True
  )

  for chunk in response:
      if chunk.choices[0].delta.content is not None:
          print(chunk.choices[0].delta.content)
  ```

  ```js JavaScript
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  let messages = [{role: "user", content: "Which of our products contain both food coloring and chocolate?"}]

  const response = await client.chat.chat(
      model: "palmyra-x-004", 
      messages: messages, 
      tools: tools, // The tools array defined earlier.
      tool_choice: "auto",
      stream: true 
  );

  for await (const chunk of response) {
      if (chunk.choices[0].delta.content) {
          console.log(chunk.choices[0].delta.content);
      }
  }
  ```
</CodeGroup>

### Display Knowledge Graph subqueries and sources

You may want to display the `sources` or `subqueries` in your UI to assist your user in understanding how the model derived the answer to the question. The following example shows how to display the subqueries as well as the status of the query from the Knowledge Graph.

<CodeGroup>
  ```python Python
  from writerai import Writer

  # Initialize the client.
  client = Writer()

  messages = [{"role": "user", "content": "Which of our products contain both food coloring and chocolate?"}]

  response = client.chat.chat(
      model="palmyra-x-004",
      messages=messages,
      tools=tools,
      tool_choice="auto",
      stream=True
  )

  for chunk in response:
      if chunk.choices[0].delta.content is not None:
          print(chunk.choices[0].delta.content, end="", flush=True)

      if chunk.choices[0].delta.graph_data is not None:
          if chunk.choices[0].delta.graph_data.status is not None:
              print(f"Query status: {chunk.choices[0].delta.graph_data.status}")
          if chunk.choices[0].delta.graph_data.subqueries:
              print(f"Subquery: {chunk.choices[0].delta.graph_data.subqueries[0].query}")
  ```

  ```js JavaScript
  import { Writer } from "writer-sdk";

  // Initialize the client.
  const client = new Writer();

  let messages = [{role: "user", content: "Which of our products contain both food coloring and chocolate?"}]

  const response = await client.chat.chat(
      model: "palmyra-x-004", 
      messages: messages, 
      tools: tools, // The tools array defined earlier.
      tool_choice: "auto",
      stream: true 
  );

  for await (const chunk of response) {
      if (chunk.choices[0].delta.content) {
          console.log(chunk.choices[0].delta.content);
      }

      if (chunk.choices[0].delta.graph_data) {
          if (chunk.choices[0].delta.graph_data.status) {
              console.log(`Query status: ${chunk.choices[0].delta.graph_data.status}`);
          }
          if (chunk.choices[0].delta.graph_data.subqueries) {
              console.log(`Subquery: ${chunk.choices[0].delta.graph_data.subqueries[0].query}`);
          }
      }
  }
  ```
</CodeGroup>

## Next steps

By following this guide, you can reference Knowledge Graphs in your users' chats in your application.

Next, learn about other prebuilt tools you can use in your chat applications:

* [Analyze images](/api-guides/vision-tool)
* [Pass questions to a domain-specific LLM](/api-guides/model-delegation)


# Create and manage a Knowledge Graph
Source: https://dev.writer.com/api-guides/knowledge-graph



Knowledge Graph, our graph-based retrieval-augmented generation (RAG), achieves [higher accuracy](https://arxiv.org/abs/2405.02048) than traditional RAG approaches that use vector retrieval.

This guide will help you understand and use the [Knowledge Graph API](/api-guides/api-reference/kg-api) to integrate RAG capabilities into your agents.

<Note>
  You need an API key to access the Writer API. Get an API key by following the steps in the [API quickstart](/api-guides/quickstart).

  We recommend setting the API key as an environment variable in a `.env` file with the name `WRITER_API_KEY`.
</Note>

## Create a Knowledge Graph

A Knowledge Graph is a collection of files that are used to answer questions. To start working with a Knowledge Graph, create an empty Knowledge Graph that you can add files to.

**Endpoint**: `POST https://api.writer.com/v1/graphs`

<CodeGroup>
  ```bash cURL
  curl --location --request POST https://api.writer.com/v1/graphs \
    --header "Authorization: Bearer $WRITER_API_KEY" \
    --header "Content-Type: application/json" \
    --data-raw '{
      "name": "Financial Reports",
      "description": "Knowledge Graph of 2024 financial reports"
      }'
  ```

  ```python Python
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  graph_create_response = client.graphs.create(
      name="Financial Reports",
      description="Knowledge Graph of 2024 financial reports"
  )
  ```

  ```javascript JavaScript
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `api_key` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const graphCreateResponse = await client.graphs.create({
    name: "Financial Reports",
    description: "Knowledge Graph of 2024 financial reports"
  });
  ```
</CodeGroup>

### Request body

The request body is a JSON object that contains the following fields:

| Parameter     | Type   | Description                                                                                                                                             |
| ------------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `name`        | string | The name of the Knowledge Graph.                                                                                                                        |
| `description` | string | The description of the Knowledge Graph. The description should help the model understand the purpose of the Knowledge Graph and when it should be used. |

### Response format

The response has the following structure:

| Parameter     | Type   | Description                                        |
| ------------- | ------ | -------------------------------------------------- |
| `id`          | string | The ID of the Knowledge Graph.                     |
| `created_at`  | string | The date and time the Knowledge Graph was created. |
| `name`        | string | The name of the Knowledge Graph.                   |
| `description` | string | The description of the Knowledge Graph.            |

```json
{
  "id": "6029b226-1ee0-4239-a1b0-cdeebfa3ad5a",
  "created_at": "2024-06-24T12:34:56Z",
  "name": "Financial Reports",
  "description": "Knowledge Graph of 2024 financial reports"
}
```

## Add a file to a Knowledge Graph

Once you've created a Knowledge Graph, you can add files to it. The files you add to a Knowledge Graph are used to answer questions and enhance the accuracy of the responses from the LLM

You must upload the file to the Writer API before adding it to a Knowledge Graph. See [Manage files](/api-guides/files) for more information about how to upload files.

**Endpoint**: `POST /v1/graphs/{graph_id}/file`

<CodeGroup>
  ```bash cURL
  curl --location --request POST https://api.writer.com/v1/graphs/{graph_id}/file \
  --header "Authorization: Bearer $WRITER_API_KEY" \
  --header "Content-Type: application/json" \
  --data-raw '{"file_id":"1862f090-a281-48f3-8838-26c1e78b605e"}'
  ```

  ```python Python
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  graph_file = client.graphs.add_file_to_graph(
    graph_id="{graph_id}",
    file_id="1862f090-a281-48f3-8838-26c1e78b605e",
  )
  ```

  ```javascript JavaScript
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `api_key` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const file = await client.graphs.addFileToGraph('{graph_id}', {
    file_id: '1862f090-a281-48f3-8838-26c1e78b605e',
  });
  ```
</CodeGroup>

The response will have this structure:

```json
{
  "id": "1862f090-a281-48f3-8838-26c1e78b605e",
  "created_at": "2024-07-01T20:41:44.159505Z",
  "name": "test.txt",
  "graph_ids": [
    "6029b226-1ee0-4239-a1b0-cdeebfa3ad5a"
  ]
}
```

### Path parameters

| Parameter  | Description                              |
| ---------- | ---------------------------------------- |
| `graph_id` | The ID of the Knowledge Graph to update. |

### Request body

The request body is a JSON object that contains the following fields:

| Parameter | Description                                       |
| --------- | ------------------------------------------------- |
| `file_id` | The ID of the file to add to the Knowledge Graph. |

You must upload the file to the Writer API before adding it to a Knowledge Graph. See [Manage files](/api-guides/files) for more information about how to upload files.

## Remove a file from a Knowledge Graph

**Endpoint**: `DELETE /v1/graphs/{graph_id}/file/{file_id}`

<CodeGroup>
  ```bash cURL
  curl --location --request DELETE "https://api.writer.com/v1/graphs/{graph_id}/file/{file_id}" \
  --header "Authorization: Bearer $WRITER_API_KEY"
  ```

  ```python Python
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  client.graphs.remove_file_from_graph(
      graph_id="{graph_id}",
      file_id="{file_id}"
  )
  ```

  ```javascript JavaScript
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `api_key` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const file = await client.graphs.removeFileFromGraph('{graph_id}', '{file_id}');
  ```
</CodeGroup>

### Path parameters

| Parameter  | Description                                            |
| ---------- | ------------------------------------------------------ |
| `graph_id` | The ID of the Knowledge Graph to update.               |
| `file_id`  | The ID of the file to remove from the Knowledge Graph. |

### Response format

The response has this structure:

```json
{
  "id": "1862f090-a281-48f3-8838-26c1e78b605e",
  "deleted": true
}
```

## Add a Knowledge Graph to a no-code agent

After you've created a Knowledge Graph, you can add it to a [no-code agent](/api-guides/applications) to add RAG capabilities.

You can use this endpoint to add or remove Knowledge Graphs from a no-code agent.

**Endpoint**: `PUT /v1/applications/{application_id}/graphs`

<CodeGroup>
  ```bash cURL
  curl --location --request PUT "https://api.writer.com/v1/applications/{application_id}/graphs" \
  --header "Authorization: Bearer $WRITER_API_KEY" \
  --header "Content-Type: application/json" \
  --data-raw '{"graph_id":"6029b226-1ee0-4239-a1b0-cdeebfa3ad5a"}'
  ```

  ```python Python
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  client.applications.graphs.update(
      application_id="{application_id}",
      graph_ids=["{graph_id}"]
  )
  ```

  ```javascript JavaScript
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `api_key` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  client.applications.graphs.update('{application_id}', ['{graph_id}']);
  ```
</CodeGroup>

### Path parameters

| Parameter        | Description                            |
| ---------------- | -------------------------------------- |
| `application_id` | The ID of the no-code agent to update. |

### Request body

The request body is a JSON object that contains the following fields:

| Parameter   | Type           | Description                                                          |
| ----------- | -------------- | -------------------------------------------------------------------- |
| `graph_ids` | array\[string] | The IDs of the Knowledge Graphs to associate with the no-code agent. |

This method updates the associated Knowledge Graphs to the exact list of IDs provided in the request.

To remove a single Knowledge Graph from the no-code agent, set the `graph_ids` parameter to an array containing the IDs of all the other Knowledge Graphs associated with the no-code agent, excluding the ID of the Knowledge Graph to remove. To remove all Knowledge Graphs from the no-code agent, set this parameter to an empty array.

### Response format

The response contains the new list of IDs of the Knowledge Graphs associated with the no-code agent.

```json
{
  "graph_ids": [
    "6029b226-1ee0-4239-a1b0-cdeebfa3ad5a"
  ]
}
```

## Next steps

Now that you've created a Knowledge Graph, learn how to ask it questions in a chat completion via [tool calling](/api-guides/kg-chat).


# Extract entities from unstructured medical text
Source: https://dev.writer.com/api-guides/medical-comprehend



The [medical comprehend endpoint](/api-guides/api-reference/tool-api/comprehend-medical) analyzes unstructured medical text to extract entities and label them with standardized medical codes. Each extracted entity comes with a confidence score, making it useful for processing clinical notes, medical records, and other healthcare-related documents.

## Use cases

* Automating medical records processing and classification
* Extracting diagnosis codes from clinical notes for billing and insurance purposes
* Creating structured datasets from unstructured medical documentation
* Identifying and categorizing medications and their attributes in patient records
* Standardizing medical terminology across different healthcare systems using SNOMED CT codes

<Note>
  You need an API key to access the Writer API. Get an API key by following the steps in the [API quickstart](/api-guides/quickstart).

  We recommend setting the API key as an environment variable in a `.env` file with the name `WRITER_API_KEY`.
</Note>

## Endpoint overview

**URL:** `POST https://api.writer.com/v1/tools/comprehend/medical`

<CodeGroup>
  ```bash cURL
  curl --location 'https://api.writer.com/v1/tools/comprehend/medical' \
  --header 'Content-Type: application/json' \
  --header "Authorization: Bearer $WRITER_API_KEY" \
  --data '{
      "content": "the symptoms are soreness, a temperature and cough", 
      "response_type": "SNOMED CT"
  }'
  ```

  ```python Python
  import os
  from writerai import Writer

  client = Writer(
      # This is the default and can be omitted
      api_key=os.environ.get("WRITER_API_KEY"),
  )
  medical = client.tools.comprehend.medical(
      content="the symptoms are soreness, a temperature and cough",
      response_type="Entities",
  )
  print(medical.entities)
  ```

  ```javascript JavaScript
  import Writer from 'writer-sdk';

  const client = new Writer({
    apiKey: process.env['WRITER_API_KEY'], // This is the default and can be omitted
  });

  async function main() {
    const medical = await client.tools.comprehend.medical({ content: 'the symptoms are soreness, a temperature and cough', response_type: 'Entities' });

    console.log(medical.entities);
  }

  main();
  ```
</CodeGroup>

### Request body

The request body includes the following parameters:

| Parameter       | Type   | Description                                |
| --------------- | ------ | ------------------------------------------ |
| `content`       | string | **Required.** The medical text to analyze. |
| `response_type` | string | **Required.** The desired response format. |

Response type options include:

* `Entities`: Returns medical entities with their categories.
* `RxNorm`: [RxNorm](https://www.nlm.nih.gov/research/umls/rxnorm/overview.html) provides normalized names and unique identifiers for medicines and drugs, allowing computer systems to communicate drug-related information efficiently and unambiguously.
* `ICD-10-CM`: [ICD-10-CM](https://www.cdc.gov/nchs/icd/icd-10-cm/index.html) is a standardized system used to code diseases and medical conditions (morbidity) data.
* `SNOMED CT`: [SNOMED CT](https://www.snomed.org/what-is-snomed-ct) is a standardized, multilingual vocabulary of clinical terminology that is used by physicians and other healthcare providers for the electronic exchange of health information.

### Response parameters

Returns an array of medical entities, where each entity includes:

| Parameter    | Type   | Description                                                |
| ------------ | ------ | ---------------------------------------------------------- |
| `category`   | string | The medical category of the entity                         |
| `text`       | string | The actual text that was identified                        |
| `score`      | float  | Confidence score for the entity (0-1)                      |
| `traits`     | array  | Array of trait objects with names and scores               |
| `concepts`   | array  | Array of medical concepts with codes and descriptions      |
| `attributes` | array  | Related attributes with their own scores and relationships |
| `type`       | string | The entity type                                            |

See the full [response schema](/api-guides/api-reference/tool-api/comprehend-medical) for more details.

```json example response [expandable]
{
  "entities": [
    {
      "category": "MEDICAL_CONDITION",
      "begin_offset": 17,
      "end_offset": 25,
      "text": "soreness",
      "traits": [
        {
          "score": 0.5752319693565369,
          "name": "HYPOTHETICAL"
        },
        {
          "score": 0.7299559712409973,
          "name": "SYMPTOM"
        }
      ],
      "concepts": [
        {
          "code": "71393004",
          "score": 0.9435068368911743,
          "description": "Soreness (finding)"
        },
        {
          "code": "279074008",
          "score": 0.27141574025154114,
          "description": "Sore skin (finding)"
        },
        {
          "code": "247348008",
          "score": 0.20372514426708221,
          "description": "Tenderness (finding)"
        },
        {
          "code": "410713007",
          "score": 0.18387910723686218,
          "description": "Sore sensation quality (qualifier value)"
        },
        {
          "code": "267102003",
          "score": 0.15431177616119385,
          "description": "Sore throat symptom (finding)"
        }
      ],
      "score": 0.7172441482543945,
      "attributes": [],
      "type": "DX_NAME"
    },
    {
      "category": "MEDICAL_CONDITION",
      "begin_offset": 29,
      "end_offset": 40,
      "text": "temperature",
      "traits": [
        {
          "score": 0.7299559712409973,
          "name": "HYPOTHETICAL"
        },
        {
          "score": 0.8787732124328613,
          "name": "SYMPTOM"
        }
      ],
      "concepts": [
        {
          "code": "703421000",
          "score": 0.4236489236354828,
          "description": "Temperature (observable entity)"
        },
        {
          "code": "386661006",
          "score": 0.4029766321182251,
          "description": "Fever (finding)"
        },
        {
          "code": "246508008",
          "score": 0.26857706904411316,
          "description": "Temperature (attribute)"
        },
        {
          "code": "56342008",
          "score": 0.26122674345970154,
          "description": "Temperature taking (procedure)"
        },
        {
          "code": "722490005",
          "score": 0.1763012409210205,
          "description": "Temperature (property) (qualifier value)"
        }
      ],
      "score": 0.8435389995574951,
      "attributes": [],
      "type": "DX_NAME"
    },
    {
      "category": "MEDICAL_CONDITION",
      "begin_offset": 45,
      "end_offset": 50,
      "text": "cough",
      "traits": [
        {
          "score": 0.9013108015060425,
          "name": "HYPOTHETICAL"
        },
        {
          "score": 0.9817302823066711,
          "name": "SYMPTOM"
        }
      ],
      "concepts": [
        {
          "code": "49727002",
          "score": 0.9173739552497864,
          "description": "Cough (finding)"
        },
        {
          "code": "263731006",
          "score": 0.20544156432151794,
          "description": "Coughing (observable entity)"
        },
        {
          "code": "247410004",
          "score": 0.18926720321178436,
          "description": "Painful cough (finding)"
        },
        {
          "code": "11833005",
          "score": 0.18911097943782806,
          "description": "Dry cough (finding)"
        },
        {
          "code": "135883003",
          "score": 0.1864289492368698,
          "description": "Cough with fever (finding)"
        }
      ],
      "score": 0.9584784507751465,
      "attributes": [],
      "type": "DX_NAME"
    }
  ]
}
```


# Use another LLM as a tool
Source: https://dev.writer.com/api-guides/model-delegation



With model delegation, you can use another Writer model as a tool in a [chat completion](/api-guides/chat-completion) with Palmyra-X-004 or later models. The predefined LLM tool allows you to delegate specific tasks to domain-specific Writer models, such as `palmyra-fin`, `palmyra-med`, or `palmyra-creative`.

For example, in a chat application using Palmyra-X-004, you can delegate financial analysis tasks to the `palmyra-fin` model.

This guide helps you understand how to perform model delegation using the Writer API.

<Note>
  You need an API key to access the Writer API. Get an API key by following the steps in the [API quickstart](/api-guides/quickstart).

  We recommend setting the API key as an environment variable in a `.env` file with the name `WRITER_API_KEY`.
</Note>

## Tool structure

Use the LLM tool to delegate specific tasks to another model when using the [chat endpoint](/api-guides/api-reference/completion-api/chat-completion). Using [tool calling](/api-guides/tool-calling), you can specify the Writer model you want to use for a given task. When the primary chat model calls the LLM tool based on the user's input, it signals it in the chat API response.

To use the LLM tool, add it to the `tools` array in your `chat-completion` endpoint request.

The LLM tool object has the following structure:

| Parameter              | Type     | Description                                                         |
| ---------------------- | -------- | ------------------------------------------------------------------- |
| `type`                 | `string` | The type of tool, which is `llm` for LLM tool                       |
| `function`             | `object` | An object containing the tool's description and model               |
| `function.description` | `string` | A description of what the model will be used for.                   |
| `function.model`       | `string` | The [ID of the Writer model](/home/models) to be used for this tool |

<Note>
  To help the model understand when to use the tool, follow these best practices for the `function.description` parameter:

  * Indicate that the tool is a function that invokes an LLM
  * Specify the model's purpose and capabilities
  * Describe when the tool should be used

  An example description for a tool using the `palmyra-med` model:

  > "A function that invokes the LLM identified by the given model, specialized in answering medical queries. Any user request asking for medical advice should use this tool."
</Note>

<CodeGroup>
  ```bash cURL
  "tools": [
      {
          "type": "llm",
          "function": {
              "description": "A function that will invoke the llm identified by the given model, specialized for financial analysis and reporting. Any user request asking for financial analysis should use this tool.",
              "model": "palmyra-fin"
          }
      }  
  ]
  ```

  ```python Python
  tools = [{
      "type": "llm",
      "function": {
          "description": "A function that will invoke the llm identified by the given model, specialized for financial analysis and reporting. Any user request asking for financial analysis should use this tool.",
          "model": "palmyra-fin"
      }
  }]
  ```

  ```js JavaScript
  const tools = [{
      type: "llm",
      function: {
          description: "A function that will invoke the llm identified by the given model, specialized for financial analysis and reporting. Any user request asking for financial analysis should use this tool.",
          model: "palmyra-fin"
      }
  }]
  ```
</CodeGroup>

<Note>
  You can only pass one prebuilt tool in the `tools` array at a time. However, you can pass multiple [custom tools](/api-guides/tool-calling) in the same request.

  Prebuilt tools are:

  * LLM tool
  * [Vision tool](/api-guides/vision-tool)
  * [Knowledge Graph tool](/api-guides/kg-chat)
</Note>

### Response format

When a chat completion uses the LLM tool, the response from the LLM tool is in the `llm_data` object. The `llm_data` object contains the following fields:

| Parameter | Type   | Description                                      |
| --------- | ------ | ------------------------------------------------ |
| `prompt`  | string | The prompt used by the LLM tool.                 |
| `model`   | string | The ID of the Writer model used by the LLM tool. |

Below is an example of the full response to a chat completion request that uses the LLM tool with `palmyra-med`.

<CodeGroup>
  ```json non-streaming response [expandable] {17}
  {
    "id": "1234",
    "object": "chat.completion",
    "choices": [
      {
        "index": 0,
        "finish_reason": "stop",
        "message": {
          "content": "The recommended daily intake of calcium for a 30-year-old woman is 1,000 mg per day.",
          "role": "assistant",
          "tool_calls": null,
          "graph_data": {
            "sources": null,
            "status": null,
            "subqueries": null
          },
          "llm_data": {
            "prompt": "What is the recommended daily intake of calcium for a 30-year-old woman?",
            "model": "palmyra-med"
          },
          "image_data": null,
          "refusal": null
        },
        "logprobs": null
      }
    ],
    "created": 1741970653,
    "model": "palmyra-x-004",
    "usage": {
      "prompt_tokens": 259,
      "total_tokens": 305,
      "completion_tokens": 46,
      "prompt_token_details": null,
      "completion_tokens_details": null
    },
    "system_fingerprint": "v1",
    "service_tier": null
  }
  ```

  ```json streaming response [expandable] {16}
  {
      "id": "1234",
      "object": "chat.completion.chunk",
      "choices": [{
          "index": 0,
          "finish_reason": None,
          "message": {
              "content": "The",
              "role": "assistant",
              "tool_calls": None,
              "graph_data": {
                  "sources": None,
                  "status": None,
                  "subqueries": None
              },
              "llm_data": {
                  "prompt": "What is the recommended daily intake of calcium for a 30-year-old woman?",
                  "model": "palmyra-med"
              },
              "image_data": None,
              "refusal": None
          },
          "logprobs": None,
      "delta": {
          "content": "The",
          "role": "assistant",
          "tool_calls": None,
          "graph_data": {
              "sources": None,
              "status": None,
              "subqueries": None
          },
          "llm_data": {
              "prompt": "What is the recommended daily intake of calcium for a 30-year-old woman?",
              "model": "palmyra-med"
          },
          "image_data": None,
          "refusal": None
      },
      "logprobs": None
      }],
      "created": 1741970696,
      "model": "palmyra-x-004",
      "usage": None,
      "system_fingerprint": "v1",
      "service_tier": None
  }
  ```
</CodeGroup>

## Usage example

Here's an example of how to use the LLM tool in your application. This example specifically delegates medical questions to the `palmyra-med` model.

### Create a tools array containing an LLM tool

To use the LLM tool, create a `tools` array that specifies the Writer model you want to use.

<CodeGroup>
  ```bash cURL
  "tools": [
      {
          "type": "llm",
          "function": {
              "description": "A function that will invoke the llm identified by the given model, specialized in answering medical queries. Any user request asking for medical advice should use this tool.",
              "model": "palmyra-med"
          }
      }
  ]
  ```

  ```python Python
  tools = [{
      "type": "llm",
      "function": {
          "description": "A function that will invoke the llm identified by the given model, specialized in answering medical queries. Any user request asking for medical advice should use this tool.",
          "model": "palmyra-med"
      }
  }]
  ```

  ```js JavaScript
  const tools = [{
      type: "llm",
      function: {
          description: "A function that will invoke the llm identified by the given model, specialized in answering medical queries. Any user request asking for medical advice should use this tool.",
          model: "palmyra-med"
      }
  }]
  ```
</CodeGroup>

### Send the request using chat completions

Add the tools array to the chat endpoint call along with your array of messages. Setting `tool_choice` to `auto` allows the model to choose when to use the LLM tool, based on the user's question and the description of the tool.

This example streams the response as the model generates it.

If you are unfamiliar with the chat completions endpoint or streaming vs. non-streaming responses, learn more in the [chat completion guide](/api-guides/chat-completion).

<CodeGroup>
  ```bash cURL
  curl --location 'https://api.writer.com/v1/chat' \
      --header 'Content-Type: application/json' \
      --header "Authorization: Bearer $WRITER_API_KEY" \
      --data '{
          "model": "palmyra-x-004",
          "temperature": 0.7,
          "messages": [
              {
                  "role": "user",
                  "content": "What is the recommended daily intake of calcium for a 30-year-old woman?"
              }
          ],
          "tool_choice": "auto",
          "tools": [
              {
                  "type": "llm",
                  "function": {
                      "description": "A function that will invoke the llm identified by the given model, specialized in answering medical queries. Any user request asking for medical advice should use this tool.",
                      "model": "palmyra-med"
                  }
              }
          ],
          "stream": true
      }'
  ```

  ```python Python
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  messages = [{"role": "user", "content": "What is the recommended daily intake of calcium for a 30-year-old woman?"}]

  response = client.chat.chat(
      model="palmyra-x-004", 
      messages=messages, 
      tools=tools,  # The tools array defined earlier.
      tool_choice="auto",
      stream=True
  )

  for chunk in response:
      if chunk.choices[0].delta.content is not None:
          print(chunk.choices[0].delta.content, end="", flush=True)
  ```

  ```js JavaScript
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const messages = [{role: "user", content: "What is the recommended daily intake of calcium for a 30-year-old woman?"}];

  const response = await client.chat.chat({
      model: "palmyra-x-004", 
      messages: messages, 
      tools: tools, // The tools array defined earlier.
      tool_choice: "auto",
      stream: true
  });

  for await (const chunk of response) {
      if (chunk.choices[0].delta.content) {
          process.stdout.write(chunk.choices[0].delta.content);
      }
  }
  ```
</CodeGroup>

By following this guide, you can use specialized, fine-tuned Writer models for specific tasks within your chat applications.

## Next steps

Learn about other prebuilt tools you can use in your chat applications:

* [Analyze images](/api-guides/vision-tool)
* [Pass questions to a Knowledge Graph](/api-guides/kg-chat)


# Parse a PDF
Source: https://dev.writer.com/api-guides/parse-pdf



The [PDF parser endpoint](/api-guides/api-reference/tool-api/pdf-parser) converts PDF documents into other formats. This is useful when you need to extract and process text content from PDF files for further analysis or integration into your workflow.

## Use cases

* Converting research papers from PDF to searchable text for analysis
* Extracting content from business reports for data processing
* Converting PDF documentation into markdown format for web publishing
* Making archived PDF documents searchable and analyzable
* Automating data extraction from PDF forms and invoices

<Note>
  You need an API key to access the Writer API. Get an API key by following the steps in the [API quickstart](/api-guides/quickstart).

  We recommend setting the API key as an environment variable in a `.env` file with the name `WRITER_API_KEY`.
</Note>

## Endpoint overview

**URL:** `POST https://api.writer.com/v1/tools/pdf-parser`

<CodeGroup>
  ```bash cURL
  curl --location 'https://api.writer.com/v1/tools/pdf-parser/<file-id>' \
  --header 'Content-Type: application/json' \
  --header "Authorization: Bearer $WRITER_API_KEY" \
  --data '{
    "format": "markdown"
  }'
  ```

  ```python Python
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  response = client.tools.parse_pdf(
      file_id="file_id",
      format="text",
  )
  print(response.content)
  ```

  ```javascript JavaScript
  import Writer from 'writer-sdk';

  // Initialize the Writer client. If you don't pass the `api_key` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  async function main() {
    const response = await client.tools.parsePdf('file_id', { format: 'text' });

    console.log(response.content);
  }

  main();
  ```
</CodeGroup>

### Path parameters

| Parameter | Description                               |
| --------- | ----------------------------------------- |
| `file_id` | The ID of the uploaded PDF file to parse. |

Before using the PDF parser, you'll need to upload your PDF file to the Writer API and obtain its file ID. Learn more about how to upload files with the [Files API](/api-guides/files).

### Request body

The request body includes the following parameters:

| Parameter | Type     | Description                                             |
| --------- | -------- | ------------------------------------------------------- |
| `format`  | `string` | The desired output format. Can be `text` or `markdown`. |

### Response parameters

Returns an object with a `content` field containing the extracted text in the specified format.

```json JSON
{
  "content": "..."
}
```


# Quickstart
Source: https://dev.writer.com/api-guides/quickstart



This guide helps you make your first API calls to the Writer API. You'll create an API key in [AI Studio](https://app.writer.com/aistudio) and begin making API calls to generate text using the [chat completion endpoint](/api-guides/api-reference/completion-api/chat-completion).

## Get an API key

Before you can make API calls, you need to create an API key in [AI Studio](https://app.writer.com/aistudio).

1. From the [AI Studio home page](https://app.writer.com/aistudio), click **Build an agent**. ![Select Build an agent from the AI Studio home page](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/api/build-an-agent.png)
2. Select **API**. ![Select API as the agent type](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/api/start-building.png)
3. Click on the title to edit it and provide a **short description** of your app to help you keep track of what it does. ![Click on the title to edit it and provide a short app description to help you keep track of what it does](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/api/rename-agent.png)
4. Under **API keys** there is a key named `Production`. Click **Reveal key** to view the key.![Click "Reveal key" to view the API key and provide a short app description to help you keep track of what it does](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/api/reveal-key-cropped.png)

<Info>Store the API key in a secure location. We recommend using a `.env` file to store the key.</Info>

You can now make calls to the Writer API using this API key as the `Bearer` token in the header:

```
Authorization: Bearer <api-key>
```

Learn more about managing API keys in the [API keys guide](/api-guides/api-reference/api-keys).

## Make your first API call

Below is an example of an API call to the [chat completion endpoint](/api-guides/chat-completion). It completes a single-turn chat completion, where the user provides a message and the AI assistant generates a response. The request is non-streaming and waits until the response is complete before returning.

```bash
curl --location 'https://api.writer.com/v1/chat' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer <your-api-key>' \
--data '{
    "model": "palmyra-x-004",
    "messages": [
        {
            "role": "user",
            "content": "Write a one sentence product description for a cozy, stylish sweater suitable for both casual and formal occasions"
        }
    ]
}'
```

The response is a JSON object with a `choices` array. The `message.content` field of the first choice contains the generated text. The `message.role` field indicates that the message is an AI assistant message.

```json
{
  "id": "78766762-bd30-4a42-bb2b-e0b35c608217",
  "object": "chat.completion",
  "choices": [
    {
      "index": 0,
      "finish_reason": "stop",
      "message": {
        "content": "This versatile, cozy sweater blends warmth and elegance with its soft knit and refined design, making it perfect for both casual days and formal evenings.",
        "role": "assistant",
        "tool_calls": null,
        "graph_data": {
          "sources": null,
          "status": null,
          "subqueries": null
        },
        "llm_data": null,
        "image_data": null,
        "refusal": null
      },
      "logprobs": null
    }
  ],
  "created": 1740711212,
  "model": "palmyra-x-004",
  "usage": {
    "prompt_tokens": 50,
    "total_tokens": 79,
    "completion_tokens": 29,
    "prompt_token_details": null,
    "completion_tokens_details": null
  },
  "system_fingerprint": "v1",
  "service_tier": null
}
```

<Info>In a streaming response, the structure of the response is similar. However, the content of the streamed response is returned in a `choices[0].delta.content` field, rather than the `choices[0].message.content` field. Learn more about streaming responses in the [chat completion guide](/api-guides/chat-completion).</Info>

You can customize your request to the chat completion endpoint by adding or updating parameters to the request body. Learn more about the different parameters in the [chat completion endpoint API reference](/api-guides/api-reference/completion-api/chat-completion).

## Next steps

Now that you've made your first API call, learn how to use [the Writer SDKs](/api-guides/sdks) to make calls to the Writer API in your applications. Or, learn more about building with the chat completion endpoint:

* Learn how to build a multi-turn, conversational AI app using the [chat completion guide](/api-guides/chat-completion)
* See the full [chat completion endpoint API reference](/api-guides/api-reference/completion-api/chat-completion)


# SDKs
Source: https://dev.writer.com/api-guides/sdks



This guide helps you get started with the Writer SDKs. Follow these steps to install the SDKs and perform basic operations.

### Prerequisites

<Tabs>
  <Tab title="Python SDK">
    * Python 3.7+
    * [pip](https://pypi.org/project/pip/)
    * A Writer API key
  </Tab>

  <Tab title="Node SDK">
    * Node.js
    * [`npm`](https://www.npmjs.com/get-npm)
    * A Writer API key
  </Tab>
</Tabs>

<Note>
  You need an API key to access the Writer API. Get an API key by following the steps in the [API quickstart](/api-guides/quickstart).

  We recommend setting the API key as an environment variable in a `.env` file with the name `WRITER_API_KEY`.
</Note>

### Install the SDK

Open your terminal or command prompt and install the Writer SDK:

<CodeGroup>
  ```sh Python
  pip install writer-sdk
  ```

  ```sh Node
  npm install writer-sdk
  ```
</CodeGroup>

## Initialize the client

To initialize the client, import the Writer SDK and create an instance of the `Writer` class.

We recommend setting your API key in an environment variable called `WRITER_API_KEY`. When you initialize the Writer client, the client looks for the `WRITER_API_KEY` environment variable automatically. You can also pass your API key directly to the client.

<CodeGroup>
  ```python Python
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()
  ```

  ```js JavaScript
  import { Writer } from 'writer-sdk';
  // Initialize the client. If you don't pass the `api_key` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();
  ```
</CodeGroup>

## Make a chat completion request

Once you've initialized the client, you can make a request to the Writer API. The following example shows how to make a [chat completion request](/api-guides/chat-completion) to generate a poem:

<CodeGroup>
  ```python Python
  from writerai import Writer

  client = Writer()

  response = client.chat.chat(
      messages=[{ "content": "Write a short poem about Python", "role": 'user' }],
      model="palmyra-x-004"
  )

  print(response.choices[0].message.content)
  ```

  ```js JavaScript
  import { Writer } from 'writer-sdk';

  const client = new Writer();

  const response = await client.chat.chat({
      messages: [{ content: "Write a short poem about JavaScript", role: 'user' }],
      model: "palmyra-x-004"
  });

  console.log(response.choices[0].message.content);
  ```
</CodeGroup>

## Next steps

Now that you're set up with the SDKs, start building with [chat completions](/api-guides/chat-completion) or [text generation](/api-guides/text-generation).

You can also use the [API reference](/api-guides/api-reference) to learn more detailed information about available endpoints.


# Stream responses from the API
Source: https://dev.writer.com/api-guides/streaming



The Writer API supports streaming responses from the API. Streams use [server-side events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent%5Fevents/Using%5Fserver-sent%5Fevents) so that you can display content as the API generates it in real time.

Streaming improves user experience by reducing latency from the time the user submits a request to the time the response is available.

## Overview

To stream a response from the API, set the `stream` parameter to `true` in the request body.

The following endpoints support streaming:

* [Text generation](https://dev.writer.com/api-guides/api-reference/completion-api/text-generation#body-stream)
* [Chat completions](https://dev.writer.com/api-guides/api-reference/chat-api/chat-completions#body-stream)
* [Generate from no-code agent](https://dev.writer.com/api-guides/api-reference/application-api/applications#body-stream): Currently, only no-code research agents support streaming.
* [Knowledge Graph question](https://dev.writer.com/api-guides/api-reference/kg-api/question#body-stream)

## Sample request and response

The code below shows a streaming request and response from a text generation request using `curl`. The response is a stream of [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent%5Fevents/Using%5Fserver-sent%5Fevents).

<CodeGroup>
  ```bash cURL
  curl --location 'https://api.writer.com/v1/completions' \
  --header 'Content-Type: application/json' \
  --header "Authorization: Bearer $WRITER_API_KEY" \
  --data '{
    "model": "palmyra-x-004",
    "prompt": "Respond to a customer chat request about a delayed shipment with a message that apologizes for the delay, offers a tracking number, and provides a new estimated delivery date.",
    "stream": true
  }'
  ```
</CodeGroup>

```json response
data: {"value":""}

data: {"value":"Hello"}

data: {"value":" ["}

data: {"value":"Customer"}

data: {"value":"'s"}

data: {"value":" Name"}
...
```

## Streaming with SDKs

When you stream a response using a Writer SDK, the SDK creates an iterator that yields chunks of the response. You can iterate over the stream to receive the response.

See below for examples of streaming with the Python and JavaScript SDKs for each endpoint that supports streaming.

<Tabs>
  <Tab title="Text Generation">
    <CodeGroup>
      ```python Python
      from writerai import Writer

      # Initialize the client. If you don't pass the `api_key` parameter,
      # the client looks for the `WRITER_API_KEY` environment variable.
      client = Writer()

      text_generation = client.completions.create(
        model="palmyra-x-004",
        prompt="Respond to a customer chat request about a delayed shipment with a message that apologizes for the delay, offers a tracking number, and provides a new estimated delivery date.",
        stream=True
      )

      for chunk in text_generation:
          print(chunk.value, end="", flush=True)
      ```

      ```javascript JavaScript
      import { Writer } from 'writer-sdk';

      // Initialize the client. If you don't pass the `apiKey` parameter,
      // the client looks for the `WRITER_API_KEY` environment variable.
      const client = new Writer();

      const text_generation = await client.completions.create({
        model: 'palmyra-x-004',
        prompt: 'Respond to a customer chat request about a delayed shipment with a message that apologizes for the delay, offers a tracking number, and provides a new estimated delivery date.',
        stream: true 
      });

      for await (const chunk of text_generation) {
          process.stdout.write(chunk.value);
      }
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Chat Completions">
    <CodeGroup>
      ```python Python
      from writerai import Writer

      # Initialize the client. If you don't pass the `api_key` parameter,
      # the client looks for the `WRITER_API_KEY` environment variable.
      client = Writer()

      stream = client.chat.chat(
        model="palmyra-x-004",
        messages=[{"role": "user", "content": "Respond to a customer chat request about a delayed shipment with a message that apologizes for the delay, offers a tracking number, and provides a new estimated delivery date."}],
        stream=True
      )

      for chunk in stream:
          if chunk.choices[0].delta.content:
              print(chunk.choices[0].delta.content, end="", flush=True)
      ```

      ```javascript JavaScript    
      import { Writer } from 'writer-sdk';

      // Initialize the client. If you don't pass the `apiKey` parameter,
      // the client looks for the `WRITER_API_KEY` environment variable.
      const client = new Writer();

      const stream = client.chat.chat({
        model: 'palmyra-x-004',
        messages: [{ role: 'user', content: 'Respond to a customer chat request about a delayed shipment with a message that apologizes for the delay, offers a tracking number, and provides a new estimated delivery date.' }],
        stream: true 
      });

      for await (const chunk of stream) {
        if (chunk.choices[0]?.delta?.content) {
          process.stdout.write(chunk.choices[0].delta.content);
        }
      }
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Generate from no-code agent">
    <CodeGroup>
      ```python Python
      from writerai import Writer

      # Initialize the client. If you don't pass the `api_key` parameter,
      # the client looks for the `WRITER_API_KEY` environment variable.
      client = Writer()

      stream = client.applications.generate_content(
          application_id="<application-id>",
          inputs=[
              {
                  "id": "query",
                  "value": ["Provide a list of three hotels in San Francisco near Union Square within the price range of $100 to $200 per night"]
              }
          ],
          stream=True
      )

      for chunk in stream:
          if chunk.delta.content:
              print(chunk.delta.content, end="", flush=True)
          else if chunk.delta.stages:
              print(chunk.delta.stages[0].content)
      ```

      ```javascript JavaScript
      import { Writer } from 'writer-sdk';

      // Initialize the client. If you don't pass the `apiKey` parameter,
      // the client looks for the `WRITER_API_KEY` environment variable.
      const client = new Writer();

      const stream = await client.applications.generateContent(
          "<application-id>", 
          { 
              inputs: [
                  {
                      id: "query",
                      value: ["Provide a list of three hotels in San Francisco near Union Square within the price range of $100 to $200 per night"]
                  }
              ],
              stream: true
          } 
      );

      for await (const chunk of stream) {
          if (chunk.delta.content) {
              process.stdout.write(chunk.delta.content);
          } else if (chunk.delta.stages) {
              process.stdout.write(chunk.delta.stages[0].content);
          }
      }
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Knowledge Graph question">
    <CodeGroup>
      ```python Python
      from writerai import Writer

      # Initialize the client. If you don't pass the `api_key` parameter,
      # the client looks for the `WRITER_API_KEY` environment variable.
      client = Writer()

      stream = client.graphs.question(
          graph_ids=["<graph-id>"],
          question="What is the generic name for the drug Bavencio?",
          stream=True
      )

      for chunk in stream:
          print(chunk.answer, end="", flush=True)
      ```

      ```javascript JavaScript
      import { Writer } from 'writer-sdk';

      // Initialize the client. If you don't pass the `apiKey` parameter,
      // the client looks for the `WRITER_API_KEY` environment variable.
      const client = new Writer();

      const stream = await client.graphs.question({
          graphIds: ["<graph-id>"],
          question: "What is the generic name for the drug Bavencio?",
          stream: true
      });

      for await (const chunk of stream) {
          process.stdout.write(chunk.answer);
      }
      ```
    </CodeGroup>
  </Tab>
</Tabs>

### Streaming helpers for chat completions

The Python and Node SDKs include streaming helpers for chat completions. These helpers provide more granular details about the streaming events and accumulate the response.

To use the streaming helpers, call `client.chat.stream`. Then, include all the same parameters as you would for a non-streaming chat completion request, except omit the `stream` parameter.

<CodeGroup>
  ```python Python
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  with client.chat.stream(
    model="palmyra-x-004",
    messages=[{"role": "user", "content": "Respond to a customer chat request about a delayed shipment with a message that apologizes for the delay, offers a tracking number, and provides a new estimated delivery date."}]
  ) as stream:
      for event in stream:
          if event.type == "content.delta":
              print(event.value, end="", flush=True)

  # print the final response
  completion = stream.get_final_completion()
  print(completion.choices[0].message.content)
  ```

  ```javascript JavaScript
  import { Writer } from 'writer-sdk';

  // Initialize the client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const stream = client.chat.stream({
    model: 'palmyra-x-004',
    messages: [{ role: 'user', content: 'Respond to a customer chat request about a delayed shipment with a message that apologizes for the delay, offers a tracking number, and provides a new estimated delivery date.' }],
  })
  .on('content', (diff) => process.stdout.write(diff));

  // print the final response
  const completion = await stream.finalChatCompletion();
  console.log(completion.choices[0].message.content);
  ```
</CodeGroup>

For more information about the streaming helpers for chat completions, see the [Python](https://github.com/writer/writer-python/blob/main/helpers.md) and [Node](https://github.com/writer/writer-node/blob/main/helpers.md) SDKs.


# Generate text with an LLM
Source: https://dev.writer.com/api-guides/text-generation



You can use the [text generation endpoint](/api-guides/api-reference/completion-api/text-generation) to generate text with a Palmyra LLM.

<Note>
  You need an API key to access the Writer API. Get an API key by following the steps in the [API quickstart](/api-guides/quickstart).

  We recommend setting the API key as an environment variable in a `.env` file with the name `WRITER_API_KEY`.
</Note>

## Text generation vs. chat completion

The text generation endpoint is appropriate when you need to generate a single text response based on a given prompt, or when you want to ask a specific LLM a question.

The [chat completion endpoint](/api-guides/chat-completion) can generate single messages, or create more complex conversations between a user and an general-purpose LLM. Additionally, the chat completion endpoint offers [tool calling](/api-guides/chat-completion), which you can use to access domain-specific LLMs, Knowledge Graphs, and custom functions.

## Endpoint overview

**URL:** `POST https://api.writer.com/v1/completions`

<Warning>
  Using the `/completions` endpoint results in charges for **model usage**. See the [pricing page](/home/pricing) for more information.
</Warning>

<CodeGroup>
  ```bash cURL
  curl --location 'https://api.writer.com/v1/completions' \
  --header 'Content-Type: application/json' \
  --header "Authorization: Bearer $WRITER_API_KEY" \
  --data '{
    "model": "palmyra-x-003-instruct",
    "prompt": "Tell me a story",
    "max_tokens": 1000,
    "temperature": 0.7,
    "stream": true
  }'
  ```

  ```python Python
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  text_generation = client.completions.create(
    model="palmyra-x-003-instruct",
    prompt="Tell me a story",
    max_tokens=1000,
    temperature=0.7,
    stream=True
  )

  for chunk in text_generation:
      print(chunk.value, end="", flush=True)
  ```

  ```javascript JavaScript
  import { Writer } from 'writer-sdk';

  // Initialize the client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const text_generation = await client.completions.create({
    model: 'palmyra-x-003-instruct',
    prompt: 'Tell me a story',
    max_tokens: 1000,
    temperature: 0.7,
    stream: true 
  });

  for await (const chunk of text_generation) {
      process.stdout.write(chunk.value);
  }
  ```
</CodeGroup>

### Request body

Below are the required and commonly used optional parameters for the text generation endpoint.

| Parameter     | Type    | Description                                                                                                                                                                      |
| ------------- | ------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `model`       | string  | **Required**. The [ID of the model](/home/models) to use for text generation.                                                                                                    |
| `prompt`      | string  | **Required**. The prompt to generate text from.                                                                                                                                  |
| `max_tokens`  | int     | The maximum number of tokens to generate for the response. Defaults to `100`.                                                                                                    |
| `temperature` | float   | Temperature influences the randomness in generated text. Defaults to `1`. Increase the value for more creative responses, and decrease the value for more predictable responses. |
| `stream`      | Boolean | A Boolean value that indicates whether to stream the response. Defaults to `false`.                                                                                              |

See the full list of available parameters in the [text generation endpoint reference](/api-guides/api-reference/completion-api/text-generation).

### Response parameters

#### Non-streaming response

If you set the `stream` parameter to `false`, the response is a single JSON object with the following parameters:

| Parameter              | Type   | Description                                                                                                                                       |
| ---------------------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| `model`                | string | The ID of the model used to generate the response.                                                                                                |
| `choices`              | array  | An array of choices objects.                                                                                                                      |
| `choices[0].text`      | string | The generated text.                                                                                                                               |
| `choices[0].log_probs` | object | The [log probabilities](/api-guides/api-reference/completion-api/text-generation#response-choices-log-probs) of the tokens in the generated text. |

```json
{
  "choices": [
    {
      "text": "Camping Gear: The Ultimate Guide\n\nCamping is a great way to get outdoors and enjoy nature",
      "log_probs": null
    }
  ],
  "model": "palmyra-x-003-instruct"
}
```

#### Streaming response

If you set the `stream` parameter to `true`, the response is delivered as [server-sent events](https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events) with the following parameters:

| Parameter | Description               |
| --------- | ------------------------- |
| `value`   | The content of the chunk. |

```json
data: {"value":"Camping Gear: The Ultimate Guide\n\nCamping is a great way to get outdoors and enjoy nature"}
```

## Example request to a specific LLM

The examples below generate a single message from the `palmyra-med` model, using the prompt "How can I treat a cold?"

### Streaming response

The text generation endpoint supports streaming responses. The response comes in chunks until the entire response finishes.

Streaming responses are useful when you want to display the generated text in real-time, or when you want to stream the response to a client, rather than waiting for the entire response to finish.

<CodeGroup>
  ```bash cURL
  curl --location 'https://api.writer.com/v1/completions' \
  --header 'Content-Type: application/json' \
  --header "Authorization: Bearer $WRITER_API_KEY" \
  --data '{
    "model": "palmyra-med",
    "prompt": "How can I treat a cold?",
    "stream": true
  }'
  ```

  ```python Python
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  text_generation = client.completions.create(
    model="palmyra-med",
    prompt="How can I treat a cold?",
    stream=True
  )

  for chunk in text_generation:
      print(chunk.value, end="", flush=True)
  ```

  ```javascript JavaScript
  import { Writer } from 'writer-sdk';

  // Initialize the client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const text_generation = await client.completions.create({
    model: 'palmyra-med',
    prompt: 'How can I treat a cold?',
    stream: true 
  });

  for await (const chunk of text_generation) {
      process.stdout.write(chunk.value);
  }
  ```
</CodeGroup>

### Non-streaming response

For non-streaming responses, the response returns as a single JSON object after the entire response is complete. The text is in the `choices[0].text` field.

<CodeGroup>
  ```bash cURL
  curl --location 'https://api.writer.com/v1/completions' \
  --header 'Content-Type: application/json' \
  --header "Authorization: Bearer $WRITER_API_KEY" \
  --data '{
    "model": "palmyra-med",
    "prompt": "How can I treat a cold?",
    "stream": false
  }'
  ```

  ```python Python
  from writerai import Writer

  # Initialize the client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  text_generation = client.completions.create(
    model="palmyra-med",
    prompt="How can I treat a cold?",
    stream=False
  )

  print(text_generation.choices[0].text)
  ```

  ```javascript JavaScript
  import { Writer } from 'writer-sdk';

  // Initialize the client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const text_generation = await client.completions.create({
    model: 'palmyra-med',
    prompt: 'How can I treat a cold?',
    stream: false
  });

  console.log(text_generation.choices[0].text);
  ```
</CodeGroup>

## Next steps

Now that you've generated text with a Palmyra LLM, try out the following:

* Create a chat with an AI assistant using the [chat completion endpoint](/api-guides/chat-completion)
* Learn more about the [tool calling](/api-guides/chat-completion#tool-calling) feature of the chat completion endpoint


# Call a custom function in a chat
Source: https://dev.writer.com/api-guides/tool-calling



This guide helps you understand how to use tool calling, sometimes known as function calling. Tool calling allows you to extend the capabilities of [AI chat applications](/api-guides/chat-completion) by enabling direct interaction between models and functions you define.

Your custom functions can perform a wide range of tasks, such as querying databases, fetching real-time data from APIs, processing  data, or executing business logic. You can then integrate the result of these tool calls back into the model's output.

Tool calling is available for Palmyra-X-004.

<Tip>
  This guide discusses calling custom functions as tools. Writer also offers prebuilt tools that models can execute remotely:

  * [Ask questions to a Knowledge Graph in a chat](/api-guides/kg-chat)
  * [Delegate questions to domain-specific LLMs](/api-guides/model-delegation)
  * [Analyze or interpret images](/api-guides/vision-tool)
</Tip>

<Note>
  You need an API key to access the Writer API. Get an API key by following the steps in the [API quickstart](/api-guides/quickstart).

  We recommend setting the API key as an environment variable in a `.env` file with the name `WRITER_API_KEY`.
</Note>

## Overview

To use tool calling, follow these steps:

1. Define your functions in code
2. Pass the functions to the model in a chat completion request
3. Check to see which functions the model wants to invoke and run the corresponding functions
4. Pass the results of the function call back to the model

Continue reading to learn more about each step.

## Define your custom functions

First, define the custom functions in your code. Typical use cases for tool calling include calling an API, performing mathematical calculations, or running complex business logic. You can define these functions in your code as you would any other function.

Here's an example of a function to calculate the mean of a list of numbers.

<CodeGroup>
  ```python Python
  def calculate_mean(numbers: list) -> float:
      return sum(numbers) / len(numbers)
  ```

  ```js JavaScript
  function calculateMean(numbers) {
    if (numbers.length === 0) {
      throw new Error("Cannot calculate mean of an empty array");
    }
    return numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
  }
  ```
</CodeGroup>

## Describe functions as tools

After you've defined your functions, create a `tools` array to pass to the model.

The `tools` array describes your functions as tools available to the model. You describe tools in the form of a [JSON schema](https://json-schema.org/). Each tool should include a `type` of `function` and a `function` object that includes a `name`, `description`, and a  dictionary of `parameters`.

### Tool structure

The `tools` array contains an object with the following parameters:

| Parameter                        | Type   | Description                                                                                                                      |
| -------------------------------- | ------ | -------------------------------------------------------------------------------------------------------------------------------- |
| `type`                           | string | The type of tool, which is `function` for a custom function                                                                      |
| `function`                       | object | An object containing the tool's description and application ID                                                                   |
| `function.name`                  | string | The name of the tool                                                                                                             |
| `function.description`           | string | A description of what the tool does and when the model should use it                                                             |
| `function.parameters`            | object | An object containing the tool's input parameters                                                                                 |
| `function.parameters.type`       | string | The type of the parameter, which is `object` for a JSON schema                                                                   |
| `function.parameters.properties` | object | An object containing the tool's parameters in the form of a [JSON schema](https://json-schema.org/). See below for more details. |
| `function.parameters.required`   | array  | An array of the tool's required parameters                                                                                       |

See the full [tools object schema](/api-guides/api-reference/completion-api/chat-completion#body-tools) for more details.

The `function.parameters.properties` object contains the tool's parameter definitions as a [JSON schema](https://json-schema.org/). The object's keys should be the names of the parameters, and the values should be objects containing the parameter's type and description.

When the model decides you should use the tool to answer the user's question, it returns the parameters that you should use when calling the function you've defined.

### Example tool array

Here's an example of a `tools` array for the `calculate_mean` function:

<CodeGroup>
  ```python Python
  tools = [
      { 
          "type": "function",
          "function": {
              "name": "calculate_mean", 
              "description": "Calculate the mean (average) of a list of numbers.", 
              "parameters": { 
                  "type": "object", 
                  "properties": { 
                      "numbers": { 
                          "type": "array", 
                          "items": {"type": "number"}, 
                          "description": "List of numbers"
                      } 
                  }, 
                  "required": ["numbers"] 
              } 
          }
      }
  ]
  ```

  ```js JavaScript
  const tools = [
      {
          type: "function",
          function: {
              name: "calculate_mean",
              description: "Calculate the mean (average) of a list of numbers.",
              parameters: {
                  type: "object",
                  properties: {
                      numbers: {
                          type: "array",
                          items: { type: "number" },
                          description: "List of numbers",
                      },
                  },
              required: ["numbers"],
              },
          },
      },
  ];
  ```
</CodeGroup>

<Note>
  To help the model understand when to use the tool, follow these best practices for the `function.description` parameter:

  * Indicate that the tool is a function that invokes a no-code agent
  * Specify the application's purpose and capabilities
  * Describe when the tool should be used

  An example description for a tool that invokes a function to calculate the mean of a list of numbers:

  > "A function that calculates the mean of a list of numbers. Any user request asking for the mean of a list of numbers should use this tool."
</Note>

## Pass tools to the model

Once the tools array is complete, you pass it to the [chat completions endpoint](/api-guides/chat-completion) along with the chat model and messages. Set `tool_choice` to `auto` to take full advantage of the model's capabilities.

If you are unfamiliar with the chat completions endpoint, learn more in the [chat completion guide](/api-guides/chat-completion).

You can use tool calling with `stream` set to either `true` or `false`.

<CodeGroup>
  ```python Python
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `apiKey` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  messages = [{"role": "user", "content": "what is the mean of [1,3,5,7,9]?"}]

  response = client.chat.chat(
      model="palmyra-x-004", 
      messages=messages, 
      tools=tools, 
      tool_choice="auto"
  )
  ```

  ```js JavaScript
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  let messages = [{"role": "user", "content": "what is the mean of [1,3,5,7,9]?"}];

  const response = await client.chat.chat({
        model: "palmyra-x-004",
        messages: messages,
        tools: tools,
        tool_choice: "auto"
  });
  ```
</CodeGroup>

## Process tool calls

When the model identifies a need to call a tool based on the user's input, it invokes it in the response, passing along any necessary parameters. You then execute the tool's function and return the result to the model.

The method for checking for tool calls and executing the tool's function differs depending on whether you're streaming the response or not.

### Streaming

When using streaming, the tool calls come back in chunks inside of the `delta` object of the `choices` array. To process the tool calls:

* Iterate through the response chunks to check for tool calls
* Concatenate the streaming tool call content
* Execute the functions identified in the tool calls
* Append the function call results to the `messages` array to continue the conversation with the function output

#### Iterate through chunks to gather tool calls

Iterate through the response chunks to check for tool calls, concatenate the streaming tool call content, and handle non-tool-call content, such as content generated when the user asks a question not requiring a tool call.

<CodeGroup>
  ```python Python
  streaming_content = ""
  function_calls = []

  for chunk in response:
      choice = chunk.choices[0]

      if choice.delta:
          # Check for tool calls
          if choice.delta.tool_calls:
              for tool_call in choice.delta.tool_calls:
                  if tool_call.id:
                      # Append an empty dictionary to the function_calls list with the tool call ID
                      function_calls.append(
                          {"name": "", "arguments": "", "call_id": tool_call.id}
                      )
                  if tool_call.function:
                      # Append function name and arguments to the last dictionary in the function_calls list
                      function_calls[-1]["name"] += (
                          tool_call.function.name
                          if tool_call.function.name
                          else ""
                      )
                      function_calls[-1]["arguments"] += (
                          tool_call.function.arguments
                          if tool_call.function.arguments
                          else ""
                      )
          # Handle non-tool-call content
          elif choice.delta.content:
              streaming_content += choice.delta.content
  ```

  ```js JavaScript
  let streamingContent = "";
  const functionCalls = [];

  for await (const chunk of response) {
      const choice = chunk.choices[0];

      if (choice.delta) {
          if (choice.delta.tool_calls) {
              for (const toolCall of choice.delta.tool_calls) {
                  if (toolCall.id) {
                      functionCalls.push({ name: "", arguments: "", call_id: toolCall.id });
                  }
                  if (toolCall.function) {
                      functionCalls[functionCalls.length - 1].name += toolCall.function.name || "";
                      functionCalls[functionCalls.length - 1].arguments += toolCall.function.arguments || "";
                  }
              }
          } else if (choice.delta.content) {
              streamingContent += choice.delta.content;
          }
      }
  }
  ```
</CodeGroup>

#### Check for the finish reason and then call each function

While inside of the loop and the if-statement for `choice.delta`, check for the `finish_reason` of the `choice`. If the `finish_reason` is `stop`, this means the model has finished generating the response without calling any tools. If the `finish_reason` is `tool_calls`, call each function in the `function_calls` list and append the result to the `messages` array. Be sure to convert the function response to a string before appending it to the messages array.

<CodeGroup>
  ```python Python
  # Inside of the loop and the if-statement for `choice.delta`
  # A finish reason of stop means the model has finished generating the response
  if choice.finish_reason == "stop":
      messages.append({"role": "assistant", "content": streaming_content})

  # A finish reason of tool_calls means the model has finished deciding which tools to call
  elif choice.finish_reason == "tool_calls":
      for function_call in function_calls:
          if function_call["name"] == "calculate_mean":
              arguments_dict = json.loads(function_call["arguments"])
              function_response = calculate_mean(arguments_dict["numbers"])

              messages.append(
                  {
                      "role": "tool",
                      "content": str(function_response),
                      "tool_call_id": function_call["call_id"],
                      "name": function_call["name"],
                  }
              )
  ```

  ```js JavaScript
  // Inside of the loop and the if-statement for `choice.delta`
  // A finish reason of stop means the model has finished generating the response
  if (choice.finish_reason === "stop") {
      messages.push({ role: "assistant", content: streamingContent });
  } else if (choice.finish_reason === "tool_calls") {
      // A finish reason of tool_calls means the model has finished deciding which tools to call
      for (const functionCall of functionCalls) {
          if (functionCall.name === "calculate_mean") {
              const argumentsDict = JSON.parse(functionCall.arguments);
              const functionResponse = calculateMean(argumentsDict.numbers);
              
              messages.push({
                  role: "tool",
                  content: functionResponse.toString(),
                  tool_call_id: functionCall.call_id,
                  name: functionCall.name,
              });
          }
      }
  ```
</CodeGroup>

#### Get the final response

After you've appended the tool call results to the messages array, you can pass the messages array back to the model to get the final response.

Note that this code block should be inside of the check for the `finish_reason` of `tool_calls`, after the loop that iterates through the `function_calls` list:

<CodeGroup>
  ```python Python
  # Inside of `elif choice.finish_reason == "tool_calls"`
  final_response = client.chat.chat(
      model="palmyra-x-004", messages=messages, stream=True
  )

  final_streaming_content = ""
  for chunk in final_response:
      choice = chunk.choices[0]
      if choice.delta and choice.delta.content:
          final_streaming_content += choice.delta.content

  print(final_streaming_content)
  # The mean is 5
  ```

  ```js JavaScript
  // Inside of `else if (choice.finish_reason === "tool_calls")`
  const finalResponse = await client.chat.chat({
      model: "palmyra-x-004",
      messages: messages,
      stream: true
  });

  let finalStreamingContent = "";
  for await (const chunk of finalResponse) {
      const choice = chunk.choices[0];
      if (choice.delta && choice.delta.content) {
          finalStreamingContent += choice.delta.content;
      }
  }

  console.log(finalStreamingContent);
  // The mean is 5
  ```
</CodeGroup>

Here is the full code example for streaming tool calling:

<CodeGroup>
  ```python Python [expandable]
  import json
  import dotenv
  from writerai import Writer

  dotenv.load_dotenv()

  client = Writer()

  def calculate_mean(numbers: list) -> float:
      return sum(numbers) / len(numbers)

  tools = [
      { 
          "type": "function",
          "function": {
              "name": "calculate_mean", 
              "description": "Calculate the mean (average) of a list of numbers.", 
              "parameters": { 
                  "type": "object", 
                  "properties": { 
                      "numbers": { 
                          "type": "array", 
                          "items": {"type": "number"}, 
                          "description": "List of numbers"
                      } 
                  }, 
                  "required": ["numbers"] 
              } 
          }
      }
  ]

  messages = [{"role": "user", "content": "what is the mean of [1,3,5,7,9]?"}]

  response = client.chat.chat(
      model="palmyra-x-004", 
      messages=messages, 
      tools=tools, 
      tool_choice="auto", 
      stream=True
  )

  streaming_content = ""
  function_calls = []

  for chunk in response:
      choice = chunk.choices[0]

      if choice.delta:
          # Check for tool calls
          if choice.delta.tool_calls:
              for tool_call in choice.delta.tool_calls:
                  if tool_call.id:
                      # Append an empty dictionary to the function_calls list with the tool call ID
                      function_calls.append(
                          {"name": "", "arguments": "", "call_id": tool_call.id}
                      )
                  if tool_call.function:
                      # Append function name and arguments to the last dictionary in the function_calls list
                      function_calls[-1]["name"] += (
                          tool_call.function.name
                          if tool_call.function.name
                          else ""
                      )
                      function_calls[-1]["arguments"] += (
                          tool_call.function.arguments
                          if tool_call.function.arguments
                          else ""
                      )
          # Handle non-tool-call content
          elif choice.delta.content:
              streaming_content += choice.delta.content

          # A finish reason of stop means the model has finished generating the response
          if choice.finish_reason == "stop":
              messages.append({"role": "assistant", "content": streaming_content})

          # A finish reason of tool_calls means the model has finished deciding which tools to call
          elif choice.finish_reason == "tool_calls":
              for function_call in function_calls:
                  if function_call["name"] == "calculate_mean":
                      arguments_dict = json.loads(function_call["arguments"])
                      function_response = calculate_mean(arguments_dict["numbers"])

                      messages.append(
                          {
                              "role": "tool",
                              "content": str(function_response),
                              "tool_call_id": function_call["call_id"],
                              "name": function_call["name"],
                          }
                      )
                 
                  final_response = client.chat.chat(
                      model="palmyra-x-004", messages=messages, stream=True
                  )

                  final_streaming_content = ""
                  for chunk in final_response:
                      choice = chunk.choices[0]
                      if choice.delta and choice.delta.content:
                          final_streaming_content += choice.delta.content

                  print(final_streaming_content)
                  # The mean is 5
  ```

  ```js JavaScript [expandable]
  const dotenv = require("dotenv");
  const Writer = require("writer-sdk");

  dotenv.config();

  const client = new Writer();

  function calculateMean(numbers) {
      if (numbers.length === 0) {
          throw new Error("Cannot calculate mean of an empty array");
      }
      return numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
  }

  const tools = [
      {
          type: "function",
          function: {
              name: "calculate_mean",
              description: "Calculate the mean (average) of a list of numbers.",
              parameters: {
              type: "object",
              properties: {
                  numbers: {
                      type: "array",
                      items: { type: "number" },
                      description: "List of numbers",
                  },
              },
              required: ["numbers"],
              },
          },
      },
  ];

  async function main() {
      let messages = [
          { role: "user", content: "what is the mean of [1,3,5,7,9]?" },
      ];

      const response = await client.chat.chat({
          model: "palmyra-x-004",
          messages: messages,
          tools: tools,
          tool_choice: "auto",
          stream: true,
      });

      let streamingContent = "";
      const functionCalls = [];

      for await (const chunk of response) {
          const choice = chunk.choices[0];

          if (choice.delta) {
              if (choice.delta.tool_calls) {
                  for (const toolCall of choice.delta.tool_calls) {
                      if (toolCall.id) {
                          functionCalls.push({
                              name: "",
                              arguments: "",
                              call_id: toolCall.id,
                          });
                      }
                      if (toolCall.function) {
                          functionCalls[functionCalls.length - 1].name +=
                              toolCall.function.name || "";
                          functionCalls[functionCalls.length - 1].arguments +=
                              toolCall.function.arguments || "";
                      }
                  }
              } else if (choice.delta.content) {
                  streamingContent += choice.delta.content;
              }

              // A finish reason of stop means the model has finished generating the response
              if (choice.finish_reason === "stop") {
                  messages.push({ role: "assistant", content: streamingContent });
              } else if (choice.finish_reason === "tool_calls") {
                  console.log(functionCalls);
                  // A finish reason of tool_calls means the model has finished deciding which tools to call
                  for (const functionCall of functionCalls) {
                      if (functionCall.name === "calculate_mean") {
                          const argumentsDict = JSON.parse(
                              functionCall.arguments
                          );
                          const functionResponse = calculateMean(
                              argumentsDict.numbers
                          );

                          messages.push({
                              role: "tool",
                              content: functionResponse.toString(),
                              tool_call_id: functionCall.call_id,
                              name: functionCall.name,
                          });
                      }
                  }
   
                  const finalResponse = await client.chat.chat({
                      model: "palmyra-x-004",
                      messages: messages,
                      stream: true,
                  });

                  let finalStreamingContent = "";
                  for await (const chunk of finalResponse) {
                      const choice = chunk.choices[0];
                      if (choice.delta && choice.delta.content) {
                          finalStreamingContent += choice.delta.content;
                      }
                  }

                  console.log(finalStreamingContent);
                  // The mean is 5
              }
          }
      }
  }

  main();

  ```
</CodeGroup>

### Non-streaming

If you set `stream` to `false`, the tool calls come back in one object inside of the `messages` object in the `choices` array. To process the tool calls:

* Check for the invocation of the tool
* Run the tool's function with the provided arguments
* Append the function call results to the `messages` array to continue the conversation with the function output

#### Check for tool calls

First, check for the invocation of the tool. If the LLM indicates that you should use a tool, run the tool's function with the provided arguments:

<CodeGroup>
  ```python Python
  response_message = response.choices[0].message
  tool_calls = response_message.tool_calls
  if tool_calls:
      tool_call = tool_calls[0]
      tool_call_id = tool_call.id
      function_name = tool_call.function.name
      function_args = json.loads(tool_call.function.arguments)

      if function_name == "calculate_mean":
          function_response = calculate_mean(function_args["numbers"])
  ```

  ```js JavaScript
  const responseMessage = response.choices[0].message;
  const toolCalls = responseMessage.tool_calls;
  if (toolCalls && toolCalls.length > 0) {
    const toolCall = toolCalls[0];
    const toolCallId = toolCall.id;
    const functionName = toolCall.function.name;
    const functionArgs = JSON.parse(toolCall.function.arguments);
    
    if (functionName === "calculate_mean") {
      const functionResponse = calculateMean(functionArgs.numbers);
    }
  }
  ```
</CodeGroup>

#### Append results to the messages array

Then, pass the result back to the model by appending it to the messages array. Be sure to convert the function response to a string if necessary before appending it to the messages array.

<CodeGroup>
  ```python Python
  # Within the if statement for tool call
  messages.append({
      "role": "tool",
      "tool_call_id": tool_call_id,
      "name": function_name,
      "content": str(function_response),
  })
  ```

  ```js JavaScript
  // Within the if statement for tool call
  messages.push({
      role: "tool",
      tool_call_id: toolCallId,
      name: functionName,
      content: functionResponse.toString(),
  });
  ```
</CodeGroup>

#### Get the final response

After you've appended the tool call results to the messages array, you can pass the messages array back to the model to get the final response.

<CodeGroup>
  ```python Python
  final_response = client.chat.chat(
      model="palmyra-x-004", 
      messages=messages, 
      stream=False
   )

  print(f"Final response: \n{final_response.choices[0].message.content}\n")
  # Final response: "The mean is 5"
  ```

  ```js JavaScript
  const finalResponse = await client.chat.chat({
      model: "palmyra-x-004",
      messages: messages,
      stream: false
  });

  console.log(`Final response: \n${finalResponse.choices[0].message.content}\n`);
  // Final response: "The mean is 5"
  ```
</CodeGroup>

Here is the full code example for non-streaming tool calling:

<CodeGroup>
  ```python Python [expandable]
  import json
  import dotenv
  from writerai import Writer

  dotenv.load_dotenv()

  client = Writer()

  def calculate_mean(numbers: list) -> float:
      return sum(numbers) / len(numbers)

  tools = [
      { 
          "type": "function",
          "function": {
              "name": "calculate_mean", 
              "description": "Calculate the mean (average) of a list of numbers.", 
              "parameters": { 
                  "type": "object", 
                  "properties": { 
                      "numbers": { 
                          "type": "array", 
                          "items": {"type": "number"}, 
                          "description": "List of numbers"
                      } 
                  }, 
                  "required": ["numbers"] 
              } 
          }
      }
  ]

  messages = [{"role": "user", "content": "what is the mean of [1,3,5,7,9]?"}]

  response = client.chat.chat(
      model="palmyra-x-004", 
      messages=messages, 
      tools=tools, 
      tool_choice="auto", 
      stream=False
  )

  response_message = response.choices[0].message
  tool_calls = response_message.tool_calls
  if tool_calls:
      tool_call = tool_calls[0]
      tool_call_id = tool_call.id
      function_name = tool_call.function.name
      function_args = json.loads(tool_call.function.arguments)

      if function_name == "calculate_mean":
          function_response = calculate_mean(function_args["numbers"])

          messages.append({
              "role": "tool",
              "tool_call_id": tool_call_id,
              "name": function_name,
              "content": str(function_response),
          })

  final_response = client.chat.chat(
      model="palmyra-x-004", 
      messages=messages, 
      stream=False
   )

  print(f"Final response: \n{final_response.choices[0].message.content}\n")
  # Final response: "The mean is 5"
  ```

  ```js JavaScript [expandable]
  const dotenv = require("dotenv");
  const Writer = require("writer-sdk");

  dotenv.config();

  const client = new Writer();

  function calculateMean(numbers) {
      if (numbers.length === 0) {
          throw new Error("Cannot calculate mean of an empty array");
      }
      return numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
  }

  const tools = [
      {
          type: "function",
          function: {
              name: "calculate_mean",
              description: "Calculate the mean (average) of a list of numbers.",
              parameters: {
                  type: "object",
                  properties: {
                      numbers: {
                          type: "array",
                          items: { type: "number" },
                          description: "List of numbers",
                      },
                  },
                  required: ["numbers"],
              },
          },
      },
  ];

  async function main() {
      let messages = [
          { role: "user", content: "what is the mean of [1,3,5,7,9]?" },
      ];

      const response = await client.chat.chat({
          model: "palmyra-x-004",
          messages: messages,
          tools: tools,
          tool_choice: "auto",
          stream: false,
      });

      const responseMessage = response.choices[0].message;
      const toolCalls = responseMessage.tool_calls;
      if (toolCalls && toolCalls.length > 0) {
          const toolCall = toolCalls[0];
          const toolCallId = toolCall.id;
          const functionName = toolCall.function.name;
          const functionArgs = JSON.parse(toolCall.function.arguments);

          if (functionName === "calculate_mean") {
              const functionResponse = calculateMean(functionArgs.numbers);

              messages.push({
                  role: "tool",
                  tool_call_id: toolCallId,
                  name: functionName,
                  content: functionResponse.toString(),
              });
          }
      }

      const finalResponse = await client.chat.chat({
          model: "palmyra-x-004",
          messages: messages,
          stream: false
      });
      
      console.log(`Final response: \n${finalResponse.choices[0].message.content}\n`);
      // Final response: "The mean is 5"
  }

  main();
  ```
</CodeGroup>

## Example: External API call

The following example covers a common use case for tool calling: calling an external API.

The code uses a publicly available dictionary API to return information about an English word's phonetic pronunciation.

This example is using non-streaming; for streaming, refer to the [preceding example](#streaming) to adjust the code.

### Define function calling an API

First, define the function in your code. The examples below take in a word, call the dictionary API, and return the phonetic pronunciation of the word as a JSON-formatted string.

<CodeGroup>
  ```python Python
  import requests
  def get_word_pronunciation(word):
      url = f"https://api.dictionaryapi.dev/api/v2/entries/en/{word}"
      response = requests.get(url)
      if response.status_code == 200:
          return json.dumps(response.json()[0]['phonetics'])
      else:
          return f"Failed to retrieve word pronunciation. Status code: {response.status_code}"
  ```

  ```js JavaScript
  async function getProductInfo(productId) {
      const url = `https://api.dictionaryapi.dev/api/v2/entries/en/${word}`;
      
      try {
          const response = await fetch(url);
          if (response.ok) {
              const data = await response.json();
              return JSON.stringify(data[0]['phonetics']);
          } else {
              return `Failed to retrieve word pronunciation. Status code: ${response.status}`;
          }
      } catch (error) {
          return `Error fetching word pronunciation: ${error.message}`;
      }
  }
  ```
</CodeGroup>

### Define tools array

Next, define a tools array that describes the tool with a JSON schema.

<CodeGroup>
  ```python Python
  tools = [
      {
          "type": "function",
          "function": {
              "name": "get_word_pronunciation",
              "description": "A function that will return JSON containing the phonetic pronunciation of an English word",
              "parameters": {
                  "type": "object",
                  "properties": {
                      "word": {
                          "type": "string",
                          "description": "The word to get the phonetic pronunciation for",
                      }
                  },
                  "required": ["word"],
              },
          },
      }
  ]
  ```

  ```js JavaScript
  const tools = [
      {
          type: "function",
          function: {
              name: "get_word_pronunciation",
              description: "A function that will return JSON containing the phonetic pronunciation of an English word",
              parameters: {
                  type: "object",
                  properties: {
                      word: {
                          type: "string",
                          description: "The word to get the phonetic pronunciation for"
                      }
                  },
                  required: ["word"]
              }
          }
      }
  ];
  ```
</CodeGroup>

### Pass the tools to the model

Call the `chat.chat` method with the `tools` parameter set to the `tools` array and `tool_choice` set to `auto`.

<CodeGroup>
  ```python Python
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `apiKey` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  messages = [{"role": "user", "content": "what is the phonetic pronunciation of the word 'epitome' in English?"}]

  response = client.chat.chat(
      model="palmyra-x-004", 
      messages=messages, 
      tools=tools, 
      tool_choice="auto", 
      stream=False
  )
  ```

  ```js JavaScript
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  let messages = [{role: "user", content: "what is the phonetic pronunciation of the word 'epitome' in English?"}];

  let response = client.chat.chat(
      model="palmyra-x-004", 
      messages=messages, 
      tools=tools, 
      tool_choice="auto", 
      stream=false
  );
  ```
</CodeGroup>

### Check response for tool calling

Loop through the `tool_calls` array to check for the invocation of the tool. Then, call the tool's function with the arguments the model provided.

<CodeGroup>
  ```python Python
  response_message = response.choices[0].message
  messages.append(response_message)
  tool_calls = response_message.tool_calls
  if tool_calls:
      tool_call = tool_calls[0]
      tool_call_id = tool_call.id
      function_name = tool_call.function.name
      function_args = json.loads(tool_call.function.arguments)

      if function_name == "get_word_pronunciation":
          function_response = get_word_pronunciation(function_args["word"])
  ```

  ```js JavaScript
  const toolCalls = responseMessage.tool_calls;
  if (toolCalls && toolCalls.length > 0) {
      const toolCall = toolCalls[0];
      const toolCallId = toolCall.id;
      const functionName = toolCall.function.name;
      const functionArgs = JSON.parse(toolCall.function.arguments);

      if (functionName === "get_word_pronunciation") {
          const functionResponse = getWordPronunciation(functionArgs.word);
      }
  }
  ```
</CodeGroup>

### Append the result back to the model

Finally, pass the result back to the model by appending it to the messages array, and get the final response.

<CodeGroup>
  ```python Python
  messages.append({
      "role": "tool",
      "tool_call_id": tool_call_id,
      "name": function_name,
      "content": function_response,
  })

  final_response = client.chat.chat(
      model="palmyra-x-004", messages=messages, stream=False
  )

  print(f"Final response: {final_response.choices[0].message.content}")
  # Final response: The phonetic pronunciation of the word "epitome" in English is /É™ËˆpÉªt.É™.mi/...
  ```

  ```js JavaScript
  messages.append({
      role: "tool",
      tool_call_id: tool_call_id,
      name: function_name,
      content: function_response,
  });

  const finalResponse = client.chat.chat(
      model="palmyra-x-004", messages=messages, stream=false
  );

  console.log(`Final response: ${finalResponse.choices[0].message.content}`)
  // Final response: The phonetic pronunciation of the word "epitome" in English is /É™ËˆpÉªt.É™.mi/...
  ```
</CodeGroup>

Here is the full code example:

<CodeGroup>
  ```python Python [expandable]
  import requests
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `apiKey` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  def get_word_pronunciation(word):
      url = f"https://api.dictionaryapi.dev/api/v2/entries/en/{word}"
      response = requests.get(url)
      if response.status_code == 200:
          return json.dumps(response.json()[0]['phonetics'])
      else:
          return f"Failed to retrieve word pronunciation. Status code: {response.status_code}"

  tools = [
      {
          "type": "function",
          "function": {
              "name": "get_word_pronunciation",
              "description": "A function that will return JSON containing the phonetic pronunciation of an English word",
              "parameters": {
                  "type": "object",
                  "properties": {
                      "word": {
                          "type": "string",
                          "description": "The word to get the phonetic pronunciation for",
                      }
                  },
                  "required": ["word"],
              },
          },
      }
  ]

  messages = [{"role": "user", "content": "what is the phonetic pronunciation of the word 'epitome' in English?"}]

  response = client.chat.chat(
      model="palmyra-x-004", 
      messages=messages, 
      tools=tools, 
      tool_choice="auto", 
      stream=False
  )

  response_message = response.choices[0].message
  messages.append(response_message)
  tool_calls = response_message.tool_calls
  if tool_calls:
      tool_call = tool_calls[0]
      tool_call_id = tool_call.id
      function_name = tool_call.function.name
      function_args = json.loads(tool_call.function.arguments)

      if function_name == "get_word_pronunciation":
          function_response = get_word_pronunciation(function_args["word"])

  messages.append({
      "role": "tool",
      "tool_call_id": tool_call_id,
      "name": function_name,
      "content": function_response,
  })

  final_response = client.chat.chat(
      model="palmyra-x-004", messages=messages, stream=False
  )

  print(f"Final response: {final_response.choices[0].message.content}")
  ```

  ```javascript JavaScript [expandable]
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  async function getProductInfo(productId) {
      const url = `https://api.dictionaryapi.dev/api/v2/entries/en/${word}`;
      
      try {
          const response = await fetch(url);
          if (response.ok) {
              const data = await response.json();
              return JSON.stringify(data[0]['phonetics']);
          } else {
              return `Failed to retrieve word pronunciation. Status code: ${response.status}`;
          }
      } catch (error) {
          return `Error fetching word pronunciation: ${error.message}`;
      }
  }

  const tools = [
      {
          type: "function",
          function: {
              name: "get_word_pronunciation",
              description: "A function that will return JSON containing the phonetic pronunciation of an English word",
              parameters: {
                  type: "object",
                  properties: {
                      word: {
                          type: "string",
                          description: "The word to get the phonetic pronunciation for"
                      }
                  },
                  required: ["word"]
              }
          }
      }
  ];

  let messages = [{role: "user", content: "what is the phonetic pronunciation of the word 'epitome' in English?"}];

  let response = client.chat.chat(
      model="palmyra-x-004", 
      messages=messages, 
      tools=tools, 
      tool_choice="auto", 
      stream=false
  );

  const toolCalls = responseMessage.tool_calls;
  if (toolCalls && toolCalls.length > 0) {
      const toolCall = toolCalls[0];
      const toolCallId = toolCall.id;
      const functionName = toolCall.function.name;
      const functionArgs = JSON.parse(toolCall.function.arguments);

      if (functionName === "get_word_pronunciation") {
          const functionResponse = getWordPronunciation(functionArgs.word);
      }
  }

  messages.append({
      role: "tool",
      tool_call_id: tool_call_id,
      name: function_name,
      content: function_response,
  });

  const finalResponse = client.chat.chat(
      model="palmyra-x-004", messages=messages, stream=false
  );

  console.log(`Final response: ${finalResponse.choices[0].message.content}`)
  // Final response: The phonetic pronunciation of the word "epitome" in English is /É™ËˆpÉªt.É™.mi/...
  ```
</CodeGroup>

## Next steps

By following this guide, you can incorporate tool calling into your application and augment the capabilities of a model with real-time data, math operations, business logic, and much more. For more examples, check out the [tool calling cookbooks](https://github.com/writer/cookbooks/tree/main/tool_calling) available on GitHub.

Next, learn how to invoke [no-code agents with tool calling](/api-guides/applications-tool-calling). Or, explore prebuilt tools that Writer models can execute remotely:

* [Ask questions to a Knowledge Graph in a chat](/api-guides/kg-chat)
* [Delegate questions to domain-specific LLMs](/api-guides/model-delegation)
* [Analyze or interpret images](/api-guides/vision-tool)


# Analyze images in a chat
Source: https://dev.writer.com/api-guides/vision-tool



The Vision tool for chat completions allows you to analyze images during a chat completion. You can perform actions such as extracting text, interpreting charts and graphs, performing image-based compliance checks, and more.

The Writer API also has a [`vision` endpoint](/api-guides/api-reference/vision-api/analyze-images) that you can use to analyze images outside of a chat completion. See the [vision API guide](/api-guides/analyze-images) for more information.

This guide explains how to use the Vision tool in a chat completion and provides an example of how to use it.

<Note>
  You need an API key to access the Writer API. Get an API key by following the steps in the [API quickstart](/api-guides/quickstart).

  We recommend setting the API key as an environment variable in a `.env` file with the name `WRITER_API_KEY`.
</Note>

## Tool structure

The Vision tool allows you to analyze an image during a [chat with an LLM](/api-guides/chat-completion).

To use the Vision tool, add it to the `tools` array in your `chat-completion` endpoint request.

The Vision tool object has the following structure:

| Parameter                    | Type     | Description                                                                                                                                                                                                                                                       |
| ---------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`                       | `string` | The type of tool, which is `llm` for LLM tool                                                                                                                                                                                                                     |
| `function`                   | `object` | An object containing the tool's description and model                                                                                                                                                                                                             |
| `function.model`             | `string` | `palmyra-vision`                                                                                                                                                                                                                                                  |
| `function.variables`         | `array`  | An array of objects, one for each image to pass to Palmyra Vision                                                                                                                                                                                                 |
| `function.variables.name`    | `string` | The name of the image to pass to Palmyra Vision. You must use this name when referencing the image in the message you provide to the chat completion endpoint. Reference the image as `{{name}}`, where `name` is the name you provided in the `variables` array. |
| `function.variables.file_id` | `string` | The ID of the uploaded image. You must upload the image to Writer before using it with the Vision tool. Learn more in [Manage Files](/api-guides/files).                                                                                                          |

The message you provide to the chat completion endpoint must reference each image you include in the `function.variables` array, by name. For example, if you include an image named `new_product` in the `function.variables` array, you must reference it in the message as `{{new_product}}`, with double curly braces around the name. Your message to the chat completion endpoint might look like this: "Provide a two-sentence summary of the product within the image `{{new_product}}`."

<CodeGroup>
  ```bash cURL
  "tools": [
      {
          "type": "vision",
          "function": {
              "model": "palmyra-vision",
              "variables": [
                  {
                      "name": "new_product",
                      "file_id": "1234567890"
                  }
              ]
          }
      }  
  ]
  ```

  ```python Python
  tools = [{
      "type": "vision",
      "function": {
          "model": "palmyra-vision",
          "variables": [
              {
                  "name": "new_product",
                  "file_id": "1234567890"
              }
          ]
      }
  }]
  ```

  ```js JavaScript
  const tools = [{
      type: "vision",
      function: {
          model: "palmyra-vision",
          variables: [
              {
                  name: "new_product",
                  file_id: "1234567890"
              }
          ]
      }
  }]
  ```
</CodeGroup>

<Note>
  You can only pass one prebuilt tool in the `tools` array at a time. However, you can pass multiple [custom tools](/api-guides/tool-calling) in the same request.

  Prebuilt tools are:

  * Vision tool
  * [Knowledge Graph tool](/api-guides/kg-chat)
  * [LLM tool](/api-guides/model-delegation)
</Note>

### Response format

For non-streaming responses, the response from the Vision tool is in the `choices[0].message.content` field. For streaming responses, the response is in the `choices[0].delta.content` field.

See the [chat completion endpoint](/api-guides/api-reference/completion-api/chat-completion#response-id) for more information on the response fields.

<CodeGroup>
  ```json non-streaming response
  {
    "id": "1234",
    "object": "chat.completion",
    "choices": [
      {
        "index": 0,
        "finish_reason": "tool_calls",
        "message": {
          "content": "The image shows...",
          "role": "assistant",
          "tool_calls": null,
          "graph_data": {
            "sources": null,
            "status": null,
            "subqueries": null
          },
          "llm_data": null,
          "image_data": null,
          "refusal": null
        },
        "logprobs": null
      }
    ],
    "created": 1743740333,
    "model": "palmyra-x-004",
    "usage": {
      "prompt_tokens": 223,
      "total_tokens": 254,
      "completion_tokens": 31,
      "prompt_token_details": null,
      "completion_tokens_details": null
    },
    "system_fingerprint": "v1",
    "service_tier": null
  }
  ```

  ```json streaming response
  {
      "id": "1234",
      "object": "chat.completion.chunk",
      "choices": [{
          "index": 0,
          "finish_reason": None,
          "message": {
              "content": "The",
              "role": "assistant",
              "tool_calls": None,
              "graph_data": {
                  "sources": None,
                  "status": None,
                  "subqueries": None
              },
              "llm_data": {},
              "image_data": None,
              "refusal": None
          },
          "logprobs": None,
      "delta": {
          "content": "The",
          "role": "assistant",
          "tool_calls": None,
          "graph_data": {
              "sources": None,
              "status": None,
              "subqueries": None
          },
          "llm_data": {},
          "image_data": None,
          "refusal": None
      },
      "logprobs": None
      }],
      "created": 1741970696,
      "model": "palmyra-x-004",
      "usage": None,
      "system_fingerprint": "v1",
      "service_tier": None
  }
  ```
</CodeGroup>

## Usage example

This example uses `palmyra-vision` to interpret a graph during a chat completion.

### Upload an image to Writer

Before you can use the Vision tool, you must upload the image to Writer.

The following code samples demonstrate how to upload an image and print the File ID. You need the File ID to pass to the Vision endpoint.

<CodeGroup>
  ```bash cURL
  curl -X POST 'https://api.writer.com/v1/files' \
    -H 'Content-Type: image/jpeg' \
    -H 'Content-Disposition: attachment; filename=graph.jpg' \
    -H "Authorization: Bearer $WRITER_API_KEY" \
    --data-binary "@path/to/file/graph.jpg"
  ```

  ```python Python
  from pathlib import Path
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  file_ = client.files.upload(
    content=Path("path/to/file/graph.jpg"),
    content_disposition="attachment; filename=graph.jpg",
    content_type="image/jpeg"
  )

  print(file_.id)
  ```

  ```javascript JavaScript
  import fs from 'fs';
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `api_key` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const file = await client.files.upload({
    content: fs.createReadStream("path/to/file/graph.jpg"),
    "Content-Disposition": "attachment; filename=graph.jpg",
    "Content-Type": "image/jpeg"
  });

  console.log(file.id)
  ```
</CodeGroup>

Learn more about [uploading and managing files](/api-guides/files).

### Create a tools array containing an LLM tool

To use the LLM tool, create a `tools` array that specifies the Writer model you want to use.

<CodeGroup>
  ```bash cURL
  "tools": [
      {
          "type": "vision",
          "function": {
              "model": "palmyra-vision",
              "variables": [
                  {
                      "name": "graph",
                      "file_id": "1234567890"
                  }
              ]
          }
      }
  ]
  ```

  ```python Python
  tools = [{
      "type": "vision",
      "function": {
          "model": "palmyra-vision",
          "variables": [
              {
                  "name": "graph",
                  "file_id": "1234567890"
              }
          ]
      }
  }]
  ```

  ```js JavaScript
  const tools = [{
      type: "vision",
      function: {
          model: "palmyra-vision",
          variables: [
              {
                  name: "graph",
                  file_id: "1234567890"
              }
          ]
      }
  }]
  ```
</CodeGroup>

### Send the request using chat completions

Add the tools array to the chat endpoint call along with your array of messages. Setting `tool_choice` to `auto` allows the model to choose when to use the Vision tool, based on the message provided in the `messages` array.

This example streams the response in real time, rather than waiting for the entire response to be generated.

If you are unfamiliar with the chat completions endpoint or streaming vs. non-streaming responses, learn more in the [chat completion guide](/api-guides/chat-completion).

<CodeGroup>
  ```bash cURL
  curl --location 'https://api.writer.com/v1/chat' \
      --header 'Content-Type: application/json' \
      --header "Authorization: Bearer $WRITER_API_KEY" \
      --data '{
          "model": "palmyra-x-004",
          "temperature": 0.7,
          "messages": [
              {
                  "role": "user",
                  "content": "Summarize the main trends and findings in the graph {{graph}}."
              }
          ],
          "tool_choice": "auto",
          "tools": [
              {
                  "type": "vision",
                  "function": {
                      "model": "palmyra-vision",
                      "variables": [
                          {
                              "name": "graph",
                              "file_id": "1234567890"
                          }
                      ]
                  }
              }
          ],
          "stream": true
      }'
  ```

  ```python Python
  from writerai import Writer

  # Initialize the Writer client. If you don't pass the `api_key` parameter,
  # the client looks for the `WRITER_API_KEY` environment variable.
  client = Writer()

  messages = [{"role": "user", "content": "Summarize the main trends and findings in the graph {{graph}}."}]

  response = client.chat.chat(
      model="palmyra-x-004", 
      messages=messages, 
      tools=tools,  # The tools array defined earlier.
      tool_choice="auto",
      stream=True
  )

  for chunk in response:
      if chunk.choices[0].delta.content is not None:
          print(chunk.choices[0].delta.content, end="", flush=True)
  ```

  ```js JavaScript
  import { Writer } from "writer-sdk";

  // Initialize the Writer client. If you don't pass the `apiKey` parameter,
  // the client looks for the `WRITER_API_KEY` environment variable.
  const client = new Writer();

  const messages = [{role: "user", content: "Summarize the main trends and findings in the graph {{graph}}."}];

  const response = await client.chat.chat({
      model: "palmyra-x-004", 
      messages: messages, 
      tools: tools, // The tools array defined earlier.
      tool_choice: "auto",
      stream: true
  });

  for await (const chunk of response) {
      if (chunk.choices[0].delta.content) {
          process.stdout.write(chunk.choices[0].delta.content);
      }
  }
  ```
</CodeGroup>

By following this guide, you can use the Vision tool to have the `palmyra-vision` model interpret an image during a chat completion.

## Next steps

Learn about additional capabilities of the Writer API, such as [analyzing unstructured medical documents](/api-guides/medical-comprehend) and [context-aware text splitting](/api-guides/context-aware-text-splitting).


# Get your organization subscription details
Source: https://dev.writer.com/api-reference-legacy/billing/get-your-organization-subscription-details

get /billing/subscription

<Warning>
  We're deprecating these API endpoints, so the AI Studio API key setup won't work. \[Contact support] ([https://support.writer.com/](https://support.writer.com/)) if you need them.
</Warning>


# Detect If the content is AI generated
Source: https://dev.writer.com/api-reference-legacy/content/detect-if-the-content-is-ai-generated

post /content/organization/{organizationId}/detect

<Warning>
  We're deprecating these API endpoints, so the AI Studio API key setup won't work. \[Contact support] ([https://support.writer.com/](https://support.writer.com/)) if you need them.
</Warning>


# null
Source: https://dev.writer.com/api-reference-legacy/content/post-contentorganization-team-check

post /content/organization/{organizationId}/team/{teamId}/check

<Warning>
  We're deprecating these API endpoints, so the AI Studio API key setup won't work. \[Contact support] ([https://support.writer.com/](https://support.writer.com/)) if you need them.
</Warning>


# null
Source: https://dev.writer.com/api-reference-legacy/content/post-contentorganization-team-correct

post /content/organization/{organizationId}/team/{teamId}/correct

<Warning>
  We're deprecating these API endpoints, so the AI Studio API key setup won't work. \[Contact support] ([https://support.writer.com/](https://support.writer.com/)) if you need them.
</Warning>


# null
Source: https://dev.writer.com/api-reference-legacy/cowrite/get-cowriteorganization-team-template

get /cowrite/organization/{organizationId}/team/{teamId}/template/{templateId}

<Warning>
  We're deprecating these API endpoints, so the AI Studio API key setup won't work. \[Contact support] ([https://support.writer.com/](https://support.writer.com/)) if you need them.
</Warning>


# null
Source: https://dev.writer.com/api-reference-legacy/cowrite/post-cowriteorganization-team-generate

post /cowrite/organization/{organizationId}/team/{teamId}/generate

<Warning>
  We're deprecating these API endpoints, so the AI Studio API key setup won't work. \[Contact support] ([https://support.writer.com/](https://support.writer.com/)) if you need them.
</Warning>


# Delete snippets
Source: https://dev.writer.com/api-reference-legacy/snippet/delete-snippets

delete /snippet/organization/{organizationId}/team/{teamId}

<Warning>
  We're deprecating these API endpoints, so the AI Studio API key setup won't work. \[Contact support] ([https://support.writer.com/](https://support.writer.com/)) if you need them.
</Warning>


# Find snippets
Source: https://dev.writer.com/api-reference-legacy/snippet/find-snippets

get /snippet/organization/{organizationId}/team/{teamId}

<Warning>
  We're deprecating these API endpoints, so the AI Studio API key setup won't work. \[Contact support] ([https://support.writer.com/](https://support.writer.com/)) if you need them.
</Warning>


# Update snippets
Source: https://dev.writer.com/api-reference-legacy/snippet/update-snippets

put /snippet/organization/{organizationId}/team/{teamId}

<Warning>
  We're deprecating these API endpoints, so the AI Studio API key setup won't work. \[Contact support] ([https://support.writer.com/](https://support.writer.com/)) if you need them.
</Warning>


# List your styleguide pages
Source: https://dev.writer.com/api-reference-legacy/styleguide/list-your-styleguide-pages

get /styleguide/page

<Warning>
  We're deprecating these API endpoints, so the AI Studio API key setup won't work. \[Contact support] ([https://support.writer.com/](https://support.writer.com/)) if you need them.
</Warning>


# Page details
Source: https://dev.writer.com/api-reference-legacy/styleguide/page-details

get /styleguide/page/{pageId}

<Warning>
  We're deprecating these API endpoints, so the AI Studio API key setup won't work. \[Contact support] ([https://support.writer.com/](https://support.writer.com/)) if you need them.
</Warning>


# Add terms
Source: https://dev.writer.com/api-reference-legacy/terminology/add-terms

post /terminology/organization/{organizationId}/team/{teamId}

<Warning>
  We're deprecating these API endpoints, so the AI Studio API key setup won't work. \[Contact support] ([https://support.writer.com/](https://support.writer.com/)) if you need them.
</Warning>


# Delete terms
Source: https://dev.writer.com/api-reference-legacy/terminology/delete-terms

delete /terminology/organization/{organizationId}/team/{teamId}

<Warning>
  We're deprecating these API endpoints, so the AI Studio API key setup won't work. \[Contact support] ([https://support.writer.com/](https://support.writer.com/)) if you need them.
</Warning>


# Find terms
Source: https://dev.writer.com/api-reference-legacy/terminology/find-terms

get /terminology/organization/{organizationId}/team/{teamId}

<Warning>
  We're deprecating these API endpoints, so the AI Studio API key setup won't work. \[Contact support] ([https://support.writer.com/](https://support.writer.com/)) if you need them.
</Warning>


# Update terms
Source: https://dev.writer.com/api-reference-legacy/terminology/update-terms

put /terminology/organization/{organizationId}/team/{teamId}

<Warning>
  We're deprecating these API endpoints, so the AI Studio API key setup won't work. \[Contact support] ([https://support.writer.com/](https://support.writer.com/)) if you need them.
</Warning>


# List users
Source: https://dev.writer.com/api-reference-legacy/user/list-users

get /user

<Warning>
  We're deprecating these API endpoints, so the AI Studio API key setup won't work. \[Contact support] ([https://support.writer.com/](https://support.writer.com/)) if you need them.
</Warning>


# Annotated text
Source: https://dev.writer.com/components/annotatedtext



Shows text with annotations

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/annotatedtext.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Annotated text</td>
      <td>Object</td>
      <td>Value array with text/annotations. Must be a JSON string or a state reference to an array.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Reference</td>
      <td>Color</td>
      <td>The colour to be used as reference for chroma and luminance, and as the starting point for hue rotation.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Seed value</td>
      <td>Number</td>
      <td>Choose a different value to reshuffle colours.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Rotate hue</td>
      <td>Boolean</td>
      <td>If active, rotates the hue depending on the content of the string. If turned off, the reference colour is always used.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Use Markdown</td>
      <td>Boolean</td>
      <td>If active, the output will be sanitized; unsafe elements will be removed.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Copy buttons</td>
      <td>Boolean</td>
      <td>If active, adds a control bar with both copy text and JSON buttons.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Button</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Annotatedtext(content={
        "text": {}, # Union[Dict, str] 
        "referenceColor": "", # str 
        "seed": 0.0, # Union[float, str] 
        "rotateHue": "yes", # str [yes, no]
        "useMarkdown": "no", # str [yes, no]
        "copyButtons": "no", # str [yes, no]
        "buttonColor": "", # str 
        "buttonTextColor": "", # str 
        "primaryTextColor": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/content/CoreAnnotatedText.vue" target="_blank">Explore this component's source code on GitHub</a>


# Avatar
Source: https://dev.writer.com/components/avatar



A component to display user avatars.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/avatar.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Name</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Image source</td>
      <td>Text</td>
      <td>A valid URL. Alternatively, you can provide a state reference to a packed file.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Caption</td>
      <td>Text</td>
      <td>Add an optional caption under the name, such as the person's job title.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Size</td>
      <td>Text</td>

      <td />

      <td>
        <ol>
          <li>Small</li>

          <li>Medium</li>

          <li>Large</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Orientation</td>
      <td>Text</td>

      <td />

      <td>
        <ol>
          <li>Horizontal</li>

          <li>Vertical</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Secondary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-click" icon="code">
    Triggered when the avatar is clicked.

    ```python
    def handle_avatar_click():
    print("The avatar was clicked")
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Avatar(content={
        "name": "", # str 
        "imageSrc": "", # str 
        "caption": "", # str 
        "size": "medium", # str [small, medium, large]
        "orientation": "horizontal", # str [horizontal, vertical]
        "primaryTextColor": "", # str 
        "secondaryTextColor": "", # str 
        "separatorColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-click": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/content/CoreAvatar.vue" target="_blank">Explore this component's source code on GitHub</a>


# Button
Source: https://dev.writer.com/components/button



A standalone button component that can be linked to a click event handler.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/button.png" />

Writer Framework uses Material Symbols to display icons. To include an icon, check [https://fonts.google.com/icons](https://fonts.google.com/icons), find the icon's id (such as `arrow_forward`) and it to your *Button*.

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Text</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Disabled</td>
      <td>Boolean</td>
      <td>Disables all event handlers.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Button</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Icon</td>
      <td>Text</td>
      <td>A Material Symbols id, such as "arrow\_forward".</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button shadow</td>
      <td>Shadow</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-click" icon="code">
    Capture single clicks.

    ```python
    def handle_button_click(state):

    # Increment counter when the button is clicked

    state["counter"] += 1
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Button(content={
        "text": "", # str 
        "isDisabled": "no", # str [yes, no]
        "buttonColor": "", # str 
        "buttonTextColor": "", # str 
        "icon": "", # str 
        "buttonShadow": "", # str 
        "separatorColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-click": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/other/CoreButton.vue" target="_blank">Explore this component's source code on GitHub</a>


# Chatbot
Source: https://dev.writer.com/components/chatbot



A chatbot component to build human-to-AI interactions.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/chatbot.png" />

Connect it to an LLM by handling the `wf-chatbot-message` event, which is triggered every time the user sends a message.

You can add `actions` to messages, which are buttons that trigger the `wf-chatbot-action-click`.

See the stubs for more details.

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Conversation</td>
      <td>Object</td>
      <td>An array with messages or a writer.ai.Conversation object.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Assistant initials</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>User initials</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Use Markdown</td>
      <td>Boolean</td>
      <td>If active, the output will be sanitized; unsafe elements will be removed.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Enable file upload</td>
      <td>Text</td>

      <td />

      <td>
        <ol>
          <li>Single file</li>

          <li>Multiple files</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Placeholder</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Assistant role</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>User role</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Avatar</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Avatar text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Accent</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Container background</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Secondary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-chatbot-message" icon="code">
    Triggered when the user sends a message.

    ```python
    def handle_message_simple(payload, state):

    # payload contains a dict in the form { "role": "user", "message": "hello"}

    state["conversation"] += [payload]
    state["conversation"] += [{
        "role": "assistant",
        "content": "Hello human" if payload == "Hello" else "I don't understand"
    }]

    # Handle streaming by appending to the last message

    import time
    for i in range(10):
        conv = state["conversation"]
        conv[-1]["content"] += f" {i}"
        state["conversation"] = conv
        time.sleep(0.5)
    ```
  </Accordion>

  <Accordion title="wf-chatbot-action-click" icon="code">
    Handle clicks on actions.

    ```python
    def handle_action_simple(payload, state):

    # payload contains the "data" property of the action

    if payload == "change_title":
        state["app_background_color"] = "red"

    # Make an action available when adding a message

    def handle_message_with_action(payload, state):
    state["conversation"] += [payload]
    state["conversation"] += [{
        "role": "assistant",
        "content": "I don't know, but check this out.",
        "actions": [{
            "subheading": "Resource",
            "name": "Surprise",
            "desc": "Click to be surprised",
            "data": "change_title"
        }]
    }]
    ```
  </Accordion>

  <Accordion title="wf-file-change" icon="code">
    Triggered when files are uploaded

    ```python
    def handle_file_upload(state, payload):

    # An array of dictionaries is provided in the payload
    # The dictionaries have the properties name, type and data
    # The data property is a file-like object

    uploaded_files = payload
    for i, uploaded_file in enumerate(uploaded_files):
        name = uploaded_file.get("name")
        file_data = uploaded_file.get("data")
        with open(f"{name}-{i}.jpeg", "wb") as file_handle:
            file_handle.write(file_data)
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Chatbot(content={
        "conversation": {}, # Union[Dict, str] 
        "assistantInitials": "", # str 
        "userInitials": "", # str 
        "useMarkdown": "no", # str [yes, no]
        "enableFileUpload": "no", # str [single, multiple, no]
        "placeholder": "", # str 
        "assistantRoleColor": "", # str 
        "userRoleColor": "", # str 
        "avatarBackgroundColor": "", # str 
        "avatarTextColor": "", # str 
        "accentColor": "", # str 
        "containerBackgroundColor": "", # str 
        "primaryTextColor": "", # str 
        "secondaryTextColor": "", # str 
        "separatorColor": "", # str 
        "buttonColor": "", # str 
        "buttonTextColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-chatbot-message": handle_event,
        "wf-chatbot-action-click": handle_event,
        "wf-file-change": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/content/CoreChatbot.vue" target="_blank">Explore this component's source code on GitHub</a>


# Checkbox Input
Source: https://dev.writer.com/components/checkboxinput



A user input component that allows users to choose multiple values from a list of options using checkboxes.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/checkboxinput.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Label</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Options</td>
      <td>Key-Value</td>
      <td>Key-value object with options. Must be a JSON string or a state reference to a dictionary.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Orientation</td>
      <td>Text</td>
      <td>Specify how to lay out the options.</td>

      <td>
        <ol>
          <li>Vertical</li>

          <li>Horizontal</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Accent</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-options-change" icon="code">
    Sent when the selected options change.

    ```python
    def onchange_handler(state, payload):

    # Set the state variable "selected" to the selected options.
    # The payload will be a list, as multiple options are allowed.

    state["selected"] = payload
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.CheckboxInput(content={
        "label": "", # str 
        "options": {}, # Union[Dict, str] 
        "orientation": "vertical", # str [vertical, horizontal]
        "primaryTextColor": "", # str 
        "accentColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-options-change": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/input/CoreCheckboxInput.vue" target="_blank">Explore this component's source code on GitHub</a>


# Color Input
Source: https://dev.writer.com/components/colorinput



A user input component that allows users to select a color using a color picker interface.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/colorinput.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Label</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Color List</td>
      <td>Object</td>
      <td>List of predefined colors</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-change" icon="code">
    Capture changes as they happen.

    ```python

    def onchange_handler(state, payload):

    # Set the state variable "new_color" to the new value, provided as string.

    state["new_color"] = payload
    ```
  </Accordion>

  <Accordion title="wf-change-finish" icon="code">
    Capture changes once this control has lost focus.

    ```python

    def onchange_handler(state, payload):

    # Set the state variable "new_color" to the new value, provided as string.

    state["new_color"] = payload
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.ColorInput(content={
        "label": "", # str 
        "colorList": {}, # Union[Dict, str] 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-change": handle_event,
        "wf-change-finish": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/input/CoreColorInput.vue" target="_blank">Explore this component's source code on GitHub</a>


# Column
Source: https://dev.writer.com/components/column



A layout component that organizes its child components in columns. Must be inside a Column Container component.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/column.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Title</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Width (factor)</td>
      <td>Number</td>
      <td>Relative size when compared to other columns in the same container. A column of width 2 will be double the width of one with width 1.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Sticky</td>
      <td>Boolean</td>

      <td />

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Collapsible</td>
      <td>Boolean</td>

      <td />

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Start collapsed</td>
      <td>Boolean</td>
      <td>Only applied when the column is collapsible.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Padding</td>
      <td>Padding</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Content alignment (H)</td>
      <td>Align (H)</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Content alignment (V)</td>
      <td>Align (V)</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Column(content={
        "title": "", # str 
        "width": 0.0, # Union[float, str] 
        "isSticky": "no", # str [yes, no]
        "isCollapsible": "no", # str [yes, no]
        "startCollapsed": "no", # str [yes, no]
        "separatorColor": "", # str 
        "contentPadding": "", # str 
        "contentHAlign": "", # str 
        "contentVAlign": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/layout/CoreColumn.vue" target="_blank">Explore this component's source code on GitHub</a>


# Column Container
Source: https://dev.writer.com/components/columns



Serves as container for Column components

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/columns.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.ColumnContainer(content={
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/layout/CoreColumns.vue" target="_blank">Explore this component's source code on GitHub</a>


# DataFrame
Source: https://dev.writer.com/components/dataframe



A component to display Pandas DataFrames.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/dataframe.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Data</td>
      <td>Text</td>
      <td>Must be a state reference to a Pandas dataframe or PyArrow table. Alternatively, a URL for an Arrow IPC file.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Show index</td>
      <td>Boolean</td>
      <td>Shows the dataframe's index. If an Arrow table is used, shows the zero-based integer index.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Enable search</td>
      <td>Boolean</td>

      <td />

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Enable adding a record</td>
      <td>Boolean</td>

      <td />

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Enable updating a record</td>
      <td>Boolean</td>

      <td />

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Enable download</td>
      <td>Boolean</td>
      <td>Allows the user to download the data as CSV.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Actions</td>
      <td>Key-Value</td>
      <td>Define rows actions</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Use Markdown</td>
      <td>Boolean</td>
      <td>If active, the output will be sanitized; unsafe elements will be removed.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Display row count</td>
      <td>Number</td>
      <td>Specifies how many rows to show simultaneously.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Wrap text</td>
      <td>Boolean</td>
      <td>Not wrapping text allows for an uniform grid, but may be inconvenient if your data contains longer text fields.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Secondary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Accent</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Background</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Font style</td>
      <td>Text</td>

      <td />

      <td>
        <ol>
          <li>normal</li>

          <li>monospace</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-dataframe-add" icon="code">
    Capture adding a row.

    ```python
    # Subscribe this event handler to the `wf-dataframe-add` event
    #
    # more on : https://dev.writer.com/framework/dataframe
    def on_record_add(state, payload):
    payload['record']['sales'] = 0 # default value inside the dataframe
    state['mydf'].record_add(payload) # should contain an EditableDataFrame instance
    ```
  </Accordion>

  <Accordion title="wf-dataframe-update" icon="code">
    Capture a cell change.

    ```python
    # Subscribe this event handler to the `wf-dataframe-update` event
    #
    # more on : https://dev.writer.com/framework/dataframe
    def on_record_change(state, payload):
    state['mydf'].record_update(payload) # should contain an EditableDataFrame instance
    ```
  </Accordion>

  <Accordion title="wf-dataframe-action" icon="code">
    Remove or open a row.

    ```python
    # Subscribe this event handler to the `wf-dataframe-action` event
    #
    # more on : https://dev.writer.com/framework/dataframe
    def on_record_action(state, payload):
    # state['mydf'] should contains an EditableDataFrame instance
    record_index = payload['record_index']
    if payload['action'] == 'remove':
    	state['mydf'].record_remove(payload) # should contain an EditableDataFrame instance
    if payload['action'] == 'open':
    	state['record'] = state['mydf'].record(record_index) # dict representation of record
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.DataFrame(content={
        "dataframe": "", # str 
        "showIndex": "yes", # str [yes, no]
        "enableSearch": "no", # str [yes, no]
        "enableRecordAdd": "no", # str [yes, no]
        "enableRecordUpdate": "no", # str [yes, no]
        "enableDownload": "no", # str [yes, no]
        "actions": {}, # Union[Dict, str] 
        "useMarkdown": "no", # str [yes, no]
        "displayRowCount": 0.0, # Union[float, str] 
        "wrapText": "no", # str [yes, no]
        "primaryTextColor": "", # str 
        "secondaryTextColor": "", # str 
        "accentColor": "", # str 
        "separatorColor": "", # str 
        "dataframeBackgroundColor": "", # str 
        "fontStyle": "normal", # str [normal, monospace]
        "cssClasses": "", # str 
    },
    handlers={
        "wf-dataframe-add": handle_event,
        "wf-dataframe-update": handle_event,
        "wf-dataframe-action": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/content/CoreDataframe.vue" target="_blank">Explore this component's source code on GitHub</a>


# Date Input
Source: https://dev.writer.com/components/dateinput



A user input component that allows users to select a date using a date picker interface.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/dateinput.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Label</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-date-change" icon="code">
    Capture changes to this control.

    ```python

    def onchange_handler(state, payload):

    # Set the state variable "new_date" to the new value, provided as a YYYY-MM-DD string.

    state["new_date"] = payload
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.DateInput(content={
        "label": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-date-change": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/input/CoreDateInput.vue" target="_blank">Explore this component's source code on GitHub</a>


# Dropdown Input
Source: https://dev.writer.com/components/dropdowninput



A user input component that allows users to select a single value from a list of options using a dropdown menu.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/dropdowninput.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Label</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Options</td>
      <td>Key-Value</td>
      <td>Key-value object with options. Must be a JSON string or a state reference to a dictionary.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-option-change" icon="code">
    Sent when the selected option changes.

    ```python
    def onchange_handler(state, payload):

    # Set the state variable "selected" to the selected option

    state["selected"] = payload
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.DropdownInput(content={
        "label": "", # str 
        "options": {}, # Union[Dict, str] 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-option-change": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/input/CoreDropdownInput.vue" target="_blank">Explore this component's source code on GitHub</a>


# File Input
Source: https://dev.writer.com/components/fileinput



A user input component that allows users to upload files.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/fileinput.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Label</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Allowed file types</td>
      <td>Text</td>
      <td>Provides hints for browsers to select the correct file types. You can specify extensions and MIME types separated by comma, or leave empty to accept any file.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Allow multiple files</td>
      <td>Boolean</td>

      <td />

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-file-change" icon="code">
    Capture changes to this control.

    ```python
    def onchange_handler(state, payload):

    # An array of dictionaries is provided in the payload
    # The dictionaries have the properties name, type and data
    # The data property is a file-like object

    uploaded_files = payload
    for i, uploaded_file in enumerate(uploaded_files):
    	name = uploaded_file.get("name")
        file_data = uploaded_file.get("data")
        with open(f"{name}-{i}.jpeg", "wb") as file_handle:
            file_handle.write(file_data)
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.FileInput(content={
        "label": "", # str 
        "allowFileTypes": "", # str 
        "allowMultipleFiles": "no", # str [yes, no]
        "cssClasses": "", # str 
    },
    handlers={
        "wf-file-change": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/input/CoreFileInput.vue" target="_blank">Explore this component's source code on GitHub</a>


# Google Maps
Source: https://dev.writer.com/components/googlemaps



A component to embed a Google Map. It can be used to display a map with markers.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/googlemaps.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>API Key</td>
      <td>Text</td>
      <td>API Key from Google Cloud Console.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Map ID</td>
      <td>Text</td>
      <td>ID of map from Google Cloud Console, needed for markers.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Map type</td>
      <td>Text</td>
      <td>One of 'roadmap', 'satellite', 'hybrid' or 'terrain'.</td>

      <td>
        <ol>
          <li>Roadmap</li>

          <li>Satellite</li>

          <li>Hybrid</li>

          <li>Terrain</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Zoom</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Latitude</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Longitude</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Markers</td>
      <td>Object</td>
      <td>Markers data</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="gmap-marker-click" icon="code">
    Capture single clicks on markers.

    ```python
    ```
  </Accordion>

  <Accordion title="gmap-click" icon="code">
    Capture single click on map.

    ```python
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.GoogleMaps(content={
        "apiKey": "", # str 
        "mapId": "", # str 
        "mapType": "roadmap", # str [roadmap, satellite, hybrid, terrain]
        "zoom": 0.0, # Union[float, str] 
        "lat": 0.0, # Union[float, str] 
        "lng": 0.0, # Union[float, str] 
        "markers": {}, # Union[Dict, str] 
        "cssClasses": "", # str 
    },
    handlers={
        "gmap-marker-click": handle_event,
        "gmap-click": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/embed/CoreGoogleMaps.vue" target="_blank">Explore this component's source code on GitHub</a>


# Header
Source: https://dev.writer.com/components/header



A container component that typically contains the main navigation elements.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/header.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Text</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Header(content={
        "text": "", # str 
        "primaryTextColor": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/layout/CoreHeader.vue" target="_blank">Explore this component's source code on GitHub</a>


# Heading
Source: https://dev.writer.com/components/heading



A text component used to display headings or titles in different sizes and styles.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/heading.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Text</td>
      <td>Text</td>
      <td>Add text directly, or reference state elements with @{my_text}.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Heading type</td>
      <td>Text</td>

      <td />

      <td>
        <ol>
          <li>h1 (Big)</li>

          <li>h2 (Normal)</li>

          <li>h3 (Small)</li>

          <li>h4 (Smallest)</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Alignment</td>
      <td>Text</td>

      <td />

      <td>
        <ol>
          <li>Left</li>

          <li>Center</li>

          <li>Right</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Heading(content={
        "text": "", # str 
        "headingType": "h3", # str [h1, h2, h3, h4]
        "alignment": "left", # str [left, center, right]
        "primaryTextColor": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/content/CoreHeading.vue" target="_blank">Explore this component's source code on GitHub</a>


# Horizontal Stack
Source: https://dev.writer.com/components/horizontalstack



A layout component that stacks its child components horizontally, wrapping them to the next row if necessary.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/horizontalstack.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Padding</td>
      <td>Padding</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Content alignment (H)</td>
      <td>Align (H)</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Content alignment (V)</td>
      <td>Align (V)</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.HorizontalStack(content={
        "contentPadding": "", # str 
        "contentHAlign": "", # str 
        "contentVAlign": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/layout/CoreHorizontalStack.vue" target="_blank">Explore this component's source code on GitHub</a>


# HTML Element
Source: https://dev.writer.com/components/html



A generic component that creates customisable HTML elements, which can serve as containers for other components.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/html.png" />

You can configure the element type, styles, and attributes to fit your design requirements. You can link them to state for advanced use cases, such as custom animations.

All valid HTML tags are supported, including tags such as `iframe`, allowing you to embed external sites.

Take into account the potential risks of adding custom HTML to your app, including XSS. Be specially careful when injecting user-generated data.

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Element</td>
      <td>Text</td>
      <td>Set the type of HTML element to create, e.g., 'div', 'section', 'span', etc.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Styles</td>
      <td>Object</td>
      <td>Define the CSS styles to apply to the HTML element using a JSON object or a state reference to a dictionary.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Attributes</td>
      <td>Object</td>
      <td>Set additional HTML attributes for the element using a JSON object or a dictionary via a state reference.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>HTML inside</td>
      <td>Text</td>
      <td>Define custom HTML to be used inside the element. It will be wrapped in a div and rendered after children components.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.HTMLElement(content={
        "element": "", # str 
        "styles": {}, # Union[Dict, str] 
        "attrs": {}, # Union[Dict, str] 
        "htmlInside": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/other/CoreHtml.vue" target="_blank">Explore this component's source code on GitHub</a>


# Icon
Source: https://dev.writer.com/components/icon



A component to display an icon

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/icon.png" />

Writer Framework uses Material Symbols to display icons. To include an icon, check [https://fonts.google.com/icons](https://fonts.google.com/icons), find the icon's id (such as `arrow_forward`) and it to your \_Icon.

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Icon</td>
      <td>Text</td>
      <td>A Material Symbols id, such as "arrow\_forward".</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Icon size</td>
      <td>Number</td>
      <td>Icon size in px</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Icon color</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Icon(content={
        "icon": "", # str 
        "size": 0.0, # Union[float, str] 
        "color": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/content/CoreIcon.vue" target="_blank">Explore this component's source code on GitHub</a>


# IFrame
Source: https://dev.writer.com/components/iframe



A component to embed an external resource in an iframe.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/iframe.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Source</td>
      <td>Text</td>
      <td>A valid URL</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-load" icon="code">
    Fires when the resource has successfully loaded.

    ```python
    def load_handler(state):

    # Sets status message when resource is loaded

    state["status"] = "Page loaded"
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.IFrame(content={
        "src": "", # str 
        "separatorColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-load": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/embed/CoreIFrame.vue" target="_blank">Explore this component's source code on GitHub</a>


# Image
Source: https://dev.writer.com/components/image



A component to display images.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/image.png" />

Use your app's static folder to serve images directly. For example, `static/my_image.png`.

Alternatively, pass a Matplotlib figure via state.

`state[&quot;my_fig&quot;] = fig` and then setting the *Image* source to `@{fig}`

You can also use packed files or bytes:

`state[&quot;img_b&quot;] = wf.pack_bytes(img_bytes, &quot;image/png&quot;)`

`state[&quot;img_f&quot;] = wf.pack_file(img_file, &quot;image/png&quot;)`

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Source</td>
      <td>Text</td>
      <td>A valid URL. Alternatively, you can provide a state reference to a Matplotlib figure or a packed file.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Caption</td>
      <td>Text</td>
      <td>Leave blank to hide.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Max width (px)</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Max height (px)</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Secondary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-click" icon="code">
    Capture single clicks.

    ```python
    def click_handler(state):

    # Increment counter when the image is clicked

    state["counter"] += 1
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Image(content={
        "src": "", # str 
        "caption": "", # str 
        "maxWidth": 0.0, # Union[float, str] 
        "maxHeight": 0.0, # Union[float, str] 
        "secondaryTextColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-click": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/content/CoreImage.vue" target="_blank">Explore this component's source code on GitHub</a>


# JSON Viewer
Source: https://dev.writer.com/components/jsonviewer



A component to explore JSON data as a hierarchy.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/jsonviewer.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Data</td>
      <td>Object</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Initial depth</td>
      <td>Number</td>
      <td>Sets the initial viewing depth of the JSON tree hierarchy. Use -1 to display the full hierarchy.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Hide root</td>
      <td>Boolean</td>
      <td>Don't show the type of the root node when it's an Object or an Array.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Copy</td>
      <td>Boolean</td>
      <td>If active, adds a control bar with copy JSON button.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>JSON indentation</td>
      <td>Width</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Accent</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Secondary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.JSONViewer(content={
        "data": {}, # Union[Dict, str] 
        "initialDepth": 0.0, # Union[float, str] 
        "hideRoot": "no", # str [yes, no]
        "copy": "no", # str [yes, no]
        "jsonViewerIndentationSpacing": "", # str 
        "accentColor": "", # str 
        "secondaryTextColor": "", # str 
        "separatorColor": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/content/CoreJsonViewer.vue" target="_blank">Explore this component's source code on GitHub</a>


# Link
Source: https://dev.writer.com/components/link



A component to create a hyperlink.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/link.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>URL</td>
      <td>Text</td>
      <td>Specify a URL or choose a page. Keep in mind that you can only link to pages for which a key has been specified.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Target</td>
      <td>Text</td>
      <td>Specifies where to open the linked document.</td>

      <td>
        <ol>
          <li>Self</li>

          <li>Blank</li>

          <li>Parent</li>

          <li>Top</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Rel</td>
      <td>Text</td>
      <td>Specifies the relationship between the current document and the linked document.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Text</td>
      <td>Text</td>
      <td>The text to display in the link.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Link(content={
        "url": "", # str 
        "target": "_self", # str [_self, _blank, _parent, _top]
        "rel": "", # str 
        "text": "", # str 
        "primaryTextColor": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/content/CoreLink.vue" target="_blank">Explore this component's source code on GitHub</a>


# Mapbox
Source: https://dev.writer.com/components/mapbox



A component to embed a Mapbox map. It can be used to display a map with markers.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/mapbox.png" />

For this component you need Mapbox access token: [https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes](https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes)

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Access Token</td>
      <td>Text</td>
      <td>Access token from Mapbox</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Map style</td>
      <td>Text</td>
      <td>Map style URL</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Zoom</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Latitude</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Longitude</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Markers</td>
      <td>Object</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Controls visible</td>
      <td>Boolean</td>
      <td>Show map controls</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="mapbox-marker-click" icon="code">
    Capture single clicks on markers.

    ```python
    ```
  </Accordion>

  <Accordion title="mapbox-click" icon="code">
    Capture single click on map.

    ```python
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Mapbox(content={
        "accessToken": "", # str 
        "mapStyle": "", # str 
        "zoom": 0.0, # Union[float, str] 
        "lat": 0.0, # Union[float, str] 
        "lng": 0.0, # Union[float, str] 
        "markers": {}, # Union[Dict, str] 
        "controls": "yes", # str [yes, no]
        "cssClasses": "", # str 
    },
    handlers={
        "mapbox-marker-click": handle_event,
        "mapbox-click": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/embed/CoreMapbox.vue" target="_blank">Explore this component's source code on GitHub</a>


# Message
Source: https://dev.writer.com/components/message



A component that displays a message in various styles, including success, error, warning, and informational.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/message.png" />

When working with operations that can succeed or fail, *Message* can be useful. You can reserve a state element to be used for the outcome of the operation; empty messages aren't shown, so you can initialise it empty.
Then, assign a message when the operation is completed.

```python
state[&quot;msg&quot;] = &quot;&quot;

if is_ok:
  state[&quot;msg&quot;] = &quot;+It worked!&quot;
else:
  state[&quot;msg&quot;] = &quot;-It failed&quot;
```

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Message</td>
      <td>Text</td>
      <td>Prefix with '+' for a success message, with '-' for error, '!' for warning, '%' for loading. No prefix for info. Leave empty to hide.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Success</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Error</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Warning</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Info</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Loading</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Message(content={
        "message": "", # str 
        "successColor": "", # str 
        "errorColor": "", # str 
        "warningColor": "", # str 
        "infoColor": "", # str 
        "loadingColor": "", # str 
        "primaryTextColor": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/content/CoreMessage.vue" target="_blank">Explore this component's source code on GitHub</a>


# Metric
Source: https://dev.writer.com/components/metric



A component that prominently displays a metric value and associated information.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/metric.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Name</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Value</td>
      <td>Text</td>
      <td>The main value to be displayed. It's not limited to numbers.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Description</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Note</td>
      <td>Text</td>
      <td>Prefix with '+' for a positive message, with '-' for a negative message.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Secondary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Positive</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Neutral</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Negative</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Metric(content={
        "name": "", # str 
        "metricValue": "", # str 
        "description": "", # str 
        "note": "", # str 
        "primaryTextColor": "", # str 
        "secondaryTextColor": "", # str 
        "positiveColor": "", # str 
        "neutralColor": "", # str 
        "negativeColor": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/content/CoreMetric.vue" target="_blank">Explore this component's source code on GitHub</a>


# Multiselect Input
Source: https://dev.writer.com/components/multiselectinput



A user input component that allows users to select multiple values from a searchable list of options.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/multiselectinput.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Label</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Options</td>
      <td>Key-Value</td>
      <td>Key-value object with options. Must be a JSON string or a state reference to a dictionary.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Placeholder</td>
      <td>Text</td>
      <td>Text to show when no options are selected.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Maximum count</td>
      <td>Number</td>
      <td>The maximum allowable number of selected options. Set to zero for unlimited.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Accent</td>
      <td>Color</td>
      <td>The colour of the chips created for each selected option.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Chip text</td>
      <td>Color</td>
      <td>The colour of the text in the chips.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Secondary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Container background</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-options-change" icon="code">
    Sent when the selected options change.

    ```python
    def onchange_handler(state, payload):

    # Set the state variable "selected" to the selected option

    state["selected"] = payload
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.MultiselectInput(content={
        "label": "", # str 
        "options": {}, # Union[Dict, str] 
        "placeholder": "", # str 
        "maximumCount": 0.0, # Union[float, str] 
        "accentColor": "", # str 
        "chipTextColor": "", # str 
        "primaryTextColor": "", # str 
        "secondaryTextColor": "", # str 
        "containerBackgroundColor": "", # str 
        "separatorColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-options-change": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/input/CoreMultiselectInput.vue" target="_blank">Explore this component's source code on GitHub</a>


# Number Input
Source: https://dev.writer.com/components/numberinput



A user input component that allows users to enter numeric values.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/numberinput.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Label</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Placeholder</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Minimum value</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Max value</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Step</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-number-change" icon="code">
    Capture changes as they happen.

    ```python

    def onchange_handler(state, payload):

    # Set the state variable "new_val" to the new value

    state["new_val"] = payload
    ```
  </Accordion>

  <Accordion title="wf-number-change-finish" icon="code">
    Capture changes once this control has lost focus.

    ```python

    def onchange_handler(state, payload):

    # Set the state variable "new_val" to the new value

    state["new_val"] = payload
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.NumberInput(content={
        "label": "", # str 
        "placeholder": "", # str 
        "minValue": 0.0, # Union[float, str] 
        "maxValue": 0.0, # Union[float, str] 
        "valueStep": 0.0, # Union[float, str] 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-number-change": handle_event,
        "wf-number-change-finish": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/input/CoreNumberInput.vue" target="_blank">Explore this component's source code on GitHub</a>


# Pagination
Source: https://dev.writer.com/components/pagination



A component that can help you paginate records, for example from a Repeater or a DataFrame.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/pagination.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Page</td>
      <td>Number</td>
      <td>The current page number.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Page Size</td>
      <td>Number</td>
      <td>The number of items per page.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Total Items</td>
      <td>Number</td>
      <td>The total number of items</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Page Size Options</td>
      <td>Text</td>
      <td>A comma-separated list of page size options. If it's empty, the user can't change the page size. Set your default page size as the first option.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Show All Option</td>
      <td>Boolean</td>
      <td>Show an option to show all records.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Jump To</td>
      <td>Boolean</td>
      <td>Show an option to jump to a specific page.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-change-page" icon="code">
    Fires when the user pick a page

    ```python
    def handle_page_change(state, payload):
    page = payload
    state["page"] = page

    records = _load_records_from_db(start = state["page"] * state["pageSize"], limit = state["pageSize"])
    # update a repeater
    state["highlighted_members"] = {r.id: r for r in records}
    ```
  </Accordion>

  <Accordion title="wf-change-page-size" icon="code">
    Fires when the user change the page size.

    ```python
    def handle_page_size_change(state, payload):
    state['pageSize'] = payload

    records = _load_records_from_db(start = state["page"] * state["pageSize"], limit = state["pageSize"])
    # update a repeater
    state["highlighted_members"] = {r.id: r for r in records}
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Pagination(content={
        "page": 0.0, # Union[float, str] 
        "pageSize": 0.0, # Union[float, str] 
        "totalItems": 0.0, # Union[float, str] 
        "pageSizeOptions": "", # str 
        "pageSizeShowAll": "no", # str [yes, no]
        "jumpTo": "no", # str [yes, no]
    },
    handlers={
        "wf-change-page": handle_event,
        "wf-change-page-size": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/other/CorePagination.vue" target="_blank">Explore this component's source code on GitHub</a>


# PDF
Source: https://dev.writer.com/components/pdf



A component to embed PDF documents.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/pdf.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>PDF source</td>
      <td>Text</td>
      <td>A valid URL. Alternatively, you can provide a state reference to a packed PDF file.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Highlights</td>
      <td>Object</td>
      <td>A list of highlights to be applied to the PDF as a JSON array of strings.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Selected highlight match</td>
      <td>Number</td>
      <td>The index of the selected highlight match.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Page</td>
      <td>Number</td>
      <td>The page to be displayed.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Controls</td>
      <td>Boolean</td>
      <td>Show controls to navigate the PDF.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Container background</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.PDF(content={
        "source": "", # str 
        "highlights": {}, # Union[Dict, str] 
        "selectedMatch": 0.0, # Union[float, str] 
        "page": 0.0, # Union[float, str] 
        "controls": "yes", # str [yes, no]
        "containerBackgroundColor": "", # str 
        "separatorColor": "", # str 
        "primaryTextColor": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/embed/CorePDF.vue" target="_blank">Explore this component's source code on GitHub</a>


# Plotly Graph
Source: https://dev.writer.com/components/plotlygraph



A component that displays Plotly graphs.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/plotlygraph.png" />

You can listen to events triggered by Plotly.js and add interactivity to your charts.
For example, implement cross-filtering.

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Graph specification</td>
      <td>Object</td>
      <td>Plotly graph specification. Pass it using state, e.g. @{fig}, or paste a JSON specification.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="plotly-click" icon="code">
    Sends a list with the clicked points.

    ```python
    ```
  </Accordion>

  <Accordion title="plotly-selected" icon="code">
    Sends a list with the selected points.

    ```python
    ```
  </Accordion>

  <Accordion title="plotly-deselect" icon="code">
    Triggered when points are deselected.

    ```python
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.PlotlyGraph(content={
        "spec": {}, # Union[Dict, str] 
        "cssClasses": "", # str 
    },
    handlers={
        "plotly-click": handle_event,
        "plotly-selected": handle_event,
        "plotly-deselect": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/content/CorePlotlyGraph.vue" target="_blank">Explore this component's source code on GitHub</a>


# Radio Input
Source: https://dev.writer.com/components/radioinput



A user input component that allows users to choose a single value from a list of options using radio buttons.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/radioinput.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Label</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Options</td>
      <td>Key-Value</td>
      <td>Key-value object with options. Must be a JSON string or a state reference to a dictionary.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Orientation</td>
      <td>Text</td>
      <td>Specify how to lay out the options.</td>

      <td>
        <ol>
          <li>Vertical</li>

          <li>Horizontal</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Accent</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-option-change" icon="code">
    Sent when the selected option changes.

    ```python
    def onchange_handler(state, payload):

    # Set the state variable "selected" to the selected radio option

    state["selected"] = payload
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.RadioInput(content={
        "label": "", # str 
        "options": {}, # Union[Dict, str] 
        "orientation": "vertical", # str [vertical, horizontal]
        "primaryTextColor": "", # str 
        "accentColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-option-change": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/input/CoreRadioInput.vue" target="_blank">Explore this component's source code on GitHub</a>


# Slider Range Input
Source: https://dev.writer.com/components/rangeinput



A user input component that allows users to select numeric values range using a range slider with optional constraints like min, max, and step.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/rangeinput.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Label</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Minimum value</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Maximum value</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Step size</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Accent</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Popover color</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Popover background</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-range-change" icon="code">
    Capture changes to this control.

    ```python

    def onchange_handler(state, payload):

    # Set the state variables "from" & "to" to the new range
    state["from"] = payload[0]
    state["to"] = payload[1]
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.SliderRangeInput(content={
        "label": "", # str 
        "minValue": 0.0, # Union[float, str] 
        "maxValue": 0.0, # Union[float, str] 
        "stepSize": 0.0, # Union[float, str] 
        "accentColor": "", # str 
        "popoverColor": "", # str 
        "popoverBackgroundColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-range-change": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/input/CoreSliderRangeInput.vue" target="_blank">Explore this component's source code on GitHub</a>


# Rating Input
Source: https://dev.writer.com/components/ratinginput



A user input component that allows users to provide a rating.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/ratinginput.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Label</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Feedback</td>
      <td>Text</td>

      <td />

      <td>
        <ol>
          <li>Stars</li>

          <li>Faces</li>

          <li>Hearts</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Minimum value</td>
      <td>Number</td>
      <td>Valid values are 0 and 1.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Max value</td>
      <td>Number</td>
      <td>Valid values are between 2 and 11.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Step</td>
      <td>Number</td>
      <td>Valid values are between 0.25 and 1.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Accent</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-number-change" icon="code">
    ```python

    def onchange_handler(state, payload):

    # Set the state variable "rating" to the new value

    state["rating"] = payload
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.RatingInput(content={
        "label": "", # str 
        "feedback": "stars", # str [stars, faces, hearts]
        "minValue": 0.0, # Union[float, str] 
        "maxValue": 0.0, # Union[float, str] 
        "valueStep": 0.0, # Union[float, str] 
        "accentColor": "", # str 
        "primaryTextColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-number-change": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/input/CoreRatingInput.vue" target="_blank">Explore this component's source code on GitHub</a>


# Repeater
Source: https://dev.writer.com/components/repeater



A container component that repeats its child components based on a dictionary.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/repeater.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Repeater object</td>
      <td>Object</td>
      <td>Include a state reference to the dictionary used for repeating the child components. Alternatively, specify a JSON object.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Key variable name</td>
      <td>Text</td>
      <td>Set the name of the variable that will store the key of the current repeater object entry.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Value variable name</td>
      <td>Text</td>
      <td>Set the name of the variable that will store the value of the current repeater object entry.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Repeater(content={
        "repeaterObject": {}, # Union[Dict, str] 
        "keyVariable": "", # str 
        "valueVariable": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/other/CoreRepeater.vue" target="_blank">Explore this component's source code on GitHub</a>


# Reuse Component
Source: https://dev.writer.com/components/reuse



Those components are used to reuse other components. Reused components share the same state and are updated together.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/reuse.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Component id</td>
      <td>Text</td>
      <td>The id of the component to reuse.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.ReuseComponent(content={
        "proxyId": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/other/CoreReuse.vue" target="_blank">Explore this component's source code on GitHub</a>


# Section
Source: https://dev.writer.com/components/section



A container component that divides the layout into sections, with an optional title.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/section.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Title</td>
      <td>Text</td>
      <td>Leave blank to hide.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Collapsible</td>
      <td>Boolean</td>

      <td />

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Start collapsed</td>
      <td>Boolean</td>
      <td>Only applied when the component is collapsible.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Accent</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Secondary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Container background</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Container shadow</td>
      <td>Shadow</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button shadow</td>
      <td>Shadow</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Padding</td>
      <td>Padding</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Content alignment (H)</td>
      <td>Align (H)</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Section(content={
        "title": "", # str 
        "isCollapsible": "no", # str [yes, no]
        "startCollapsed": "no", # str [yes, no]
        "accentColor": "", # str 
        "primaryTextColor": "", # str 
        "secondaryTextColor": "", # str 
        "containerBackgroundColor": "", # str 
        "containerShadow": "", # str 
        "separatorColor": "", # str 
        "buttonColor": "", # str 
        "buttonTextColor": "", # str 
        "buttonShadow": "", # str 
        "contentPadding": "", # str 
        "contentHAlign": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/layout/CoreSection.vue" target="_blank">Explore this component's source code on GitHub</a>


# Select Input
Source: https://dev.writer.com/components/selectinput



A user input component that allows users to select a single value from a searchable list of options.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/selectinput.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Label</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Options</td>
      <td>Key-Value</td>
      <td>Key-value object with options. Must be a JSON string or a state reference to a dictionary.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Placeholder</td>
      <td>Text</td>
      <td>Text to show when no options are selected.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Maximum count</td>
      <td>Number</td>
      <td>The maximum allowable number of selected options. Set to zero for unlimited.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Accent</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Chip text</td>
      <td>Color</td>
      <td>The color of the text in the chips.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Secondary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Container background</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-option-change" icon="code">
    Sent when the selected option changes.

    ```python
    def onchange_handler(state, payload):

    # Set the state variable "selected" to the selected option

    state["selected"] = payload
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.SelectInput(content={
        "label": "", # str 
        "options": {}, # Union[Dict, str] 
        "placeholder": "", # str 
        "maximumCount": 0.0, # Union[float, str] 
        "accentColor": "", # str 
        "chipTextColor": "", # str 
        "primaryTextColor": "", # str 
        "secondaryTextColor": "", # str 
        "containerBackgroundColor": "", # str 
        "separatorColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-option-change": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/input/CoreSelectInput.vue" target="_blank">Explore this component's source code on GitHub</a>


# Separator
Source: https://dev.writer.com/components/separator



A visual component to create a separation between adjacent elements.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/separator.png" />

*Separator* components are used to separate layout elements. They can be used in most containers, including *Column Container* to separate columns.

If the container flows horizontally (like a *Horizontal Stack* or a *Column Container*) the *Separator* will be a vertical line. Otherwise, it'll be a horizontal line.

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Separator(content={
        "separatorColor": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/layout/CoreSeparator.vue" target="_blank">Explore this component's source code on GitHub</a>


# Sidebar
Source: https://dev.writer.com/components/sidebar



A container component that organizes its children in a sidebar. Its parent must be a Page component.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/sidebar.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Start collapsed</td>
      <td>Boolean</td>

      <td />

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Background</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Accent</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Secondary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Container background</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Container shadow</td>
      <td>Shadow</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button shadow</td>
      <td>Shadow</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Sidebar(content={
        "startCollapsed": "no", # str [yes, no]
        "sidebarBackgroundColor": "", # str 
        "accentColor": "", # str 
        "primaryTextColor": "", # str 
        "secondaryTextColor": "", # str 
        "containerBackgroundColor": "", # str 
        "containerShadow": "", # str 
        "separatorColor": "", # str 
        "buttonColor": "", # str 
        "buttonTextColor": "", # str 
        "buttonShadow": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/layout/CoreSidebar.vue" target="_blank">Explore this component's source code on GitHub</a>


# Slider Input
Source: https://dev.writer.com/components/sliderinput



A user input component that allows users to select numeric values using a slider with optional constraints like min, max, and step.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/sliderinput.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Label</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Minimum value</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Maximum value</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Step size</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Accent</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Popover color</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Popover background</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-number-change" icon="code">
    Capture changes to this control.

    ```python

    def onchange_handler(state, payload):

    # Set the state variable "new_val" to the new value

    state["new_val"] = payload
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.SliderInput(content={
        "label": "", # str 
        "minValue": 0.0, # Union[float, str] 
        "maxValue": 0.0, # Union[float, str] 
        "stepSize": 0.0, # Union[float, str] 
        "accentColor": "", # str 
        "popoverColor": "", # str 
        "popoverBackgroundColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-number-change": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/input/CoreSliderInput.vue" target="_blank">Explore this component's source code on GitHub</a>


# Step
Source: https://dev.writer.com/components/step



A container component that displays its child components as a step inside a Step Container.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/step.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Name</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Padding</td>
      <td>Padding</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Completed</td>
      <td>Boolean</td>
      <td>Use a state reference to dynamically mark this step as complete.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Content alignment (H)</td>
      <td>Align (H)</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Step(content={
        "name": "", # str 
        "contentPadding": "", # str 
        "isCompleted": "no", # str [yes, no]
        "contentHAlign": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/layout/CoreStep.vue" target="_blank">Explore this component's source code on GitHub</a>


# Step Container
Source: https://dev.writer.com/components/steps



A container component for displaying Step components, allowing you to implement a stepped workflow.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/steps.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Accent</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Secondary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Container background</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Container shadow</td>
      <td>Shadow</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button shadow</td>
      <td>Shadow</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.StepContainer(content={
        "accentColor": "", # str 
        "primaryTextColor": "", # str 
        "secondaryTextColor": "", # str 
        "containerBackgroundColor": "", # str 
        "containerShadow": "", # str 
        "separatorColor": "", # str 
        "buttonColor": "", # str 
        "buttonTextColor": "", # str 
        "buttonShadow": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/layout/CoreSteps.vue" target="_blank">Explore this component's source code on GitHub</a>


# Switch Input
Source: https://dev.writer.com/components/switchinput



A user input component with a simple on/off status.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/switchinput.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Label</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Accent</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-toggle" icon="code">
    Sent when the switch is toggled.

    ```python
    def handle_toggle(state, payload):

    # The payload will be a bool 

    state["its_on"] = payload
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.SwitchInput(content={
        "label": "", # str 
        "accentColor": "", # str 
        "primaryTextColor": "", # str 
        "separatorColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-toggle": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/input/CoreSwitchInput.vue" target="_blank">Explore this component's source code on GitHub</a>


# Tab
Source: https://dev.writer.com/components/tab



A container component that displays its child components as a tab inside a Tab Container.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/tab.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Name</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Padding</td>
      <td>Padding</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Content alignment (H)</td>
      <td>Align (H)</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Tab(content={
        "name": "", # str 
        "contentPadding": "", # str 
        "contentHAlign": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/layout/CoreTab.vue" target="_blank">Explore this component's source code on GitHub</a>


# Tab Container
Source: https://dev.writer.com/components/tabs



A container component for organising and displaying Tab components in a tabbed interface.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/tabs.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Accent</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Secondary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Container background</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Container shadow</td>
      <td>Shadow</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button shadow</td>
      <td>Shadow</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.TabContainer(content={
        "accentColor": "", # str 
        "primaryTextColor": "", # str 
        "secondaryTextColor": "", # str 
        "containerBackgroundColor": "", # str 
        "containerShadow": "", # str 
        "separatorColor": "", # str 
        "buttonColor": "", # str 
        "buttonTextColor": "", # str 
        "buttonShadow": "", # str 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/layout/CoreTabs.vue" target="_blank">Explore this component's source code on GitHub</a>


# Tags
Source: https://dev.writer.com/components/tags



A component to display coloured tag pills.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/tags.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Tags</td>
      <td>Key-Value</td>
      <td>Key-value object with tags. Must be a JSON string or a state reference to a dictionary.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Reference</td>
      <td>Color</td>
      <td>The colour to be used as reference for chroma and luminance, and as the starting point for hue rotation.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Seed value</td>
      <td>Number</td>
      <td>Choose a different value to reshuffle colours.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Rotate hue</td>
      <td>Boolean</td>
      <td>If active, rotates the hue depending on the content of the string. If turned off, the reference colour is always used.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-tag-click" icon="code">
    Triggered when a tag is clicked.

    ```python
    def handle_tag_click(state, payload):
    state["selected_tag_id"] = payload
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Tags(content={
        "tags": {}, # Union[Dict, str] 
        "referenceColor": "", # str 
        "seed": 0.0, # Union[float, str] 
        "rotateHue": "yes", # str [yes, no]
        "primaryTextColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-tag-click": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/content/CoreTags.vue" target="_blank">Explore this component's source code on GitHub</a>


# Text
Source: https://dev.writer.com/components/text



A component to display plain text or formatted text using Markdown syntax.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/text.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Text</td>
      <td>Text</td>
      <td>Add text directly, or reference state elements with @{my_text}.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Use Markdown</td>
      <td>Boolean</td>
      <td>The Markdown output will be sanitised; unsafe elements will be removed.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Alignment</td>
      <td>Text</td>

      <td />

      <td>
        <ol>
          <li>Left</li>

          <li>Center</li>

          <li>Right</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Primary text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-click" icon="code">
    Capture single clicks.

    ```python
    def click_handler(state):

    # Increment counter when the text is clicked

    state["counter"] += 1
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Text(content={
        "text": "", # str 
        "useMarkdown": "no", # str [yes, no]
        "alignment": "left", # str [left, center, right]
        "primaryTextColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-click": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/content/CoreText.vue" target="_blank">Explore this component's source code on GitHub</a>


# Textarea Input
Source: https://dev.writer.com/components/textareainput



A user input component that allows users to enter multi-line text values.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/textareainput.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Label</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Placeholder</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Rows</td>
      <td>Number</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-change" icon="code">
    Capture changes as they happen.

    ```python

    def onchange_handler(state, payload):

    # Set the state variable "new_val" to the new value

    state["new_val"] = payload
    ```
  </Accordion>

  <Accordion title="wf-change-finish" icon="code">
    Capture changes once this control has lost focus.

    ```python

    def onchange_handler(state, payload):

    # Set the state variable "new_val" to the new value

    state["new_val"] = payload
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.TextareaInput(content={
        "label": "", # str 
        "placeholder": "", # str 
        "rows": 0.0, # Union[float, str] 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-change": handle_event,
        "wf-change-finish": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/input/CoreTextareaInput.vue" target="_blank">Explore this component's source code on GitHub</a>


# Text Input
Source: https://dev.writer.com/components/textinput



A user input component that allows users to enter single-line text values.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/textinput.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Label</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Placeholder</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Password mode</td>
      <td>Boolean</td>

      <td />

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Accent</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-change" icon="code">
    Capture changes as they happen.

    ```python

    def onchange_handler(state, payload):

    # Set the state variable "new_val" to the new value

    state["new_val"] = payload
    ```
  </Accordion>

  <Accordion title="wf-change-finish" icon="code">
    Capture changes once this control has lost focus.

    ```python

    def onchange_handler(state, payload):

    # Set the state variable "new_val" to the new value

    state["new_val"] = payload
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.TextInput(content={
        "label": "", # str 
        "placeholder": "", # str 
        "passwordMode": "no", # str [yes, no]
        "accentColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-change": handle_event,
        "wf-change-finish": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/input/CoreTextInput.vue" target="_blank">Explore this component's source code on GitHub</a>


# Time Input
Source: https://dev.writer.com/components/timeinput



A user input component that allows users to select a time.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/timeinput.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Label</td>
      <td>Text</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-time-change" icon="code">
    Capture changes to this control.

    ```python

    def onchange_handler(state, payload):

    # Set the state variable "new_time" to the new value, provided as a hh:mm string (in 24-hour format that includes leading zeros).

    state["new_time"] = payload
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.TimeInput(content={
        "label": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-time-change": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/input/CoreTimeInput.vue" target="_blank">Explore this component's source code on GitHub</a>


# Timer
Source: https://dev.writer.com/components/timer



A component that emits an event repeatedly at specified time intervals, enabling time-based refresh.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/timer.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Interval (ms)</td>
      <td>Number</td>
      <td>How much time to wait between ticks. A tick is considered finished when its event is handled.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Active</td>
      <td>Boolean</td>
      <td>Whether the timer should trigger tick events.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Accent</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-tick" icon="code">
    Emitted when the timer ticks.

    ```python
    def handle_timer_tick(state):

    # Increment counter when the timer ticks

    state["counter"] += 1
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.Timer(content={
        "intervalMs": 0.0, # Union[float, str] 
        "isActive": "yes", # str [yes, no]
        "accentColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-tick": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/other/CoreTimer.vue" target="_blank">Explore this component's source code on GitHub</a>


# Vega Lite Chart
Source: https://dev.writer.com/components/vegalitechart



A component that displays Vega-Lite/Altair charts.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/vegalitechart.png" />

Generate a chart using Altair and pass it via state; it'll be converted to Vega-Lite specification.

`state[&quot;my_chart&quot;] = chart`

Afterwards, you can reference the chart in the specification using the syntax `@{my_chart}`.

Alternatively, you can work with Vega-Lite directly.

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Chart specification</td>
      <td>Object</td>
      <td>Vega-Lite chart specification. Pass a Vega Altair chart using state or paste a JSON specification.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.VegaLiteChart(content={
        "spec": {}, # Union[Dict, str] 
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/content/CoreVegaLiteChart.vue" target="_blank">Explore this component's source code on GitHub</a>


# Video Player
Source: https://dev.writer.com/components/videoplayer



A video player component that can play various video formats.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/videoplayer.png" />

Use your app's static folder to serve videos directly. For example, `static/my_video.mp4`.

Alternatively, you can pack bytes or files in state:

`state[&quot;vid_b&quot;] = wf.pack_bytes(vid_bytes, &quot;video/mp4&quot;)`

`state[&quot;vid_f&quot;] = wf.pack_file(vid_file, &quot;video/mp4&quot;)`

Afterwards, you can reference the video using the syntax `@{vid_f}`.

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Source</td>
      <td>Text</td>
      <td>The URL of the video file. Alternatively, you can pass a file via state.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Controls</td>
      <td>Boolean</td>
      <td>Display video player controls.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Autoplay</td>
      <td>Boolean</td>
      <td>Autoplay the video when the component is loaded.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Loop</td>
      <td>Boolean</td>
      <td>Loop the video when it reaches the end.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Muted</td>
      <td>Boolean</td>
      <td>Mute the video by default.</td>

      <td>
        <ol>
          <li>Yes</li>

          <li>No</li>
        </ol>
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.VideoPlayer(content={
        "src": "", # str 
        "controls": "yes", # str [yes, no]
        "autoplay": "no", # str [yes, no]
        "loop": "no", # str [yes, no]
        "muted": "no", # str [yes, no]
        "cssClasses": "", # str 
    }
)
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/content/CoreVideoPlayer.vue" target="_blank">Explore this component's source code on GitHub</a>


# Webcam Capture
Source: https://dev.writer.com/components/webcamcapture



A user input component that allows users to capture images using their webcam.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/components/webcamcapture.png" />

## Fields

<table className="componentFields">
  <thead>
    <th>Name</th>
    <th>Type</th>
    <th class="desc">Description</th>
    <th>Options</th>
  </thead>

  <tbody>
    <tr>
      <td>Refresh rate (ms)</td>
      <td>Number</td>
      <td>Set to 0 for manual capture.</td>

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button text</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Button shadow</td>
      <td>Shadow</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Separator</td>
      <td>Color</td>

      <td />

      <td>
        <ol />
      </td>
    </tr>

    <tr>
      <td>Custom CSS classes</td>
      <td>Text</td>
      <td>CSS classes, separated by spaces. You can define classes in custom stylesheets.</td>

      <td>
        <ol />
      </td>
    </tr>
  </tbody>
</table>

## Events

<AccordionGroup>
  <Accordion title="wf-webcam" icon="code">
    Sent when a frame is captured. Its payload contains the captured frame in PNG format.

    ```python
    def webcam_handler(payload):

    # This handler will save the captured images based on timestamp

    import time
    timestamp = time.time()

    # The payload is a file-like object which contains the captured image
    # in PNG format

    image_file = payload
    with open(f"capture-{timestamp}.png", "wb") as file_handle:
    	file_handle.write(image_file)
    ```
  </Accordion>
</AccordionGroup>

## Low code usage

This component can be declared directly in Python, using [backend-driven UI](/framework/backend-driven-ui).

```python
ui.WebcamCapture(content={
        "refreshRate": 0.0, # Union[float, str] 
        "buttonColor": "", # str 
        "buttonTextColor": "", # str 
        "buttonShadow": "", # str 
        "separatorColor": "", # str 
        "cssClasses": "", # str 
    },
    handlers={
        "wf-webcam": handle_event,
    }
)
```

A function, in this example `handle_event`, should be implemented in your code to handle events.

```python
def handle_event(state, payload, context, ui):
  pass
```

## Reference

* <a href="https://github.com/writer/writer-framework/blob/dev/src/ui/src/components/core/other/CoreWebcamCapture.vue" target="_blank">Explore this component's source code on GitHub</a>


# Writer AI module
Source: https://dev.writer.com/framework/ai-module



This module leverages the [Writer Python SDK](https://pypi.org/project/writer-sdk/) to enable applications to interact with large language models (LLMs) in chat or text completion formats. It provides tools to manage conversation states and to dynamically interact with LLMs using both synchronous and asynchronous methods.

## Getting your API key

To utilize the Writer AI module, you'll need to configure the `WRITER_API_KEY` environment variable with an API key obtained from AI Studio. Here is a detailed [guide](/api-guides/quickstart) to setup up this key. You will need to select an **API** app under **Developer tools**

Once you have your API key, set it as an environment variable on your system:

<CodeGroup>
  ```bash For macOS and Linux
  export WRITER_API_KEY=your_api_key_here
  ```

  ```bash For Windows
  set WRITER_API_KEY=your_api_key_here
  ```
</CodeGroup>

You can manage your environment variables using methods that best suit your setup, such as employing tools like [python-dotenv](https://pypi.org/project/python-dotenv/).

## Chat completion with the Conversation class

The `Conversation` class manages LLM communications within a chat framework, storing the conversation history and handling the interactions.

```python
import writer as wf
import writer.ai

def handle_simple_message(state, payload):
    # Update the conversation state by appending the incoming user message.
    state["conversation"] += payload
    
    # Stream the complete response from the AI model in chunks.
    for chunk in state["conversation"].stream_complete():
        # Append each chunk of the model's response to the ongoing conversation state.
        state["conversation"] += chunk

# Initialize the application state with a new Conversation object.
initial_state = wf.init_state({
    "conversation": writer.ai.Conversation(),
})
```

### Initializing a conversation

A `Conversation` can be initialized with either a system prompt or a list of previous messages. It can also accept a default configuration dictionary that sets parameters for all interactions.

```python
# Initialize with a system prompt for a Financial Analyst specializing in balance sheets
conversation = Conversation("You assist clients with analyzing and understanding their balance sheets")

# Initialize with a history of messages related to balance sheet queries
history = [
    {"role": "user", "content": "Can you explain the liabilities section?"},
    {"role": "assistant", "content": "Certainly! Liabilities are legally binding obligations payable to another entity."}
]

conversation = Conversation(history)

# Initialize with a configuration suitable for financial analysis discussions
config = {'max_tokens': 200, 'temperature': 0.5}
conversation = Conversation("You provide detailed insights into balance sheet components", config=config)
```

### Adding messages to conversation

Messages can be added to a `Conversation` instance using the `+` operator or the `add` method.

```python
# Using the `+` operator to add a balance sheet-related query
conversation += {"role": "user", "content": "Can you break down the assets section of the balance sheet?"}

# Using the `add` method to add a balance sheet-related query
conversation.add(role="user", content="How should I interpret the equity section?")
```

### Completing and streaming Conversations

The `complete` and `stream_complete` methods facilitate interaction with the LLM based on the accumulated messages and configuration. These methods execute calls to generate responses and return them in the form of a message object, but do not alter the conversation's `messages` list, allowing you to validate or modify the output before deciding to add it to the history.

<CodeGroup>
  ```python complete
  # Using `complete` to get a single response
  response = conversation.complete()
  print("LLM Response:", response)
  ```

  ```python stream_complete
  # Using `stream_complete` to get streamed responses
  for chunk in conversation.stream_complete():
      print("Streamed Message:", chunk)
      # Manually adding to the conversation
      conversation += chunk
  ```
</CodeGroup>

Instance-wide configuration parameters can be complemented or overriden on individual call's level, if a `config` dictionary is provided to the method:

```python
# Overriding configuration for a specific call
response = conversation.complete(config={'max_tokens': 200, 'temperature': 0.5})
```

### Using Graphs with Conversation

A `Graph` is a collection of files meant to provide their contents to the LLM during conversations. Framework allows you to create, retrieve, update, and delete graphs, as well as manage the files within them.

#### Creating and Managing Graphs

To create and manipulate graphs, use the following methods:

```python
from writer.ai import create_graph, retrieve_graph, list_graphs, delete_graph

# Create a new graph
graph = create_graph(name="Financial Data", description="Quarterly reports")

# Retrieve an existing graph by ID
graph = retrieve_graph("d90a632b-5c1f-42b8-8748-5b7f769d9a36")

# Update a graph
graph.update(name="Updated Financial Data", description="Updated description")

# Retrieve a list of created graphs
graphs = list_graphs()
for graph in graphs:
    # Delete a graph
    delete_graph(graph)
```

#### Adding and Removing Files from Graphs

You can upload files, associate them with graphs, and download or remove them.

```python
from writer.ai import upload_file

# Upload a file
file = upload_file(data=b"file content", type="application/pdf", name="Report.pdf")

# Add the file to a graph
graph.add_file(file)

# Remove the file from the graph
graph.remove_file(file)
```

#### Applying Graphs to Conversation completion

You can utilize graphs within conversations. For instance, you may want to provide the LLM access to a collection of files during an ongoing conversation to query or analyze the file content. When passing a graph to the conversation, the LLM can query the graph to retrieve relevant data.

```python
# Retrieve a graph
graph = retrieve_graph("d90a632b-5c1f-42b8-8748-5b7f769d9a36")

# Pass the graph to the conversation for completion
response = conversation.complete(tools=graph)
```

Alternatively, you can define a graph using JSON:

```python
tool = {
    "type": "graph",
    "graph_ids": ["d90a632b-5c1f-42b8-8748-5b7f769d9a36"]
}

response = conversation.complete(tools=tool)
```

### Using Function Calls with Conversations

<Warning>
  Function tools are only available with `palmyra-x-004` model
</Warning>

Framework allows you to register Python functions that can be called automatically during conversations. When the LLM determines a need for specific information or processing, it issues a request to use the local code (your function), and Framework handles that request automatically.

#### Defining Function Tools

Function tools are defined using either a Python class or a JSON configuration.

```python
from writer.ai import create_function_tool

# Define a function tool with Python callable
def calculate_interest(principal: float, rate: float, time: float):
    return principal * rate * time

tool = create_function_tool(
    name="calculate_interest",
    callable=calculate_interest,
    parameters={
        "principal": {"type": "float", "description": "Loan principal"},
        "rate": {"type": "float", "description": "Interest rate"},
        "time": {"type": "float", "description": "Time in years"}
    }
)

response = conversation.complete(tools=tool)
```

Alternatively, you can define a function tool in JSON format, but the callable function must still be passed:

```python
tool = {
    "type": "function",
    "name": "calculate_interest",
    "callable": calculate_interest,
    "parameters": {
        "principal": {"type": "float", "description": "Loan principal"},
        "rate": {"type": "float", "description": "Interest rate"},
        "time": {"type": "float", "description": "Time in years"}
    }
}

response = conversation.complete(tools=tool)
```

Function tools require the following properties:

* **`name: str`**: A string that defines how the function is referenced by the LLM. It should describe the functionâ€™s purpose.
* **`callable: Callable`**: A Python function that will be called automatically when needed by the LLM.
* **`parameters: dict`**: A dictionary that specifies what input the function expects. The keys should match the functionâ€™s parameter names, and each parameter should have a `type`, and an optional `description`.\
  Supported types are: `string`, `number`, `integer`, `float`, `boolean`, `array`, `object` and `null`.

#### Automated Function Calling

When a conversation involves a tool (either a graph or a function), Framework automatically handles the requests from LLM to use the tools during interactions. If the tool needs multiple steps (for example, querying data and processing it), Framework will handle those steps recursively, calling functions as needed until the final result is returned.

By default, to prevent endless recursion, Framework will only handle 5 consecutive tool calls. You can expand it in case it doesn't suit your case â€“ both `complete()` and `stream_complete()` accept a `max_tool_depth` parameter, which configures the maximum allowed recursion depth:

```python
response = conversation.complete(tools=tool, max_tool_depth=7)
```

### Providing a Tool or a List of Tools

You can pass either a single tool or a list of tools to the `complete()` or `stream_complete()` methods. The tools can be a combination of FunctionTool, Graph, or JSON-defined tools.

```python
from writer.ai import create_function_tool, retrieve_graph

# Define a function tool
tool1 = create_function_tool(
    name="get_data",
    callable=lambda x: f"Data for {x}",
    parameters={"x": {"type": "string", "description": "Input value"}}
)

# Retrieve a graph
graph = retrieve_graph("d90a632b-5c1f-42b8-8748-5b7f769d9a36")

# Provide both tools in a list
response = conversation.complete(tools=[tool1, graph])
```

## Text generation without a conversation state

### Text generation against a string prompt

`complete` and `stream_complete` methods are designed for one-off text generation without the need to manage a conversation state. They return the model's response as a string. Each function accepts a `config` dictionary allowing call-specific configurations.

<CodeGroup>
  ```python complete
  # Using `complete` for a single completion
  text_response = complete("Explore the benefits of AI.", config={'temperature': 0.3})
  print("Completion:", text_response)
  ```

  ```python stream_complete
  # Using `stream_complete` for streamed text completions
  for text_chunk in stream_complete("Explore the benefits of AI.", config={'temperature': 0.3}):
      print("Streamed Text:", text_chunk)
  ```
</CodeGroup>

### Text generation against graphs

The `ask` and `stream_ask` methods allow you to query one or more graphs to generate responses from the information stored within them.

#### Two approaches to questioning graphs

There are two ways to query graphs, depending on your needs:

1. **Graph-Level Methods** (`Graph.ask`, `Graph.stream_ask`): Used when working with a single graph instance. These methods are tied directly to the Graph object, encapsulating operations within that instance.
2. **Module-Level Methods** (`writer.ai.ask`, `writer.ai.stream_ask`): Designed for querying multiple graphs simultaneously. These methods operate on a broader scale, allowing mixed inputs of graph objects and IDs.

<Note>
  â€¢	Use graph-level methods when working with a single graph instance.
  â€¢	Use module-level methods when querying multiple graphs or when graph IDs are your primary input.
</Note>

#### Parameters

Both methods include:
â€¢ `question: str`: The main query for the LLM.
â€¢ *Optional* `subqueries: bool` (default: `False`): Allows the LLM to generate additional questions during response preparation for more detailed answers. Enabling this might increase response time.

Method-level methods require:
â€¢ `graphs_or_graph_ids: list[Graph | str]`: A list of graphs to use for the question. You can pass `Graph` objects directly into the list, use graph IDs in string form, or a mix of both.

#### Graph-level methods

The graph-level methods, `Graph.ask` and `Graph.stream_ask`, are designed for interacting with a single graph. By calling these methods on a specific `Graph` instance, you can easily pose questions and retrieve answers tailored to that graphâ€™s content.

<CodeGroup>
  ```python ask
  # Retrieve a specific graph
  graph = retrieve_graph("f47ac10b-58cc-4372-a567-0e02b2c3d479")

  # Pose a question to the graph and get a complete response
  response = graph.ask("What are the benefits of renewable energy?")
  print(response)
  ```

  ```python stream_ask
  # Retrieve a specific graph
  graph = retrieve_graph("f47ac10b-58cc-4372-a567-0e02b2c3d479")

  # Pose a question and stream the response in chunks
  for chunk in graph.stream_ask("Explain the history of solar energy."):
      print(chunk)
  ```
</CodeGroup>

#### Module-level methods

The module-level methods, `writer.ai.ask` and `writer.ai.stream_ask`, are designed for querying multiple graphs simultaneously. They are useful when you need to aggregate or compare data across multiple graphs.

<CodeGroup>
  ```python ask
  from writer.ai import ask

  # Pose a question to multiple graphs
  response = ask(
      question="What are the latest advancements in AI?",
      graphs_or_graph_ids=[
          "550e8400-e29b-41d4-a716-446655440000",
          "123e4567-e89b-12d3-a456-426614174000"
          ]
  )
  print(response)
  ```

  ```python stream_ask
  from writer.ai import stream_ask

  # Stream responses from multiple graphs
  for chunk in stream_ask(
      question="Describe the key features of renewable energy sources.",
      graphs_or_graph_ids=[
          "550e8400-e29b-41d4-a716-446655440000",
          "123e4567-e89b-12d3-a456-426614174000"
          ]
  ):
      print(chunk)
  ```
</CodeGroup>

## Using the `Tools` class

<Note>
  This document outlines the use of `Tools` in the Writer Framework; for more thorough documentation, check out (this guide)\[[https://dev.writer.com/api-guides/tools](https://dev.writer.com/api-guides/tools)].
</Note>

The `writer.ai.tools` instance provides access to Writer SDK `tools` resources, such as text splitting, medical content comprehension, and PDF parsing. Below is a guide on how to use each method.

### Splitting Content

The `split` method divides text into chunks based on a selected strategy.

```python
from writer.ai import tools

content = \
    """
    This is a long piece of text that needs to be split into smaller parts.
    Lorem ipsum dolor sit amet...
    """
chunks = tools.split(content, strategy="llm_split")
print(chunks)
```

**Parameters**:

* `content` (str): The text to be split.
* `strategy` (str): The splitting strategy (`llm_split`, `fast_split`, or `hybrid_split`).

**Returns**:
A list of text chunks.

### Medical Content Comprehension

The `comprehend_medical` method processes medical text and extracts relevant entities based on a specified response type.

```python
from writer.ai import tools

medical_text = "Patient shows symptoms of hypertension and diabetes."
entities = tools.comprehend_medical(medical_text, response_type="Entities")
print(entities)
```

**Parameters**:

* `content` (str): The medical text to process.
* `response_type` (str): The type of medical response (`Entities`, `RxNorm`, `ICD-10-CM`, or `SNOMED CT`).

**Returns**:
A list of extracted medical entities.

### PDF Parsing

The `parse_pdf` method extracts text content from a PDF file. The file can be referenced by its ID, or provided as a `File` object.

<CodeGroup>
  ```python file_id
  from writer.ai import tools

  file_id = "example-file-id"
  parsed_content = tools.parse_pdf(file_id, format="text")
  print(parsed_content)
  ```

  ```python upload_file
  from writer.ai import tools

  file_object = upload_file(
      data=pdf_content,
      type="application/pdf",
      name="uploaded_file.pdf"
  )
  parsed_content = tools.parse_pdf(file_object, format="text")
  print(parsed_content)
  ```
</CodeGroup>

**Parameters**:

* `file_id_or_file` (str or File): The file to parse (by ID or as an object).
* `format` (str): The format of the extracted content (`text` or `markdown`).

**Returns**:
The text content of the PDF.


# Application state
Source: https://dev.writer.com/framework/application-state



Each session is assigned a unique application state by the Framework.

## Initializing state

To set the initial application state, use the `wf.init_state()` method with a dictionary argument.

<Tip>
  All user sessions will start with a clone of this initial state.
</Tip>

```py
import writer as wf

# Define the initial state
initial_state = wf.init_state({
    "counter": 0,
})

# Define an event handler that modifies the state
# It receives the session state as an argument and mutates it
def increment(state):
    state["counter"] += 1
```

In the above example, each session begins with a `counter` at 0. As users interact with the application and activate event handlers, their session's `counter` value will change. For instance, if a user triggers the `increment` handler three times, their counter will increase to 3.

To access the `counter` value in the Builder, use @{counter}.

### Managing nested state elements

To include nested elements in your state, use nested dictionaries:

```python
# Example of nested state initialization
wf.init_state({
    "counter": 0,
    "my_app": {
        "title": "Nested value"
    }
})
```

You can reference nested elements in the Builder as `@{my_app.title}`.

### Backend-only state elements

By default, all of the elements in the session state are sent to the front-end.

<Warning>
  All state elements are transmitted to the front-end by default, regardless of their visibility in the user interface.
</Warning>

To keep certain state elements private (back-end-only), prefix them with an underscore `_`. This is useful in several scenarios:

1. When data synchronization to the front-end is unnecessary.
2. When data cannot be serialized for the front-end, such as database connections.
3. When data is sensitive to the specific session and should remain confidential.

These elements remain in the back-end and cannot be accessed from the Builder.

## Managing files and binary data

In components where the Builder interfaces with external data, such as images, it often requires the use of data URLs. The source for an *Image* component, for example, can be a standard URL or a data URL.

Packing Files and Binary Data: Files and binary data can be converted to data URLs before they are sent to the front-end. Use `wf.pack_file()` and `wf.pack_bytes()` for this purpose. The `mime_type` argument, while optional, specifies the media type, helping the browser to correctly handle the data.

```python
import writer as wf

# Initialize state with various data types
wf.init_state({
    # Reference a file by its filesystem path
    "sales_spreadsheet": wf.pack_file("sales_spreadsheet.xlsx"),

    # Use a file-like object that implements a .read() method
    "main_image": wf.pack_file(image_file, mime_type="image/jpeg"),

    # Convert raw bytes specifying a MIME type
    "my_bytes": wf.pack_bytes(b"\x31\x33\x33\x37", mime_type="text/plain"),

    # Directly assign raw bytes without a MIME type
    "my_raw_bytes": b"\x31\x33\x33\x37",
})
```

## Handling non-standard data types

The front-end cannot directly display complex data types such as Pandas dataframes or Matplotlib figures. Such objects must be serialized before being sent.

<Tabs>
  <Tab title="Matplotlib figures">
    Matplotlib figures are converted to PNG data URLs, which can be shown using a standard *Image* component.

    ```python
    wf.init_state({
        "my_matplotlib_fig": fig,
    })
    ```

    The element can be used in an *Image* component in the Builder by setting the source to `@{my_matplotlib_fig}`. Alternatively, as data inside a *File Download* component.
  </Tab>

  <Tab title="Plotly graphs">
    Plotly graphs are converted to Plotly JS specifications, using JSON. They can be used in *Plotly Graph* components.
  </Tab>

  <Tab title="Altair charts">
    Altair charts are converted to Vega Lite specifications, based on JSON. They can be used in *Vega Lite Chart* components.
  </Tab>

  <Tab title="Pandas dataframes">
    Pandas dataframes are converted to JSON and can be used in *Dataframe* components.
  </Tab>
</Tabs>

## State schema

State schema is a feature that allows you to define the structure of the state.
This is useful for ensuring that the state is always in the expected format.

Schema allows you to use features like

* typing checking with mypy / ruff
* autocomplete in IDEs
* declare dictionaries
* automatically calculate mutations on properties

more into [Advanced > State schema](./state-schema)

```python
import writer as wf

class AppSchema(wf.WriterState):
    counter: int

initial_state = wf.init_state({
    "counter": 0
}, schema=AppSchema)

# Event handler
# It receives the session state as an argument and mutates it
def increment(state: AppSchema):
    state.counter += 1
```


# Authentication
Source: https://dev.writer.com/framework/authentication



The Writer Framework authentication module allows you to restrict access to your application. Framework will be able to authenticate a user through an identity provider such as Google, Microsoft, Facebook, Github, Auth0, etc.

<Warning>
  Authentication is done before accessing the application. It is not possible to
  trigger authentication for certain pages exclusively.
</Warning>

<Warning>
  Static assets from Writer Framework exposed through `/static` and `/extensions` endpoints are not protected behind Authentication.
</Warning>

## Use Basic Auth

Basic Auth is a simple authentication method that uses a username and password. Authentication configuration is done in the [server\_setup.py module](/framework/custom-server).

<Warning>
  Password authentication and Basic Auth are not sufficiently secure for critical applications. If HTTPS encryption fails, a user could potentially intercept passwords in plaintext. Additionally, these methods are vulnerable to brute force attacks that attempt to crack passwords. To enhance security, it is advisable to implement authentication through trusted identity providers such as Google, Microsoft, Facebook, GitHub, or Auth0.
</Warning>

```python server_setup.py
import os
import writer.serve
import writer.auth

auth = writer.auth.BasicAuth(
    login=os.getenv('LOGIN'),
    password=os.getenv('PASSWORD'),
)

writer.serve.register_auth(auth)
```

### Brute force protection

A simple brute force protection is implemented by default. If a user fails to log in, the IP of this user is blocked.
Writer framework will ban the IP from either the `X-Forwarded-For` header or the `X-Real-IP` header or the client IP address.

When a user fails to log in, they wait 1 second before they can try again. This time can be modified by
modifying the value of `delay_after_failure`.

![429](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/429.png)

## Use OIDC provider

Authentication configuration is done in the `server_setup.py` [module](/framework/custom-server). The configuration depends on your identity provider.
Here is an example configuration for Google.

![Authentication OIDC Principle](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/auth.png)

```python server_setup.py
import os
import writer.serve
import writer.auth

oidc = writer.auth.Oidc(
    client_id="1xxxxxxxxx-qxxxxxxxxxxxxxxx.apps.googleusercontent.com",
    client_secret="GOxxxx-xxxxxxxxxxxxxxxxxxxxx",
    host_url=os.getenv('HOST_URL', "http://localhost:5000"),
    url_authorize="https://accounts.google.com/o/oauth2/auth",
    url_oauthtoken="https://oauth2.googleapis.com/token",
    url_userinfo='https://www.googleapis.com/oauth2/v1/userinfo?alt=json'
)

writer.serve.register_auth(oidc)
```

### Use pre-configured OIDC

The Writer Framework provides pre-configured OIDC providers. You can use them directly in your application.

| Provider | Function             | Description                                                                             |
| -------- | -------------------- | --------------------------------------------------------------------------------------- |
| Google   | `writer.auth.Google` | Allow your users to login with their Google Account                                     |
| Github   | `writer.auth.Github` | Allow your users to login with their Github Account                                     |
| Auth0    | `writer.auth.Auth0`  | Allow your users to login with different providers or with login password through Auth0 |

#### Google

You have to register your application into [Google Cloud Console](https://console.cloud.google.com/).

```python server_setup.py
import os
import writer.serve
import writer.auth

oidc = writer.auth.Google(
	client_id="1xxxxxxxxx-qxxxxxxxxxxxxxxx.apps.googleusercontent.com",
	client_secret="GOxxxx-xxxxxxxxxxxxxxxxxxxxx",
	host_url=os.getenv('HOST_URL', "http://localhost:5000")
)

writer.serve.register_auth(oidc)
```

#### Github

You have to register your application into [Github](https://docs.github.com/en/apps/creating-github-apps/registering-a-github-app/registering-a-github-app#registering-a-github-app)

```python server_setup.py
import os
import writer.serve
import writer.auth

oidc = writer.auth.Github(
	client_id="xxxxxxx",
	client_secret="xxxxxxxxxxxxx",
	host_url=os.getenv('HOST_URL', "http://localhost:5000")
)

writer.serve.register_auth(oidc)
```

#### Auth0

You have to register your application into [Auth0](https://auth0.com/).

```python server_setup.py
import os
import writer.serve
import writer.auth

oidc = writer.auth.Auth0(
	client_id="xxxxxxx",
	client_secret="xxxxxxxxxxxxx",
	domain="xxx-xxxxx.eu.auth0.com",
	host_url=os.getenv('HOST_URL', "http://localhost:5000")
)

writer.serve.register_auth(oidc)
```

### Authentication workflow

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/authentication_oidc.png" />

### App static assets

Static assets in your application are inaccessible. You can use the `app_static_public` parameter to allow their usage.
When `app_static_public` is set to `True`, the static assets in your application are accessible without authentication.

```python
oidc = writer.auth.Auth0(
	client_id="xxxxxxx",
	client_secret="xxxxxxxxxxxxx",
	domain="xxx-xxxxx.eu.auth0.com",
	host_url=os.getenv('HOST_URL', "http://localhost:5000"),
	app_static_public=True
)
```

## User information in event handler

When the `user_info` route is configured, user information will be accessible
in the event handler through the `session` argument.

```python
def on_page_load(state, session):
    email = session['userinfo'].get('email', None)
    state['email'] = email
```

## Unauthorize access

It is possible to reject a user who, for example, does not have the correct email address.

<Tip>
  You can also use userinfo inside app. You can restrict access to certain pages
  inside the application by using the `session` object. See [User information in
  event handler](#user-information-in-event-handler)
</Tip>

```python
from fastapi import Request

import writer.serve
import writer.auth

oidc = ...

def callback(request: Request, session_id: str, userinfo: dict):
    if userinfo['email'] not in ['nom.prenom123@example.com']:
        raise writer.auth.Unauthorized(more_info="You can contact the administrator at <a href='https://support.example.com'>support.example.com</a>")

writer.serve.register_auth(oidc, callback=callback)
```

The default authentication error page look like this:

<img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/auth_unauthorized_default.png" />

| Parameter    | Description            |
| ------------ | ---------------------- |
| status\_code | HTTP status code       |
| message      | Error message          |
| more\_info   | Additional information |

## Modify user info

User info can be modified in the callback.

```python
from fastapi import Request

import writer.serve
import writer.auth

oidc = ...

def callback(request: Request, session_id: str, userinfo: dict):
	userinfo['group'] = []
	if userinfo['email'] in ['fabien@example.com']:
		userinfo['group'].append('admin')
		userinfo['group'].append('user')
	else:
		userinfo['group'].append('user')

writer.serve.register_auth(oidc, callback=callback)
```

## Custom unauthorized page

You can customize the access denial page using your own template.

```python
import os

from fastapi import Request, Response
from fastapi.templating import Jinja2Templates

import writer.serve
import writer.auth

oidc = ...

def unauthorized(request: Request, exc: writer.auth.Unauthorized) -> Response:
    templates = Jinja2Templates(directory=os.path.join(os.path.dirname(__file__), "templates"))
    return templates.TemplateResponse(request=request, name="unauthorized.html", status_code=exc.status_code, context={
        "status_code": exc.status_code,
        "message": exc.message,
        "more_info": exc.more_info
    })

writer.serve.register_auth(oidc, unauthorized_action=unauthorized)
```

## Enable in edit mode

Authentication is disabled in edit mode. To activate it, you must trigger the loading of the server\_setup module in edition mode.

```bash
writer edit --enable-server-setup
```


# Backend-driven UI
Source: https://dev.writer.com/framework/backend-driven-ui



Framework facilitates backend-initiated user interface modifications. These changes are made possible through **Code-Managed Components** (CMCs), distinct from the *Builder-Managed Components* (BMCs).

CMCs, unlike BMCs, are dynamically created and modified via back-end code, and cannot be edited (but still can be viewed) within the application builder. It's important to also note that CMCs do not persist in your application's files and exist only during the application runtime, supporting dynamic UI adjustments.

<Note>
  To summarise:

  **CMC** â€“ Code-Managed Component

  * created via **application back-end**;
  * **cannot be edited** in builder;
  * is **not saved** to `.wf/components-*.jsonl`.

  **BMC** â€“ Builder-Managed Component

  * created via **builder**;
  * **can be edited** in builder;
  * is **saved** to `.wf/components-*.jsonl`.
</Note>

## UI manager

Framework provides two independent approaches for managing your application's UI: initializing a base UI and making session-specific updates.

### Initializing base UI

The `init_ui()` method sets up a UI manager to configure UI components at the application's startup. This creates a component set that is accessible across all sessions:

```python
import writer as wf

with wf.init_ui() as ui:
    with ui.Page(id="my-page"):
        ui.Header({"text": "Hello World!"})
        ui.ColumnContainer(id="column-container")
```

### Making session-specific updates

For dynamic, session-specific UI updates, the `ui` parameter is used within handler functions. This approach allows for real-time modifications tailored to individual user sessions:

```python
def display_user_data(ui, state):
    with ui.find("column-container"):
        with ui.Column():
            ui.Text({"text": f"And welcome {state["username"]}!"})
        with ui.Column():
            ui.Text({"text": f"Your data: {state["user_data"]}"})
```

## UI manager methods

### `find` method

You can use the `ui.find(component_id: str)` method to access existing components by ID:

```python
with ui.find("column-container"):
    with ui.Column():
        ...
```

If the component couldn't be found, the method raises a `RuntimeError`.

### `refresh_with` method

You can use the `ui.refresh_with(component_id: str)` method to replace children CMCs of an existing component (referenced by its ID):

```python
with ui.refresh_with("my-page"):
    # Previously existing children are cleared
    ui.Header({"text": "Hello New World!"})
    with ui.ColumnContainer():
        with ui.Column():
            ui.Text({"text": "Nobody here for now..."})
```

This method also allows to clear children CMCs of a component:

```python
with ui.refresh_with("my-page"):
    # Empties the page
    pass
```

If a targeted component has builder-managed children, they will not be removed. A warning message will be recorded in the application's log for each BMC attempted to be removed. This does not stop the execution of the method â€“ any remaining CMCs will still be removed.
As well as with `find` method, it also raises a `RuntimeError` if it fails to find a referenced component.

### `parent` method

`ui.parent(component_id: str, level: int = 1)` gives access to the id to parents at higher levels.

```python
container = ui.parent('my-text') # first parent id

container = ui.parent('my-text', 3) # level 3 parent id
with ui.find(container):
	...
```

### Component methods

UI manager contains methods linked to each front-end component. For example, in previous code snippets we provide a `ui.Text` method, which is used for creating [Text components](https://dev.writer.com/components/text).

This method expects `content: dict` as first argument, which enables you to set the field properties of the component, through corresponding keys:

```python
ui.Text(
    {
        "text": "Hello World!",  
        # The text content of the component
        "useMarkdown": "no",  
        # Will not use Markdown
        "alignment": "left",  
        # Text is aligned to the left
        "primaryTextColor": "#000000",  
        # The text color is black
        "cssClasses": "my-text hello-world"  
        # Apply 'my-text' and 'hello-world' CSS classes
    }
)
```

In a similar way, every other component method also expects `content` as its first argument:

```python
ui.VideoPlayer(
    {
        "src": "https://example.com/assets/mov/rick-roll-video.mov",
        "autoplay": "yes",
        "controls": "no",
        "muted": "no",
        "loop": "no",
    }
)
```

In addition to `content`, a set of fields which is specific to the component type, you can also modify the base properties of the component itself, which are:

* **`id: str`**: A unique identifier used for accessing the component after it was created.\
  *Providing an identifier that is already taken would result in `RuntimeWarning` and the existing component being overwritten with a newly created one.*
  ```python
  ui.Text(
      {"text": "Hello World!"}, 
      id="hello-world-text"
      )
  ```
  *If no ID is provided with a component, a UUID is automatically generated for it.*
  <Note>
    Make sure to provide an `id` if you intend to `find` the component later\
    As the `find` method relies on `id` of the component, retrieval might get tricky if its `id` was generated randomly.
  </Note>
* **`position: int`**: Determines the display order of the component in relation to its siblings.\
  Position `0` means that the component is the first child of its parent.\
  Position `-2` is used for components â€“ such as [sidebars](https://dev.writer.com/components/sidebar) â€“ that have a specific reserved position not related to their siblings.
  ```python
  ui.Text(
      {"text": "Hello Parent, I'm your first child!"}, 
      position=0
      )
  ```
  *Position is calculated automatically for each component, and you should be careful when you override it with predefined value, as this might lead to unexpected results.*
* **`parentId: str`**: Determines the parent [container](#container-components) for the component. By default, components recognise the container in the context of which they were defined as their parent. This allows for linking components to their parents outside of context, or for overriding a parent within a context.
  ```python
  ui.Text(
      {"text": "Hello Parent, I'm your child too!"}, 
      parentId="dear-parent"
      )
  ```
* **`visible: bool | str`**: Determines the visibility of the component, `True` by default.
  ```python
  ui.Text({"text": "I'm visible!"}, visible=True)

  ui.Text({"text": "And I'm not!"}, visible=False)

  ui.Text({"text": "My visibility depends on the @{my_var}!"}, visible="my_var")
  ```
* **`handlers: dict[str, callable]`**: Attaches [event handlers](https://dev.writer.com/framework/event-handlers) to the component. Each dictionary key represents an event, and its value is the corresponding handler.:
  ```python
  def increment(state):
      state["counter"] += 1

  initial_state = wf.init_state({"counter": 0})

  ...

  ui.Button(
      {"text": "My Counter: @{counter}"}, 
      handlers={"wf-click": increment}
      )
  # You have two options for adding a function 
  # to the `handlers` dictionary: 
  # directly pass the function itself, 
  # or use the function's name as a string. 
  # Both approaches yield the same outcome.
  ```
  *A component can be linked to multiple event handlers.*
* **`binding: dict[str, str]`**: Links the component to a state variable via [binding](https://dev.writer.com/framework/builder-basics#binding). The dictionary key is the bindable event, and the value is the state variable's name:
  ```python
  initial_state = wf.init_state({
      "header_text": "Default Text"
      "counter": 0
      })

  ...

  ui.TextInput(
      {"label": "Bound Text"}, 
      binding={"wf-change": "header_text"}
      )
  # This input will display "Default Text"
  # Changing the text in this input will modify the `header_text` variable

  ui.SliderInput(
      {"minValue": 0, "maxValue": 300, "stepSize": 1}, 
      binding={"wf-number-change": "counter"}
      )
  # This slider will have 0 as a default value
  # Sliding it will modify the `counter` variable
  ```
  *Unlike handlers, a component can be linked to just one variable via a bindable event. If the `binding` dictionary includes multiple event-variable pairs, a `RuntimeError` will be triggered.*

### Container components

Framework provides multiple layout components that can serve as *containers* for other components.

You can use `with` keyword to define such layouts:

```python
with ui.Section({"title": "My Section"}):
    ui.Text({"text": 'Hello World!'}, id="hello-world")
```

It also allows for "chaining" multiple containers together, creating extensive and deeply-nested layout structures when needed:

```python
with ui.ColumnContainer(id="cmc-column-container"):
    with ui.Column(id="cmc-column-1"):
        with ui.Section({"title": "My Section 1"}):
            ui.Text({"text": 'Hello World!'}, id="hello-world-1")
    with ui.Column(id="cmc-column-2"):
        with ui.Section({"title": "My Section 2"}):
            ui.Text({"text": 'Hello World again!'}, id="hello-world-2")
```

<Warning>
  Most components depend on being inside of a container. This means, for example, that Text components in code above cannot be created as "orphans", outside a Column or Section. Attempting to do so would raise an `UIError`.
</Warning>

By default, components inside container's `with` are being *appended* to it:

```python
with ui.Column(id="cmc-column-1"):
    ui.Text({"text": 'Hello World!'}, id="hello-world-1")

...

# Retrieves the Column component created before
with ui.find(id="cmc-column-1"): 
    # The following component is going to be appended 
    # to the retrieved Column
    ui.Text({"text": 'Hello World again!'}, id="hello-world-2")
```

This will result in a Column component having two children Text components. To replace or clear the children, use [`refresh_with` method](#refresh_with-method):

```python
with ui.Column(id="cmc-column-1"):
    ui.Text({"text": 'Hello World!'}, id="hello-world-1")

...

with ui.refresh_with(id="cmc-column-1"):
    # The following component is going to replace 
    # previously existing children of the retrieved Column
    ui.Text(
        {"text": 'To Hello World, or not to Hello World?'}, 
        id="hello-world-new"
        )
```


# Backend-initiated actions
Source: https://dev.writer.com/framework/backend-initiated-actions



Targeted, backend-initiated actions can be triggered from event handlers, using methods of `state`. Internally, this is achieved using Framework's `mail`, ephemeral state that is cleared when it reaches the intended user.

## Triggering a file download

The `file_download` method takes the `data` and `file_name` arguments. The first must contain raw bytes (a `bytes` object) or a packed file. As mentioned in the [Application State](/framework/application-state#managing-files-and-binary-data) section of the guide, a packed file is obtained using the `wf.pack_file` or `wf.pack_bytes` methods.

```py
def handle_file_download(state):
    # Pack the file as a FileWrapper object
    data = wf.pack_file("assets/story.txt", "text/plain")
    file_name = "thestory.txt"
    state.file_download(data, file_name)
```

## Adding a notification

![Notifications](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/backend-initiated-actions.notifications.png)

Framework adds notifications when a runtime error takes place. You can add your own notifications using the `add_notification` method, which takes the `type`, `title` and `message` arguments. `type` must be one of `error`, `warning`, `info`, `success`.

```py
def notify_of_things_that_happened(state):
    state.add_notification("error", "An Error", "Something bad happened.")
    state.add_notification("warning", "A Warning", "Be aware that something happened.")
    state.add_notification("info", "Some Info", "Something happened.")
    state.add_notification("success", "A Success", "Something good happened.")
```

## Opening a URL

Open a URL in a new tab using the `open_url` method, which takes the `url` argument.

```py
def handle_open_website(state):
    state.open_url("https://writer.com")
```

The URL will be safely opened with `noopener` and `noreferrer` options.

<Warning>
  Popup blockers: Given that the URL is opened asynchronously, popup blockers will likely block the new window â€”unless the user has opted in.
</Warning>

## Changing the active page

The active page and route parameters can be changed using the methods `set_page` and `set_route_vars`. This is explained in more detail in [Page Routes](/framework/page-routes).


# Builder basics
Source: https://dev.writer.com/framework/builder-basics



Writer Framework Builderâ€™s interface is an overlay on top of the running app, which allows you to edit your app while itâ€™s running. This approach gives you an accurate representation of how the app will look and behave without the need to constantly preview it.

## Writer Framework Builderâ€™s modes

Writer Framework Builder has two modes:

1. **UI mode:** This is the default mode, which provides an overlay of tools for building and editing the user interface. The app still runs in UI mode, allowing to you test its functionality while youâ€™re building it. You can also edit the appâ€™s code and view its log.

![Writer Framework Builder in UI mode](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.ui-mode.png)

2. **Preview mode:** This mode lets you preview the application, experiencing it almost as your end users would. The tool overlay is hidden, but you can still edit the appâ€™s code and view its log in this mode.

![Writer Framework Builder in Preview mode](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.preview-mode.png)

You can switch between UI mode and Preview mode by using the **UI**/**Preview** selector near the upper left corner of the page.

![Writer Framework Builderâ€™s UI/Preview selector](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.ui-preview-selector.png)

## Building your app in UI mode

### The different areas of UI mode

In UI mode, Writer Framework Builderâ€™s page is divided into these areas:

![Writer Framework Builder in UI mode, with indivdual areas labeled](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.ui-mode-with-labels.png)

1. **Canvas:** This is where you lay out components to build your appâ€™s user interface. It displays the UI as your users will see it.
2. **Core toolkit:** A â€œpaletteâ€ of UI components that can be added to your appâ€™s user interface. To add a component to your appâ€™s UI, drag it onto the Canvas or into the Component tree.
3. **Component tree:** This provides an alternative way to view your appâ€™s user interface: as a hierarchical tree structure. Itâ€™s useful for ensuring that UI components are located in the right place or in the correct container object, and is handy for selecting UI components in complex layouts.
4. **Component settings:** This panel lets you view and edit the settings for the currently selected UI component. You can hide the Component settings panel if you need more screen space to work on the Canvas.
5. **Top bar:** Contains the â€œhigh levelâ€ editing controls: switching between UI and Preview mode, undoing and redoing the most recent change to the UI, and viewing the applicationâ€™s state.
6. **Bottom bar:** Contains the â€œlow levelâ€ editing controls, which toggle the Code and Log panels.

### Defining your appâ€™s user interface

Writer Framework Builder provides a selection of over 50 UI components that you can use to build your appâ€™s user interface:

![Visual catalog of all the components in the Core toolkit](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.components.png)

You define your appâ€™s user interface by dragging components from the Core toolkit and dropping them either onto the Canvas or into the Component tree (remember, the Canvas and Component tree provide different ways to look at your appâ€™s user interface). If you simply drag and drop a UI component onto an empty spot on the Canvas, it will be placed at the â€œend,â€ below all other UI components in the user interface. To place a UI component at a specific location, drag them over the desired location or parent component until you see the insertion lines.

![Writer Framework Builder with diagram showing how to drag and drop components from Core toolkit](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.drag-drop-components.png)

It can sometimes be difficult to find the component youâ€™re looking for, so the Core toolkit has a search field. You can use it to find the narrow down the list of components or find a specific one.

![Close-up of Core toolkit with instructions for using its Search text field](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.component-search.png)

Some UI components, such as Section, can act as â€œparents,â€ which are UI components that can contain other UI components. Others, such as Text, cannot. Additionally, certain components have placement restrictions â€” for instance, a Column must be added to a Column Container, and a Sidebar can only be added to a Page.

![Writer Framework builder, showing parent-child relationship between a Section and the Text Input and Button components it contains](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.parent-components.png)

The Component tree provides a hierarchical view of your appâ€™s user interface. It shows the top-down layout of UI components in your app, as well as the parent-child relationships between components, making it easier to understand your appâ€™s structure and ensure that components are correctly nested.

You will find the Component tree useful when trying to reorganize the order of components in the UI, especially those located inside a parent UI component. For more flexibility and finer control, you can use the Component tree as a source or a destination for your drag and drop actions.

### Discovering components

The Builder is designed to allow easy discoverability of components. Rather than scouring specifications every time you need to use a component, you can rely on the visual editor to guide you.

1. **Short description:** You can hover on the component type to get a tooltip with a short description.
2. **Available properties and events:** Looking at *Settings* will allow you to see which of its properties are configurable.
3. **Built-in docs:** Components have short docs built into them. You can expand it by clicking the help icon in Settings.
4. **Event handler stub code:** Different events need to be handled differently. The built-in stub handlers, which can be found next to each event, can help you get started when writing event handlers.

### Selecting and editing components

To move or edit a component in your UI, you need to select it first. You can do this by clicking on the component either in the Canvas or in the Component tree. The selected component will be highlighted in both the Canvas and Component tree.

![Writer Framework Builder, with instructions to select a component by clicking on it either on the Canvas or in the Component tree](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.select-components.png)

Selecting a UI component will allow you to view and edit its settings in the Component settings panel on the right side of the page.

![Writer Framework Builder, with Component settings panel on display, and instructions to hide the panel](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.component-settings.png)

To hide the Component settings panel to get a better view of the Canvas, click on **Â»** in the button bar. To show the panel, click on **âš™** in the button bar.

![Writer Framework Builder, with Component settings panel hidden, and instructions to show the panel](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.component-settings-show.png)

The settings in the Component settings panel are divided into the following sections:

<AccordionGroup>
  <Accordion title="Basic settings">
    ![Component settings panel, with basic settings highlighted](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.basic-settings.png)

    These settings are divided into two categores:

    1. **General**, which specifies the componentâ€™s content
    2. **Style**, which defines the componentâ€™s appearance.

    Values for these settings can include:

    1. Literals, e.g. `monkey`
    2. References to application state using the template syntax `@{}`, e.g. `@{my_favourite_animal}`.
    3. A combination of both, e.g. `My favourite animal is @{my_favourite_animal}`.
    4. Nested states can be accessed with `.` (dot), e.g. `@{building.height}`.
    5. Nested elements can be dynamically accessed with `[]`, e.g. `@{building[dynamic_prop]}` will be equivalent to `@{building.height}` when `dynamic_prop` equals `height`.

    The values for these settings can be of different types, such as *Text*, *Color* and *Number*. The values are stored as text and are cast to the correct type when evaluated.
  </Accordion>

  <Accordion title="Binding">
    ![Component settings panel, with Binding settings highlighted](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.binding.png)

    Only input components have a **Binding** section, whose settings are used to bind the component to a variable in the applicationâ€™s state. The binding is two-way; if the user changes the componentâ€™s value, the state variable will change to match, and any change the code makes to the bound state variable will also change the componentâ€™s value.

    For example, a *Slider Input* component can be bound to a state variable `my_var`. If the value of the slider changes, so does the value of `my_var`. Similarly, if the value of `my_var` changes, the slider is moved automatically to reflect the change.

    To bind an input component, specify the state element. For example, `my_var` or `building.height`. Note that this field should not contain the template syntax, e.g. `my_var` and not `@{my_var}`.
  </Accordion>

  <Accordion title="Events">
    ![Component settings panel, with Events settings highlighted](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.events.png)

    The **Events** section lists all the events generated by the selected component, with the option of setting event handlers for them. For example, one of the events that the Text Input component generates is the `wf-change` event, which occurs whenever the user changes the contents of the component.

    For more about event handlers, consult the [*Event handlers*](/framework/event-handlers) section of the Writer Framework documentation.
  </Accordion>

  <Accordion title="Visibility">
    ![Component settings panel, with Visibility settings highlighted](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.visibility.png)

    The **Visibility** settings control Whether the component should be displayed. There are three visibility options:

    1. **Yes**: The component is displayed.
    2. **No**: The component is *not* displayed. Note that hidden components are still part of the HTML code but aren't shown.
    3. **Custom**: The componentâ€™s visibility depends on the value of a given state or context element. For example, if set to `my_var`, visibility will depend on the value of the `my_var` state element. Note that this field, similarly to Binding, should only contain the state element, e.g. `my_var` and not `@{my_var}`.
  </Accordion>
</AccordionGroup>

### Component shortcuts

The Component shortcuts bar contains a set of options to perform various operations that are often performed on components.

![Component settings panel, with Component shortcuts bar highlighted](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.component-shortcuts.png)

Options will be grayed out when they're not applicable to the relevant component. Most shortcuts can also be activated using the keyboard; hover the cursor over a shortcut to see its keyboard shortcut.

The shortcuts are:

![The Component shortcuts bar, with labels](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.component-shortcuts-guide.png)

* **Add**: Adds a child of a specified type to the selected component.
* **Move up**: Decrements the position index of the selected component, used to sort children within the parent container.
* **Move down**: Increments the position index of the selected component.
* **Cut**: Cuts the selected component and places it in the clipboard.
* **Copy**: Copies the selected component to the clipboard.
* **Paste**: Pastes the content of the internal clipboard using the selected component as a parent.
* **Go to parent**: Selects the parent of the selected component.
* **Delete**: Deletes the selected component.

### The Code editor and the Log

Writer Framework Builder provides a built-in Code editor for the `main.py` file, which defines the behavior of the app. You can toggle the Code panel by clicking the **Code** control near the lower left corner of the page:

![Writer Framework Builder, with the Code editor displayed](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.code.png)

Any changes made to the code do not take effect until you click the **Save and run** button, located at the upper right corner of the code editor.

The log is a useful debugging tool that displays any messages sent to standard output via the `print()` function, as well as any error messages. You can toggle the Log panel by clicking the **Log** control near the lower right corner of the page:

![Writer Framework Builder, with the Log editor displayed](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.log.png)

Note that both the Code editor and Log panes can be displayed at the same time:

![Writer Framework Builder, with the Code editor and Log displayed at the same time](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.code-and-log.png)

## Testing your app in Preview mode

In Preview mode, the overlays that let you build the user interface â€”Â the Core toolkit, Component tree, and Component settings â€” are invisible and unavailable. You see the app *almost* as your users would see it; the Top bar and Bottom bar, which your users would not see, are still available to you in Preview mode.

![Writer Framework Builder in preview mode](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.preview.png)

You can still use the Code editor and Log in Preview mode:

![Writer Framework Builder in Preview mode, with the Code editor and Log displayed at the same time](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/builder-basics.preview-code-and-log.png)


# Chat assistant
Source: https://dev.writer.com/framework/chat-assistant



In this tutorial, you'll use the Writer Framework to create a simple yet powerful chat assistant that can engage in conversations on various topics, provide answers to your questions, and maybe even help you when you're experiencing writer's block!

The process will take only minutes using a drag-and-drop visual editor to build the user interface and Python for the back-end code.

Here's what the finished project will look like:

![Finished chat assistant project](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_1.png)

## Prerequisites

Before starting, ensure you have:

* **A Writer account:** You don't need an account to use Writer Framework, but you'll need one to use the AI module. [Sign up for a free account here](https://app.writer.com/register).
* **Python 3.9.2 or later**: Use the installer from [python.org](https://www.python.org/downloads/).
* **pip:** This command-line application comes with Python and is used for installing Python packages, including those from Writer.
* **A basic understanding of Python:** You should be familiar with the basics of the language.
* **Your favorite code editor (optional):** There's a code editor built into Writer for editing back-end code, but you can also use Visual Studio Code, Notepad++, Vim, Emacs, or any text editor made for programming if you prefer.

## Setting up your project

### Create a Writer app and get its API key

First, you'll need to create a new app within Writer.

<Steps>
  <Step title="Create the app in Writer">
    Log into Writer. From the Home screen, click on the **Build an app** button.

    ![Writer home screen](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2.png)

    The **Start building** menu will appear, presenting options for the types of apps you can create.

    Select **Framework**, located under **Developer tools**. This will create a brand new app based on Writer Framework.

    !["Start building" menu](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_3.png)
  </Step>

  <Step title="Copy your app's API key">
    On the next screen, titled **How to deploy an application**, you can get the API key for the app by clicking on the **Reveal key** button, located under the text **Authenticate with an API key**. Your complete API key will be displayed, and a "copy"Â button will appear. Click this button to copy the key; you'll use it in the next step.

    !["How to deploy an application" page](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2a.png)
  </Step>
</Steps>

### Set up your computer and create the app's project

The next step is to set up the Writer Framework environment on your computer. You'll do this by creating a directory for the project, installing dependencies, and creating the project for the application using a template.

<Steps>
  <Step title="Open your terminal application">
    Open your terminal application. On macOS and Linux, this application goes by the name *Terminal*; on Windows, you can use either *Windows PowerShell* (which is preferred) or *Command Prompt*.
  </Step>

  <Step title="Install the dependencies">
    <Note>If you already have the `writer` and `python-dotenv` packages installed on your computer, you can skip this step.</Note>

    Install the `writer` and `python-dotenv` packages by entering the following commands in your terminal application:

    ```
    pip install writer python-dotenv
    ```

    This command tells `pip`, the Python package installer, to install two packages:

    * `writer`, which provides some command-line commands and enables Python code to interact with Writer and the Writer Framework.
    * `python-dotenv`, which makes it easy to manage environment variables by loading them from a `.env` file. This one is optional for this exercise, but you might find it useful when working on larger projects.
  </Step>

  <Step title="Set the API key environment variable">
    To pass your API key to the Writer Framework, you need to set an environment variable called `WRITER_API_KEY`.

    Select your operating system and terminal application below, then copy and paste the command into your terminal application, replacing `[your_api_key]` with the API key you copied earlier:

    <CodeGroup>
      ```sh macOS/Linux (Terminal)
      export WRITER_API_KEY=[your_api_key]
      ```

      ```sh On Windows (Windows PowerShell)
      $env:WRITER_API_KEY=[your_api_key]
      ```

      ```sh On Windows (Command Prompt)
      set WRITER_API_KEY=[your_api_key]
      ```
    </CodeGroup>

    The `WRITER_API_KEY` environment variable will remain defined as long your terminal session is open (that is, until you close your terminal applicationâ€™s window).
  </Step>

  <Step title="Create the project">
    Create the project by entering this command into your terminal application:

    ```
    writer create chat-assistant --template=ai-starter
    ```

    This command sets up a new project called `chat-assistant` using a starter template called `ai-starter` so that you're not starting "from scratch."
  </Step>
</Steps>

## Build the UI

Now that you've created the project, it's time to define the UI. The Writer Framework's drag-and-drop capabilities make it easy â€”Â even if you haven't done much UI work before!

The project editor is a web application that runs on your computer and enables you to define and edit your app's user interface. Launch it by typing the following into your terminal application:

```
writer edit chat-assistant
```

You'll see a URL. Control-click it (command-click on macOS) to open it, or copy the URL and paste it into the address bar of a browser window.

The browser window will contain the project editor, which will look like this:

![Project editor](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2b.png)

You'll see the following:

* The **canvas** is in the center. It displays the app's user interface.
* The column on the left contains:
  * The **Core toolkit**, which contains all the UI components. You define the user interface by dragging components from the Toolkit and placing them on the canvas.
  * The **Component tree**, which shows the arrangement of the UI components on the canvas. It's also useful for selecting items on the canvas, especially when it has a lot of UI components.

It's time to build the UI!

<Steps>
  <Step title="Examine the header">
    Select the **Header** component by clicking it â€” it's the component at the top, containing the title **AI STARTER** and a gray area labeled **Empty Header**.

    When you click it, you'll see the **properties** panel appear on the right side of the page. This lets you view and edit the properties of the selected component.

    ![The selected header and its properties panel](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2c.png)

    The first property you'll see in the panel is the **Text** property, which defines the text that appears as the header's title. It should contain the value `@{my_app.title}`. The `@{` and `}` indicate that `my_app.title` is a variable and that its contents should be the text displayed instead of the literal text "my\_app.title". You'll set the value of this variable soon.
  </Step>

  <Step title="Clear the Section's default title">
    Select the **Section** component by clicking it â€” it's just below the **Header** component and contains the title **Section Title** and a gray area labeled **Empty Section**.

    In the **properties** panel, clear out the value of the **Title** property. This will remove the **Section**'s default title.

    ![The selected section and its properties panel](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2d.png)
  </Step>

  <Step title="Add a Text component to the Section">
    Drag a **Text** component from the **Core toolkit** panel on the left (it's under **Content**, and you may need to scroll down a little to find it) and into the *Section*. Sections can act as containers for other components.

    <Note>You can search for a specific component by using the search bar at the top of the **Core toolkit** panel.</Note>

    Select the **Text** component. In the **properties** panel, set the **Text** property to provide instructions or context for your chat assistant. Here's an example: `Welcome to the Chat Assistant. Ask me anything!`

    ![The text component and its properties panel](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2e.png)
  </Step>

  <Step title="Add a Chatbot component to the Section">
    The heart of this app is the **Chatbot** component, a pre-built component that displays the conversation between the LLM and the user and provides a text field where the user can enter prompts.

    Drag a **Chatbot** component from the **Core toolkit** panel (it's under **Content**) into the *Section*, just below the Text box.

    ![The chatbot component](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2f.png)
  </Step>
</Steps>

## Add the back-end code

With the UI laid out, it's time to work on the logic behind it.

The logic behind the user interface is defined in a file named `main.py`, which is in your project's directory. This file was automatically generated; you'll update the code in it to define the behavior of your app.

The simplest way to edit `main.py` is within the project editor. Click on the "toggle code" button (beside the word **Code**) near the lower left corner of the project editor page.

![Project editor with arrow pointing to toggle code button](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2g.png)

A pane with the name **Code** will appear at the bottom half of the screen, displaying an editor for the the contents of `main.py`.

![Project editor with the code editor displayed](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2h.png)

<Note>If you'd rather use a code editor instead of coding in the browser, use it to open the `main.py` file in your project's directory.</Note>

Now follow these steps:

<Steps>
  <Step title="Import libraries and load the Writer Framework API key">
    You should see the following at the start of the file:

    ```python
    import writer as wf
    import writer.ai
    ```

    Replace that code with the following:

    ```python
    import os
    import writer as wf
    import writer.ai

    # Set the API key
    wf.api_key = os.getenv("WRITER_API_KEY")
    ```

    This code imports the libraries that the application will need and then reads your Writer Framework API key in the `WRITER_API_KEY` environment variable.
  </Step>

  <Step title="Create a handler to respond to the user's input">
    The application needs a function to handle incoming chat messages. Find these comments in the code...

    ```python
    # Welcome to Writer Framework! 
    # This template is a starting point for your AI apps.
    # More documentation is available at https://dev.writer.com/framework
    ```

    ...and replace them with the following function:

    ```python
    def generate_completion(state, payload):
      print(f"Here's what the user entered: {payload['content']}")
      state["conversation"] += payload
      print(f"Conversation: {state['conversation'].messages}")
      try:
          for index, chunk in enumerate(state["conversation"].stream_complete()):
              print(f"Chunk {index}: {chunk}")
              if not chunk.get("content"):
                  chunk["content"] = ""
              state["conversation"] += chunk
              
          print(f"state['conversation']:\n{state['conversation'].messages}")
      except Exception as e:
          print(f"Error during stream_complete: {e}")
    ```

    The `generate_completion()` function will be called when the user enters a prompt, which is contained in the `payload` object. The `payload` object is added to the `conversation` object contained in the application's `state`, which adds the user's prompt to the record of the conversation between the user and the LLM.

    After adding the user's prompt to the conversational record, `generate_completion()` calls the `conversation` object's `stream_complete()` method, which generates an LLM completion based on the conversation so far. As its name implies, `stream_complete()` returns the completion as a stream of text chunks, which are captured and added to the `conversation` object.

    <Note>The `conversation` object in the code above is an instance of Writerâ€™s `Conversation` class. You can find out more about this class on our [*Writer AI module*](https://dev.writer.com/framework/ai-module) page.</Note>

    Note that `generate_completion()` completion uses a lot of `print()` functions for debugging purposes, and you can use them to get a better idea of what's happening in the function. You'll see their output in both your terminal application and in the project editor's 'log' pane (which will be covered shortly) as you use the chat assistant. This output will include:

    * The prompt the user entered
    * The chunks of data that make up the LLM's response as they are generated
    * The record of the conversation between the user and the LLM.

    The `print()` functions don't affect the operation of the chat assistant in any way, and you can remove them if you wish.
  </Step>

  <Step title="Initialize the application">
    The final step is to set the application's initial state. Find this code, which should be just after the `generate_completion()` function...

    ```python
    # Initialise the state
    wf.init_state({
        "my_app": {
            "title": "AI STARTER"
        },
    })
    ```

    ...and replace it with this:

    ```python
    # Initialize the state
    wf.init_state({
        "conversation": writer.ai.Conversation(),
        "my_app": {
            "title": "CHAT ASSISTANT"
        },
    })
    ```

    The Writer Framework's `init_state()` method sets the initial value of `state`, a dictionary containing values that define the state of the application. The key-value pairs in `state` are how you store values used by your app and how you pass data between the back-end code and the UI.

    The code above sets the initial value of `state` so that it has two key-value pairs:

    * `conversation`: An object that keeps a record of the conversation that the user is having with the LLM. You'll bind its value to the **Chatbot** component soon.
    * `my_app`: A dictionary containing values that define the application's appearance. This dictionary has a single key-value pair, `title`, which defines the text that appears as the application's title in the **Header**.

    <Note>For more details about the `state` variable, see our [*Application state*](https://dev.writer.com/framework/application-state#application-state) page.</Note>
  </Step>

  <Step title="Save the updated code and hide the code editor">
    Thatâ€™s all the code. If you edited the code in the browser, save it by clicking the â€œsaveâ€ button near the top right corner of the code editor.

    ![Project editor and code editor, with arrow pointing to save button](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2i.png)

    Click the "toggle code" button to hide the code editor.
  </Step>
</Steps>

## Bind the UI to the back-end code

You've built the UI and written the code behind it. Let's connect the two! Go back to the browser window with the project editor and do the following:

<Steps>
  <Step title="Observe that the heading at the top of the app is now 'CHATBOT ASSISTANT'">
    Earlier, you saw that the **Header** component's **Text** property was set to `@{my_app.title}`, a value in the app's `state` variable. You changed this value when you update the call to the Writer Framework's `init_state()` method.
  </Step>

  <Step title="Bind the Chatbot component to the 'state' variable's 'conversation' key">
    Recall that the `conversation` object contained within the `state` variable contains the record of the conversation that the user is having with the LLM. Binding the **Chatbot** component to this object allows it to display the conversation to the user.

    Select the **Chatbot** component. In the **properties** panel, find the **Conversation** property and set its value to `@{conversation}`.

    ![Updating the Chatbot's conversation property](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2j.png)

    The value `@{conversation}` specifies that the **Chatbot** component should get its information from the value corresponding to the `conversation` key in the application's `state` variable.
  </Step>

  <Step title="Specify the Chatbot component's event handler">
    You need to specify that the **Chatbot** component should call the `generate_completion()` function when the user enters a prompt.

    Do this by scrolling down the **properties** panel to the **Events** section until you see a property called **`wf_chatbot_message`**. Select **`generate_completion`** from its menu.

    ![Updating the Chatbot's wf\_chatbot\_message property](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2k.png)
  </Step>
</Steps>

## Test the application

You've completed all the steps to make a working chat assistant, and you can try using it right now, even while editing the user interface!

Try entering some prompts into the text entry at the bottom of the **Chatbot** component. The LLM should respond accordingly:

![The chat assistant, with the project editor in "UI" mode](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2l.png)

To get a better sense of what the experience will be like for the user, switch to the preview by changing the edit mode (located near the upper left corner of the page) from *UI* mode to *Preview* mode by selecting the **Preview** option:

![The project editor with an arrow pointing to the Preview button](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2m.png)

Hereâ€™s what the app looks like in *Preview* mode:

![The chat assistant, with the project editor in "Preview" mode](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2n.png)

You can see the output of any `print()` functions and error messages by clicking on the **Log** button located near the upper right corner of the page:

![The chat assistant with an arrow pointing to the Log button](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2o.png)

Hereâ€™s what the app looks like when displaying the log:

![The working chat assistant, with the log pane displayed](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_2p.png)

It's very helpful to be able to test the application while editing it. As you continue to work with Writer Framework, you'll find yourself alternating between making changes to your application and testing those changes without having to leave the project editor.

## Run the application locally

Once you've tested the application, it's time to run it locally.

Switch back to your terminal application. Stop the project editor with ctrl-c, then run the application by entering the following command:

```
writer run chat-assistant
```

Note that the command starts with `writer run` as opposed to `writer edit`. This launches the application as your users will see it, without any of the editing tools. Even though you can preview your applications in the project editor, it's still a good idea to test it by running it on your computer, outside the project editor, before deploying it.

You'll be able to access the application with your browser at the URL that appears on the command line. It should look like this:

![Finished chat assistant project](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/chat/chat_assistant_1.png)

<Note>The Writer editor, which you launched with `writer edit chat-assistant`, and your application, which you launched with `writer run chat-assistant`, run  on the same URL, but on different *ports* (specified by the number after the `:` character at the end of the URL).</Note>

## Conclusion

That's it â€” you've built a functional chat assistant using the Writer Framework!

Feel free to modify this project! The Writer platform is flexible enough for you to customize, extend, and evolve your application into something completely different! To find out what else you can do, check out the documentation for [Writer Framework](https://dev.writer.com/framework/introduction) and the [Writer API](https://dev.writer.com/api-guides/introduction).


# Custom components
Source: https://dev.writer.com/framework/custom-components



It's possible to extend Framework with custom component templates.

They're developed using Vue 3 and TypeScript. Once transpiled, they can be used by copying them to the `extensions/` folder of any project.

<Note>
  Custom components behave exactly like built-in ones. They are just as
  performant, can contain other components, and offer the same the Builder
  experience. They only differ from built-in components in the way that they're
  bundled and imported.
</Note>

## Architecture

Framework front-end compiles to a collection of static assets that is distributed in the Python package. These static assets are then served via FastAPI.

During initialisation time, the server scans the `extensions/` folder in the project folder and looks for `.css` and `.js` files. This folder is also served, similarly to `static/`. If it finds any valid files in `extensions/`, it shares the list with clients and tells them to dynamically import these files during runtime.

Extensions and custom templates are currently synonyms, but this might change in order to accommodate other extension capabilities.

![Custom Components - Architecture](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/custom-components.architecture.png)

Dependencies are [provided](https://vuejs.org/api/composition-api-dependency-injection.html) using injection symbols and can be *injected* to be used by the component template. These include `evaluatedFields`, which contain the current values of the editable fields. Injected dependencies are fully typed, making development easier.

[Rollup's external feature](https://rollupjs.org/configuration-options/#external), invoked via Vite, allows for extensions to be compiled without dependencies and link those during runtime. Therefore, extensions aren't bundled to be standalone, but rather to work as a piece of a puzzle.

![Custom Components - External](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/custom-components.external.png)

## Anatomy of a template

A template defines how a certain component is rendered. For example, `corebutton` defines how *Button* components are rendered.

Framework component templates are purely front-end. They are Vue 3 templates that extend the Vue specification via a [custom option](https://vuejs.org/api/utility-types.html#componentcustomoptions), `writer`. This custom option defines all the Framework-specific behaviour of the component. For example, its `fields` property establishes which fields will be editable via the Builder.

### Simple example

This example shows a template for *Bubble Message*, a simple demo component with one editable field, `text`.

```js
<template>
	<div class="BubbleMessage">
        <div class="triangle"></div>
        <div class="message">

            <!-- Shows the current value of the field "text" -->

            {{ fields.text.value }}
        </div>
	</div>
</template>

<script lang="ts">
export default {
    writer: {
		name: "Bubble Message",
		description: "Shows a message in the shape of a speech bubble.",
		category: "Content",

        // Fields will be editable via Framework Builder

        fields: {
			text: {
				name: "Text",
				type: FieldType.Text,
			},
		},

        // Preview field is used in the Component Tree

		previewField: "text",
	},
};
</script>
<script setup lang="ts">
import { FieldType } from "@/writerTypes";
import injectionKeys from "../injectionKeys";
import { inject } from "vue";

/*
The values for the fields defined earlier in the custom option
will be available using the evaluatedFields injection symbol.
*/

const fields = inject(injectionKeys.evaluatedFields);
</script>

<style scoped>
/* ... */
</style>
```

The code above will make Bubble Message available in the Builder.

![Custom Components - Bubble Message](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/custom-components.bubble-message.png)

## Developing templates

### Run a local server

<Steps>
  <Step title="Clone the Framework Repository">
    To get started, clone the [Framework
    repository](https://github.com/writer/writer-framework) from GitHub.
  </Step>

  <Step title="Set Up the Development Environment">
    To develop custom templates in a developer-friendly way, ensure you have a
    front-end development server with instant reload capabilities. The front-end
    code for Framework is located in the `ui` folder. With Node and npm
    installed on your system, run `npm install` to install dependencies. Then,
    start the server with support for custom component templates using `npm run
        custom.dev`.

    ```sh cd ui npm install # "custom.dev" links templates in
    "custom_components/" # "dev" runs the server without them npm run custom.dev
    ```
  </Step>

  <Step title="Start the Back-End Server">
    The command `npm run custom.dev` starts a front-end server, which requires a
    back-end to function fully. Start Framework via command line, specifying the
    option `--port 5000`, to provide a back-end on that port. It's recommended
    to create a new app for testing the template you're developing. `sh writer
        create customtester writer edit customtester --port 5000 `
  </Step>

  <Step title="Access Framework and Test Custom Component">
    You should now be able to access Framework via the URL provided by Vite,
    e.g. `http://localhost:5174`. In the Builder's *Toolkit*, you should see the
    sample component, *Balloon Message*. Add it to your tester application.
  </Step>
</Steps>

### Create a new component

<Tip>
  You can also have a look at the built-in component templates, since their
  syntax is equivalent. They can be found in the `ui/src/components/core` folder.
</Tip>

Go to `ui/src/components/custom` and open the Vue single-file components, i.e. the
`.vue` files. These files contain comments that will help you get started. Try editing
the provided templates, you should see changes reflected.

You can get started by duplicating one of these examples. Make sure you add the new template to the entrypoint, as discussed below.

### Define entrypoint

For custom component templates to be taken into account, they need to be accessible from the entrypoint. Edit `ui/src/components/custom/index.ts` to define which templates you wish to export and under which identifiers.

```ts
// Import the templates

import BubbleMessage from "./BubbleMessage.vue";
import BubbleMessageAdvanced from "./BubbleMessageAdvanced.vue";

// Export an object with the ids and the templates as default

export default {
  bubblemessage: BubbleMessage,
  bubblemessageadvanced: BubbleMessageAdvanced,
};
```

A single or multiple templates can be specified. Take into account that they will all be exported, and later imported, together.

## Bundling templates

Execute `npm run custom.build` into `src/ui`, this will generate the output `.js` and `.css` files into `./custom_components_dist`.

```sh
# "build" builds the entire front-end
# "custom.build" only builds the custom templates

npm run custom.check # Optional: checks certain issues on custom components
npm run custom.build
```

Collect the files from `./custom_components_dist` and pack them in a folder such as `my_custom_bubbles`. The folder containing the generated files, e.g. `my_custom_bubbles`, can now be placed in the `extensions/` folder of any Framework project. It'll be automatically detected during server startup.

<Tip>
  The `custom.check` command is optional, but it's recommended to run it before building the custom components. It checks for common issues in the custom components, such as invalid key declaration, ...
</Tip>


# Custom server
Source: https://dev.writer.com/framework/custom-server



Framework uses Uvicorn and serves the app in the root path i.e. `/`. If you need to use another ASGI-compatible server or fine-tune Uvicorn, you can easily do so.

## Configure webserver

You can tune your server by adding a `server_setup.py` file to the root
of your application, next to the `main.py` files.

This file is executed before starting writer. It allows you to configure [authentication](./authentication.md),
add your own routes and middlewares on FastAPI.

```python
# server_setup.py
import typing

import writer.serve

if typing.TYPE_CHECKING:
    from fastapi import FastAPI

# Returns the FastAPI application associated with the writer server.
asgi_app: FastAPI = writer.serve.app

@asgi_app.get("/probes/healthcheck")
def hello():
    return "1"
```

<Warning>
  `server_setup.py` is disabled by default on edit mode. If you want to use in `edit` mode, you can launch `writer edit --enable-server-setup <app>`.
</Warning>

## Implement custom server

You can import `writer.serve` and use the function `get_asgi_app`. This returns an ASGI app created by FastAPI, which you can choose how to serve.

The following code can serve as a starting point. You can save this code as `serve.py` and run it with `python serve.py`.

```py
import uvicorn
import writer.serve

app_path = "." # . for current working directory
mode = "run" # run or edit

asgi_app = writer.serve.get_asgi_app(app_path, mode)

uvicorn.run(asgi_app,
    host="0.0.0.0",
    port=5328,
    log_level="warning",
    ws_max_size=writer.serve.MAX_WEBSOCKET_MESSAGE_SIZE)
```

Note the inclusion of the imported `ws_max_size` setting. This is important for normal functioning of the framework when dealing with bigger files.

Fine-tuning Uvicorn allows you to set up SSL, configure proxy headers, etc, which can prove vital in complex deployments.

If you want to disable server setup hook, you should use `enable_server_setup`:

```python
asgi_app = writer.serve.get_asgi_app(app_path, mode, enable_server_setup=False)
```

## Multiple apps at once

Framework is built using relative paths, so it can be served from any path. This allows multiple apps to be simultaneously served on different paths.

The example below uses the `get_asgi_app` function to obtain two separate Framework apps, which are then mounted on different paths, `/app1` and `/app2`, of a FastAPI app.

```py
import uvicorn
import writer.serve
from fastapi import FastAPI, Response

root_asgi_app = FastAPI(lifespan=writer.serve.lifespan)
sub_asgi_app_1 = writer.serve.get_asgi_app("../app1", "run")
sub_asgi_app_2 = writer.serve.get_asgi_app("../app2", "run")

root_asgi_app.mount("/app1", sub_asgi_app_1)
root_asgi_app.mount("/app2", sub_asgi_app_2)

@root_asgi_app.get("/")
async def init():
    return Response("""
    <h1>Welcome to the App Hub</h1>
    """)

uvicorn.run(root_asgi_app,
    host="0.0.0.0",
    port=5328,
    log_level="warning",
    ws_max_size=writer.serve.MAX_WEBSOCKET_MESSAGE_SIZE)
```


# Dataframe
Source: https://dev.writer.com/framework/dataframe



## DataFrames

If your application needs to present data as a table, it should use a **DataFrame**. DataFrames provide a simple way to present data in a grid format, require only a couple of lines of code to set up, and provide an interface that users expect from modern data applications.

![DataFrame showing a table of popular ice cream flavors](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/dataframe.png)

DataFrames built-in features that users expect, such as headers that can be clicked to change the sort order and resizable columns...

![DataFrame with arrows pointing to the re-sort and resizing features](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/dataframe_resort_resize.png)

...and with the simple change of a parameter, you can enable features such as the Search field, which lets the user find the data theyâ€™re looking for (or filter out unwanted data), and the Download button, which downloads the data currently being displayed as a .csv file:

![DataFrame with arrows pointing to the Search field and Download button](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/dataframe_search_download.png)

You can find the full list of DataFrame properties and fields on the [*DataFrame* component page](/components/dataframe).

### â€œDataFrameâ€ has multiple meanings

**Writer Framework has two objects with the name *DataFrame*:**

1. **UI DataFrame:** In Writer Framework's UI, "DataFrame" refers to a ***user interface component*** that displays data in rows and columns in a way similar to a spreadsheet or SQL table.
2. **Code Dataframe:** In code that you write for a Writer Framework application, `DataFrame` refers to a ***data structure*** that stores data in rows and columns in a way similar to a spreadsheet or SQL table.

To present a data table in Writer Framework, you create a `DataFrame` data structure in your code and then bind it to a UI Dataframe.

## Displaying a static DataFrame

A static DataFrame is one whose content does not change. The user can change its sort order, but the data within the DataFrame remains constant.

<Steps>
  <Step title="Create a DataFrame data structure">
    Writer Framework supports both [pandas](https://pandas.pydata.org/) and [Polars](https://pola.rs/) `DataFrame` data structures. Create a `DataFrame`, assign its value to a variable, then assign make that variable a value in the `state` dictionary:

    <CodeGroup>
      ```python pandas
      import writer as wf
      import pandas as pd

      data = [
      	{"rank": 1, "flavor": "Vanilla", "favorite": 0.11},
      	{"rank": 2, "flavor": "Chocolate", "favorite": 0.1},
      	{"rank": 3, "flavor": "Cookies and cream", "favorite": 0.07},
      	{"rank": 4, "flavor": "Strawberry", "favorite": 0.06},
      	{"rank": 5, "flavor": "Chocolate chip", "favorite": 0.02},
      ]
      df = pd.DataFrame(data)

      wf.init_state({
      	"mydf": df
      })
      ```

      ```python Polars
      import writer as wf
      import polars as pl

      data = [
      	{"rank": 1, "flavor": "Vanilla", "favorite": 0.11},
      	{"rank": 2, "flavor": "Chocolate", "favorite": 0.1},
      	{"rank": 3, "flavor": "Cookies and cream", "favorite": 0.07},
      	{"rank": 4, "flavor": "Strawberry", "favorite": 0.06},
      	{"rank": 5, "flavor": "Chocolate chip", "favorite": 0.02},
      ]
      df = pl.DataFrame(data)

      wf.init_state({
      	"mydf": df
      })
      ```
    </CodeGroup>

    The call to `wf.init_state()` adds the `DataFrame` to the application's `state` variable as the value of the `mydf` key.
  </Step>

  <Step title="Add a DataFrame component to the UI and bind it to the DataFrame data structure">
    Add a DataFrame UI component to the user interface, then set its **Data** property to `@{`*dataframe\_key*`}`, where *dataframe\_key* is the `state` variable key whose value refers to the `DataFrame` data structure.

    In the case of this example, `mydf` is the `state` variable key referring to the `DataFrame`, so set the **Data** property to `@{mydf}`.

    ![DataFrame for static table example with properties panel open](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/dataframe_static_table_1.png)
  </Step>
</Steps>

## Displaying an editable DataFrame

A editable DataFrame is one whose content can change. Like static DataFrames, editable DataFrames use the **DataFrame** UI component. Unlike static tables, the DataFrame UI component is bound to an instance of `EditableDataFrame`, a class provided by the Writer library. Changes to a  `EditableDataFrame` object will be immediately reflected in the DataFrame UI component that it is bound to.

<Steps>
  <Step title="Create an EditableDataFrame data structure">
    An `EditableDataFrame` object can be instantiated from any of the following:

    1. A pandas `DataFrame`
    2. A Polars `DataFrame`
    3. A list of dictionaries

    <CodeGroup>
      ```python pandas
      import writer as wf
      import pandas as pd

      data = [
      	{"rank": 1, "flavor": "Vanilla", "favorite": 0.11},
      	{"rank": 2, "flavor": "Chocolate", "favorite": 0.1},
      	{"rank": 3, "flavor": "Cookies and cream", "favorite": 0.07},
      	{"rank": 4, "flavor": "Strawberry", "favorite": 0.06},
      	{"rank": 5, "flavor": "Chocolate chip", "favorite": 0.02},
      ]
      df = pd.DataFrame(data)

      wf.init_state({
      	"mydf": wf.EditableDataFrame(df)
      })
      ```

      ```python Polars
      import writer as wf
      import polars as pl

      data = [
      	{"rank": 1, "flavor": "Vanilla", "favorite": 0.11},
      	{"rank": 2, "flavor": "Chocolate", "favorite": 0.1},
      	{"rank": 3, "flavor": "Cookies and cream", "favorite": 0.07},
      	{"rank": 4, "flavor": "Strawberry", "favorite": 0.06},
      	{"rank": 5, "flavor": "Chocolate chip", "favorite": 0.02},
      ]
      df = pl.DataFrame(data)

      wf.init_state({
      	"mydf": wf.EditableDataFrame(df)
      })
      ```

      ```python List of dictionaries
      import writer as wf

      data = [
      	{"rank": 1, "flavor": "Vanilla", "favorite": 0.11},
      	{"rank": 2, "flavor": "Chocolate", "favorite": 0.1},
      	{"rank": 3, "flavor": "Cookies and cream", "favorite": 0.07},
      	{"rank": 4, "flavor": "Strawberry", "favorite": 0.06},
      	{"rank": 5, "flavor": "Chocolate chip", "favorite": 0.02},
      ]

      wf.init_state({
      	"mydf": wf.EditableDataFrame(data)
      })
      ```
    </CodeGroup>

    The call to `wf.init_state()` adds the `DataFrame` to the application's `state` variable as the value of the `mydf` key.
  </Step>

  <Step title="Add a DataFrame component to the UI and bind it to the DataFrame data structure">
    Add a **DataFrame** component to the user interface, then set its **Data** property to `@{`*dataframe\_key*`}`, where *dataframe\_key* is the `state` variable key whose value refers to the `DataFrame` data structure.

    In the case of this example, `mydf` is the `state` variable key referring to the `DataFrame`, so set the **Data** property to `@{mydf}`.

    ![DataFrame for dynamic table example with properties panel open](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/dataframe_dynamic_table_1.png)
  </Step>
</Steps>

## Updating an editable DataFrame

Editable DataFrames are updated by updating the `EditableDataFrame` object they are bound to, which is done using `EditableDataFrame`'s methods.

### `record_add`: Add a new row

`record_add()` adds a new row to an `EditableDataFrame`. It takes a dictionary with the following structure...

```python
{"record": new_row}
```

...where `new_row` is a dictionary containing the data for the row to be added.

In the code example above, you would add a new row to the DataFrame with the following code:

```python
state["mydf"].record_add({"record": {"rank": 6, "flavor": "Birthday cake", "favorite": 0.01}})
```

### `record`: Read the contents of a row

`record()` returns a row in an `EditableDataFrame`. It takes an integer specifying the index of the row.

In the code example above, you would retrieve the record at row 1 with the following code:

```python
record = state["mydf"].record(1)
```

### `record_update`: Change an existing row

`record_update()` replaces an existing row in an `EditableDataFrame` with a new one. It takes a dictionary with the following structure...

```python
{
	"record_index": index,
	"record": row_to_update
}
```

...where `index` is an integer specifying which row should be updated and `row_to_update` is a dictionary containing the updated row data.

In the code example above, you would update the row at index 0 with the following code:

```python
state["mydf"].record_update({
	"record_index": 0,
	"record": {"rank": 6, "flavor": "Bubble gum", "favorite": 0.08}
})
```

### `record_remove`: Delete an existing row

`record_remove()` removes an existing row from an `EditableDataFrame`. It takes a dictionary with the following structure...

```python
{"record_index": index}
```

...where `index` is an integer specifying which row should be deleted.

In the code example above, you would delete the row at index 2 with the following code:

```python
state["mydf"].record_remove({"record_index": 2})
```

## Enabling additional features

The DataFrame component has these â€œalways-onâ€ features:

1. **Sorting:** Clicking a column header sorts the entire DataFrame based on that column's values. The first click sorts that DataFrame in ascending order, a second click changes it to descending order, and a third click restores the DataFrame to its original sort order.
2. **Column resizing:** Click and drag the dividing line on the right edge of a column header to adjust its width.

DataFrames have other features that you need to activate, which are listed below.

### Search field

To enable the Search field, select the DataFrame, open the Component settings panel, and set **Enable search** to **yes**.

![Enabling the Search field in a DataFrame](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/dataframe_enable_search.png)

### Download button

To enable the Download button, select the DataFrame, open the Component settings panel, and set **Enable download** to **yes**.

![Enabling the Download button in a DataFrame](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/dataframe_enable_download.png)


# Event handlers
Source: https://dev.writer.com/framework/event-handlers



Events originate in the front-end, for example, when a user clicks a *Button* component. Using the Builder, these events can be linked to event handlers.

## Plain Python functions

Event handlers are Python functions accessible from `main.py`. They can be defined in that same file or imported. No decorators or special syntax are required.

```py
# This event handler will add an entry to the log
def handle_click()
    print("Hello")
```

To specify that a function isn't an event handler and should remain hidden to the front-end, prefix it with a `_` (underscore).

```py
# This function won't be visible in the front-end
# because its name starts with an underscore
def _reticulate(splines):
    r_splines = np.random.normal(size=(splines,100))
    return r_splines
```

### External handlers

If your `main.py` file has become cluttered with too many handler functions, you can organize them more effectively using the `init_handlers` method. This method allows you to register handler functions from other modules. You can pass a single imported module or a list of modules to the init\_handlers method to register multiple handlers simultaneously:

<CodeGroup>
  ```py one_handler
  # my_app/my_handlers_module.py

  def increment(state):
      state["counter"] += 1
  ```

  ```py init_handlers one module
  # my_app/main.py

  import writer as wf
  import my_handlers_module

  wf.init_handlers(my_handlers_module)
  # Register all functions from the module as handlers;
  # this makes `increment` handler accessible on front-end
  ```

  ```py init_handlers many modules
  # my_app/main.py

  import writer as wf
  import handler_module_one
  import handler_module_two

  wf.init_handlers([handler_module_one, handler_module_two])
  ```
</CodeGroup>

<Warning>
  Each function inside a module is attempted to be registered as a handler. Make sure to use `_` prefix as described [before](#plain-python-functions) to prevent exposing unwanted functions to front-end.
</Warning>

You can also call `init_handlers` within other modules, which allows for a sequence of registrations:

<CodeGroup>
  ```py another_handlers_module
  # my_app/another_handlers_module.py

  def decrement(state):
      state["counter"] -= 1
  ```

  ```py register_additional_handlers
  # my_app/my_handlers_module.py

  import writer as wf
  import another_handlers_module

  wf.init_handlers(another_handlers_module)
  # Makes `decrement` handler accessible on front-end

  ...
  ```

  ```py my_handlers_module
  # my_app/main.py

  import writer as wf
  import my_handlers_module

  ...
  ```
</CodeGroup>

Note that for this "chain" to work, you need to import the final module in the sequence into `main.py`.

## Mutating state

In most cases, event handlers will modify the application state. State can be accessed by including the `state` argument in the handler, which will provide you with a `WriterState` object for the session that invoked the handler.

Elements of state can be reached using the square brackets syntax `state["my_element"]`. Accessing keys that don't exist will return `None`.

```py
def handle_click(state):
    state["counter"] += 1
```

The handler above receives the application state for the relevant session and mutates it. For example, if Bob's counter was 4, and he clicks on a *Button* linked to `handle_click`, his new counter value will be 5. Other sessions remain unaffected.

## Mutation detection

<Warning>
  Mutations are detected via assignment.
  Make sure you perform an assignment on the state element you're mutating, for the mutation to be detected.
</Warning>

When communicating with the front-end, Framework only sends state elements that have mutated.

To detect which elements have mutated, it relies on assignment (via operators such as `=`, `+=`, etc). This is because Python doesn't offer a performant, reliable mechanism to detect mutations. See the two examples below.

<CodeGroup>
  ```python hande_click
  def handle_click(state):
      state["my_df"].sample(frac=1, random_state=random.seed())

      # The self-assignment is necessary when mutating
      # an existing object directly on state

      state["my_df"] = state["my_df"]
  ```

  ```python hande_click_cleaner
  # The following cleaner code also works as it relies on assignment
  def hande_click_cleaner(state):
      my_df = state["my_df"]
      my_df.sample(frac=1, random_state=random.seed())
      state["my_df"] = my_df # State assignmnet
  ```
</CodeGroup>

## Mutation event

You can subscribe to mutations on a specific key in the state.
This is useful when you want to trigger a function every time a specific key is mutated.

<CodeGroup>
  ```python simple subscription
  import writer as wf

  def _increment_counter(state):
      state['my_counter'] += 1

  state = wf.init_state({"a": 1, "my_counter": 0})
  state.subscribe_mutation('a', _increment_counter)

  state['a'] = 2  # trigger _increment_counter mutation
  ```

  ```python multiple subscriptions
  import writer as wf

  def _increment_counter(state):
      state['my_counter'] += 1

  state = wf.init_state({
  	'title': 'Hello',
  	'app': {'title', 'Writer Framework'},
  	'my_counter': 0}
  )

  state.subscribe_mutation(['title', 'app.title'], _increment_counter)  # subscribe to multiple keys

  state['title'] = "Hello Pigeon"  # trigger _increment_counter mutation
  ```

  ```python trigger event handler
  import writer as wf

  def _increment_counter(state, context: dict, payload: dict, session: dict, ui: WriterUIManager):
  	if context['event'] == 'mutation' and context['mutation'] == 'a':
  		if payload['previous_value'] > payload['new_value']:
  			state['my_counter'] += 1

  state = wf.init_state({"a": 1, "my_counter": 0})
  state.subscribe_mutation('a', _increment_counter)

  state['a'] = 2  # increment my_counter
  state['a'] = 3  # increment my_counter
  state['a'] = 2  # do nothing
  ```
</CodeGroup>

<Tip>
  `subscribe_mutation` is compatible with event handler signature. It will accept all the arguments
  of the event handler (`context`, `payload`, ...).
</Tip>

## Receiving a payload

Several events include additional data, known as the event's payload. The event handler can receive that data using the `payload` argument.

For example, the `wf-change` event in a *Text Input* component is triggered every time the value changes. As a payload, it includes the new value.

```py
def handle_input_change(state, payload):
    state["value"] = payload
```

The content of the payload will vary depending on the event. For example, when a user takes a photo with a *Webcam Capture*, the picture they took is sent across as a PNG image.

```py
def handle_webcam_capture(payload):
	image_file = payload
	with open(f"picture.png", "wb") as file_handle:
		file_handle.write(image_file)
```

Handling different payloads across events can be challenging, especially since the shape of the payload may vary. To simplify this process, the Builder provides stub code that can help you get started with writing an event handler. You can access it by clicking the icon located next to the event when configuring the component's settings. This feature can help you quickly understand the structure of the payload and start writing the appropriate code to handle it.

## Globals

You can use globals and module attributes, just as you would in a standard Python script. This is very convenient for storing a single copy of resource-intensive object.

```py
my_ai = CatIdentifierAI()

def evaluate(state, payload):
    result = my_ai.process(payload)
    state["is_a_cat"] = result
```

Take into account that globals apply to all users. If you need to store data that's only relevant to a particular user, use application state.

## Middlewares

Middlewares are functions that run before and after every event handler.
They can be used to perform tasks such as logging, error handling, session management, or modifying the state.

```py
import writer as wf

@wf.middleware()
def middleware_before(state, payload, context):
	print("Middleware before event handler")
	state['running'] += 1
	yield
	print("Middleware after event handler")
	state['running'] -= 1
```

A middleware receives the same parameters as an event handler.

A middleware can be used to handle exceptions that happens in event handlers.

```py
import writer as wf

@wf.middleware()
def middleware_before(state):
	try:
		yield
	except Exception as e:
		state['error_counter'] += 1
		state['last_error'] = str()
	finally:
		pass
```

## Standard output

The standard output of an app is captured and shown in the code editor's log. You can use the standard `print` function to output results.

```py
# Shown every time the app starts
print("Hello world")

def payload_inspector(state, payload):
    # Shown every time the event handler is executed
    print("Payload: " + repr(payload))
```

## Execution flow

Event handlers run in a thread pool and are non-blocking. Each event is processed independently from each other.

State mutations are sent to the front-end after the function has finished executing. The code in `handle_fast` will accumulate all mutations and send to the front-end after the function returns. For long-running tasks, Framework will periodically check state and provide partial updates to the user.

<CodeGroup>
  ```py handle_fast
  def handle_fast(state):
      state["text"] = "Hello"
      state["x"] += 3
      state["y"] += 2
  ```

  ```py handle slowly
  # The code below will set `message` to "Loading...", then to "Completed".  
  def handle_slowly(state):
      state["message"] = "Loading..."
      import time
      time.sleep(5)
      state["message"] = "Completed"
  ```
</CodeGroup>

## Asynchronous event handlers

Framework supports asynchronous event handlers, allowing for non-blocking I/O operations directly within event handlers. This is particularly useful for tasks such as fetching data from a database, making HTTP requests, or performing any other I/O bound operation that can benefit from asynchronous execution.

### Defining an asynchronous handler

An asynchronous event handler is defined with the standard `async` keyword syntax.

```py
# An asynchronous event handler for performing an I/O bound operation
async def handle_async_click(state):
    data = await fetch_data()
    state["data"] = data
```

In the example above, `fetch_data()` is an asynchronous function that retrieves data, potentially from a remote source. The `await` keyword is used to wait for the operation to complete without blocking the main thread, allowing other tasks to run concurrently.

### Awaitable objects

You can use any awaitable object within an async event handler. This includes the output of any function defined with `async def`, or objects with an `__await__` method. This makes it easy to integrate with asynchronous libraries and frameworks.

## Context

The `context` argument provides additional information about the event.

The context provide the id of component that trigger the event in `target` field.

```py
def handle_click(state, context: dict):
	last_source_of_click = context['target']
	state["last_source_of_click"] = last_source_of_click
```

The context provides the event triggered in the `event` field.

```py
def handle_click(state, context: dict):
	event_type = context['event']
	if event_type == 'click':
		state["last_event"] = 'Click'
```

The repeater components have additional fields in the context, such as defined in `keyVariable` and `valueVariable`.

```py
def handle_repeater_click(state, context: dict):
	key = context['keyVariable']
	state['repeater_content'][key]['last_action'] = 'Clicked' 
```

More information in [Repeater chapter](/framework/repeater)


# Frontend scripts
Source: https://dev.writer.com/framework/frontend-scripts



Framework can import custom JavaScript/ES6 modules from the front-end. Module functions can be triggered from the back-end.

## Importing an ES6 module

Similarly to [stylesheets](/framework/stylesheets), front-end scripts are imported via Framework's `mail` capability. This allows you to trigger an import for all or specific sessions at any time during runtime. When the `import_frontend_module` method is called, this triggers a dynamic [import()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import) call in the front-end.

The `import_frontend_module` method takes the `module_key` and `specifier` arguments. The `module_key` is an identifier used to store the reference to the module, which will be used later to call the module's functions. The `specifier` is the path to the module, such as `/static/mymodule.js`. It needs to be available to the front-end, so storing in the `/static/` folder is recommended.

The following code imports a module during event handling.

```py
def handle_click(state):
    state.import_frontend_module("my_script", "/static/mymodule.js")
```

If you want the module to be imported during initialisation, use the initial state.

```py
initial_state = wf.init_state({
    "counter": 1
})

initial_state.import_frontend_module("my_script", "/static/mymodule.js")
```

<Note>
  Use versions to avoid caching. Similarly to stylesheets, your browser may cache modules, preventing updates from being reflected. Append a querystring to invalidate the cache, e.g. use `/static/script.js?3`.
</Note>

## Writing a module

The module should be a standard ES6 module and export at least one function, enabling it to be triggered from the back-end. As per JavaScript development best practices, modules should have no side effects. An example of a module is shown below.

```js
let i = 0;

export function sendAlert(personName) {
    i++;
    alert(`${personName}, you've been alerted. This is alert ${i}.`);
}
```

## Calling a function

Once the module is imported, functions can be called from the back-end using the `call_frontend_function` method of state. This function takes three arguments. The first, `module_key` is the identifier used to import the module. The second, `function_name` is the name of the exported front-end function. The third, `args` is a `List` containing the arguments for the call.

The following event handler triggers the front-end function defined in the section above.

```py
def handle_click(state):
    state.call_frontend_function("mymodule", "sendAlert", ["Bob"])
```

## Import a JS script

Framework can also import and run JavaScript scripts directly, for their side effects. These are imported via the report's `import_script` method. This method takes two arguments. The first, `script_key` is the identifier used to import the script. The second, `path` is the path to the file. The specified path must be available to the front-end, so storing it in your application's `./static` folder is recommended.

```py
initial_state = wf.init_state({
    "counter": 1
})

initial_state.import_script("my_script", "/static/script.js")
```

<Warning>
  Prefer ES6 modules: importing scripts is useful to import libraries that don't support ES6 modules. When possible, use ES6 modules. The `import_script` syntax is only used for side effects; you'll only be able to call functions from the back-end using modules that have been previously imported via `import_frontend_module`.
</Warning>

## Importing a script from a URL

Framework can also import scripts and stylesheets from URLs. This is useful for importing libraries from CDNs. The `import_script` and `import_stylesheet` methods take a `url` argument, which is the URL to the script or stylesheet.

```python
initial_state = wf.init_state({
    "my_app": {
        "title": "My App"
    },
})

initial_state.import_script("lodash", "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.js")
```

## Frontend core

<Warning>
  Effectively using Framework's core can be challenging and will likely entail reading its [source code](https://github.com/writer/writer-framework/blob/master/src/ui/src/core/index.ts). Furthermore, it's considered an internal capability rather than a public API, so it may unexpectedly change between releases.
</Warning>

You can access Framework's front-end core via `globalThis.core`, unlocking all sorts of functionality. Notably, you can use `getUserState()` to get values from state.

```js
export function alertHueRotationValue() {
    const state = globalThis.core.userState.value.
    console.log("State is", state);
}
```


# Handling inputs
Source: https://dev.writer.com/framework/handling-inputs



There are two, complementary, ways to handle inputs in Framework: via event handlers and via binding.

## Event handlers

Input components have *change* events that are dispatched when the value changes. The new value is provided as a payload in the event handler. Change events have slightly different names across components, reflecting the payloads they provide. For example, *Number Input* and *Slider Input* use the event `wf-number-change` while *Text Input* and *Text Area Input* use the generic `wf-change`.

As discussed in the [Event handlers](/framework/event-handlers) section, the payload can be accessed via the `payload` argument in the event handler.

```py
# This event handler takes the payload and assigns it
# to the state element "name"
def handle_input_change(state, payload):
    state["name"] = payload
```

## Two-way bindings

Writing event handlers for every input component can be tedious. In most cases, you'll only need to update a single element of state when the value changes, akin to the example above. You can achieve this by binding a component to a state element.

Bindings automatically handle the *change* event for the component and set the value of the state element to the payload. Furthermore, bindings are two-way. If the state element is updated from the back-end, the front-end component is updated to reflect the new value.

As mentioned in the [Builder basics](/framework/builder-basics) section of the guide, bindings can be configured in the component settings.

![Repeater example](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/handling-inputs.binding.png)

The binding above establishes a two-way link between the component and the state element `name`. If `name` changes in the back-end, the component changes. If the component changes, the value of `name` changes.

## Using events and bindings simultaneously

Bindings can be used together with events. This is useful for triggering recalculations or applying dynamic filters. For example, you may want to have three *Number Input* components bound to `a`, `b` and `c` and display a value `n`. This easily done by binding the components and linking the same recalculation event handler to all three components.

```py
def recalculate(state):
    state["n"] = state["a"]*state["b"]*state["c"]
```

## Handling inputs safely

Framework automatically sanitises the payloads it provides for its built-in events, those that start with `wf-`.

For example, if a *Dropdown Input* component lists options `high` and `low`, you're guaranteed you won't get a value like `"Robert'); DROP TABLE students;--"` when handling `wf-option-change`. You'll get `"high"`, `"low"` or `None`.

<Warning>
  Inputs are sanitised, but you should still be careful

  As with any application, it's important to be familiar with the risks associated with handling user input, especially SQL injections. If you're using any custom HTML and mixing it with user generated content, make sure you understand XSS.
</Warning>

## Creating forms

Input components can be combined with *Message* and *Button* components to create forms with messages, indicating whether the submission was successful.

![Form example](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/handling-inputs.form.png)


# Writer Framework
Source: https://dev.writer.com/framework/introduction



The Writer Framework lets you build feature-rich apps by using a drag-and-drop visual editor called **the Builder** and writing the back-end code in Python. It's fast and flexible, with clean, easy-to-test syntax. It provides separation of concerns between UI and business logic, enabling more complex apps.

![Framework Builder screenshot](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/public/builder.png)

Build AI apps with the Writer Framework when:

1. You need to incorporate external data sources, such as external APIs
2. You have complex user input that requires custom logic, such as conditions that trigger the use of different prompts
3. You want to quickly analyze and visualize data using an LLM

The Writer Framework offers:

<AccordionGroup>
  <Accordion title="Easily-testable Python functions">
    Define event handlers as plain Python functions.

    ```python
    def handle_text_update(state):
        state["text"] = "Updated text"

    writer.init_state({
        "text": "Initial text"
    })
    ```
  </Accordion>

  <Accordion title="Visual editor">
    Link the event handler and state to the UI seamlessly.
  </Accordion>

  <Accordion title="Standard Python packages">
    Install with a simple pip command.
  </Accordion>

  <Accordion title="Version control">
    Save user interfaces as JSON to be version controlled with the rest of the app.
  </Accordion>

  <Accordion title="Flexible editing">
    Use your local code editor with instant refreshes or the provided web-based editor. Edit the UI while your app is running without needing to click â€œPreview.â€
  </Accordion>

  <Accordion title="Minimal overhead">
    Event handling adds only 1-2ms to your Python code.
  </Accordion>

  <Accordion title="Real-time synchronization">
    Use WebSockets to synchronize front-end and back-end states.
  </Accordion>

  <Accordion title="Efficient execution">
    Non-blocking by default, with asynchronous event handling in a dedicated thread pool.
  </Accordion>

  <Accordion title="Customizable elements">
    No CSS required for customization like shadows, button icons, and background colors.
  </Accordion>

  <Accordion title="HTML integration">
    Include HTML elements with custom CSS using the HTML Element component, which can serve as containers for built-in components.
  </Accordion>
</AccordionGroup>

To get started, head to [Quickstart](/framework/quickstart) or our tutorials:

<CardGroup cols={3}>
  <Card title="Social post generator" icon="megaphone" href="/framework/social-post-generator" color="currentColor">
    Generate multiple social media posts in a click of button using our social media generator.
  </Card>

  <Card title="Chat assistant" icon="comment" href="/framework/chat-assistant" color="currentColor">
    Using Knowledge Graph, our graph-based RAG solution, you can build chat assistants to quickly ask questions using your data sources.
  </Card>

  <Card title="Product description generator" icon="page" href="/framework/product-description-generator" color="currentColor">
    Build real-time digital shelves for hundreds of products that are automatically customized for different e-retailers.
  </Card>
</CardGroup>


# Page routes
Source: https://dev.writer.com/framework/page-routes



Framework apps can have multiple pages, with parametrised routes. Pages can be switched from the front-end or the back-end.

## Basic navigation

To enable navigation between *Page* components, they must have a key assigned. This can be set up from the component's settings. Once a key is set up, the page will be accessible at `/#my_page_key`.

### Frontend-triggered page changes

For basic page changes, assign a "Go to page" action to an event handler. For example, if you want to change to page `my_page_key` when a *Button* is clicked, go to the button's settings and under the `click` event select `Go to page "my_page_key"`.

### Backend-triggered page changes

Trigger a page change from the back-end using the `set_page` method of state.

```py
# This event handler sends the user to a different page
# depending on time of the day
def handle_click(state):
    from datetime import datetime

    now = datetime.now()
    if now.hour >= 18:
        state.set_page("fun_work_page")
    else:
        state.set_page("work_work_page")
```

## Routes with parameters

You may want to share a URL that links directly to a specific resource within your app. For example, to a specific location or product.

You can do so by specifying parameters in the URL, known as route vars. Framework URLs contain the page key, followed by the route vars and their values. For example, `/#detailPage/product_id=32&country=AR`.

### Adding vars to the URL from the back-end

You can set up variables that are displayed in the URL by passing a dictionary to the `set_route_vars` state method. Use `None` to clear specific keys.

```py
# The following code will set the value of product_id
# to the value of the "product" state element
def change_route_vars(state):
    state.set_route_vars({
        "product_id": state["product"]
    })
```

### Retrieving the values

Framework uses the hash portion of the URL to store page and variable data, so even when switching pages or changing variables, the page doesn't reload. To monitor changes to the active URL, set up an event handler for `wf-hashchange` in the *Root* component.

```py
# The following event handler reads the product_id route var,
# then assigns its value to the "product" state element.
def handle_hash_change(state, payload):
    route_vars = payload.get("route_vars")
    if not route_vars:
        return
    state["product"] = route_vars.get("product_id")
```


# Product description generator
Source: https://dev.writer.com/framework/product-description-generator



In this tutorial, you'll use the Writer Framework to build a Saturn Snacks product description generator for a variety of food outlets. After adding the initial functionality of the app, you'll also extend the app to include a chart of SEO keyword analysis and the ability for users to add their own food outlet.

![Finished application](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/product_desciption/pd_gen_1.png)

## Setting up your project

### Creating a Writer app and getting your API key

From the Home screen, click on **Build an app**.

![Writer home screen](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/product_desciption/pd_gen_2.png)

Select Framework as the app type youâ€™d like to create, enabling you to generate keys and build your app with the Writer Framework.

![App type selection](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/product_desciption/pd_gen_3.png)

On the next screen, you can edit your Writer application name in the upper left. Underneath â€œAuthenticate with an API key,â€ click on â€œRevealâ€ to see and copy your API key.

### Creating the application

Next, open your terminal and navigate to the directory where you want to create your application directory.

<Steps>
  <Step title="Set the API key environment variable">
    To pass your API key to the Writer Framework, you'll need to set an environment variable called `WRITER_API_KEY`. Hereâ€™s how you can set this variable in your terminal session:

    <CodeGroup>
      ```sh On macOS/Linux
      export WRITER_API_KEY=[key]
      ```

      ```sh On Windows
      set WRITER_API_KEY=[key]
      ```
    </CodeGroup>
  </Step>

  <Step title="Create the application">
    Run the following command to create your application. Replace `product-description-app` with your desired project name and `pdg-tutorial` with the template you wish to use:

    ```
    writer create product-description-app --template=pdg-tutorial
    ```

    This command sets up a new project called `product-description-app` in the specified directory using a template designed for this tutorial.
  </Step>

  <Step title="Edit your project">
    To edit your project, run the below commands. This will bring up the console, where Framework-wide messages and errors will appear, including logs from the API. By default, the Writer Framework Builder is accessible at `localhost:4005`. If that port is in use, you can specify a different port. Open this address in your browser to view your default application setup.

    <CodeGroup>
      ```bash Standard port
       writer edit product-description-app
      ```

      ```bash Custom port
       writer edit product-description-app --port=3007
      ```
    </CodeGroup>
  </Step>
</Steps>

## Introduction to the application setup

When you first start up the application, you're going to see two main layout items provided by the template:

1. A Header component with the name of the application
2. A Column container that'll house most of the UI of the app

The left column includes a form that has three text inputs and a button. These three text inputs are bound to corresponding state elements. The right column contains a Message component for loading and status messages, as well as an empty Tab container which you'll use to display the product descriptions of the various outlets.

### Code overview

Looking at the code in `main.py`, you'll see that the template already imported the Writer Framework, the AI module, and the product description prompts that you'll use throughout this tutorial.

```python
import writer as wf
import writer.ai
from prompts import base_prompts, user_prompt, seo_keywords
```

The prompts are stored in a separate file called `prompts.py`. You are welcome to open this project in the IDE of your choice and modify the prompts however you wish. However, you don't need to make any changes to this file to follow this tutorial.

You'll also see the state initialization:

```python
wf.init_state({
   "form": {
       "title": "",
       "description": "",
       "keywords": ""
   },
   "message": "Fill in the inputs and click \"Generate\" to get started.",
})
```

The form elements and the message have been initialized as strings. You'll add to this state dictionary throughout the tutorial.

## Implementing the Product description generator

Your first goal is to generate product descriptions for the various food outlets, with each outlet appearing as a tab to the right of the form.

![Finished product description tabs](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/product_desciption/pd_gen_4.png)

### Setting up the code

First, integrate new functionality into your code for generating product descriptions.

<Steps>
  <Step title="Add a private helper method">
    Paste the following method on line 5 after all of the imports to create a helper function for generating product descriptions:

    ```python
    def _generate_product_description(base_prompt, product_info):
       prompt = base_prompt.format(**product_info)
       description = writer.ai.complete(prompt)
       return description
    ```

    This function, `_generate_product_description`, accepts a base prompt and the product information from a form on the page. The underscore at the beginning of its name indicates that it's a private method not exposed to the UI.
  </Step>

  <Step title="Initialize additional state elements">
    Update the `wf.init_state()` to include a `product_description` dictionary with visibility control and outlets for descriptions:

    ```python
    wf.init_state({
       "form": {
           "title": "",
           "description": "",
           "keywords": ""
       },
       "message": "Fill in the inputs and click \"Generate\" to get started.",
       "product_descriptions": {
           "visible": False,
           "outlets": {}
       }
    })
    ```

    This setup includes a variable `visible` to control whether product description tabs are shown or hidden, and an empty dictionary `outlets` for storing descriptions.
  </Step>

  <Step title="Add a button click handler">
    Paste the following method beneath `_generate_product_description` to handle button clicks and generate descriptions:

    ```python
    def handle_click(state):
       state["product_descriptions"]["visible"] = False

       # Loop through all the base prompts to generate versions tailored to each outlet
       for outlet, base_prompt in base_prompts.items():
           state["message"] = f"% Generating product description for {outlet}..."
           product_description = _generate_product_description(base_prompt, state["form"].to_dict())
           state["product_descriptions"]["outlets"][outlet] = product_description

       state["product_descriptions"]["visible"] = True
       state["message"] = ""
    ```

    This handler will loop through each imported base prompt, format it with the form information, and pass it to the helper method. The handler also manages UI interactions, such as displaying and hiding product descriptions and managing loading messages.
  </Step>
</Steps>

### Setting up the user interface

You can now set up the UI to iterate over the product descriptions dictionary and create tabs. Begin by opening the User Interface.

<Steps>
  <Step title="Add and configure the Repeater component">
    In the toolkit, drag a Repeater component from the Other section into the empty Tab Container. Click on the Repeater component to open its component settings. Under Properties, add `@{product_descriptions.outlets}` as the Repeater object to be used for repeating the child components. Replace the default â€œKey variable nameâ€ with `itemId`. You can leave â€œValue variable nameâ€ as `item`.

    ![Repeater settings](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/product_desciption/pd_gen_5.png)
  </Step>

  <Step title="Add and configure the Tab component">
    From the Layout section of the toolkit, drag a Tab component into the Repeater. Click on the Tab to bring up the component settings and add `@{itemId}` to the Name property to display the outlet name on the tab.

    ![Tab settings](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/product_desciption/pd_gen_6.png)
  </Step>

  <Step title="Add and configure the Text component">
    Drag a Text component from the Content section of the Toolkit into the Tab. Click on the Text component to open the Component settings and set the Text property to `@{item}`. You may also choose to set â€œUse Markdownâ€ to â€œyes.â€

    ![Text settings](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/product_desciption/pd_gen_7.png)
  </Step>

  <Step title="Control the visibility of the Tab container">
    Click on the Tab container to bring up its Component settings. Scroll to the bottom and, under Visibility, click â€œCustomâ€ and add `product_descriptions.visible` to the Visibility value input.

    ![Tab container visibility settings](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/product_desciption/pd_gen_8.png)
  </Step>

  <Step title="Wire up the form with the Generate button">
    Click on the Generate button inside the form to bring up its Component settings. In the Events section, select `handle_click` for the `wf-click` event.

    ![Button settings](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/product_desciption/pd_gen_9.png)
  </Step>

  <Step title="Preview and test the application">
    Click **Preview** in the top toolbar, enter some test data, and click the **Generate** button. You should see a loading message, as well as three example food outlets displayed in the tabs. The loading message should disappear when everything is loaded, and the tab should remain visible once the data has loaded.

    Great work!
  </Step>
</Steps>

## Expanding the application: SEO keyword analysis

You can expand on this application by adding a chart that displays the top ten SEO keywords present in the product descriptions.

### Updating the code

To do this, back in the code, first add the following helper function underneath your ` _generate_product_description` helper method:

```python
def _generate_seo_keywords(outlets):
   combined_descriptions = "\n".join(f"{key}: {value}" for key, value in outlets.items())


   # Generate the prompt with the provided descriptions
   prompt = seo_keywords.format(descriptions=combined_descriptions)
   # Strip out whitespace and backticks from the response
   return writer.ai.complete(prompt).strip(" `\n")

```

This method concatenates all of the product descriptions and incorporates them into a prompt in `prompts.py`. It then sends the formatted prompt to the Palmyra LLM using the `complete` method. The prompt not only analyzes the descriptions for SEO keywords, but also outputs a [Plotly.js](/components/plotlygraph) schema object that you can use directly with a Plotly graph component.

With the helper method in place, you can now update the click handler for the button. On line 27, add the following code before the product description visibility is set:

```python
# Create the SEO analysis
   state["message"] = "Analyzing SEO keywords..."
   outlets = state["product_descriptions"]["outlets"]
   state["seo_analysis"] = _generate_seo_keywords(outlets)
```

This code sets the loading message and passes all of the product descriptions to the SEO keyword helper method.

### Adding SEO analysis to the UI

To update the UI to display this chart, first drag a new tab from the Layout section of the toolkit into the Tab container. This tab should not be inside of the Repeater, but can be either before or after it. Click on the tab to open the component settings, and change the name to â€œSEO Analysis.â€ If you'd like, you can also set the Visibility to â€œCustomâ€ and set `seo_analysis` as the visibility value.

![SEO Tab](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/product_desciption/pd_gen_10.png)

To display the chart, drag a Plotly graph component from the Content section of the toolkit into your new tab. Click on the component to bring up the component settings. The Plotly graph component accepts a graph specification. Add `@{seo_analysis}` to pass the LLM-generated graph specification to the component.

Click preview, add some data to the form, and click generate. You should see a new SEO analysis tab appear with a nicely formatted and labeled chart.

![SEO analysis tab and chart](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/product_desciption/pd_gen_11.png)

## Extending the application: user-added outlet

Finally, you can extend this application even further by allowing users to add their own custom food outlet and derive a new description from a custom prompt.

### Adding the new form

Start by building the UI for this new form. From the Layout section of the Toolkit, drag a new Section component into the column where the current form is and drop it above or below it. Click on the Section and change the Name to â€œAdd an outlet.â€

To create the inputs for the form, drag a Text Input and a Number Input from the Input section of the Toolkit into the newly created section. Click on the Text Input component to change the Label to â€œOutlet name.â€ Click on the Number Input and change the label to â€œCharacter max.â€

Finally, add a Button from the Other section of the toolkit to the bottom of the new section. Click on the button and change the text to â€œAdd and Generate.â€ You can also add `laps` or another [Material Symbols](https://fonts.google.com/icons) ID to the Icon input if you wish.

![Add outlet form](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/product_desciption/pd_gen_12.png)

### Updating the code

In the code, you next need to add corresponding state elements for the new form components to `wf.init_state()`. Add the following to the state dictionary:

```python
"outlet_form": {
       "name": "",
       "character_max": "",
   },
```

Don't forget to check your commas when adding to the state dictionary. Your completed state should look like this:

```python
wf.init_state({
   "form": {
       "title": "",
       "description": "",
       "keywords": ""
   },
   "outlet_form": {
       "name": "",
       "character_max": "",
   },
   "message": "Fill in the inputs and click \"Generate\" to get started.",
   "product_descriptions": {
       "visible": False,
       "outlets": {}
   }
})
```

The `outlet_form` state elements will bind to the form elements.

Next, add the click handler for the new button. Copy and paste this `handle_add_outlet` method into the code under the `handle_click` method:

```python
def handle_add_outlet(state):
   # Create a new base prompt for the new outlet
   new_outlet_name = state["outlet_form"]["name"]
   product_info = {**state["outlet_form"].to_dict(), **state["form"].to_dict()}
   base_prompt = user_prompt.format(**product_info)


   # Add the new base prompt to the base_prompts dictionary
   base_prompts[new_outlet_name] = base_prompt


   # Generate the product description for the new outlet
   state["message"] = f"% Generating product description for {new_outlet_name}..."
   product_description = _generate_product_description(base_prompt, state["form"].to_dict())
   state["product_descriptions"]["outlets"][new_outlet_name] = product_description


   # Update the SEO analysis
   state["message"] = "Updating SEO analysis..."
   outlets = state["product_descriptions"]["outlets"]
   state["seo_analysis"] = _generate_seo_keywords(outlets)


   state["message"] = ""
```

This method formats the input from both forms into the imported `user_prompt` and adds the formatted prompt to the `base_prompts` dictionary. It then generates the product description for the new food outlet, updates the SEO analysis, and clears the status message.

### Binding the elements and handler to the UI

Finalize your setup by binding the state elements and configuring the click handler to the UI components.

<Steps>
  <Step title="Bind text inputs to state elements">
    * **Outlet Name**: Click on the â€œOutlet nameâ€ Text Input component. In the Binding section of the component settings, set the state element to `outlet_form.name`.
    * **Character Max**: Move to the â€œCharacter maxâ€ Text Input. Update its state element binding to `outlet_form.character_max`.
  </Step>

  <Step title="Assign click handler to button">
    Click on the **Add and Generate** Button. In the Events section of the component settings, select `handle_add_outlet` for the `wf-click` event.
  </Step>

  <Step title="Configure form visibility">
    To conditionally display the form based on whether descriptions have been generated, click on the Section containing the form. In the Visibility section, choose â€œCustomâ€ and set `product_descriptions.visible` as the â€œVisibility value.â€
  </Step>
</Steps>

### Testing the finished product

To see the result of your hard work, click **Preview** in the top toolbar, enter some information into the original product description form, and click **Generate**. The â€œAdd an outletâ€ form should appear once the product descriptions have been generated. Add a new example outlet name and a character max and click â€œAdd and Generate.â€ You should see a new tab appear with your new outlet, as well as an updated SEO analysis chart.

![Finished application](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/product_desciption/pd_gen_13.png)

You can add whatever additional form inputs you wish to the outlet form, but be sure to update `user_prompt` in the `prompts.py` file using your favorite editor.

## Conclusion

Youâ€™ve now built a full application with the Writer Framework and the Writer AI module. Congratulations! This application not only demonstrates the platform's capabilities but also provides a foundation on which you can build more complex applications. To learn more, explore the rest of the Writer Framework documentation and the API documentation.


# Quickstart
Source: https://dev.writer.com/framework/quickstart



## Overview

In this guide, you'll learn how to get started with the Writer Framework by building a simple "Hello, World" application. This beginner-friendly guide will help you install the necessary tools, set up an app, and deploy it to the Writer Cloud.

## Step 1: Install Writer Framework and run the demo app

<Tip>
  Writer Framework works on Linux, Mac, and Windows. It supports Python versions 3.9.2 through 3.12. We recommend using a virtual environment.
</Tip>

<Warning>
  Python 3.13 is not yet supported.
</Warning>

<Steps>
  <Step title="Install Writer Framework">
    Use the following command to install the Writer Framework using `pip`. Open your command line interface and type:

    ```bash
    pip install writer
    ```

    This will download and install the Writer Framework and all its required dependencies.
  </Step>

  <Step title="Test installation with demo application">
    Once the installation is complete, you can verify that everything is set up correctly by running the built-in demo application. Navigate to your desired directory and type:

    ```bash
    writer hello
    ```

    This command creates a subfolder named **hello** and launches the Writer Framework, opening a visual editor accessible through a local URL displayed in your command line. This demo app illustrates the different components available in Writer Framework, helping you get familiar with the setup.
  </Step>
</Steps>

## Step 2: Create a new framework app

Now that we've tested the setup, let's create our first "Hello, World" app using the `ai-starter` template. This template showcases how quickly you can build AI-powered applications with the Writer Framework.

Use the following command to generate the app structure:

```sh
writer create hello-world --template=ai-starter
```

This will create a new app folder, **hello-world**, with the following structure:

1. `main.py` - The entry point for the app. You can import anything you need from here.
2. `.wf/` - This folder contains the UI component declarations. Maintained by the Writer Framework's visual editor.
3. `static/` - This folder contains front-end static files which you might want to distribute with your app, such as images and stylesheets.

## Step 3: Start the visual editor

To start building and customizing your app visually, use the Writer Frameworkâ€™s editor. This browser-based interface allows you to drag components, arrange layouts, and modify settings in real-time.

```sh
writer edit hello-world
```

After running this command, you'll see a local URL displayed in your command line. Open this URL in a web browser to access the editor.

<Frame caption="Writer Framework editor opens at https://localhost:4005">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/quickstart/hello-world-editor.png" />
</Frame>

<Steps>
  <Step title="Launch the Editor">
    In your terminal, enter the following command to open the editor:

    ```sh
    writer edit hello-world
    ```

    This command opens the Writer Framework editor in your browser, where youâ€™ll see a live preview of your app. The editor interface includes a **component library** on the left, a **canvas** in the center for building layouts, and a **settings panel** on the right for customizing selected components.

    <Info>
      The editor starts by default on port 4005. If you launch multiple editors in parallel and do not specify a port, Writer Framework will automatically assign the next port until reaching the limit of 4099.
    </Info>

    <Warning>
      It's not recommended to expose the Framework to the Internet. If you need to access the editor remotely, we recommend setting up an SSH tunnel. By default, requests from non-local origins are rejected as a security measure to protect against drive-by attacks.

      If you need to disable this protection, use the flag `--enable-remote-edit`.
    </Warning>
  </Step>

  <Step title="Add Components to Your Canvas">
    On the left sidebar, browse through the **Component Library** and try dragging a few components onto the **Canvas**. For example, you can add a **Text** component to display "Hello, World!" or try other components to see how they work together.

    Experiment with arranging these components on the canvas to create a simple layout.

    <Frame caption="Writer Framework launches the app at https://localhost:3005">
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/quickstart/hello-world-preview.png" />
    </Frame>
  </Step>

  <Step title="Customize Component Settings">
    With a component selected, look at the **Settings Panel** on the right side. Here, you can edit properties like text content, colors, and alignment to see how it changes the appearance and behavior of the component on the canvas.

    This panel allows you to customize components without writing any code, giving you a quick and visual way to build a frontend.
  </Step>

  <Step title="Change the App Name in main.py">
    To personalize your app further, open `main.py` in the root of your project folder. Locate the following line:

    ```python
    wf.init_state({
        "my_app": {
            "title": "AI STARTER"
        },
    })
    ```

    Change `"AI STARTER"` to something unique, like `"My First Writer App"`. Save the file, and youâ€™ll see the updated name reflected immediately in the editor.

    <Frame caption="App name updated in the Writer Framework editor">
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/quickstart/hello-world-app-name.png" />
    </Frame>
  </Step>
</Steps>

For now, this simple exploration gives you an idea of how the framework enables rapid frontend building without code. In later tutorials, like creating a [Chat assistant](/framework/chat-assistant) or a [Social post generator](/framework/social-post-generator), youâ€™ll explore more advanced components and layouts using this visual editor.

## Step 4: Run the app locally

When your app is ready, execute the `run` command, which will allow others to run, but not edit, your Framework app.

```sh
writer run hello-world
```

<Info>
  Your app starts by default on port 3005. If you launch multiple apps in parallel and do not specify a port, Writer Framework will automatically assign the next port until reaching the limit of 3099.
</Info>

You can specify a port and host. Specifying `--host 0.0.0.0` enables you to share your application in your local network.

```sh
writer run hello-world --port 5000 --host 0.0.0.0
```

## Conclusion

Congratulations! Youâ€™ve set up and configured your first app with the Writer Framework. Now, try building a [Chat assistant](/framework/chat-assistant) or a [Social post generator](/framework/social-post-generator) to put these skills into action.


# Release notes generator
Source: https://dev.writer.com/framework/release-notes-generator



In this tutorial, you'll build a release notes generator using the Writer Framework. This application will help you generate release notes as formatted HTML for software updates based on user-provided data as a CSV file. You can check out the [finished code on GitHub](https://github.com/writer/framework-tutorials/tree/main/release-notes-generator/end) to see what you'll be building.

The application consists of two main parts: the backend, which processes the uploaded CSV file and generates the release notes, and the frontend, which displays the release notes and allows users to download them.

![Finished release notes generator application](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/release_notes/release_gen_1.png)

## Setting up your project

### Creating a Writer app and getting your API key

From the Home screen, click on **Build an app**.

![Writer home screen](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/release_notes/release_gen_2.png)

Select Framework as the app type you want to create, enabling you to generate keys and build your app with the Writer Framework.

![App type selection](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/release_notes/release_gen_3.png)

On the next screen, you can edit your Writer application name at the top left. Underneath "Authenticate with an API key," click "Reveal" to view and copy your API key.

### Creating the application

Next, open your terminal and navigate to the directory where you want to create your application directory.

<Steps>
  <Step title="Set the API key environment variable">
    To pass your API key to the Writer Framework, you'll need to set an environment variable called `WRITER_API_KEY`. Here's how you can set this variable in your terminal session:

    <CodeGroup>
      ```sh On macOS/Linux
      export WRITER_API_KEY=[key]
      ```

      ```sh On Windows
      set WRITER_API_KEY=[key]
      ```
    </CodeGroup>
  </Step>

  <Step title="Clone the application">
    Run the following command to clone the `framework-tutorials` repo and navigate to the folder containing the starting point for this application.

    ```
    git clone https://github.com/writer/framework-tutorials.git
    cd framework-tutorials/release-notes-generator/start
    ```
  </Step>

  <Step title="Edit your project">
    To edit your project, run the following commands. This will bring up the console, which displays Framework-wide messages and errors, including logs from the API. By default, the Writer Framework Builder is accessible at `localhost:4005`. If this port is in use, you can specify a different port. Open this address in your browser to view your default application setup.

    <CodeGroup>
      ```bash Standard port
       writer edit .
      ```

      ```bash Custom port
       writer edit . --port=3007
      ```
    </CodeGroup>
  </Step>
</Steps>

## Introduction to the application setup

The template includes some basic code, UI setup, and files to help you get started.

### Included files

The files `prompts.py` and `html_template.py` contain helper functions for generating prompts for the AI model and formatting the output HTML, respectively.

In the `sample-input` folder, you'll find a sample CSV file that you can use to test the application.

Finally, the `custom.css` file in the `static` folder contains custom CSS styles for the application.

### Dependency imports

In `main.py`, you'll see that the dependencies are already imported at the top:

```python
import writer as wf
import writer.ai
import pandas as pd
from prompts import get_release_notes_summary_prompt, get_release_notes_desc_prompt, get_category_prompt
from html_template import format_output
```

These dependencies include the Writer Framework, the Writer AI module, and pandas for data manipulation.

### Initial UI

The template includes a basic UI setup, including a Page component with a Header component. The Header component also includes an Image. If you want to change the logo image, you can replace the `logo_image_path` variable in the state with the path to your desired image in the `static` folder.

## Initializing the application state

First, in `main.py`, set up the initial state for the application. This state will store the application's title, logo image path, file data, metrics, and processing status for each step. You'll also import a custom CSS file to style the application and create a placeholder DataFrame.

<Steps>
  <Step title="Create initial DataFrame">
    Create a placeholder DataFrame on the line above `wf.init_state`:

    ```python
    placeholder_data = {
        'Description': ['Description 1', 'Description 2', 'Description 3'],
        'Label': ['Label 1', 'Label 2', 'Label 3']
    }
    initial_df = pd.DataFrame(placeholder_data)
    ```
  </Step>

  <Step title="Initialize state">
    Update the initial state for the application at the bottom of `main.py`:

    ```python
    initial_state = wf.init_state({
        "my_app": {"title": "RELEASE NOTES GENERATOR"},
        "logo_image_path": 'static/Writer_Logo_black.svg',
        "file": {"name": "", "file_path": ""},
        "metrics": {"new_features": 0, "caveats": 0, "fixed_issues": 0, "total": 0},
        "step1": {
            "raw_csv": initial_df,
            "completed": "no",
            "generate-button-state": "yes",
            "processing-message": None,
            "styled-table": "<h3>csv table</h3>"
        },
        "step2": {
            "release-notes": None,
            "completed": "no",
            "formatted-release-notes": "notes should go here"
        },
    })
    ```
  </Step>

  <Step title="Import custom CSS">
    Import the custom CSS file below the initial state setup:

    ```python
    initial_state.import_stylesheet(".description, .list, .summary, .category ", "/static/custom.css")
    ```
  </Step>
</Steps>

## Building the file upload functionality

First, you'll build the file upload feature. Note that `prompts.py`, `html_template.py`, and `custom.css` are provided in the starting point for the application. There is also a sample CSV file in the `sample-input` folder that you can use to test the application.

### Implementing the file upload handler

To handle file uploads, you'll create a function in `main.py` that reads the uploaded CSV file, processes the data, and stores it in the application state.

<Steps>
  <Step title="Implementing a file upload handler">
    In `main.py`, create a function to handle file uploads. This function will read the uploaded CSV file, process the data, and store it in the application state.

    ```python
    def onchangefile_handler(state, payload):
        uploaded_file = payload[0]
        name = uploaded_file.get("name")
        state["file"]["name"] = name
        state["step1"]["processing-message"] = f'+File {name} uploaded successfully.'
        state["file"]["file_path"] = f"data/{name}"
        file_data = uploaded_file.get("data")
        with open(f"data/{name}", "wb") as file_handle:
            file_handle.write(file_data)
        
        data = pd.read_csv(state["file"]["file_path"])
        df = pd.DataFrame(data)
        state["step1"]["raw_csv"] = df
        state["step1"]["generate-button-state"] = "no"
    ```
  </Step>

  <Step title="Create CSV to DataFrame converter">
    Define a function to convert the CSV file to a DataFrame:

    ```python
    def _raw_csv_to_df(state):
        data = pd.read_csv(state["file"]["file_path"])
        df = pd.DataFrame(data)
        return df
    ```
  </Step>
</Steps>

### Displaying the uploaded CSV file

Next, you'll display the uploaded CSV file in the application UI.

<Steps>
  <Step title="Creating a Step Container">
    Add a Step Container component to the Page. This will contain the two steps for the application.
  </Step>

  <Step title="Create Step components">
    Drag two Step components into the Step Container. Name the first one "Load CSV file" and the second "Release notes".
  </Step>

  <Step title="Configure first Step component">
    Click on the the first Step component to select it and bring up the Properties pane. Set "Completed" to `@{step1.completed}`. This state reference will contain either "yes" or "no" based on the completion status of the step.
  </Step>

  <Step title="Add Message component">
    Within this Step, add a Message component with the message set to `@{step1.processing-message}`. Scroll down to the Visibility section of the settings. Select "Custom" and set the condition to `step1.processing-message`.
  </Step>

  <Step title="Create three-column layout">
    Add a Column Container component and add three Column components. For the first column, set the width to 0.5. For the third column, set "Content alignment (H)" to "Left" and "Content alignment (V)" to "Bottom."
  </Step>

  <Step title="Add file input">
    In the middle column, place a File Input component labeled "Please upload your CSV file". Set its `wf-file-change` handler to `onchangefile_handler`.
  </Step>

  <Step title="Add generate button">
    In the third column, add a Button labeled "Generate release notes". Set its "Disabled" property to `@{step1.generate-button-state}` and its "Icon" property to `laps`.
  </Step>

  <Step title="Add Raw CSV section">
    Under the columns, create a Section component and set the title to "Raw CSV".
  </Step>

  <Step title="Add DataFrame component">
    In this section, add a DataFrame component to display the raw CSV data. Configure its properties to use `@{step1.raw_csv}` as the data source. Toggle "Enable download," "Use Markdown," and "Wrap text" to "yes". Set the Separator color to `#d4b2f7` using the CSS tab.
  </Step>
</Steps>

Your application should now look like this:

![Release notes generator UI](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/release_notes/release_gen_4.png)

When using the sample data located in `sample-input/test-data.csv`, the Raw CSV section will display the uploaded CSV file:

![Raw CSV section](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/release_notes/release_gen_5.png)

## Generating release notes

Now that you've set up the file upload functionality, you can generate release notes based on the uploaded CSV file.

### Defining text completion functions

Using the prompts provided, define functions to get the category, release notes summary, and release notes description using AI completion. You'll use these functions to process the uploaded CSV file and generate release notes.

<Steps>
  <Step title="Create category function">
    Define a function to get the category using AI completion:

    ```python
    def _get_category(desc, label):
        prompt = get_category_prompt(desc, label)
        label = writer.ai.complete(prompt)
        return label
    ```
  </Step>

  <Step title="Create summary function">
    Define a function to get the release notes summary:

    ```python
    def _get_release_notes_summary(label, desc):
        prompt = get_release_notes_summary_prompt(label, desc)
        formatted_desc = writer.ai.complete(prompt)
        return formatted_desc
    ```
  </Step>

  <Step title="Create description function">
    Define a function to get the release notes description:

    ```python
    def _get_release_notes_desc(label, desc):
        prompt = get_release_notes_desc_prompt(label, desc)
        formatted_desc = writer.ai.complete(prompt)
        return formatted_desc
    ```
  </Step>
</Steps>

### Implementing the generate functionality

You'll next implement the ability to process the CSV and generate release notes.

<Steps>
  <Step title="Create category HTML">
    Define a function to generate HTML for the categories:

    ```python
    def _create_df_for_category(df,state):
        unique_categories = df['Primary-Category']
        formatted_output_list = list()
        for category in set(unique_categories):
            df_category = df[df['Primary-Category']==category]
            categories = {" New Feature": "new_features", " Caveat": "caveats", " Fixed Issue": "fixed_issues" }
            curr_category = categories[category]
            state["metrics"][curr_category]= df_category.shape[0]
            formatted_output = format_output(category,df_category)
            formatted_output_list.append(formatted_output)
        return "".join(formatted_output_list)
    ```
  </Step>

  <Step title="Create HTML file writer">
    Define a function to write HTML to a file:

    ```python
    def _write_html_to_file(html):
        with open("data/output-html.html", "w") as file_handle:
            file_handle.write(html)
    ```
  </Step>

  <Step title="Implement generate button handler">
    Next, create a function to handle the generate button click. This function will process the uploaded CSV file, generate release notes, and store the formatted output in the application state.

    ```python
    def handle_generate_button_click(state):
        state["step1"]["generate-button-state"] = "yes"
        state["step1"]["processing-message-isVisible"] = True
        state["step1"]["processing-message"] = "%Hang tight, preparing to process your file"

        notes_counter = 0
        df = _raw_csv_to_df(state)
        csv_row_count = df.shape[0]
        for index, row in df.iterrows():
            df.at[index,"Primary-Category"] = _get_category(label=row["Labels"], desc=row["Description"])
            df.at[index,"Release-Notes-Summary"] = _get_release_notes_summary(label=row["Labels"], desc=row["Description"])
            df.at[index,"Release-Notes-Description"] = _get_release_notes_desc(label=row["Labels"], desc=row["Description"])
            notes_counter += 1 
            state["step1"]["processing-message"] = f'%Processing {notes_counter} of {csv_row_count} Release Notes'
        
        df_temp = df[["Primary-Category","Release-Notes-Summary","Release-Notes-Description"]]
        df_sorted = df_temp.sort_values(by='Primary-Category')

        state["step2"]["release-notes"] = df_sorted
        state["step1"]["completed"] = "yes"
        state["step1"]["processing-message"] = ""

        html = _create_df_for_category(df_sorted,state)
        _write_html_to_file(html)
        state["step2"]["formatted-release-notes"] = html
        state["metrics"]["total"] = df_sorted.shape[0]

        state["step1"]["generate-button-state"] = "no"
    ```
  </Step>

  <Step title="Bind button handler to Generate button">
    Finally, click on the "Generate release notes" button in the UI builder and set its `wf-click` handler to `handle_generate_button_click`.
  </Step>
</Steps>

## Displaying the release notes

Now that you've generated the release notes, you can display them in the application UI.

### Implementing helper functions

Define helper functions to handle back button clicks, write HTML to a file and download the HTML file.

<Steps>
  <Step title="Create back button handler">
    Define a function to handle the back button click:

    ```python
    def handle_back_button_click(state):
        state["step1"]["completed"] = "no"
    ```
  </Step>

  <Step title="Create file download handler">
    Define a function to handle downloading the HTML file:

    ```python
    def handle_file_download(state):
        html_data = wf.pack_file("data/output-html.html","text/html")
        file_name = "output-html.html"
        state.file_download(html_data,file_name)
    ```
  </Step>
</Steps>

### Building the initial release notes UI

Next, you'll build the UI for the "Release notes" step.

<Steps>
  <Step title="Select 'Release notes' Step">
    To display the Release notes Step component, you'll need to double-click on it.
  </Step>

  <Step title="Add Separator">
    Inside of the Step component, add a Separator component.
  </Step>

  <Step title="Add Columns components">
    Below the Separator, add a Column Container component and a single Column component.
  </Step>

  <Step title="Add Back button">
    In the column, add a Button. Set its text to "Back" and set its `wf-click handler` to `handle_back_button_click`. Set the "Icon" property to `arrow_back`.
  </Step>
</Steps>

### Buiding tabs for Release notes display

Below the Back button, add a Tab Container component and two Tab components. Name them "Formatted release notes" and "Release notes".

#### Formatted release notes tab

In the first tab, you'll display the formatted release notes.

<Steps>
  <Step title="Add HTML component">
    In the first tab, add an HTML Element component. Set the "Element" property `div` and the "Styles" property to the following object:

    ```
    {
        "padding": "16px",
        "min-height": "64px",
        "min-width": "64px",
        "border-radius": "8px",
        "background": "white",
    }
    ```

    Finally, set the "HTML inside" property to `@{step2.formatted-release-notes}`.
  </Step>

  <Step title="Create three-column layout">
    Inside thie HTML Element component, create a three-column layout using a Column Container component and three Column components.
  </Step>

  <Step title="Add Metric components">
    In each column, add three Metric components to display new features, caveats, and fixed issues, respectively.
    Set the "Name" of these components to a single space to remove the placeholder text: ` `. Then, set the values of these components to `@{metrics.new_features}`, `@{metrics.caveats}`, and `@{metrics.fixed_issues}`. Finally, set the "Note" text to "+New Features", "+Caveats", and "+Fixed Issues" respectively. The "+" sign will display styling that indicates a positive message.
  </Step>

  <Step title="Add download button">
    Under the columns, add a Button component. Set its "Text" to "Download HTML" and its "Icon" to `download`. Then, set the `wf-click` handler to `handle_file_download`.
  </Step>
</Steps>

The Formatted release notes tab should look like this when using the sample data:

![Formatted release notes tab](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/release_notes/release_gen_1.png)

#### Release notes tab

Finally, you'll add a Dataframe component to the second tab to display the detailed release notes.

<Steps>
  <Step title="Add Metric component">
    In the second tab, start with a Metric component to show the total number of release notes generated. Set the "Name" to "Number of release notes generated" and the "Value" to `@{metrics.total}`. Delete the default value for "Note".
  </Step>

  <Step title="Add DataFrame component">
    Follow this with a DataFrame component to display the detailed release notes, setting the "Data" property to `@{step2.release-notes}`. Configure it for text wrapping, downloading, and searching capabilities. Set the Separator color to `#d4b2f7`.
  </Step>
</Steps>

The final Release notes section should look like this:

![Release notes final UI](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/release_notes/release_gen_6.png)

You can [see the finished code on GitHub](https://github.com/writer/framework-tutorials/tree/main/release-notes-generator/end) or in `framework-tutorials/release-notes-generator/end` in the `tutorials` repo you cloned at the beginning of the tutorial.

## Conclusion

By following these steps, you've created a complete Release notes generator application using Writer Framework. To learn more, explore the rest of the Writer Framework documentation and the API documentation.


# Repeater
Source: https://dev.writer.com/framework/repeater



The *Repeater* component allows you to repeat a group of components according to a list or dictionary.

## How it works

*Repeater* repeats its contents for every item of a given list or dictionary. It's similar to a `for each` construct.

Each iteration is rendered with a different **context**, a dictionary containing the key and value for the relevant item. By default, in the variables `itemId` and `item`.

### Food Selector example

![Repeater example](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/repeater.example.png)

Given the state below, the contents of *Repeater* will be repeated 3 times. For the first iteration, `itemId` will equal `Banana`, and `item` will equal `{"type": "fruit", "colour": "yellow"}`. Components inside *Repeater* will be able to access this data using references such as `@{itemId}` and `@{item.type}`.

```py
wf.init_state({
    "articles": {
        "Banana": {
            "type": "fruit",
            "colour": "yellow"
        },
        "Lettuce": {
            "type": "vegetable",
            "colour": "green"
        },
        "Spinach": {
            "type": "vegetable",
            "colour": "green"
        }
    },
    "order_list": []
})
```

## Event context

When working with *Repeater* components, you can get the context data using the `context` argument in the event handler.

Continuing with the Food Selector example above, the following handler can be linked to a *Button* â€”allowing users to add items to a list.

```py
# The event handler below adds the itemId
# of the relevant article to the order list
def handle_add_to_list(state, context):
    state["order_list"] += [context["itemId"]]
```

<Warning>
  Binding directly to context isn't possible

  Use dynamic accessors when binding inside a *Repeater*. For example, `articles[itemId].colour`. This will bind to a different property of `articles` for every `itemId`.
</Warning>


# Sample app library
Source: https://dev.writer.com/framework/sample-apps



Writer Framework lets you build a wide variety of applications across different domains. Here are some sample apps to get you started, which are all [available on GitHub](https://github.com/writer/framework-tutorials/).

<Card title="Code generator" icon="code" iconType="solid" href="https://github.com/writer/framework-tutorials/tree/main/code-generator" horizontal>
  Generate React apps editable in a code sandbox.
</Card>

<Card title="Finance content checker" icon="file-invoice-dollar" iconType="solid" href="https://github.com/writer/framework-tutorials/tree/main/finance-content-checker" horizontal>
  Tool for analyzing financial content based on compliance guidelines.
</Card>

<Card title="Finance dashboard" icon="chart-line" iconType="solid" href="https://github.com/writer/framework-tutorials/tree/main/finance-dashboard" horizontal>
  AI-powered interactive dashboard for summarizing and visualizing financial data and metrics. Check out the [app tour](https://writer.com/engineering/financial-app-writer-framework-palmyra-fin/) on our Engineering blog.
</Card>

<Card title="Localized promo dashboard" icon="globe" iconType="solid" href="https://github.com/writer/framework-tutorials/tree/main/localized-promo-dashboard" horizontal>
  Tool to generate promotional content based on uploaded demographic data.
</Card>

<Card title="Patient portal" icon="hospital-user" iconType="solid" href="https://github.com/writer/framework-tutorials/tree/main/patient-portal" horizontal>
  Uses Palmyra-Med to generate SOAP notes and extract ICD codes from patient-doctor chat.
</Card>

<Card title="Product description embedded chat" icon="comments" iconType="solid" href="https://github.com/writer/framework-tutorials/tree/main/pd-embedded-chat" horizontal>
  Use an embedded no-code chat app to chat with a Knowledge Graph about products.
</Card>

<Card title="Product description page generator" icon="file-lines" iconType="solid" href="https://github.com/writer/framework-tutorials/tree/main/pdp-generator" horizontal>
  Tool for generating formatted product description pages.
</Card>

<Card title="Release notes generator" icon="clipboard-list" iconType="solid" href="https://github.com/writer/framework-tutorials/tree/main/release-notes-generator" horizontal>
  Utility for creating formatted, downloadable release notes from CSVs containing GitLab notes. [Full tutorial here](./release-notes-generator).
</Card>


# SEO and social sharing
Source: https://dev.writer.com/framework/seo



Writer Framework provides powerful options for optimizing your application's metadata to improve SEO (Search Engine Optimization) and enhance how your content appears when shared on social networks. These options are available in the `writer.serve.configure_webpage_metadata` function available in the `server_setup.py` file.

## Page title configuration

The page title is a crucial element for your application's SEO. Web crawlers and bots will see this title without loading the full application. By default, they will see `Writer Framework`.

```python
# ./server_setup.py
writer.serve.configure_webpage_metadata(title="My Amazing App")
```

For dynamic titles, you can use a function instead of a static string. The title will be evaluated when a bot loads the page:

```python
# ./server_setup.py
def _title():
	last_news = db.get_last_news()
	return f"Last news: {last_news.title}"

writer.serve.configure_webpage_metadata(title=_title)
```

## Meta tags configuration

HTTP headers allow you to specify a title, description, and keywords that search engines will use to understand and index your content. You can configure these tags using the `meta` parameter.

```python
# ./server_setup.py
writer.serve.configure_webpage_metadata(
	title="My Amazing App",
    meta={
    	"description": "My amazing app",
    	"keywords": "WF, Amazing, AI App",
    	"author": "Amazing Company"
    }
)
```

You can also generate meta tags dynamically using a function:

```python
# ./server_setup.py
def _meta():
	last_news = db.get_last_news()
	return {
		"description": f"Last news: {last_news.title}",
		"keywords": f"{last_news.keywords}",
		"author": "Amazing Company"
	}

writer.serve.configure_webpage_metadata(meta=_meta)
```

## Social network configuration

When users share links to your application on social networks, those platforms will attempt to fetch metadata to create rich previews of your content. You can configure the OpenGraph tags to improve the appearance of your content when shared.

```python
# ./server_setup.py
writer.serve.configure_webpage_metadata(
    opengraph_tags= {
    	"og:title": "My App",
    	"og:description": "My amazing app",
    	"og:image": "https://myapp.com/logo.png",
    	"og:url": "https://myapp.com"
    }
)
```

Like meta tags, OpenGraph tags can also be generated dynamically:

```python
# ./server_setup.py
def _opengraph_tags():
	last_news = db.get_last_news()
	return {
		"og:title": f"Last news: {last_news.title}",
		"og:description": f"{last_news.description}",
		"og:image": f"{last_news.image}",
		"og:url": f"https://myapp.com/news/{last_news.id}"
	}

writer.serve.configure_webpage_metadata(opengraph_tags=_opengraph_tags)
```

By configuring your application's metadata, your application will be more visible in search engines and social networks.


# Sessions
Source: https://dev.writer.com/framework/sessions



Sessions are designed for advanced use cases, being most relevant when Framework is deployed behind a proxy.

## Session information in event handlers

You can access the session's unique id, HTTP headers and cookies from event handlers via the `session` argument â€”similarly to how `state` and `payload` are accessed. The data made available here is captured in the HTTP request that initialised the session.

The `session` argument will contain a dictionary with the following keys: `id`, `cookies` and `headers`. Values for the last two are themselves dictionaries.

```py
# The following will output a dictionary
# with the session's id, cookies and headers.
def session_inspector(session):
    print(repr(session))
```

This enables you to adapt the logic of an event to a number of factors, such as the authenticated user's role, preferred language, etc.

## Session verifiers

You can use session verifiers to accept or deny a session based on headers or cookies, thus making sure that users without the right privileges don't get access to the initial state or components.

Session verifiers are functions decorated with `wf.session_verifier` and are run every time a user requests a session. A `True` value means that the session must be accepted, a `False` value means that the session must be rejected.

```py
import writer as wf

# Users without the header x-success will be denied the session

@wf.session_verifier
def check_headers(headers):
    if headers.get("x-success") is None:
        return False
    return True
```


# Social post generator
Source: https://dev.writer.com/framework/social-post-generator



In this tutorial, you'll use the Writer Framework to build an AI-powered tool for generating social media posts and tags based on the input you provide!

The process will take only minutes using a drag-and-drop visual editor to build the user interface and Python for the back-end code.

Here's what the finished project will look like:

![Finished social post generator project](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2ab.png)

## Prerequisites

Before starting, ensure you have:

* **A Writer account:** You don't need an account to use Writer Framework, but you'll need one to use the AI module. [Sign up for a free account here](https://app.writer.com/register).
* **Python 3.9.2 or later**: Use the installer from [python.org](https://www.python.org/downloads/).
* **pip:** This command-line application comes with Python and is used for installing Python packages, including those from Writer.
* **A basic understanding of Python:** You should be familiar with the basics of the language.
* **Your favorite code editor (optional):** There's a code editor built into Writer for writing back-end code, but you can also use Visual Studio Code, Notepad++, Vim, Emacs, or any text editor made for programming if you prefer.

## Setting up your project

### Create a Writer app and get its API key

First, you'll need to create a new app within Writer.

<Steps>
  <Step title="Create the app in Writer">
    Log into Writer. From the Home screen, click on the **Build an app** button.

    ![Writer home screen](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2.png)

    The **Start building** menu will appear, presenting options for the types of apps you can create.

    Select **Framework**, located under **Developer tools**. This will create a brand new app based on Writer Framework.

    !["Start building" menu](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_3.png)
  </Step>

  <Step title="Copy your app's API key">
    On the next screen, titled **How to deploy an application**, you can get the API key for the app by clicking on the **Reveal key** button, located under the text **Authenticate with an API key**. Your complete API key will be displayed, and a "copy"Â button will appear. Click this button to copy the key; you'll use it in the next step.

    !["How to deploy an application" page](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2a.png)
  </Step>
</Steps>

### Set up your computer and create the app's project

The next step is to set up the Writer Framework environment on your computer. You'll do this by creating a directory for the project, installing dependencies, and creating the project for the application using a template.

<Steps>
  <Step title="Open your terminal application">
    Open your terminal application. On macOS and Linux, this application goes by the name *Terminal*; on Windows, you can use either *Windows PowerShell* (which is preferred) or *Command Prompt*.
  </Step>

  <Step title="Install the dependencies">
    <Note>If you already have the `writer` and `python-dotenv` packages installed on your computer, you can skip this step.</Note>

    Install the `writer` and `python-dotenv` packages by entering the following commands in your terminal application:

    ```
    pip install writer python-dotenv
    ```

    This command tells `pip`, the Python package installer, to install two packages:

    * `writer`, which provides some command-line commands and enables Python code to interact with Writer and the Writer Framework.
    * `python-dotenv`, which makes it easy to manage environment variables by loading them from a `.env` file. This one is optional for this exercise, but you might find it useful when working on larger projects.
  </Step>

  <Step title="Set the API key environment variable">
    To pass your API key to the Writer Framework, you need to set an environment variable called `WRITER_API_KEY`.

    Select your operating system and terminal application below, then copy and paste the command into your terminal application, replacing `[your_api_key]` with the API key you copied earlier:

    <CodeGroup>
      ```sh macOS/Linux (Terminal)
      export WRITER_API_KEY=[your_api_key]
      ```

      ```sh On Windows (Windows PowerShell)
      $env:WRITER_API_KEY=[your_api_key]
      ```

      ```sh On Windows (Command Prompt)
      set WRITER_API_KEY=[your_api_key]
      ```
    </CodeGroup>

    The `WRITER_API_KEY` environment variable will remain defined as long your terminal session is open (that is, until you close your terminal applicationâ€™s window).
  </Step>

  <Step title="Create the project">
    Create the project by entering this command into your terminal application:

    ```
    writer create social-post-generator --template=ai-starter
    ```

    This command sets up a new project called `social-post-generator` using a starter template called `ai-starter` so that you're not starting "from scratch."
  </Step>
</Steps>

## Build the UI

Now that you've created the project, it's time to define the UI. The Writer Framework's drag-and-drop capabilities make it easy â€”Â even if you haven't done much UI work before!

The project editor is a web application that runs on your computer and enables you to define and edit your app's user interface. Launch it by typing the following into your terminal application:

```
writer edit social-post-generator
```

You'll see a URL. Control-click it (command-click on macOS) to open it, or copy the URL and paste it into the address bar of a browser window.

The browser window will contain the project editor, which will look like this:

![Project editor](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2b.png)

You'll see the following:

* The **canvas** is in the center. It displays the app's user interface.
* The column on the left contains:
  * The **Core toolkit**, which contains all the UI components. You define the user interface by dragging components from the Toolkit and placing them on the canvas.
  * The **Component tree**, which shows the arrangement of the UI components on the canvas. It's also useful for selecting items on the canvas, especially when it has a lot of UI components.

It's time to build the UI!

<Steps>
  <Step title="Examine the header">
    Select the **Header** component by clicking it â€” it's the component at the top, containing the title **AI STARTER** and a gray area labeled **Empty Header**.

    When you click it, you'll see the **properties** panel appear on the right side of the page. This lets you view and edit the properties of the selected component.

    ![The selected header and its properties panel](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2c.png)

    The first property you'll see in the panel is the **Text** property, which defines the text that appears as the header's title. It should contain the value `@{my_app.title}`. The `@{` and `}` indicate that `my_app.title` is a variable and that its contents should be the text displayed instead of the literal text "my\_app.title". You'll set the value of this variable soon.
  </Step>

  <Step title="Clear the Section's default title">
    Select the **Section** component by clicking it â€” it's just below the **Header** component and contains the title **Section Title** and a gray area labeled **Empty Section**.

    In the **properties** panel, clear out the value of the **Title** property. This will remove the *Section*'s default title.

    ![The selected section and its properties panel](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2d.png)
  </Step>

  <Step title="Add a Text Input component">
    The user will need a place to enter words or phrases that the app will use as the basis for generating posts and tags.

    Drag a **Text Input** component â€” and note, it's **Text *Input***, not **Text** â€”  from the **Core toolkit** panel on the left (it's under **Input**, and you may need to scroll down a little to find it) and into the **Section**. Sections can act as containers for other components.

    <Note>You can search for a specific component by using the search bar at the top of the **Core toolkit** panel.</Note>

    Select the **Text Input** component. In the **properties** panel:

    * Find the **Label** property and set its value to `Topic for social posts and tags`.
    * (Optional) Feel free to add some placeholder to the *Text Input* component by setting the value of the **Placeholder** property with something like `Enter words or phrases describing your topic`.

    ![The text input component and its properties panel](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2e.png)
  </Step>

  <Step title="Add a Button component">
    Drag a **Button** component from the **Core toolkit** panel (it's under **Other**, and you may need to scroll down a little to find it) into the **Section**, directly below the **Text Input**. The user will click this button to submit their prompt.

    Select the **Button**. In the **properties** panel:

    * Set the **Text** property's value to `Generate posts`.
    * Find the **Icon** property, and set its value to `arrow_forward`.

    ![The button component and its properties panel](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2f.png)
  </Step>

  <Step title="Add a Message component">
    The process of creating social media posts and tags takes a few moments. In order to reassure the user that the app is working and hasn't crashed, it will use a **Message** component to display something reassuring while it's generating.

    Drag a **Message** component from the **Core toolkit** panel into the **Section** positioning it immediately below the **Button**.

    Select the **Message** component. In the **properties** panel:

    * Scroll down to the **Style** section and look for the **Loading** property, which sets the color of the **Message** component when it's loading.
    * Click its **CSS** button, which will cause a text field to appear below it.
    * Enter this color value into the text field: `#D4FFF2`.

    ![The message component and its properties panel](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2g.png)
  </Step>

  <Step title="Add a new Section">
    The **Section** that you were working on is for user input. Let's add a new **Section** to hold the output â€”Â the social media posts and tags the app will generate.

    Drag a **Section** component from the **Toolbox** panel and place it *inside* the **Section** that's already there, just below the **Message** component.

    <Note>That's right â€”Â **Sections** can contain other **Sections**!</Note>

    ![The new section inside the existing section](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2h.png)

    Select the **Section** you just added. In the **properties** panel:

    * Find the **Title** property and clear it its value to remove the **Section**'s title.
    * Scroll down to the **Style** section and look for the **Container background** property, which sets the **Section**'s background color.
    * Click its **CSS** button, which will cause a text field to appear below it.
    * Enter this color value into the text field: `#F6EFFD`.

    ![The new section and its properties](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2i.png)
  </Step>

  <Step title="Add a Tags component">
    Writer Framework has a number of useful components to make your apps more functional and beautiful. One of these is the **Tags** component, which can take a list of hashtags (or words, or short phrases) and display them inside colorful "bubbles" to make them stand out. This app will display the social media tags it generates in a **Tags** component.

    Drag a **Tags** component from the **Toolbox** panel and place it inside the new **Section**.

    ![The tags component](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2j.png)
  </Step>

  <Step title="Add a Separator">
    Drag a **Separator** component from the **Toolbox** panel and place it inside the new **Section**, just below the **Tags** component. This will separate the tags from the posts.

    ![The separator](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2k.png)
  </Step>

  <Step title="Add a Text component">
    Finally, drag a **Text** component from the **Toolbox** panel and position it below the **Separator**. This will hold the generated social media posts.

    ![The text component](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2l.png)
  </Step>
</Steps>

## Add the back-end code

With the UI laid out, it's time to work on the logic behind it.

The logic behind the user interface is defined in a file named `main.py`, which is in your project's directory. This file was automatically generated; you'll update the code in it to define the behavior of your app.

The simplest way to edit `main.py` is within the project editor. Click on the "toggle code" button (beside the word **Code**) near the lower left corner of the project editor page.

![Project editor with arrow pointing to toggle code button](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2m.png)

A pane with the name **Code** will appear at the bottom half of the screen, displaying an editor for the the contents of `main.py`.

![Project editor with the code editor displayed](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2n.png)

<Note>If you'd rather use a code editor instead of coding in the browser, use it to open the `main.py` file in your project's directory.</Note>

Now follow these steps:

<Steps>
  <Step title="Import libraries and load the Writer Framework API key">
    You should see the following at the start of the file:

    ```python
    import writer as wf
    import writer.ai
    ```

    Replace that code with the following:

    ```python
    import os
    import re
    import writer as wf
    import writer.ai

    # Set the API key
    wf.api_key = os.getenv("WRITER_API_KEY")
    ```

    This code imports the libraries that the application will need and then reads your Writer Framework API key in the `WRITER_API_KEY` environment variable.
  </Step>

  <Step title="Create a handler to respond to the user's input">
    When the user presses the app's **Button**, the app needs to call a function to generate and display the social media posts and tags. Find these comments in the code...

    ```python
    # Welcome to Writer Framework! 
    # This template is a starting point for your AI apps.
    # More documentation is available at https://dev.writer.com/framework
    ```

    ...and replace them with the following function:

    ```python
    def generate_and_display_posts_and_tags(state):
        print(f"Here's what the user entered: {state['topic']}")

        # Display message
        state["message"] = "% Generating social media posts and tags for you..."

        # Generate and display social posts
        prompt = f"You are a social media expert. Generate 5 engaging social media posts about {state['topic']}. Include emojis, and put a blank line between each post."
        state["posts"] = writer.ai.complete(prompt)
        print(f"Posts: {state['posts']}")

        # Generate and display hashtags
        prompt = f"You are a social media expert. Generate around 5 hashtags about {state['topic']}, delimited by spaces. For example, #dogs #cats #ducks #elephants #badgers"
        pattern = r"#\w+"
        hashtags = re.findall(pattern, writer.ai.complete(prompt))
        state["tags"] = {item: item for item in hashtags}
        print(f"Tags: {state['tags']}")

        # Hide message
        state["message"] = ""
    ```

    The `%` at the start of the string being assigned to `state["message"]` will be replaced by a â€œspinning circleâ€ progress indicator graphic in the *Message* component.

    The `pattern` variable in the `# Generate and display hashtags` section defines a regular expression pattern to search for words that begin with the `#` character. The `r` in front of the opening quote specifies that the string is a *raw string*, which means that the `\` character should be treated as a literal backslash and not as the start of an escape character sequence.

    Note that `generate_and_display_posts_and_tags()` uses `print()` functions for debugging purposes, and you can use them to get a better idea of what's happening in the function. You'll see their output in both your terminal application and in the project editor's 'log' pane (which will be covered shortly) as you use the social post generator. This output will include:

    * The topic the user entered
    * The posts generated by the LLM
    * The hashtags generated by the LLM

    The `print()` functions don't affect the operation of the social post generator in any way, and you can remove them if you wish.
  </Step>

  <Step title="Initialize the application">
    The final step is to set the application's initial state. Find this code, which should be just after the `generate_and_display_posts_and_tags()` function...

    ```python
    # Initialise the state
    wf.init_state({
        "my_app": {
            "title": "AI STARTER"
        },
    })
    ```

    ...and replace it with this:

    ```python
    # Initialize the state
    wf.init_state({
        "topic": "writing",
        "message": "",
        "tags": {},
        "posts": "",
        "my_app": {
            "title": "SOCIAL POST GENERATOR"
        }
    })
    ```

    The Writer Framework's `init_state()` method sets the initial value of `state`, a dictionary containing values that define the state of the application. The key-value pairs in `state` are how you store values used by your app and how you pass data between the back-end code and the UI.

    The code above sets the initial value of `state` so that it has these key-value pairs:

    * `topic`: A string containing the topic that the application should generate social media posts and tags for. You'll bind its value to the *Text Input* component where the user will enter the topic.
    * `message`: A string containing text of the message that will be displayed to the user while the application is generating posts and tags. You'll bind its value to the **Message** component.
    * `tags`: A list containing the hashtags generated by the LLM. You'll bind its value to the **Tags** component.
    * `posts`: A string containing the social media posts generated by the LLM. You'll bind its value to the **Text** component.
    * `my_app`: A dictionary containing values that define the application's appearance. This dictionary has a single key-value pair, `title`, which defines the text that appears as the application's title.

    <Note>For more details about the `state` variable, see our [*Application state*](https://dev.writer.com/framework/application-state#application-state) page.</Note>
  </Step>

  <Step title="Save the updated code and hide the code editor">
    Thatâ€™s all the code. If you edited the code in the browser, save it by clicking the â€œsaveâ€ button near the top right corner of the code editor.

    ![Project editor and code editor, with arrow pointing to save button](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2o.png)

    Click the "toggle code" button to hide the code editor.
  </Step>
</Steps>

## Bind the UI to the back-end code

You've built the UI and written the code behind it. Let's connect the two! Go back to the browser window with the project editor and do the following:

<Steps>
  <Step title="Observe that the heading at the top of the app is now 'SOCIAL POST GENERATOR'">
    Earlier, you saw that the **Header** component's **Text** property was set to `@{my_app.title}`, a value in the app's `state` variable. You changed this value when you update the call to the Writer Framework's `init_state()` method.
  </Step>

  <Step title="Bind the Text Input component to the 'state' variable's 'topic' key">
    Select the **Text Input** component. In the **properties** panel, scroll down to the **Binding** section and find the **State element** property. This is where you specify the `state` variable key whose value will be connected to the **Text Input** component. Set its value to `topic`.

    ![Updating the text input component's state element property](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2p.png)
  </Step>

  <Step title="Connect the Button component to the 'generate_and_display_posts_and_tags()' function">
    Select the **Button** component. In the **properties** panel, scroll down to the **Events** section and find the **`wf-click`** property. This is where you specify the function to call when the user clicks the button â€” set its value to `generate_and_display_posts_and_tags`.

    ![Updating the button's wf-click property](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2q.png)
  </Step>

  <Step title="Bind the Message component to the 'state' variable's 'message' key">
    Select the **Message** component. In the **properties** panel, find the **Message** property, which specifies the content of the **Message** component. Set its value to `@{message}`.

    ![Updating the message's message property](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2r.png)
  </Step>

  <Step title="Bind the Tags component to the 'state' variable's 'tags' key.">
    Select the **Tags** component. In the **properties** panel:

    * Find the **Tags** property, which specifies the source of the tags that the component will display.
    * Click its **JSON** button.
    * In the text field below the **JSON** button, set the **Tags** property's value to `@{tags}`.

    ![Updating the tags component's tags property](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2s.png)
  </Step>

  <Step title="Bind the Text component to the 'state' variable's 'posts' key">
    Select the **Text** component. In the **properties** panel:

    * Find the **Text** property, which specifies the content of the **Text** component. Set its value to `@{posts}`.
    * Set the **Use Markdown** property to **yes**.

    ![Updating the text component's properties](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2t.png)
  </Step>

  <Step title="Set the visiblity of the Section component containing the Tags and Text components based on the 'state' variable's 'posts' key">
    Select the **Section** component containing the **Tags** and **Text** components. In the **properties** panel:

    * Scroll to the **Visibility** property at the bottom.
    * Click on the **Custom** button.
    * In the **Visibility value** field, set the value to `posts`. This will cause the **Section** to be visible only when the `state` variable's `posts` key has a non-empty value.

    ![Updating the inner section's visibility property](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2u.png)
  </Step>
</Steps>

## Test the application

You've completed all the steps to make a working social post generator, and you can try using it right now, even while editing the user interface!

Enter a topic into the **Topic for social posts and tags** text field, then click the **Generate Posts** button\* *twice* â€” the first time will cause the **properties** panel to appear, and the second click will register as a click. You'll know that you've clicked the button when you see the **Message** component display the text â€œGenerating social media posts and tags for you...â€

![Waiting for the generator to finish while the message component displays its message](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2v.png)

...and soon after that, you should see some results:

![The results](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2w.png)

To get a better sense of what the experience will be like for the user, switch to the preview by changing the edit mode (located near the upper left corner of the page) from *UI* mode to *Preview* mode by selecting the **Preview** option:

![The project editor with an arrow pointing to the Preview button](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2x.png)

Hereâ€™s what the app looks like in *Preview* mode:

![The working social post generator, with the project editor in "Preview" mode](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2y.png)

You can see the output of any `print()` functions and error messages by clicking on the **Log** button located near the upper right corner of the page:

![The social post generator with an arrow pointing to the Log button](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2z.png)

Hereâ€™s what the app looks like when displaying the log:

![The social post generator, with the log pane displayed](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2aa.png)

It's very helpful to be able to test the application while editing it. As you continue to work with Writer Framework, you'll find yourself alternating between making changes to your application and testing those changes without having to leave the project editor.

## Run the application locally

Once you've tested the application, it's time to run it locally.

Switch back to your terminal application. Stop the editor with ctrl-c, then run the application by entering the following command:

```
writer run social-post-generator
```

Note that the command starts with `writer run` as opposed to `writer edit`. This launches the application as your users will see it, without any of the editing tools. Even though you can preview your applications in the project editor, it's still a good idea to test it by running it on your computer, outside the project editor, before deploying it.

You'll be able to access the application with your browser at the URL that appears on the command line. It should look like this:

![Finished social post generator project](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/tutorial/social_post/sp_gen_2ab.png)

<Note>The Writer editor, which you launched with `writer edit social-post-generator`, and your application, which you launched with `writer run social-post-generator`, run  on the same URL, but on different *ports* (specified by the number after the `:` character at the end of the URL).</Note>

## Conclusion

That's it â€” you've built a functional social post generator using the Writer Framework!

Feel free to modify this project! The Writer platform is flexible enough for you to customize, extend, and evolve your application into something completely different! To find out what else you can do, check out the documentation for [Writer Framework](https://dev.writer.com/framework/introduction) and the [Writer API](https://dev.writer.com/api-guides/introduction).


# State schema
Source: https://dev.writer.com/framework/state-schema



Schema declarations on the [Application state](./application-state) allows Framework to handle complex serialisation
scenarios, while also allowing your IDE and toolchains to provide autocomplete and type checking.

## Schema declaration

```python
import writer as wf

class AppSchema(wf.WriterState):
    counter: int

initial_state = wf.init_state({
    "counter": 0
}, schema=AppSchema)

# Event handler
# It receives the session state as an argument and mutates it
def increment(state: AppSchema):
    state.counter += 1
```

Accessing an attribute by its key is always possible.

```python
def increment(state: AppSchema):
    state["counter"] += 1
```

Attributes missing from the schema remain accessible by their key.

```python
initial_state = wf.init_state({
    "counter": 0,
    "message": None
}, schema=AppSchema)

def increment(state: AppSchema):
    state['message'] = "Hello pigeon"
```

## Schema composition

Schema composition allows you to model a complex Application state.

```python
class MyappSchema(wf.State):
    title: str

class AppSchema(wf.WriterState):
    my_app: MyappSchema
    counter: int

initial_state = wf.init_state({
    "counter": 0,
    "my_app": {
        "title": "Nested value"
    }
}, schema=AppSchema)
```

## Calculated properties

Calculated properties are updated automatically when a dependency changes.
They can be used to calculate values derived from application state.

```python
class MyAppState(wf.State):
  counter: List[int]

class MyState(wf.WriterState):
  counter: List[int]

  @wf.property(['counter', 'app.counter'])
  def total_counter(self):
    return sum(self.counter) + sum(self.app.counter)

initial_state = wf.init_state({
    "counter": 0,
    "my_app": {
        "counter": 0
    }
}, schema=MyState)
```

## Multi-level dictionary

Some components like *Vega Lite Chart* require specifying a graph in the form of a multi-level dictionary.

A schema allows you to specify that an attribute which contains a dictionary
must be treated as a dictionary, rather than as a group of state.

```python
class AppSchema(wf.WriterState):
    vegas_graph: dict

# Without schema, this handler is execute only once
def handle_vega_graph(state: AppSchema):
    graph = state.vega_graph
    graph["data"]["values"][0]["b"] += 1000
    state.vega_graph = graph
    
initial_state = wf.init_state({
    "vegas_graph": {
        "data": {
            "values": [
                {"a": "C", "b": 2}, {"a": "C", "b": 7}, {"a": "C", "b": 4},
                {"a": "D", "b": 1}, {"a": "D", "b": 2}, {"a": "D", "b": 6},
                {"a": "E", "b": 8}, {"a": "E", "b": 4}, {"a": "E", "b": 7}
            ]
        },
        "mark": "bar",
        "encoding": {
            "x": {"field": "a", "type": "nominal"},
            "y": {"aggregate": "average", "field": "b", "type": "quantitative"}
        }
    },
}, schema=AppSchema)
```

## Type checking

A schema allows you to check the integrity of your back-end using the type system.
The code below will raise an error with mypy.

```bash
$ mypy apps/myapp/main.py
apps/myapp/main.py:7: error: "AppSchema" has no attribute "countr"; maybe "counter"?  [attr-defined] 
```

Here is the code, can you spot the error ?

```python
import writer as wf

class AppSchema(wf.WriterState):
    counter: int

def increment(state: AppSchema):
    state.countr += 1

initial_state = wf.init_state({
    "counter": 26,
}, schema=AppSchema)
```


# Stylesheets
Source: https://dev.writer.com/framework/stylesheets



The appearance of your application can be fully customised via CSS stylesheets. These are dynamically linked during runtime and can be switched from the back-end, targeting all or specific sessions.

## Importing a stylesheet

Stylesheet imports are triggered via Framework's `mail`, similarly to other features discussed in [Backend-initiated actions](/framework/backend-initiated-actions). When the import is triggered, the front-end downloads the specified stylesheet and creates a `style` element with its contents.

The `import_stylesheet` method takes the `stylesheet_key` and `path` arguments. The first works as an identifier that will let you override the stylesheet later if needed. The second is the path to the CSS file.The path specified needs to be available to the front-end, so storing it in the `/static` folder of your app is recommended.

The following code imports a stylesheet when handling an event.

```py
def handle_click(state):
    state.import_stylesheet("theme", "/static/custom.css")
```

In many cases, you'll want to import a stylesheet during initialisation time, for all users. This is easily achievable via the initial state, as shown below.

```py
initial_state = wf.init_state({
    "counter": 1
})

initial_state.import_stylesheet("theme", "/static/custom.css")
```

<Tip>
  Use versions to avoid caching. During development time, stylesheets may be cached by your browser, preventing updates from being reflected. Append a querystring to bust the cache, e.g. use `/static/custom.css?3`.
</Tip>

## Applying CSS classes

You can use the property *Custom CSS classes* in the Builder's *Component Settings* to apply classes to a component, separated by spaces. Internally, this will apply the classes to the root HTML element of the rendered component.

![Stylesheets - Component Settings](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/stylesheets.component-settings.png)

## Tips for effective stylesheets

The CSS code for the class used earlier, `bubblegum`, can be found below. Note how the `!important` flag is used when targetting style attributes that are configurable via the Builder. If the flag isn't included, these declarations will not work, because built-in Framework styling is of higher specificity.

```css
.bubblegum {
    background: #ff63ca !important;
    line-height: 1.5;
    transform: rotate(-5deg);
}

/* Targeting an element inside the component root element */
.bubblegum > h2 {
    color: #f9ff94 !important;
}
```

<Warning>
  Component structure may change. When targeting specific HTML elements inside components, take into account that the internal structure of components may change across Framework versions.
</Warning>

Alternatively, you can override Framework's style variables. This behaves slightly differently though; style variables are inherited by children components. For example, if a *Section* has been assigned the `bubblegum` class, its children will also have a pink background by default.

```css
.bubblegum {
    --containerBackgroundColor: #ff63ca;
    --primaryTextColor: #f9ff94;
    line-height: 1.5;	
    transform: rotate(-5deg);
}
```

The class can be used in *Component Settings*. If the stylesheet is imported, the effect will be immediate. In case the stylesheet has been modified since imported, it'll need to be imported again.

![Stylesheets - Applied Classes](https://mintlify.s3.us-west-1.amazonaws.com/writer/framework/images/stylesheets.applied-classes.png)

## Targeting component types

Framework components have root HTML elements with a class linked to their type. For example, *Dataframe* components use the class *CoreDataframe*. When writing a stylesheet, you can target all *Dataframe* components as shown below.

```css
.CoreDataframe {
    line-height: 2.0;
}
```

## Implementing themes

It's possible to switch stylesheets during runtime, by specifying the same `stylesheet_key` in subsequent calls. This allows you to implement a "theme" logic if desired, targeting the whole or a specific part of your app.

```py
def handle_cyberpunk(state):
    state.import_stylesheet("theme", "/static/cyberpunk_theme.css")

def handle_minimalist(state):
    state.import_stylesheet("theme", "/static/minimalist_theme.css")
```


# Testing
Source: https://dev.writer.com/framework/testing



Testing a Framework application is easy. Given that event handlers are plain Python functions that take arguments such as `state` and `payload`, you can inject your own and test whether the outcome is correct. This section will use `pytest` examples.

## State

### Accessing the initial state

To get started, import your app's entry point, `main`. This will initialise state and make event handlers available. The initial state is available in the module, at `main.wf.initial_state` provided you imported `writer` as `wf`.

### Creating states

For testing purposes, you can create your own state using the `WriterState` class in `writer.core`. Pass a dictionary when constructing it.

```py
from writer.core import WriterState

artificial_state = WriterState({
    "a": 3,
    "b": 6
})
```

## Example

The code of a Framework application basically consists of two things:

1. Initial state
2. Event handlers

It's straightforward to test both, as shown below.

### The app

```py
import writer as wf

def handle_multiplication(state):
    state["n"] = state["a"]*state["b"]

wf.init_state({
    "counter": 0,
    "a": 0,
    "b": 0
})
```

### The tests

```py
from writer.core import WriterState
import main


class TestApp:

    initial_state = main.wf.initial_state
    artificial_state = WriterState({
        "a": 3,
        "b": 2
    })

    def test_counter_must_start_from_zero(self):
        assert self.initial_state["counter"] == 0

    def test_handle_multiplication(self):
        main.handle_multiplication(self.artificial_state)
        assert self.artificial_state["n"] == 6

```


# Account management
Source: https://dev.writer.com/home/account_management



AI Studio has four available user roles based on what parts of the agent creation building process those users will be performing.

These roles are:

1. **View-only:** Get view-only access to your organization's resources such as agents, voices, and Knowledge Graphs (KGs). This role can't make changes across AI Studio.
2. **Individual builder:** Build and maintain your agents, voices, and KGs.
3. **Full access:** Manage deployments across your organization, and create and maintain API keys and Framework agents.
4. **Org admin:** Manage both people and billing.

| Feature                                               | View only | Individual builder | Full access | Org admin + Full access |
| ----------------------------------------------------- | --------- | ------------------ | ----------- | ----------------------- |
| View no-code agents                                   | âœ…         | âœ…                  | âœ…           | âœ…                       |
| View templates                                        | âœ…         | âœ…                  | âœ…           | âœ…                       |
| Create agent from template                            | âŒ         | âœ…                  | âœ…           | âœ…                       |
| Duplicate existing no-code agent                      | âŒ         | âœ…                  | âœ…           | âœ…                       |
| Create no code agent                                  | âŒ         | âœ…                  | âœ…           | âœ…                       |
| Delete draft agent - created by self                  | âŒ         | âœ…                  | âœ…           | âœ…                       |
| Delete draft agent - created by anyone                | âŒ         | âŒ                  | âœ…           | âœ…                       |
| Modify no code agent (draft) - created by self        | âŒ         | âœ…                  | âœ…           | âœ…                       |
| Modify any no code agent                              | âŒ         | âŒ                  | âœ…           | âœ…                       |
| Deploy no code agent (embed snippet or to Writer)     | âŒ         | âŒ                  | âœ…           | âœ…                       |
| Push changes (deploy current draft of existing agent) | âŒ         | âŒ                  | âœ…           | âœ…                       |
| Regenerate embed token for no code agent              | âŒ         | âŒ                  | âœ…           | âœ…                       |
| API keys (create, revoke, view secret, etc)           | âŒ         | âŒ                  | âœ…           | âœ…                       |
| Framework agents (create, revoke, view secret, etc)   | âŒ         | âŒ                  | âœ…           | âœ…                       |
| Open agents in playground & copy playground URL       | âœ…         | âœ…                  | âœ…           | âœ…                       |
| Enable/disable playground - agent created by self     | âŒ         | âœ…                  | âœ…           | âœ…                       |
| Enable/disable playground - all agents                | âŒ         | âŒ                  | âœ…           | âœ…                       |
| Create Knowledge Graph                                | âŒ         | âœ…                  | âœ…           | âœ…                       |
| Create Voice                                          | âŒ         | âœ…                  | âœ…           | âœ…                       |
| Modify/delete KG - created by self                    | âŒ         | âœ…                  | âœ…           | âœ…                       |
| Modify/delete Voice - created by self                 | âŒ         | âœ…                  | âœ…           | âœ…                       |
| Modify/delete KG - created by anyone                  | âŒ         | âŒ                  | âœ…           | âœ…                       |
| Modify/delete Voice - created by anyone               | âŒ         | âŒ                  | âœ…           | âœ…                       |
| Invite user to AI Studio                              | âŒ         | âŒ                  | âŒ           | âœ…                       |
| Delete AI Studio user                                 | âŒ         | âŒ                  | âŒ           | âœ…                       |
| Change user AI Studio roles                           | âŒ         | âŒ                  | âŒ           | âœ…                       |
| CRUD Billing details                                  | âŒ         | âŒ                  | âŒ           | âœ…                       |
| View analytics (when released)                        | âœ…         | âœ…                  | âœ…           | âœ…                       |


# Deployment options
Source: https://dev.writer.com/home/deployment_options



Writerâ€™s platform is purpose-built for the enterprise, designed to provide security, compliance, and scalability to support AI deployments at an enterprise scale. We currently offer two platform deployment options: a standard, default option, and dedicated deployment at a fee. Each option comes with tailored features to suit diverse operational needs.

In both deployment models, Writer prioritizes data privacy and rigorous protection standards. We offer fully managed application lifecycle management, including monitoring, scaling, and high availability (99.9% uptime). We also adhere to global privacy laws and security standards such as GDPR, CCPA, SOC 2 Type II, PCI, and HIPAA.

Across all deployments, customer data is:

* Encrypted in transit and at rest
* Retained only for the duration necessary to fulfill service requirements
* Not used for model training, testing, or improvements

To learn more about deploying Writer apps, read our [AI Studio app deployment guide](https://dev.writer.com/framework/cloud-deploy#deploy-to-writer-cloud).

<Tabs>
  <Tab title="Standard Managed Deployment">
    <Card title="Ideal for" icon="shield-check" iconType="regular" color="#00a651">
      Organizations seeking a streamlined, secure, scalable, and cost-effective deployment with minimal management required.
    </Card>

    ### Features

    <ul>
      <li>Faster time-to-market with a fully integrated platform and out-of-the-box solution</li>
      <li>Application-level data isolation and encryption both at rest and in-transit</li>
      <li>Scalability and cost efficiency, with optimized resource allocation across customers</li>
    </ul>
  </Tab>

  <Tab title="Dedicated Managed Deployment">
    <Card title="Ideal for" icon="key" iconType="regular" color="#ff7f50">
      Organizations with specific data privacy, security, and compliance requirements, or AI workflows involving sensitive data handling or access controls.
    </Card>

    ### Features

    <ul>
      <li>Cloud project-level isolation and dedicated API platform with isolated compute, storage, and network</li>
      <li>Dedicated encryption key for cloud resources with a bring-your-own encryption key option</li>
      <li>Option to use Private Connect for accessing Writer in the same cloud region as customer workloads</li>
      <li>Custom domain support available</li>
    </ul>
  </Tab>
</Tabs>


# Development options
Source: https://dev.writer.com/home/development_options



<Tip>
  Need help building? Writer has an in-house solutions team that can build custom
  AI agents for you. **[Contact our sales team](https://go.writer.com/contact-sales)**
</Tip>

While each development environment is powered by the Writer generative AI platform, they differ in code capabilities, customization options, and use case support.

## Development options comparison

You can determine which path is right for you by thinking about what you want to achieve and your technical background:

| Platform         | Best for                                                     | Coding required                                                               | Customization scope                                                                           |
| :--------------- | :----------------------------------------------------------- | :---------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------- |
| No-code builder  | Agents with text generation, chat, and research capabilities | None. Get started fast with prompts and zero coding                           | Easy, and flexible customization. Chain prompts, set outputs, and adjust variables with ease. |
| Writer Framework | Web-based custom agents, ideal for Python developers         | Intermediate to Advanced. Customize with Python (flexible for advanced users) | Extensive. Custom components, HTML, iFrame, pages.                                            |
| Writer API/SDKs  | Embedding AI into existing tech stacks or new languages      | Advanced. Full flexibility, integrate in any codebase                         | Unlimited. Full API access, complete customization                                            |

## Choose your development path

<Tabs>
  <Tab title="No-code">
    <Check>
      No-code tools are ideal for business users who want to quickly build an AI agent without writing any lines of code.
    </Check>

    **With the No-code builder, you can:**

    * Build AI agents using a visual editor
    * Build agents with content generation or editing capabilities
    * Create internal tools for content teams
    * Create agents with chat capabilities that can also connect to a Knowledge Graph of your data
    * Create agents that can research, search the web, and prepare reports
    * Integrate any of the Palmyra LLMs

    ### Quickstart guides

    To start building, follow a quickstart for your specific use case:

    * [Text generation](/no-code/text-generation)
    * [Chat](/no-code/chat)
    * [Research](/no-code/research)

    ### Example use cases

    <AccordionGroup>
      <Accordion title="Knowledge assistants" icon="book" iconType="regular">
        Using [Knowledge Graph](https://writer.com/product/graph-based-rag/), our graph-based RAG solution, you can build chat assistants to quickly ask questions using your data sources.
      </Accordion>

      <Accordion title="Campaign workflow automation" icon="arrow-progress" iconType="regular">
        Automate an entire campaign workflow and generate all launch assets from a single messaging document or GTM presentation.
      </Accordion>
    </AccordionGroup>

    <div class="button-wrapper">
      <a class="link" href="https://app.writer.com/aistudio"><button class="button primary-button button--arrow" id="home-button">Start building</button></a>
      <a class="link" href="/no-code"><button class="button secondary-button button--arrow" id="home-button">**Learn more**</button></a>
    </div>
  </Tab>

  <Tab title="Writer Framework">
    <Check>
      Writer Framework is ideal for Python engineers who want to quickly build an AI-powered agent with a visual editor and extensible Python backend.
    </Check>

    **With Writer Framework, you can:**

    * Build AI agents using a drag-and-drop visual editor for the frontend, and write backend code in Python
    * Use external data, like APIs, to bring in information from other sources
    * Handle complex user input and custom logic
    * Quickly analyze and visualize data using an LLM
    * Easily integrate Writer platform capabilities like Knowledge Graphs and tool calling using the AI module

    **Things to know:**

    * Install with `pip install writer` (a standard Python package)
    * UI is saved as JSONL files, so you can version it with the rest of the application.
    * Two ways to edit the UI: Using your local code editor for instant refreshes or the provided web-based editor
    * See live updates while editingâ€”no need to hit 'Preview'
    * **Note**: You will need an API key if you want to use Writer's LLMs and other advanced capabilities in the Writer framework. [Follow the instructions here to sign up for AI Studio and get your Framework API key](https://dev.writer.com/api/quickstart#generate-a-new-api-key).

    ### Getting started resources

    * [Writer Framework Quickstart](/framework/quickstart)
    * [Build a social post generator](/framework/social-post-generator)
    * [Build a chat assistant](/framework/chat-assistant)

    ### Example use cases

    <AccordionGroup>
      <Accordion title="Finance content checker" icon="file-invoice-dollar" iconType="solid">
        Tool for analyzing financial content based on compliance guidelines.
        <a href="https://github.com/writer/framework-tutorials/tree/main/finance-content-checker">Get the code</a>.
      </Accordion>

      <Accordion title="Finance dashboard" icon="chart-line" iconType="solid">
        AI-powered interactive dashboard for summarizing and visualizing financial data and metrics.
        <a href="https://github.com/writer/framework-tutorials/tree/main/finance-dashboard">Get the code</a>.
        Check out the <a href="https://writer.com/engineering/financial-app-writer-framework-palmyra-fin/">app tour</a> on our Engineering blog.
      </Accordion>

      <Accordion title="Localized promo dashboard" icon="globe" iconType="solid">
        Tool to generate promotional content based on uploaded demographic data.
        <a href="https://github.com/writer/framework-tutorials/tree/main/localized-promo-dashboard">Get the code</a>.
      </Accordion>

      <Accordion title="Patient portal" icon="hospital-user" iconType="solid">
        Uses Palmyra-Med to generate SOAP notes and extract ICD codes from patient-doctor chat.
        <a href="https://github.com/writer/framework-tutorials/tree/main/patient-portal">Get the code</a>.
      </Accordion>

      <Accordion title="Product description embedded chat" icon="comments" iconType="solid">
        Use an embedded no-code chat app to chat with a Knowledge Graph about products.
        <a href="https://github.com/writer/framework-tutorials/tree/main/pd-embedded-chat">Get the code</a>.
      </Accordion>

      <Accordion title="Product description page generator" icon="file-lines" iconType="solid">
        Tool for generating formatted product description pages.
        <a href="https://github.com/writer/framework-tutorials/tree/main/pdp-generator">Get the code</a>. View the <a href="/framework/product-description-generator">full tutorial here</a>.
      </Accordion>

      <Accordion title="Release notes generator" icon="clipboard-list" iconType="solid">
        Utility for creating formatted, downloadable release notes from CSVs containing GitLab notes.
        <a href="https://github.com/writer/framework-tutorials/tree/main/release-notes-generator">Get the code</a>.
        View the <a href="/framework/release-notes-generator">full tutorial here</a>.
      </Accordion>
    </AccordionGroup>

    For more sample applications, explore the <a href="/framework/sample-apps">sample app library</a>.

    <div class="button-wrapper">
      <a class="link" href="https://app.writer.com/aistudio"><button class="button primary-button button--arrow" id="home-button">Start building</button></a>
      <a class="link" href="/framework"><button class="button secondary-button button--arrow" id="home-button">**Learn more**</button></a>
    </div>
  </Tab>

  <Tab title="Writer API & SDKs">
    <Check>
      Writer API and SDKs are ideal for engineers who want to embed generative AI into their own stack or access the Writer platform via an API, regardless of the programming language.
    </Check>

    **With the Writer APIs, you can:**

    * Use chat and completion APIs to build custom apps, or build custom integrations with your existing tech stack.
    * Create knowledge graphs using your own files and documents, allowing you to build intelligent Q\&A systems, content recommendation engines, and document retrieval systems that understand context.
    * Extend the LLM's functionality by enabling it to call your custom functions with tool calling. The model can use these functions to fetch real-time data or perform calculations when generating responses.
    * Use the RESTful API with any language you prefer, or use our Python SDK or Node SDK.
    * **Note:** You will need an API key to use Writer APIs/SDKs. [Follow the instructions here to get your API key](https://dev.writer.com/api/quickstart#generate-a-new-api-key).

    ### Getting started resources

    * [API Quickstart](/api-guides/quickstart)
    * [Getting started with Writer SDKs](https://dev.writer.com/api/sdks)
      * [Python SDK](https://pypi.org/project/writer-sdk/) (`pip install writer-sdk`)
        * We also have several [Python cookbooks](https://github.com/writer/cookbooks) available to help you get started with common tasks.
      * [Node SDK](https://www.npmjs.com/package/writer-sdk) (`npm install writer-sdk`)

    ### Guides

    * [Text generation](/api-guides/text-generation)
    * [Chat completion](/api-guides/chat-completion)
    * [Knowledge Graph](/api-guides/knowledge-graph)
    * [Applications API](/api-guides/applications)
    * [Tool calling](/api-guides/tool-calling)
    * [Knowledge Graph chat](/api-guides/kg-chat)

    ### Example use cases

    <AccordionGroup>
      <Accordion title="Integrated chat assistant" icon="code" iconType="regular">
        Embed a chat app into an existing tool or service.
      </Accordion>

      <Accordion title="Integrated text completion" icon="text" iconType="regular">
        Add text completion capabilities to an existing tool or service your company already uses.
      </Accordion>
    </AccordionGroup>

    <div class="button-wrapper">
      <a class="link" href="https://app.writer.com/aistudio"><button class="button primary-button button--arrow" id="home-button">Start building</button></a>
      <a class="link" href="/api-guides"><button class="button secondary-button button--arrow" id="home-button">**Learn more**</button></a>
    </div>
  </Tab>
</Tabs>


# Writer AI Studio
Source: https://dev.writer.com/home/introduction

The fastest way to build AI agents

export const capabilities_2 = " Text input & "

export const contextWindow_2 = "32k"

export const inputPrice_2 = "5.00"

export const outputPrice_2 = "12.00"

export const capabilities_1 = " Text input & "

export const contextWindow_1 = "128k"

export const inputPrice_1 = "5.00"

export const outputPrice_1 = "12.00"

export const capabilities_0 = " Text input & "

export const contextWindow_0 = "128k"

export const inputPrice_0 = "5.00"

export const outputPrice_0 = "12.00"

<CardGroup cols={3}>
  <Card
    title="No-code agents"
    icon={
<img
  src="https://img.writer.com/app-images/No-code.svg"
  alt="No-code"
  class="large-icon"
/>
}
  >
    Automate repetitive tasks, generate content, or answer questions about company data.

    <br />

    [Build with No-code](/no-code/introduction) â†’
  </Card>

  <Card
    title="Writer Framework"
    icon={
<img
  src="https://img.writer.com/app-images/Writer-framework.svg"
  alt="Writer framework"
  class="large-icon"
/>
}
  >
    Build feature-rich agents with an open-source Python framework fully integrated with Writer.

    <br />

    [Build with Framework](/framework/quickstart) â†’
  </Card>

  <Card
    title="API and SDKs"
    icon={
<img
  src="https://img.writer.com/app-images/Writer-API.svg"
  alt="Writer API"
  class="large-icon"
/>
}
  >
    Integrate Writer generative AI technology into apps or services within your own stack.

    <br />

    [Build with API and SDKs](/api-guides/quickstart) â†’
  </Card>
</CardGroup>

Each option offers different levels of coding and customization, so you can choose what fits your project best.

â†’ Explore the [development options guide](/home/development_options) to learn more.

## Explore our models

Whatever option you choose, you get access to Writer Palmyra models, offering a range of capabilities for content generation, editing, and automation.

<CardGroup cols={3}>
  <Card title="Palmyra X 004" icon="square-1" color="currentColor">
    Our latest and most advanced model with a large context window

    <br />

    <ul class="no-bullet">
      <li>
        <Icon icon="star" iconType="regular" color="currentColor" /> {capabilities_0} output
      </li>

      <li>
        <Icon icon="ruler-vertical" iconType="regular" color="currentColor" /> {contextWindow_0} context
        window
      </li>

      <li>
        <Icon icon="circle-dollar" iconType="regular" color="currentColor" />  **Input**: \${inputPrice_0} â†’
        **Output**: \${outputPrice_0}
      </li>
    </ul>
  </Card>

  <Card title="Palmyra Fin" icon="square-2" color="currentColor">
    Our finance domain specialized model; first model to pass the CFA exam

    <br />

    <ul class="no-bullet">
      <li>
        <Icon icon="star" iconType="regular" color="currentColor" /> {capabilities_1} output
      </li>

      <li>
        <Icon icon="ruler-vertical" iconType="regular" color="currentColor" /> {contextWindow_1} context
        window
      </li>

      <li>
        <Icon icon="circle-dollar" iconType="regular" color="currentColor" />  **Input**: \${inputPrice_1} â†’
        **Output**: \${outputPrice_1}
      </li>
    </ul>
  </Card>

  <Card title="Palmyra Med" icon="square-3" color="currentColor">
    Our most sophisticated model for delivering accurate medical analysis

    <br />

    <ul class="no-bullet">
      <li>
        <Icon icon="star" iconType="regular" color="currentColor" /> {capabilities_2} output
      </li>

      <li>
        <Icon icon="ruler-vertical" iconType="regular" color="currentColor" /> {contextWindow_2} context
        window
      </li>

      <li>
        <Icon icon="circle-dollar" iconType="regular" color="currentColor" />  **Input**: \${inputPrice_2} â†’
        **Output**: \${outputPrice_2}
      </li>
    </ul>
  </Card>
</CardGroup>

â†’ Explore all of our [models](/home/models).

## Where to go for help

<CardGroup cols={3}>
  <Card title="Help center" icon="headset" href="https://support.writer.com/">
    Need help with billing, account management, or enterprise support? Visit our help center.
  </Card>

  <Card title="Developer feedback" icon="envelope" href="mailto:dev-feedback@writer.com">
    Stuck on something? Have feedback on the docs? Send us an email.
  </Card>

  <Card title="Writer Framework issues" icon="github" href="https://support.writer.com/">
    Bug or feature request for Writer Feedback? Submit an issue on GitHub.
  </Card>
</CardGroup>


# Language support
Source: https://dev.writer.com/home/language_support



Writer Palmyra LLM is designed to support over 30 languages, including Arabic, French, Spanish, Hindi, Simplified Chinese, Traditional Chinese, and more. This page provides an overview of our capabilities, performance benchmarks, and prompting examples on how to leverage these features.

When it comes to multi-language capabilities, there are two primary categories to consider: generation and translation. Generation typically refers to the ability to understand/create content, answer questions, and converse, all within the same language. Translation typically refers to the ability to transform text to and from English, where either the input or output language is English.

On this page, we display two of the many benchmarks we use to evaluate multi-language performance in our Palmyra LLMs. Writer Palmyra has the highest performance of any production LLM in the Holistic Evaluation of Language Models (HELM), an LLM evaluation framework developed by Stanford CRFM to serve as a living benchmark for the community, continuously updated with new scenarios, metrics, and models. While there are limited benchmarks available for evaluating text generation and translation in different languages, we have achieved some of the highest scores in both MMLU and BLEU for other languages.

One benchmark that Writer uses to evaluate text generation performance is [MMLU](https://arxiv.org/abs/2009.03300) (Massive Multitask Language Understanding). The [MLMM evaluation](https://arxiv.org/pdf/2307.16039.pdf) covers 57 tasks including elementary mathematics, U.S. history, computer science, law, and more. To attain high accuracy on this test, models must possess extensive world knowledge and problem solving ability.

One benchmark that Writer uses to evaluate text translation performance is [BLEU](https://aclanthology.org/P02-1040.pdf) (Bilingual Evaluation Understudy). It's worth noting that [any BLEU score above 60](https://cloud.google.com/translate/automl/docs/evaluate#interpretation) indicates a higher quality translation than a human translation.

While Palmyra's core competency lies in the text generation realm, translation use cases are possible. However, it's important to exercise caution in languages where benchmarks are not yet established (we are actively working on establishing these benchmarks). We believe in transparency and advise potential users to be aware of this caveat.

Therefore, any outputs or usage of Writer LLM should always be accompanied by the guidance of a human expert. We are continuously evaluating and refining our capabilities, and we are committed to learning with our customers.

| Language            | MMLU/MLMM | BLEU (source \ English) |
| :------------------ | :-------- | :---------------------- |
| Arabic              | 68.9      | 61.2                    |
| Bengali             | 63.3      | 54.4                    |
| Bulgarian           | 76.3      | 64.2                    |
| Chinese simplified  | 71.7      | 63.8                    |
| Chinese traditional | 73.7      | 57.0                    |
| Croatian            | 64.9      | 66.4                    |
| Czech               | -         | 52.5                    |
| Danish              | 77.7      | 70.5                    |
| Dutch               | 73.6      | 73.9                    |
| English             | 70.2      | -                       |
| Finnish             | -         | 68.9                    |
| French              | 69.1      | 63.1                    |
| German              | 70.4      | 71.3                    |
| Greek               | -         | 60.4                    |
| Hebrew              | -         | 67.8                    |
| Hindi               | 77.9      | 68.4                    |
| Hungarian           | 67.7      | 65.3                    |
| Indonesian          | 67.8      | 63.5                    |
| Italian             | 72.5      | 70.9                    |
| Japanese            | 73.5      | 66.8                    |
| Korean              | -         | 56.8                    |
| Lithuanian          | -         | 59.3                    |
| Polish              | -         | 60.6                    |
| Portuguese          | -         | 66.2                    |
| Romanian            | 70.9      | 67.6                    |
| Russian             | 75.1      | 65.2                    |
| Spanish             | 72.5      | 79.3                    |
| Swahili             | -         | 62.8                    |
| Swedish             | -         | 63.2                    |
| Thai                | -         | 54.7                    |
| Turkish             | 64.1      | 57.5                    |
| Ukrainian           | 75.2      | 68.0                    |
| Vietnamese          | 72.5      | 60.3                    |

# Dialect support

Writer Palmyra LLM also supports outputting in specific language dialects. The best results come from using a prompt with the following characteristics:

1. The prompt itself is in the desired language and dialect
2. The prompt clearly describes the type of dialect (e.g. "It's essential that you use the Spanish spoken in Spain.")
3. The prompt provides specific examples of the dialect, both vocabulary and grammatical differences

The following example, although not in the desired language for simplicity's sake, is an example of an optimal prompt that asks for a translation in Spanish spoken in Spain.

> Hello, good afternoon! I need you to help me translate the following text. It's essential that you use the Spanish spoken in Spain. For example, you should use words like "coche" and/or "patata" instead of "carro" and/or "pap." Additionally, you need to pay attention to grammatical differences, such as the use of "voy a por" (Spain) instead of "voy por" (Latin America), or the structure of sentences like "hoy he comido una manzana" instead of "hoy comÃ­ una manzana." I prefer that you use "vosotros" (speak) instead of "ustedes" (speak), unless it's necessary to write very formally.
> Here is the text to be translated:\
> \[text you want translated]

## Basic prompt examples

### Translation

> Read the content of this source. Provide me with a translation of all its contents in French: [https://writer.com/blog/ai-guardrails/](https://writer.com/blog/ai-guardrails/)

### Text generation

> Please write a blog post about the importance of productivity for small businesses in Arabic.

### Native multi-language support

> äººå·¥çŸ¥èƒ½ã®æ­´å²ã¨å¤§è¦æ¨¡è¨€èªžãƒ¢ãƒ‡ãƒ«ã®é–‹ç™ºã«ã¤ã„ã¦ã€çŸ­ã„æ®µè½ã‚’æ›¸ã„ã¦ãã ã•ã„ã€‚èª­è€…ã¯ãƒ“ã‚¸ãƒã‚¹ãƒ†ã‚¯ãƒŽãƒ­ã‚¸ãƒ¼ãƒ‹ãƒ¥ãƒ¼ã‚¹ã«èˆˆå‘³ãŒã‚ã‚Šã¾ã™ãŒã€æŠ€è¡“çš„ãªãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æŠ€è¡“çš„ãªæ¦‚å¿µã‚’8å¹´ç”Ÿã®èª­è§£ãƒ¬ãƒ™ãƒ«ã§ç°¡æ½”ã«èª¬æ˜Žã—ã¦ãã ã•ã„ã€‚


# Mitigating bias
Source: https://dev.writer.com/home/mitigating_bias



## Introduction

In the era of artificial intelligence, ensuring that AI models produce unbiased and fair outputs has become a critical concern. Writer, one of the leading organizations in the field, takes this challenge seriously and employs a range of strategies to detect and mitigate biases in its AI models. In this article, we explore the technical methodologies employed by Writer to grapple with this complex issue.

## Mechanisms and methodologies for detecting and mitigating Bias

<Tabs>
  <Tab title="Data cleaning and preprocessing">
    At the heart of any machine learning model lies the data on which it's trained. Writer meticulously curates its training data, often sourced from a myriad of platforms like websites, books, and Wikipedia. Text preprocessing techniques, such as removing sensitive content or flagging potential hotspots for bias, are employed before the data is used for training.
  </Tab>

  <Tab title="Annotation guidelines">
    The first layer of oversight comes in the form of human annotators who label the data. These annotators are guided by a stringent set of rules designed to counteract the introduction of bias. For example, they're trained to avoid favoring any political ideology, ethnicity, or other sociocultural factors when annotating the training data.
  </Tab>

  <Tab title="Auditing">
    After the initial training, the model is subjected to a rigorous auditing process. This involves running the model through a series of test cases designed to gauge its propensity for biased or unsafe content. These audits are often carried out by both internal teams and third-party organizations to ensure objectivity.
  </Tab>

  <Tab title="RLHF">
    The next step involves fine-tuning the model based on the results of the audit. Writer uses reinforcement learning from human feedback (RLHF) or similar techniques to adjust the model's parameters, helping it to make less biased decisions. Fine-tuning focuses on specific aspects like language nuances, sentiment interpretation, and context-aware decision-making.
  </Tab>

  <Tab title="Feedback loop">
    Writer has an active feedback loop with itsÂ betaÂ user community. Reports of biased outputs are taken seriously and are used to further fine-tune the model. This makes the model more robust and adaptable to real-world applications.
  </Tab>
</Tabs>

## Sources of bias in training data

Writer models are trained on large datasets that are a snapshot of human culture and thought, collected by our team. While this helps the model to be versatile and knowledgeable, it also brings in the risk of the model inheriting the existing biases in society. Writer mitigates this by adding layers of scrutiny and control, both algorithmic and human, on the data used for training.

## Adapting to different contexts and languages

<Tabs>
  <Tab title="Context-aware fine-tuning">
    Writer is pioneering research in making its models more context-sensitive. This involves incorporating additional features into the modelâ€™s architecture that allows it to understand the specific context in which a text snippet appears, enabling more nuanced responses.
  </Tab>

  <Tab title="Language-specific models">
    Given the global reach of AI, Writer is also working on language-specific versions of its models. These models undergo fine-tuning with data that is representative of the linguistic and cultural idiosyncrasies of specific languages.
  </Tab>

  <Tab title="Annotator teams">
    To further the goal of international adaptability, Writer often employs annotators from various cultural backgrounds. This helps in creating a model that is less likely to favor any particular group.
  </Tab>
</Tabs>

## Conclusion

The challenge of eliminating bias in AI models is a complex and ongoing task. Writer employs a multi-faceted approach, combining data science, human oversight, and cutting-edge machine learning techniques, to tackle this critical issue. While there's always room for improvement, the methodologies adopted serve as a strong framework for mitigating bias in AI.


# Models
Source: https://dev.writer.com/home/models



export const capabilities_2 = " Text input & "

export const contextWindow_2 = "32k"

export const inputPrice_2 = "5.00"

export const outputPrice_2 = "12.00"

export const capabilities_1 = " Text input & "

export const contextWindow_1 = "128k"

export const inputPrice_1 = "5.00"

export const outputPrice_1 = "12.00"

export const capabilities_0 = " Text input & "

export const contextWindow_0 = "128k"

export const inputPrice_0 = "5.00"

export const outputPrice_0 = "12.00"

Whether you use no-code, Writer framework, or APIs, you need to choose a model. Here is an overview of the Palmyra models and their capabilities.

## Leading models

<Info>
  The input and output price is displayed in 1M tokens. See the
  [pricing](/home/pricing) page for the full cost.
</Info>

<CardGroup cols={3}>
  <Card title="Palmyra X 004" icon="square-1" color="currentColor">
    Our latest and most advanced model with a large context window

    <br />

    <ul class="no-bullet">
      <li>
        <Icon icon="star" iconType="regular" color="currentColor" /> {capabilities_0} output
      </li>

      <li>
        <Icon icon="ruler-vertical" iconType="regular" color="currentColor" /> {contextWindow_0} context
        window
      </li>

      <li>
        <Icon icon="circle-dollar" iconType="regular" color="currentColor" />  **Input**: \${inputPrice_0} â†’
        **Output**: \${outputPrice_0}
      </li>
    </ul>
  </Card>

  <Card title="Palmyra Fin" icon="square-2" color="currentColor">
    Our finance domain specialized model; first model to pass the CFA exam

    <br />

    <ul class="no-bullet">
      <li>
        <Icon icon="star" iconType="regular" color="currentColor" /> {capabilities_1} output
      </li>

      <li>
        <Icon icon="ruler-vertical" iconType="regular" color="currentColor" /> {contextWindow_1} context
        window
      </li>

      <li>
        <Icon icon="circle-dollar" iconType="regular" color="currentColor" />  **Input**: \${inputPrice_1} â†’
        **Output**: \${outputPrice_1}
      </li>
    </ul>
  </Card>

  <Card title="Palmyra Med" icon="square-3" color="currentColor">
    Our most sophisticated model for delivering accurate medical analysis

    <br />

    <ul class="no-bullet">
      <li>
        <Icon icon="star" iconType="regular" color="currentColor" /> {capabilities_2} output
      </li>

      <li>
        <Icon icon="ruler-vertical" iconType="regular" color="currentColor" /> {contextWindow_2} context
        window
      </li>

      <li>
        <Icon icon="circle-dollar" iconType="regular" color="currentColor" />  **Input**: \${inputPrice_2} â†’
        **Output**: \${outputPrice_2}
      </li>
    </ul>
  </Card>
</CardGroup>

## Model overview

<Tip>
  A âœ… indicates the model is available in the product offering, while a âŒ
  indicates the model is not live for this product offering.
</Tip>

| Model name             | Model ID                 | No-code | Framework | API              |
| ---------------------- | ------------------------ | ------- | --------- | ---------------- |
| Palmyra X 004          | `palmyra-x-004`          | âœ…       | âœ…         | âœ…                |
| Palmyra X 003 Instruct | `palmyra-x-003-instruct` | âœ…       | âœ…         | âœ…                |
| Palmyra Vision         | `palmyra-vision`         | âœ…       | âŒ         | âŒ <span>âœ±</span> |
| Palmyra Med            | `palmyra-med`            | âœ…       | âœ…         | âœ…                |
| Palmyra Fin            | `palmyra-fin`            | âœ…       | âœ…         | âœ…                |
| Palmyra Creative       | `palmyra-creative`       | âœ…       | âœ…         | âœ…                |

<Tip>
  <span>âœ±</span> Palmyra Vision is available in the chat completions API with the [vision tool](/api-guides/vision-tool).
</Tip>

## Model details

<AccordionGroup>
  <Accordion title="Palmyra X 004" icon="comment" iconType="regular">
    <Tabs>
      <Tab title="Overview">
        `palmyra-x-004` is our most advanced language model. Itexcels in processing and understanding complex tasks, making it ideal for workflow automation, coding tasks, and data analysis.

        **Pricing**:

        * Input: \$5.00 per 1M tokens
        * Output: \$12.00 per 1M tokens

        **Content window**: 128k
      </Tab>

      <Tab title="Use cases and capabilities">
        * **Agents & actions**: Palmyra X 004 acts as an advanced AI agent, capable of executing tasks beyond simple text generation by interacting with external systems like databases, applications, and other services. This enables it to perform real-time data updates and automate complex workflows.
        * **Retrieval-augmented generation (RAG)**: Equipped with RAG, Palmyra X 004 can retrieve and incorporate relevant information from vast data sources, enhancing the modelâ€™s accuracy and ensuring responses are always grounded in current, context-specific data.
        * **Code generation**: The model supports advanced code generation, enabling it to automate scripting and integrate seamlessly with various programming environments, optimizing workflows for technical teams.
        * **Tool calling**: Palmyra X 004 is built to handle precise API interactions, allowing it to execute complex functions directly, making it a versatile tool for enterprise-level integrations and automated actions.
      </Tab>

      <Tab title="Benchmarking">
        Palmyra X 004 consistently ranks at the top in structured output, API tool calling, and accuracy for complex, multi-step workflows.

        * **Top accuracy (ACC)**: Palmyra X 004 achieves 78.76% accuracy in tool call identification and execution, leading the industry by nearly 20%.
        * **Structured call planning (AST)**: Palmyra X 004 scores 87.93% in planning and organizing tool calls, accurately interpreting input, generating parameters, and sequencing steps.
        * **Execution performance (Exec)**: With an 88.27% score in executing tool calls, Palmyra X 004 ranks highest in efficiently carrying out enterprise actions.
        * **Global benchmarks**: Palmyra X 004 ranks in the world's top 10 on HELM Lite (86.1%) and HELM MMLU (81.3%), excelling across 57 subjects.
      </Tab>
    </Tabs>
  </Accordion>

  <Accordion title="Palmyra X 003 Instruct" icon="book" iconType="regular">
    <Tabs>
      <Tab title="Overview">
        `palmyra-x-003-instruct` is highly proficient in generating precise and detailed responses. It's particularly useful for applications that require fine-grained language generation.

        **Pricing**:

        * Input: \$7.50 per 1M tokens
        * Output: \$22.50 per 1M tokens

        **Content window**: 32k
      </Tab>

      <Tab title="Use cases and capabilities">
        * **Instruction-based content generation**: Palmyra X 003 excels at following detailed instructions to create structured documents, from reports and proposals to step-by-step guides, assisting with accuracy and consistency across workflows.
        * **Data-driven analysis**: Ideal for complex datasets, Palmyra X 003 can analyze and summarize information into concise, actionable insights, making it easy for teams to digest lengthy reports or research findings quickly.
        * **Multilingual support**: Palmyra X 003's multilingual capabilities allow it to generate and adapt content across multiple languages, supporting enterprises with global operations.
      </Tab>

      <Tab title="Benchmarking">
        Palmyra X 003 launched as the #3 model on Stanford's HELM benchmark and has since claimed the top spot in translation accuracy. Its industry-leading performance in multilingual tasks ensures precise, culturally relevant translations, making it a trusted choice for global organizations that require consistent and reliable content across languages.

        | Model                    | GSM8K | LegalBench | MedQA | WMT 2014 |
        | ------------------------ | ----- | ---------- | ----- | -------- |
        | Palmyra X V3 (72B)       | 0.831 | 0.709      | 0.684 | 0.262    |
        | PaLM-2 (Unicorn)         | 0.831 | 0.677      | 0.684 | 0.26     |
        | PaLM-2 (Bison)           | 0.61  | 0.654      | 0.547 | 0.241    |
        | Claude 3 Opus (20240229) | 0.924 | 0.662      | 0.775 | 0.24     |
      </Tab>
    </Tabs>
  </Accordion>

  <Accordion title="Palmyra Vision" icon="glasses" iconType="regular">
    <Tabs>
      <Tab title="Overview">
        `palmyra-vision` is specifically designed for processing images. It combines the power of natural language processing with computer vision techniques to analyze and generate textual descriptions of images. Palmyra Vision can be used for tasks such as image captioning, visual question answering, and image-to-text generation.

        **Pricing**:

        * Image: \$.005 per image
        * Video: \$.005 per second
        * Text: \$7.50 per 1M tokens

        **Content window**: 8k
      </Tab>

      <Tab title="Use cases and capabilities">
        * **Image-based compliance checks**: Palmyra Vision can identify and analyze visual elements helping enable you to meet your regulatory and brand guidelines and requirements.
        * **Product description generation**: Automatically generates detailed descriptions from product images, streamlining e-commerce workflows and enhancing catalog consistency.
        * **Chart and graph interpretation**: Transforms complex data visualizations into summarized, text-based insights, enabling quick analysis of trends and metrics in reports and presentations.
        * **Handwritten text extraction**: Accurately reads and digitizes handwritten notes or annotations, simplifying data entry and documentation processes.
      </Tab>

      <Tab title="Benchmarking">
        Palmyra Vision sets new standards in multimodal AI performance, excelling in key visual and text generation benchmarks.

        * **Visual Question Answering (VQAv2)**: Achieved an 84.4% accuracy rate, outperforming leading models like GPT-4V and Gemini 1.0 Ultra in interpreting and answering questions based on visual content.
        * **Image-text comprehension**: Consistently high performance in understanding and generating accurate text from diverse visual inputs, from scanned documents to complex graphics.
      </Tab>
    </Tabs>
  </Accordion>

  <Accordion title="Palmyra Med" icon="stethoscope" iconType="regular">
    <Tabs>
      <Tab title="Overview">
        `palmyra-med` is a language model tailored for the healthcare industry. It is an assistive tool for processing, summarizing, and understanding extensive medical texts, making it ideal for comprehensive medical document analysis, patient record summarization, and supporting medical research.

        This model is not designed to provide medical advice, and must not be used for any diagnostic or therapeutic purposes. It is not to be used in direct patient care. Any output generated by the model must always be reviewed and verified by a qualified and licensed physician, based on their professional judgement, before any use is made of it.

        **Pricing**:

        * Input: \$5.00 per 1M tokens
        * Output: \$12.00 per 1M tokens

        **Content window**: 32k
      </Tab>

      <Tab title="Use cases and capabilities">
        * **Medical coding**: Palmyra Med supports highly accurate retrieval and application of medical codes, including RxNorm for medications, ICD-10-CM for diagnoses, and SNOMED CT for medical concepts, making it a powerful tool for healthcare documentation and billing.
        * **Clinical decision support**: With healthcare-specific knowledge, Palmyra Med can assist in diagnostics and treatment planning, helping healthcare providers make informed, data-backed decisions.
        * **Document summarization and reporting**: Optimized for summarizing lengthy medical records and generating concise reports, Palmyra Med enhances efficiency in patient documentation and case review.
      </Tab>

      <Tab title="Benchmarking">
        Palmyra Med sets the industry standard in healthcare-specific performance, excelling across a range of medical benchmarks with unmatched accuracy and clinical relevance.

        * **Overall medical benchmarks**: Palmyra Med averaged 85.9% across all medical benchmarks, surpassing Med-PaLM-2 by nearly 2 percentage points. Unlike Med-PaLM-2, which requires multiple examples to reach similar scores, Palmyra Med achieved these results in a zero-shot setting, highlighting its advanced capabilities.
        * **Clinical knowledge and anatomy**: Scoring 90.9% in MMLU Clinical Knowledge and 83.7% in MMLU Anatomy, Palmyra Med demonstrates a strong understanding of clinical procedures and human anatomy, making it an invaluable tool for assisting with medical analsyis and treatment planning.
        * **Genetics and college medicine**: With scores of 94.0% in Medical Genetics and 84.4% in College Medicine, Palmyra Med excels in interpreting genetic data and applying complex medical knowledge, supporting use cases in assisting with genetic counseling and medical education.
        * **Biomedical research**: Palmyra Med achieved 80% on PubMedQA, showcasing its ability to extract and analyze information from biomedical literature, which is essential for research and evidence-based medical practices.
      </Tab>
    </Tabs>
  </Accordion>

  <Accordion title="Palmyra Fin" icon="money-bill" iconType="regular">
    <Tabs>
      <Tab title="Overview">
        `palmyra-fin` is a language model developed specifically for the financial sector. This model is an assistive tool for analyzing and synthesizing long financial documents, including comprehensive market reports, detailed investment analyses, and lengthy regulatory filings. With its ability to grasp complex financial narratives and perform deep contextual analysis, `palmyra-fin` is ideal for applications requiring a thorough understanding of extensive textual information.

        This model is not designed to assess the suitability of an investment or transaction, and must not be used directly to advise on or recommend any investment or financial transaction. Any output generated by the model must always be reviewed and verified by a qualified and licensed financial advisor, based on their professional judgment, before any use is made of it.

        **Pricing**:

        * Input: \$5.00 per 1M tokens
        * Output: \$12.00 per 1M tokens

        **Content window**: 128k
      </Tab>

      <Tab title="Use cases and capabilities">
        * **Market and financial analysis**: Palmyra Fin interprets and analyzes data trends, enabling financial analysts to generate insights and forecasts for strategic decision-making.
        * **Risk assessment**: With a deep understanding of financial language and terminology, Palmyra Fin helps assess risk factors, generating precise reports that aid in risk management compliance.
        * **Data summarization**: Palmyra Fin excels at summarizing complex financial documents, providing concise overviews and insights to support quick, informed decisions.
      </Tab>

      <Tab title="Benchmarking">
        Palmyra Fin leads the industry in financial expertise and benchmark performance, making it the top choice for finance-related AI applications.

        * **CFA Level III performance**: Palmyra Fin scored 73% on the multiple-choice section of a CFA Level III sample test, becoming the first AI model to pass this prestigious exam. For perspective, the average passing score is 60%, and less than half of test takers typically pass. This achievement marks a significant leap over general-purpose models like GPT-4, which scored only 33%.
        * **Long-fin-eval benchmark**: In real-world financial tasks, Palmyra Fin outperformed popular models such as Claude 3.5 Sonnet, GPT-4o, and Mixtral-8x7b on the long-fin-eval benchmark, showcasing its superior financial acumen and capability across diverse financial use cases.
      </Tab>
    </Tabs>
  </Accordion>

  <Accordion title="Palmyra Creative" icon="pen-fancy" iconType="regular">
    <Tabs>
      <Tab title="Overview">
        `palmyra-creative` is Writer's purpose-built language model, engineered to elevate creative thinking and writing across diverse professional contexts. With capabilities that amplify originality and adaptability, it caters to industries and teams where innovation drives success. Available via API, No-code tools, the Writer Framework, and as an NVIDIA NIM microservice, Palmyra Creative is tailored to inspire bold ideas and solutions.

        **Pricing**:

        * Input: \$5.00 per 1M tokens
        * Output: \$12.00 per 1M tokens

        **Content window**: 128k
      </Tab>

      <Tab title="Use cases and capabilities">
        * **Imaginative brainstorming**: Palmyra Creative generates a wide range of unique, innovative ideas tailored to specific challenges. Whether brainstorming marketing campaigns or conceptualizing new products, it empowers users to think beyond the obvious.
        * **Enhanced storytelling**: The model transforms basic content into engaging, impactful narratives. From crafting compelling copy to simplifying technical explanations, Palmyra Creative ensures every story resonates with its audience.
        * **Retail**: Palmyra Creative empowers retailers to craft highly personalized marketing campaigns, design innovative loyalty programs, and develop engaging in-store experiences. For example, it can generate unique, on-brand promotional ideas or create compelling product descriptions that resonate with target audiences.
        * **Healthcare**: In healthcare, Palmyra Creative simplifies complex communications, inspires empathetic patient outreach strategies, and supports innovative research initiatives. It can help create accessible patient education materials, draft engaging wellness campaigns, or refine technical research papers for broader audiences.
        * **Finance**: For finance professionals, Palmyra Creative humanizes messaging, creates educational tools, and designs strategies to enhance portfolio performance. It can assist in simplifying complex financial concepts for clients, drafting engaging investment reports, or generating impactful outreach campaigns for wealth management firms.
      </Tab>

      <Tab title="Benchmarking">
        Measuring creativity is inherently challenging. Unlike traditional benchmarks that focus on accuracy or reasoningâ€”like HELM or MMLUâ€”creativity is subjective, messy, and thrives on adaptability and originality. Rather than fitting into rigid metrics, Palmyra Creative's impact is best demonstrated through comparisons with general-purpose models like Palmyra X 004.

        Here, we showcase two examples that highlight Palmyra Creative's ability to transform workflows: brainstorming innovative strategies for a small-town bakery and refining a technical explanation to make it engaging and relatable.

        ### Example 1: Creative thinking

        **Prompt**: Imagine you're a struggling small-town bakery competing with a chain that opened across the street. Brainstorm unconventional strategies to win over customers without lowering prices.

        <Tabs>
          <Tab title="Palmyra Creative">
            The classic David vs. Goliath battle of the bakeries! Here are three unconventional strategies to help you, the plucky underdog, win over customers without sacrificing your margins:

            **Bake My Memory Experience**:
            Host free sensory baking sessions for seniors and individuals with memory loss. Recreate their favorite childhood treats and offer them for free. Word-of-Mouth will spread, and their families will follow.

            **Bake-Off with a Twist**:
            Host a baking competition where local businesses and groups compete to benefit a local charity. The winning team chooses the charity, and you provide a year's worth of free baked goods. Promote on social media and invite the community to cheer.

            **Breadwinner's Club Loyalty Program 2.0**:
            Ditch traditional loyalty cards. Create a "Breadwinner's Club" where customers earn "dough points" for completing baking challenges (try a new flavor, attend a class, share a photo). Redeem points for exclusive rewards, like a free custom cake or behind-the-scenes tour.
          </Tab>

          <Tab title="Palmyra X 004">
            Absolutely, here are three unconventional strategies to help your small-town bakery compete with a chain:

            **Bakery Scavenger Hunt**:
            Organize a monthly scavenger hunt where participants have to find clues hidden around town that lead them back to your bakery. The winner gets a special prize, like a custom-designed cake or a free baking class. This not only creates excitement but also gets people talking about your bakery.

            **Bake-Off Challenges with Local Celebrities**:
            Host a bake-off challenge where local celebrities (like the mayor, a popular teacher, or a local athlete) compete against each other using your bakery's ingredients and recipes. Stream the event live on social media to generate buzz and engagement.

            **Personalized Baking Kits**:
            Offer DIY baking kits that include pre-measured ingredients and step-by-step instructions for customers to recreate your signature treats at home. This can be a fun family activity and also introduces your bakery's unique flavors to a wider audience.
          </Tab>
        </Tabs>

        ### Example 2: Creative writing

        **Prompt**: Write a guide for a programmer who wants to explain their AI side project to a grandparent. The explanation must be engaging, simple, and use humorous analogies, while avoiding technical jargon.

        <Tabs>
          <Tab title="Palmyra Creative">
            **Explaining AI to Grandma (or Grandpa) 101**

            **Step 1: Start with something familiar**
            "Hey Grandma, you know how you're amazing at recognizing my voice on the phone, even when I'm all grown up and sound like a stranger? That's kind of like what I've been working on with my computer project. But instead of voices, I'm teaching the computer to recognize patterns in things like pictures, words, and even conversations!"

            **Step 2: Introduce the "Super Smart Assistant"**
            "Imagine you had a super smart, super patient assistant who could help you with anything. You could show them a picture of a cat and say, 'What's that?' And they'd say, 'Oh, that's a cat!' But here's the cool part: the more pictures of cats you show them, the better they get at recognizing new pictures of cats they've never seen before!"

            **Step 3: Use a relatable example**
            "Think of it like when you were learning to bake your famous chocolate chip cookies. At first, you had to follow a recipe to the letter. But the more you baked, the more you could just look at the ingredients and the dough and say, 'Ah, yeah, I know exactly what to do!' That's kind of what I'm teaching the computer to do, but instead of cookies, it's learning to recognize patterns in data."

            **Step 4: Keep it light and fun**
            "Don't worry if it still sounds a bit like magic, Grandma! The important thing is that it's like having a really smart, really helpful friend who can assist us with all sorts of things. And who knows, maybe one day it'll even be able to recognize your famous cookie recipe just by looking at a picture!"
          </Tab>

          <Tab title="Palmyra X 004">
            **Explaining Your AI Side Project to Grandma**

            **Step 1: Start with a Familiar Analogy**
            Imagine you're teaching a parrot to talk. You repeat words, and over time, the parrot learns to mimic you. AI is like a super smart parrot that can learn from lots of examples.

            **Step 2: Explain What AI Does**
            Just like how the parrot learns to say "Hello!" when you wave, AI can learn to recognize patterns. For example, it can learn to tell the difference between a cat and a dog in pictures.

            **Step 3: Describe Your Project**
            Let's say your project is about teaching AI to recognize different types of flowers. You can say, "I'm teaching the computer to be a flower expert. I show it lots of pictures of roses, daisies, and tulips, and it learns to tell them apart."

            **Step 4: Make It Relatable**
            You can joke, "It's like having a really helpful gardener who never forgets what each flower looks like, even if it's been a long time since they last saw it."

            **Step 5: Talk About the Benefits**
            Explain how this can be useful. For example, "This could help people who love gardening but have trouble remembering the names of all the flowers. They can just take a picture, and the AI will tell them what it is!"

            **Step 6: Keep It Light and Fun**
            End with a funny note, like, "And the best part is, unlike a real parrot, the computer won't squawk at you if you forget to feed it!"
          </Tab>
        </Tabs>
      </Tab>
    </Tabs>
  </Accordion>
</AccordionGroup>

## Using models with the Writer API

<Tabs>
  <Tab title="Chat completions">
    To select the Palmyra model you want to use for a chat completion, specify the model ID in the [`model` parameter](/api-guides/api-reference/completion-api/chat-completion#body-model) of the request.

    Below is an example of specifying the `palmyra-x-004` model in a chat completion request.

    <CodeGroup>
      ```bash cURL
      curl --location 'https://api.writer.com/v1/chat' \
      --header 'Content-Type: application/json' \
      --header "Authorization: Bearer $WRITER_API_KEY" \
      --data '{
        "model": "palmyra-x-004",
        "messages": [
          {
            "role": "user",
            "content": "Summarize GDPR compliance requirements for a cloud-based data storage provider"
          }
        ]
      }'
      ```

      ```python Python
      from writerai import Writer

      # Initialize the client. If you don't pass the `api_key` parameter,
      # the client looks for the `WRITER_API_KEY` environment variable.
      client = Writer()

      chat_completion = client.chat.completions.create(
        model="palmyra-x-004",
        messages=[
          {
            "role": "user",
            "content": "Summarize GDPR compliance requirements for a cloud-based data storage provider"
          }
        ]
      )

      print(chat_completion.choices[0].message.content)
      ```

      ```javascript JavaScript
      import { Writer } from 'writer-sdk';

      // Initialize the client. If you don't pass the `apiKey` parameter,
      // the client looks for the `WRITER_API_KEY` environment variable.
      const client = new Writer();

      const chat_completion = await client.chat.completions.create({
        model: 'palmyra-x-004',
        messages: [
          {
            "role": "user",
            "content": "Summarize GDPR compliance requirements for a cloud-based data storage provider"
          }
        ]
      });

      console.log(chat_completion.choices[0].message.content);
      ```
    </CodeGroup>

    You can also use prebuilt tools to interact with specialized LLMs within a general purpose chat completion request, or to use the Palmyra Vision model in a chat completion.

    See more details in the tool calling guides:

    * [LLM tool for calling specialized models](/api-guides/model-delegation)
    * [Vision tool for analyzing images](/api-guides/vision-tool)
  </Tab>

  <Tab title="Text generation">
    To select the Palmyra model you want to use for text generation, specify the model ID in the [`model` parameter](/api-guides/api-reference/completion-api/text-generation#body-model) of the request.

    Below is an example of specifying the `palmyra-x-004` model in a text generation request.

    <CodeGroup>
      ```bash cURL
      curl --location 'https://api.writer.com/v1/completions' \
      --header 'Content-Type: application/json' \
      --header "Authorization: Bearer $WRITER_API_KEY" \
      --data '{
        "model": "palmyra-x-004",
        "prompt": "Summarize GDPR compliance requirements for a cloud-based data storage provider"
      }'
      ```

      ```python Python
      from writerai import Writer

      # Initialize the client. If you don't pass the `api_key` parameter,
      # the client looks for the `WRITER_API_KEY` environment variable.
      client = Writer()

      text_generation = client.completions.create(
        model="palmyra-x-004",
        prompt="Summarize GDPR compliance requirements for a cloud-based data storage provider"
      )

      print(text_generation.choices[0].text)
      ```

      ```javascript JavaScript
      import { Writer } from 'writer-sdk';

      // Initialize the client. If you don't pass the `apiKey` parameter,
      // the client looks for the `WRITER_API_KEY` environment variable.
      const client = new Writer();

      const text_generation = await client.completions.create({
        model: 'palmyra-x-004',
        prompt: 'Summarize GDPR compliance requirements for a cloud-based data storage provider'
      });

      console.log(text_generation.choices[0].text);
      ```
    </CodeGroup>
  </Tab>
</Tabs>

Get started with the Writer API by signing up for a free account and following the [API quickstart](/api-guides/quickstart).

## Deprecation policy

### Timeline for deprecation

* We'll announce the deprecation of a model at least three months in advance. This will give customers time to plan for the migration to the new model.
* We'll continue to support deprecated models for a period of time after they're deprecated. This will give customers time to migrate to the new model.
* We'll eventually stop supporting deprecated models. The timeline for this will vary depending on the model. We will announce the end of support for a deprecated model at least six months in advance.

### Deprecated models

| Model name             | Deprecation Date |
| ---------------------- | ---------------- |
| Palmyra Fin 32k        | 2025-03-03       |
| Palmyra X 002 32k      | 2024-09-06       |
| Palmyra X 32k Instruct | 2024-09-06       |
| Palmyra X 002 Instruct | 2024-09-06       |

### Migration path

* We'll provide customers with a migration path to the new model, including detailed documentation and support to help them migrate their applications.
* We'll also offer training and consulting services to help customers transition.


# Observability
Source: https://dev.writer.com/home/observability



<Info>
  The **Consumption** view is only available to [organization admins](/home/account_management).
</Info>

The Consumption view in AI Studio gives you a detailed view of your usage and spend month-by-month.

To access this view, [log in to AI Studio](https://app.writer.com/aistudio) and click the **Consumption** tab in the left sidebar.

![Consumption view in AI Studio](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/home/consumption-sidebar.png)

You can switch between a cost view and an activity view, which shows the number of tokens used for each agent type. See below for more details about the data available in the [cost view](#cost-view) and the [activity view](#activity-view).

The image below shows the cost view for a sample organization.

![February 2025 usage report showing \$1,509.645 total spend, broken down by agent type (API, Framework, No-code) and spend source (LLM models, Others).](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/home/usage.png)

## Cost view

The cost view shows the following information:

* **Monthly usage-based spend**: The total cost of usage for the month, with a comparison to the previous month.
* **Spend by agent type**: A day-by-day breakdown of the cost of usage by agent type (API, Framework, and No-Code).
* **Spend breakdown**:
  * **LLM models**: The usage cost for each LLM model.
  * **Others**: The usage cost for all other services, such as Knowledge Graph hosting, web access, and optical character recognition (OCR).

## Activity view

The activity view shows the following information:

* **Monthly token usage**: The total number of tokens used for the month, with a comparison to the previous month.
* **Top users by token usage**: The top five users with the most token usage.
* **Top agents by token usage**: The top five agents with the most token usage.
* **Token usage by agent type**: A day-by-day breakdown of the token usage by agent type (API, Framework, and No-Code).
* **Token usage by model**: The total number of tokens used for each model.


# Pricing
Source: https://dev.writer.com/home/pricing



<Info>
  For any custom pricing, please **[contact our sales
  team](https://go.writer.com/contact-sales)**.
</Info>

## Base model

The table below outlines our [base model](/home/models#models), which is focused on text input and output. The input and output prices are displayed per 1M tokens unless otherwise specified.

| Model name                                                                                   | Model ID                 | Input / 1M | Output / 1M |
| -------------------------------------------------------------------------------------------- | ------------------------ | ---------- | ----------- |
| [Palmyra X 004](/home/models#palmyra-x-004)                                                  | `palmyra-x-004`          | \$5.00     | \$12.00     |
| [Palmyra X 003 Instruct](/home/models#palmyra-x-003-instruct)                                | `palmyra-x-003-instruct` | \$7.50     | \$22.50     |
| [Palmyra Med](/home/models#palmyra-med)                                                      | `palmyra-med`            | \$5.00     | \$12.00     |
| [Palmyra Fin](/home/models#palmyra-fin)                                                      | `palmyra-fin`            | \$5.00     | \$12.00     |
| [Palmyra Creative](/home/models#palmyra-creative)                   Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  | `palmyra-creative`       | \$5.00     | \$12.00     |

## Palmyra Vision

The table below outlines pricing for our [Palmyra Vision](/home/models#palmyra-vision) model which takes in a variety of inputs and produces text as an output. The input and output price is displayed in 1M tokens unless otherwise specified.

| Type  | Input          | Output / 1M |
| ----- | -------------- | ----------- |
| Image | \$0.005/image  | \$8.00      |
| Video | \$0.005/second | \$8.00      |
| Text  | \$7.50/1M      | \$22.50     |

## Knowledge Graph

The table below outlines pricing for [Knowledge Graph](/api-guides/knowledge-graph#knowledge-graph), our graph-based RAG that grounds generative AI in your company-level context by connecting our platform to your internal data sources.

| Capability              | Cost                          |
| ----------------------- | ----------------------------- |
| Knowledge Graph hosting | \$0.085/gb of storage per day |
| Data extraction         | \$0.00015/page                |
| File parsing (OCR)      | \$0.055/page                  |
| Web Access              | \$0.12/page                   |

Data connectors are part of our Enterprise plan, to learn more please **[contact our sales team](https://go.writer.com/contact-sales)**

## Tools API

The table below outlines pricing for our [Tools API](/api-guides/api-reference/tool-api/), which provides utilities for pre-processing and comprehending text.

| Tool                                                                                       | Cost                                        |
| ------------------------------------------------------------------------------------------ | ------------------------------------------- |
| [Context-aware text splitting](/api-guides/api-reference/tool-api/context-aware-splitting) | \$0.04 per 1M words input/output            |
| [Medical comprehend](/api-guides/api-reference/tool-api/comprehend-medical)                | \$0.02 per 1M words input (no output costs) |
| [PDF parser](/api-guides/api-reference/tool-api/pdf-parser)                                | \$0.055/page                                |

## Deprecated models

The table below are our deprecated models. To learn more see the [deprecation policy](/home/models#deprecation-policy).

| Model name             | Deprecation Date | Input / 1M | Output / 1M |
| ---------------------- | ---------------- | ---------- | ----------- |
| Palmyra X 002 32k      | 2024-09-06       | \$1.00     | \$2.00      |
| Palmyra X 32k Instruct | 2024-09-06       | \$1.00     | \$2.00      |
| Palmyra X 002 Instruct | 2024-09-06       | \$1.00     | \$2.00      |


# Prompt security
Source: https://dev.writer.com/home/prompt_injections



Security measures against prompt injections, jailbreak attacks, and secrets leakage

## Introduction

As AI systems like Writer models become increasingly integrated into a wide range of applications, the importance of securing them against various types of attacks becomes paramount. In this article, we delve into the technical details of how Writer safeguards its AI models against prompt injections, jailbreak attempts, and the leakage of sensitive information.

## Measures against prompt injections

<Tabs>
  <Tab title="Input sanitization">
    One of the first lines of defense is input sanitization, where incoming prompts are screened for potentially malicious code or harmful strings. Sophisticated Natural Language Processing (NLP) techniques, combined with standard cybersecurity measures, are used to detect and remove or neutralize suspicious inputs.
  </Tab>

  <Tab title="Rate limiting">
    To prevent brute-force attacks and other malicious activities, Writer often implements <a href="/api-guides/api-reference/rate-limits">rate limiting</a> on the API requests. This ensures that a user can't overload the system with a large number of potentially harmful prompts in a short amount of time.
  </Tab>

  <Tab title="RBAC">
    Role-cased access control (RBAC) to more advanced or potentially risky functionalities is restricted based on roles. This prevents unauthorized users from injecting malicious prompts that could potentially exploit these functionalities.
  </Tab>
</Tabs>

## Safeguards against jailbreak attacks

<Tabs>
  <Tab title="Runtime environment isolation">
    The runtime environment in which the AI models operate is isolated from the rest of the system. This isolation is often achieved using containerization technologies like Docker, which limit the resources and system calls available to the running model.
  </Tab>

  <Tab title="Anomaly detection systems">
    Advanced anomaly detection systems are put in place to monitor the behavior of the AI models in real-time. Any unusual patterns or inconsistencies could trigger alerts, initiating immediate investigation and potential shutdown of the affected instance.
  </Tab>

  <Tab title="Code review and static analysis">
    Before deployment, the codebase undergoes rigorous reviews and static analysis to ensure that there are no vulnerabilities that could be exploited to "jailbreak" the AI system.
  </Tab>
</Tabs>

## Measures against secrets leakage

<Tabs>
  <Tab title="Encryption and secure storage">
    All sensitive information, including security keys and credentials, is encrypted using state-of-the-art encryption algorithms. These encrypted secrets are stored in secure vaults that are accessible only to authorized personnel.
  </Tab>

  <Tab title="Zero trust architecture">
    A Zero trust architecture is employed, which means that every request or interaction with the AI system is treated as potentially malicious until proven otherwise. This adds an extra layer of security against unauthorized access and data leakage.
  </Tab>
</Tabs>

## Conclusion

Security is a multi-faceted challenge that requires a holistic approach. Writer employs a combination of advanced technologies and best practices to safeguard its AI models against prompt injections, jailbreak attacks, and the leakage of sensitive information. While no system can be 100% secure, these measures provide a robust framework for identifying, mitigating, and responding to various security threats.


# Prompting strategies
Source: https://dev.writer.com/home/prompting



export const PromptComponent = ({prompt}) => <div>
    <p class="prompts">{prompt}</p>
  </div>;

This guide covers the [fundamentals](/home/prompting#fundamentals) behind prompting strategies and discusses some [advanced techniques](/home/prompting#advanced-techniques).

For in-depth information on prompting, see the Writer [prompt crafting guide](https://writer.com/guides/prompt-crafting/).

## Fundamentals

<CardGroup cols={2}>
  <Card title="Directive writing" icon="pencil" color="currentcolor">
    Be direct and to the point:

    <br />

    <br />

    <PromptComponent prompt={`Write a short summary of the article titled "The Impact of Artificial Intelligence on Employment"`} />
  </Card>

  <Card title="Inclusive prompts" icon="users" color="currentcolor">
    Include your audience in your prompt:

    <br />

    <br />

    <PromptComponent prompt={`Explain the implications of the recent changes in tax laws for small business owners in California.`} />
  </Card>

  <Card title="Structured formatting" icon="hashtag" color="currentcolor">
    Format your prompt with *### Instruction ###*, followed by *### Question
    \###*:

    <br />

    <br />

    <p class="prompts">
      <strong>### Instruction ###</strong> <br />Write a poem in the style of
      Robert Frost. <br />

      <br />

      <strong>### Question ###</strong>
      <br /> What's the poem about?
    </p>
  </Card>

  <Card title="Task breakdown" icon="list-check" color="currentcolor">
    Break down complicated tasks into multiple prompts:

    <br />

    <br />

    <PromptComponent prompt={`First, provide a brief overview of derivatives. Then, explain how it's related to credit risk.`} />
  </Card>

  <Card title="Positive language" icon="thumbs-up" color="currentcolor">
    Use directives like "do" instead of "don't":

    <br />

    <br />

    <PromptComponent prompt={`Do provide an analysis of the potential benefits and drawbacks of using renewable energy sources in the manufacturing industry, focusing on the economic, environmental, and social impacts.`} />
  </Card>

  <Card title="Mandatory instructions" icon="triangle-exclamation" color="currentcolor">
    Use phrases like *You MUST*:

    <br />

    <br />

    <PromptComponent prompt={`You must provide a step-by-step guide to setting up a WordPress website, including domain registration, web hosting, and content creation.`} />
  </Card>

  <Card title="Penalty warning" icon="gavel" color="currentcolor">
    Use phrases like *You'll be penalized*:

    <br />

    <br />

    <PromptComponent prompt={`Youâ€™ll be penalized if you don't include at least three different methods for solving the following math problem: Find the area of a circle with a radius of 5 units.`} />
  </Card>

  <Card title="Natural responses" icon="comments" color="currentcolor">
    Request a simple response:

    <br />

    <br />

    <PromptComponent prompt={`Please provide a brief explanation of the difference between a virus and a bacterium, answering in a natural, human-like manner.`} />
  </Card>

  <Card title="Unbiased descriptions" icon="scale-balanced" color="currentcolor">
    Make sure that your answer is unbiased and doesnâ€™t rely on stereotype:

    <br />

    <br />

    <PromptComponent prompt={`Please describe the cultural significance of sushi in Japan, making sure that your answer is unbiased.`} />
  </Card>

  <Card title="Educational writing" icon="book-open" color="currentcolor">
    To write an essay, text, paragraph, article, or any detailed text:

    <br />

    <br />

    <PromptComponent prompt={`Write a detailed essay for me on the history of the monetary policy.`} />
  </Card>

  <Card title="Style consistency" icon="typewriter" color="currentcolor">
    Improve the tone of the text to make the writing style more
    professional:

    <br />

    <br />

    <PromptComponent prompt={`Revise the following paragraph to improve its grammar and vocabulary, but make sure that the writing style remains formal.`} />
  </Card>

  <Card title="Creative writing" icon="pen-fancy" color="currentcolor">
    I'll give you the beginning of a story. Finish it and keep the flow
    consistent:

    <br />

    <br />

    <PromptComponent prompt={`As the sun began to set, the sky turned a deep shade of orange. The birds returned to their nests, and the crickets started to chirp.`} />
  </Card>

  <Card title="Linguistic mimicry" icon="copy" color="currentcolor">
    Use the same language as the following paragraph to explain the importance
    of exercise:

    <br />

    <br />

    <PromptComponent prompt={`The practice of meditation has been around for thousands of years. It's a way to calm the mind and body, and it can be done almost anywhere.`} />
  </Card>

  <Card title="Precise instructions" icon="ruler" color="currentcolor">
    Clearly state the requirements that the model must follow to produce
    content, in the form of keywords or instructions. <br />

    <br />

    <PromptComponent prompt={`Write a short summary of the article titled 'The Impact of AI on Employment'. Ensure that the summary is no longer than 150 words and includes the main arguments.`} />
  </Card>
</CardGroup>

## Advanced techniques

<CardGroup cols={1}>
  <Card title="Example driven prompts" icon="check" color="currentcolor">
    Use example-driven (few-shot) prompting:

    <br />

    <p class="prompts">
      Provide a list of idioms in English, along with their meanings and example
      sentences.

      <br />

      Here is an example for the output: <br />

      <br />

      <strong>An idiom</strong>: 'Break a leg' <br />
      <strong>Meaning</strong>: Good luck <br />
      <strong>Example sentence</strong>: 'I'm sure you'll do great in your interview.
      Break a leg!'
    </p>
  </Card>

  <Card title="Chain-of-thought Prompts" icon="thought-bubble" color="currentcolor">
    Combine chain-of-thought (CoT) prompts with few-shot prompts:

    <br />

    <p class="prompts">
      <strong>System instruction:</strong> Create a product detail page for a
      fictional innovative smartphone by a retailer known as "TechTrend
      Electronics."

      <br />

      <strong>Prompt 1:</strong> Start by describing the unique features of the smartphone,
      such as its solar-powered battery, triple-lens camera system, and foldable
      screen technology.

      <br />

      <strong>Prompt 2:</strong> Next, outline the benefits of these features
      for users, like extended battery life, exceptional photo quality, and
      enhanced device portability.

      <br />

      <strong>Prompt 3:</strong> Conclude with crafting compelling product descriptions
      and a call-to-action that entices customers to make a purchase during the upcoming
      holiday sale.
    </p>
  </Card>

  <Card title="Delimited prompts" icon="text" color="currentcolor">
    Use delimiters to structure text:

    <br />

    <p class="prompts">
      Summarize a series of healthcare claims documents for a fictional
      healthcare company, 'HealthFirst Solutions', using the following delimiter `\n`
      to separate different sections of the summary:

      <br />

      <strong>Claim Number:</strong> 123456789 `\n` <br />
      <strong>Date of Service:</strong> January 1, 2024 `\n` <br />
      <strong>Diagnosis:</strong> Acute sinusitis `\n` <br />
      <strong>Total Claimed:</strong> \$300 `\n` <br />
      <strong>Status:</strong> Pending review `\n` <br />
    </p>
  </Card>
</CardGroup>


# Research papers
Source: https://dev.writer.com/home/research



Below are research papers published by the Writer AI, NLP, and Data Science team.

<AccordionGroup>
  <Accordion title="Expect the Unexpected: FailSafe Long Context QA for Finance" icon="square-1">
    <a href="https://arxiv.org/abs/2502.06329">Link to paper</a>
    <p class="papers">February 2025</p>

    <p class="papers">We propose a new long-context financial benchmark, FailSafeQA, designed to test the robustness and context-awareness of LLMs against six variations in human-interface interactions in LLM-based query-answer systems within finance.</p>

    <p class="papers">We concentrate on two case studies: Query Failure and Context Failure. In the Query Failure scenario, we perturb the original query to vary in domain expertise, completeness, and linguistic accuracy. In the Context Failure case, we simulate the uploads of degraded, irrelevant, and empty documents. We employ the LLM-as-a-Judge methodology with Qwen2.5-72B-Instruct and use fine-grained rating criteria to define and calculate Robustness, Context Grounding, and Compliance scores for 24 off-the-shelf models.</p>

    <p class="papers">The results suggest that although some models excel at mitigating input perturbations, they must balance robust answering with the ability to refrain from hallucinating. Notably, Palmyra-Fin-128k-Instruct, recognized as the most compliant model, maintained strong baseline performance but encountered challenges in sustaining robust predictions in 17% of test cases. On the other hand, the most robust model, OpenAI o3-mini, fabricated information in 41% of tested cases. The results demonstrate that even high-performing models have significant room for improvement and highlight the role of FailSafeQA as a tool for developing LLMs optimized for dependability in financial applications.</p>
  </Accordion>

  <Accordion title="Writing in the Margins: Better inference pattern for long context retrieval" icon="square-2">
    <a href="https://arxiv.org/abs/2408.14906">Link to paper</a>

    <p class="papers">August 2024</p>

    <p class="papers">In this paper, we introduce Writing in the Margins (WiM), a new inference pattern for Large Language Models designed to optimize the handling of long input sequences in retrieval-oriented tasks. This approach leverages the chunked prefill of the key-value cache to perform segment-wise inference, which enables efficient processing of extensive contexts along with the generation and classification of intermediate information ("margins") that guide the model towards specific tasks.</p>

    <p class="papers">This method increases computational overhead marginally while significantly enhancing the performance of off-the-shelf models without the need for fine-tuning. Specifically, we observe that WiM provides an average enhancement of 7.5% in accuracy for reasoning skills (HotpotQA, MultiHop-RAG) and more than a 30.0% increase in the F1-score for aggregation tasks (CWE). </p>

    <p class="papers">Additionally, we show how the proposed pattern fits into an interactive retrieval design that provides end-users with ongoing updates about the progress of context processing, and pinpoints the integration of relevant information into the final response. We release our implementation of WiM using Hugging Face Transformers library at [https://github.com/writer/writing-in-the-margins](https://github.com/writer/writing-in-the-margins).</p>
  </Accordion>

  <Accordion title="Comparative analysis of retrieval systems in the real world" icon="square-3">
    <a href="https://arxiv.org/abs/2405.02048">Link to paper</a>

    <p class="papers">May 2024</p>

    <p class="papers">This research paper presents a comprehensive analysis of integrating advanced language models with search and retrieval systems in the fields of information retrieval and natural language processing. The objective is to evaluate and compare various state-of-the-art methods based on their performance in terms of accuracy and efficiency.</p>

    <p class="papers">The analysis explores different combinations of technologies, including Azure Cognitive Search Retriever with GPT-4, Pinecone's Canopy framework, Langchain with Pinecone and different language models (OpenAI, Cohere), LlamaIndex with Weaviate Vector Store's hybrid search, Google's RAG implementation on Cloud Vertex AI Search, Amazon SageMaker's RAG, and a novel approach called KG-FID Retrieval.</p>

    <p class="papers">The motivation for this analysis arises from the increasing demand for robust and responsive question-answering systems in various domains. The RobustQA metric is used to evaluate the performance of these systems under diverse paraphrasing of questions. The report aims to provide insights into the strengths and weaknesses of each method, facilitating informed decisions in the deployment and development of AI-driven search and retrieval systems.</p>
  </Accordion>

  <Accordion title="OmniACT: a dataset and benchmark for enabling multimodal generalist autonomous agents for desktop and web" icon="square-4">
    <a href="https://arxiv.org/abs/2402.17553">Link to paper</a>

    <p class="papers">February 2024</p>

    <p class="papers">For decades, human-computer interaction has fundamentally been manual. Even today, almost all productive work done on the computer necessitates human input at every step. Autonomous virtual agents represent an exciting step in automating many of these menial tasks. Virtual agents would empower users with limited technical proficiency to harness the full possibilities of computer systems. They could also enable the efficient streamlining of numerous computer tasks, ranging from calendar management to complex travel bookings, with minimal human intervention. </p>

    <p class="papers">In this paper, we introduce OmniACT, the first-of-a-kind dataset and benchmark for assessing an agent's capability to generate executable programs to accomplish computer tasks. Our scope extends beyond traditional web automation, covering a diverse range of desktop applications. The dataset consists of fundamental tasks such as "Play the next song", as well as longer horizon tasks such as "Send an email to John Doe mentioning the time and place to meet". Specifically, given a pair of screen image and a visually-grounded natural language task, the goal is to generate a script capable of fully executing the task.</p>

    <p class="papers">We run several strong baseline language model agents on our benchmark. The strongest baseline, GPT-4, performs the best on our benchmark However, its performance level still reaches only 15% of the human proficiency in generating executable scripts capable of completing the task, demonstrating the challenge of our task for conventional web agents.Our benchmark provides a platform to measure and evaluate the progress of language model agents in automating computer tasks and motivates future work towards building multimodal models that bridge large language models and the visual grounding of computer screens.</p>
  </Accordion>

  <Accordion title="Fusion-in-decoder: achieving state-of-the-art open-domain QA performance" icon="square-5">
    <a href="https://www.researchgate.net/publication/374031063_Achieving_State-of-the-Art_Open-Domain_QA_Performance_through_Fusion-in-Decoder_Method">Link to paper</a>

    <p class="papers">September 2023</p>

    <p class="papers">Open-domain question answering (QA) has recently made significant progress, with generative models like Transformers demonstrating impressive performance. However, these models are computationally expensive to train and query, limiting their practical application. In this whitepaper, we introduce a novel approach to open-domain QA that combines the strengths of retrieval and generative models, aiming to achieve more efficient and accurate question answering.</p>

    <p class="papers">Our approach, termed Fusion-in-Decoder, retrieves informative passages and leverages them with a sequence-to-sequence model to generate answers. This method demonstrates state-of-the-art results on benchmarks like Natural Questions and TriviaQA, and offers a highly scalable framework for aggregating and combining information from multiple passages.</p>
  </Accordion>

  <Accordion title="Becoming self-instruct: introducing early stopping criteria for minimal instruct tuning" icon="square-6">
    <a href="https://arxiv.org/abs/2307.03692">Link to paper</a>

    <p class="papers">July 2023</p>

    <p class="papers">In this paper, we introduce the IFS, a metric for instruction following. The metric detects language models' ability to follow instructions. First, IFS can distinguish between base and instruct models. We benchmark public bases and models, showing they're well-formatted responses to partial and full sentences are effective. The metric can be used as a measure between model classes. </p>

    <p class="papers">We compute IFS for Supervised early stopping. Follow instructions early and finetune later. As an example, we show model predictions are objective. We show that semantic changes can be caused by auxiliary metric ObjecQA. When IFS decomposes, it steepens. IFS and semantic factors start a controllable instruct trend. Tuning and querying opens minimal instruct interfaces Foundation models are short-lived.</p>
  </Accordion>

  <Accordion title="Palmyra-Med: instruction-based fine-tuning of LLMs enhancing medical domain performance" icon="square-7">
    <a href="https://www.researchgate.net/publication/372157453_Palmyra-Med_Instruction-Based_Fine-Tuning_of_LLMs_Enhancing_Medical_Domain_Performance">Link to paper</a>
    <p class="papers">July 2023</p>

    <p class="papers">Palmyra-20b and Palmyra-40b are two cutting-edge large language models (LLMs) that were fine-tuned and evaluated for medical language understanding tasks. By applying instruction-based fine-tuning on a custom-curated medical dataset of 200,000 examples, we create novel, fine-tuned models, Palmyra-Med-20b and Palmyra-Med-40b. Performance is then measured across multiple medical knowledge datasets, including PubMedQA and MedQA.</p>

    <p class="papers">Our fine-tuned models outperform both their base counterparts and other LLMs pre-trained on domain-specific knowledge. This research demonstrates the effectiveness of instruction-based fine-tuning in enhancing LLMs performance in the medical domain.</p>
  </Accordion>

  <Accordion title="Grammatical error correction: a survey of the state of the art" icon="square-8">
    <a href="https://arxiv.org/pdf/2211.05166.pdf">Link to paper</a>

    <p class="papers">April 2023</p>

    <p class="papers">Grammatical Error Correction (GEC) is the task of automatically detecting and correcting errors in text. The task not only includes the correction of grammatical errors, such as missing prepositions and mismatched subject-verb agreement, but also orthographic and semantic errors, such as misspellings and word choice errors respectively. The field has seen significant progress in the last decade, motivated in part by a series of five shared tasks, which drove the development of rule-based methods, statistical classifiers, statistical machine translation, and finally neural machine translation systems which represent the current dominant state of the art.</p>

    <p class="papers">In this survey paper, we condense the field into a single article and first outline some of the linguistic challenges of the task, introduce the most popular datasets that are available to researchers (for both English and other languages), and summarise the various methods and techniques that have been developed with a particular focus on artificial error generation. We hope that this survey will serve as comprehensive resource for researchers who are new to the field or who want to be kept apprised of recent developments.</p>
  </Accordion>
</AccordionGroup>


# Transparency
Source: https://dev.writer.com/home/transparency



Ensuring transparency and accountability in AI systems

## Introduction

The complexity of deep learning models like Palmyra-X makes them remarkably powerful but also increasingly opaque. As the adoption of these AI technologies expands, the necessity for transparency and accountability becomes critical. Writer addresses these concerns by employing a multi-tiered approach that leverages cutting-edge algorithms and technologies. This article provides a detailed technical perspective on these strategies.

## Tools and algorithms for insights into decision-making

<Tabs>
  <Tab title="Attention mechanism analysis">
    In transformer-based models like Palmyra, attention mechanisms play a crucial role in determining output. By visualizing the weights in the multi-headed attention layers, one can gain insights into which input tokens significantly influence the output. Algorithms like layer-wise relevance propagation can be employed to decompose these attention scores.
  </Tab>

  <Tab title="SHAP">
    SHAP (SHapley Additive exPlanations) values are derived from cooperative game theory and offer a unified measure of feature importance. By computing SHAP values for each feature in the input data, one can quantify how much each feature contributes to a particular decision, thus offering a granular view of the model's inner workings.
  </Tab>

  <Tab title="Comprehensive logging">
    A robust logging system captures not just input-output pairs but also intermediate representations, attention maps and activation functions. Tools like TensorBoard with custom dashboards are used for real-time monitoring and auditing at testing stage.
  </Tab>

  <Tab title="Bayesian A/B testing">
    Traditional A/B testing is enhanced with Bayesian statistical methods to rigorously compare the performance and decision-making processes of different model versions. This provides confidence intervals and posterior distributions that offer more nuanced insights than point estimates.
  </Tab>
</Tabs>

## Addressing the 'opaque' nature of AI: explainability and transparency

<Tabs>
  <Tab title="LIME">
    Local Interpretable Model-agnostic Explanations (LIME) is used to create surrogate models that approximate the behavior of the complex model in the vicinity of the instance being explained. By perturbing the input and observing the output, LIME fits a simple model that is easier to interpret, thus shedding light on the original model's decision-making process.
  </Tab>

  <Tab title="Counterfactual Explanations">
    Counterfactual explanations provide "what-if" scenarios that help understand how a different input could lead to a different output. We use DiCE Algorithm (Diverse Counterfactual Explanations) to generate these scenarios.
  </Tab>

  <Tab title="Open Source and Community Auditing">
    Releasing the models under an open-source Apache 2.0 license allows for community-based auditing. Skilled developers and researchers can scrutinize the codebase, algorithms, and even contribute to enhancing transparency features.
  </Tab>

  <Tab title="Differential Privacy">
    To safeguard user data while maintaining transparency, differential privacy algorithms like Laplace noise addition or Differential Privacy SGD are implemented. This allows the model to be queried for insights without revealing any individual data points.
  </Tab>
</Tabs>

## Compliance and regulations

For regulatory compliance, techniques such as Automatic Fairness Verification and Fairness-aware Learning are integrated into the model training pipeline. These ensure that the model meets standards like GDPR, which mandates the right to explanation for automated decisions.

## Conclusion

Transparency and accountability in AI models are complex challenges that require a multi-layered, algorithmically robust approach. By employing advanced techniques like SHAP, LIMEâ€Œ and Bayesian A/B testing, Writer aims to open up the "black box" of its AI models. While full transparency remains a moving target, these technologies and methodologies provide a comprehensive framework for making significant strides in understanding and auditing AI systems.


# Chat
Source: https://dev.writer.com/no-code/chat



Agents with the chat capability can answer questions with tailored responses based on topics, personas, or data.

![Agent with chat capabilities](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/chat-agent.png)

## Building an agent with chat

To build an agent with chat capabilities, choose the **Chat** option after clicking **Build an agent** in AI Studio.

![Create an agent with chat](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/build-options.png)

## Writing a welcome message

Next, create a welcome message. A welcome message is the first message your users will see. Greet them, tell them how to use the chat, and include any special instructions or anything else they should know.

![welcome-message](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/welcome-message.png)

## Creating an avatar

Choose an avatar for your chat. This can be your company logo or any other image you prefer.

![Creating a chat avatar](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/creating-avatar.png)

<Info> Currently only .svg files are supported.</Info>

## Choosing a mode

To choose the right mode for your chat you need to decide how your users will interact with it. If you want them to ask general questions, choose the **General chat mode**. If you want them to ask specific questions about your company's data, choose the **Knowledge Graph mode**.

<Tip>
  [Knowledge Graph](https://support.writer.com/category/241-knowledge-graph) lets you ask questions about your company's data and get reliable, accurate answers. It uses multiple internal sources, making it easy to find information even if you're not sure where it's stored. Read more [here](https://support.writer.com/article/244-how-to-use-knowledge-graph).
</Tip>

Here is a detailed breakdown:

#### General chat mode

* Use this mode to ideate or create content

#### Knowledge Graph mode

* Use this mode to get answers from your company's data
* Before you can use Knowledge Graph mode, you need to set up a [Knowledge Graph](https://support.writer.com/article/244-how-to-use-knowledge-graph) with all the relevant files for your use case. You can do this from the side navigation bar. You won't be able to build a chat with a Knowledge Graph if no Knowledge Graph exists. Read how to set it up [here](https://support.writer.com/article/242-how-to-create-and-manage-a-knowledge-graph).

#### Document mode

* Use this mode to answer questions about specific documents
* You can specify the number, types, and sources of documents you want to allow users to upload. You can also choose to allow users to add URLs or copy and paste text.

You'll need to select at least one mode. If you're not sure which one to choose, select the General chat mode.

![Choosing a mode for your agent with chat capabilities](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/choosing-mode.png)

## Providing instructions

All of the modes allow you to provide instructions. Instructions are the system messages that reach the LLM and can be used to provide context or structure to how your chat responds to requests.

For example, you can use instructions to:

1. Request answers in a specific language by providing examples.
2. Patch stale data in your Knowledge Graph that's hard to retrieve by providing additional information.
3. Provide context about the users and how to address them.
4. Set limits on the topics that can be answered.

Your instructions will tell the LLM what answers to generate and how to format them.

![Providing instructions](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/mode-instructions.png)


# Chat with Knowledge Graph
Source: https://dev.writer.com/no-code/chat-kg



export const PromptComponent = ({prompt}) => <div>
    <p class="prompts">{prompt}</p>
  </div>;

With Knowledge Graph mode for chat agents, you can create agents that can search for information and answer questions specific to your company's data.

This guide walks through the steps to create a Knowledge Graph from a Confluence space. Then, it creates a chat agent that uses that Knowledge Graph to answer questions about your company's policies.

![Example of a chat agent with Knowledge Graph](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/kg-chat.png)

<Steps>
  <Step title="Create a Knowledge Graph">
    To get started, set up a Knowledge Graph in Writer.

    From the home screen of AI Studio, click **Knowledge Graphs** in the left sidebar and click **Add a Graph**.

    ![Create a Knowledge Graph](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/create-knowledge-graph.png)

    <Warning>Knowledge graphs created in AI Studio aren't accessible in the Ask Writer core app unless you define the Knowledge Graph as part of a custom agent.</Warning>
  </Step>

  <Step title="Add graph name and description">
    In the modal that appears, give your graph a name and description.
    ![Add a graph](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/kg-options.png)
  </Step>

  <Step title="Add data to your graph">
    Choose how you want to add your data to the graph and add your data:

    * Add via manual file upload: Upload files manually from your device
    * Add via data connector: Integrate data from an existing tool such as Confluence, Notion, and Google Drive
    * Add via API: Send docs to Writer [via the API](/api-guides/knowledge-graph)
    * Add websites: Create a list of websites to search

    This example uses the **Add via data connector** option to integrate data from a Confluence space. To use this option, you need to have access to the Confluence space you want to integrate.

    Learn more about creating and managing a Knowledge Graph in the [Knowledge Graphs support article](https://support.writer.com/article/242-how-to-create-and-manage-a-knowledge-graph).
  </Step>

  <Step title="Create an agent with chat capabilities">
    Once you create your Knowledge Graph, you can then create an agent with chat capabilities and add the Knowledge Graph to the agent.

    From the [AI Studio home page](https://app.writer.com/ai-studio), click **Build an agent** in the top right corner. Then, select **Chat** as the type of agent you want to create.
  </Step>

  <Step title="Enable the Knowledge Graph mode">
    For this example, enable only the **Knowledge Graph mode** so the chat agent answers questions specifically about your company's data from the Knowledge Graph.

    In the agent configuration, turn off the **General chat mode** toggle and turn on the **Knowledge Graph mode**.

    Next, select **Always stay connected to a specific set of graphs** and select the Knowledge Graph you created in the previous step. This ensures that the agent only answers questions about the data in the Knowledge Graph you provide, and doesn't allow the user to switch to a different Knowledge Graph.

    ![Enable Knowledge Graph](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/enable-kg.png)
  </Step>

  <Step title="Add instructions for the model">
    You can add additional instructions for Knowledge Graph mode by clicking **Add instructions**.

    The instructions can include context for the model to understand what this agent does, and what types of answers it should provide. You may also want to include instructions on what to output if someone asks a question that isn't specific to a customer story or quote.

    For example, you could include: <PromptComponent prompt={`If you get a question about a company other than Writer, output: I don't have any information on that.`} />
  </Step>

  <Step title="Test your agent">
    On the right side of the screen, you can see what your agent looks like and test it.

    Try asking a variety of questions to make sure you're getting the types of answers you expect. You can continue to update the instructions until you're happy with the answers you receive.
  </Step>

  <Step title="Deploy your agent">
    Once you're happy with how everything looks, [deploy your agent](/no-code/deploying-an-agent) so that everyone can use it.
  </Step>
</Steps>


# Choosing your use case
Source: https://dev.writer.com/no-code/choosing



With our no-code tools, you can build agents for these use cases:

1. **Chat:** Answer questions with tailored responses based on topics, personas, or data.
2. **Text generation:** Collect specific user inputs and generate customized outputs. Best for long- or short-form structured content, such as blog posts, FAQs, press releases, and newsletters.
3. **Research:** Conduct web research and receive a structured report.

Define the structure of the agent by outlining the inputs (the information you provide) and the outputs (the content you receive).

Here are some input and output examples:

## Chat

**Inputs:**

* User queries about specific topics (e.g., "What are your store hours?")
* User requests for assistance (e.g., "Help me track my order.")

**Outputs:**

* Direct answers to user queries (e.g., "Our store hours are 9 AM to 9 PM, Monday through Friday.")
* Assistance responses and guidance (e.g., "I can help you track your order. Please provide your order ID.")

## Text generation

**Inputs:**

* Content briefs or outlines that specify the topic you want to write about, the SEO keywords and a CTA you want to include.

**Outputs:**

* Completed text that includes SEO keywords and the specific CTA

## Research

**Inputs:**

* Questions or briefs about the topic that you want to research.
* Whether the research should perform a general search of the web or limit the search to specific sources.

**Outputs:**

* A summary of the information found, including links to the sources.


# Deploying an agent
Source: https://dev.writer.com/no-code/deploying-an-agent



<Warning> Only full-access users can deploy agents.</Warning>
To deploy a no-code agent, first click on the **Deploy** tab at the top of the page. Depending on your organization's status, you'll have up to four deployment options:

* [**Playground**](#playground): Receive a URL to share with others to test the agent.
* [**Embed agent**](#embed-agent): Embed the agent on your own website or portal.
* [**Deploy to Slack**](#deploy-to-slack): Enable the agent for use within Slack.
* [**Deploy to Writer**](#deploy-to-writer): Enable the agent for use within Writer.

## Playground

Playground is the easiest way to share and test your agent. Just go to **Deploy** and turn on the Playground toggle. You can either copy the Playground URL to share with others, or open the agent in **Playground** in a new tab.

![Deploying an agent to the playground](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/playground.png)

The **Open** button will take you directly to this agent through the Playground, while the **Copy link** option will generate a shareable link that you can send to any tester or end user to get feedback on your agent.

<Warning>
  Links to the Playground view of an agent don't require authentication. This can be useful for providing external users access to test an agent (they won't be able to navigate elsewhere within your AI Studio).
</Warning>

## Embed agent

Embedding an agent allows you to embed the agent on your own website or portal.

<Steps>
  <Step title="Toggle embed option">
    First, go to the **Deploy** tab and toggle the **Embed Agent** option.
    ![Embedding an agent](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/embed-agent.png)
  </Step>

  <Step title="Add domains to allowlist">
    Prevent unauthorized use of this agent by adding domains to the allowlist
    ![Add domains to allowlist](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/embed-allowlist.png)
  </Step>

  <Step title="Select embed style">
    After enabling embed, select your preferred style: centered or widget.
    ![Embedding styles](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/embed-style.png)
  </Step>

  <Step title="Copy the snippet">
    You'll see a block of code that contains the snippet you need to include wherever you want, such as on your own website or portal. Copy the iFrame snippet and share it with your engineering team to embed this agent. You can disable the embed snippet at any time in AI Studio, and any changes you push will immediately update the embeds.
    ![Copy the iFrame snippet](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/embed-iframe.png)
  </Step>
</Steps>

## Deploy to Slack

If your organization uses chat agents with General chat mode or Knowledge Graph mode with AI Studio graphs, you'll see a Deploy to Slack option. This allows you to enable the agent for use within Slack. Once deployed, the agent will be available in Slack, and you'll be able to access it directly from within your workspace.

<Warning>Deployed agents in Slack will charge token usage. Please refer to our [pricing page](/home/pricing) for more details.</Warning>
<Note>You'll have access to this deployment option if your organization uses agents with chat capabilities using General chat mode or Knowledge Graph mode.</Note>

<Steps>
  <Step title="Toggle Slack option">
    First, go to the **Deploy** tab and click the **Connect to Slack** link.
    ![Deploying an agent to Slack](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/deploy-slack.png)
  </Step>

  <Step title="Go through the OAuth flow">
    Next, you'll need to go through the OAuth flow to allow Writer to access your Slack workspace.
    ![Go through the OAuth flow](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/slack-2.png)
  </Step>

  <Step title="Toggle Slack option">
    You can now toggle the **Deploy to Slack** option to enable the agent for use within Slack.
  </Step>

  <Step title="Connect to Writer">
    Once the agent is Slack-enabled, you can start interacting with it by clicking the Writer button in Slack and selecting "Connect to Writer."
    ![Connect to Writer](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/slack-1.png)
  </Step>

  <Step title="Return to Slack">
    When you return to Slack, the agent will be available for use. You'll see that the Q\&A functionality is now integrated within Slack.
    ![Return to Slack](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/slack-3.png)
  </Step>

  <Step title="Select interaction mode">
    When using the agent in Slack, you'll have two interaction modes:

    * **General mode:** If the agent uses General mode and doesn't include a Knowledge Graph mode, simply select it and start chatting.
    * **Knowledge Graph mode:** If the agent includes a Knowledge Graph, select the interaction modeâ€”either Knowledge Graph mode or General mode.
      * In General mode, it'll function like a non-graph-enabled agent.
      * In Knowledge Graph mode, you'll be prompted to connect the relevant graphs. Once connected, you can start chatting with the agent.

    If the agent is built with specific data constraints (e.g., a sales Q\&A agent linked only to Salesforce data), you'll select the Knowledge Graph, and the setup will be complete without needing to choose different graphs. This deployment mode leverages the configurations set in the agent builder, ensuring the agent behaves as expected in Slack
    ![Select interaction mode](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/slack-4.png)
  </Step>
</Steps>

## Deploy to Writer

If your organization uses the Writer App in addition to AI Studio, you'll see a **Deploy to Writer** option. This allows you to select specific teams in Writer where you want to deploy the agent.
<Note>You'll have access to this option if you have access to the Writer App.</Note>

<Steps>
  <Step title="Update Agent Info">
    Before deploying to Writer, update the **Agent Info** under the **Agent Guide** tab to provide helpful information about the agent to users.
    ![Agent Info](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/agent-info.png)
  </Step>

  <Step title="Deploy to Writer">
    Click the deploy button. Once deployed, the agent will be available to those teams within the app library. You can choose to deploy the agent to all teams or select specific teams.
    ![Deploy to Writer](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/deploy-writer.png)
  </Step>
</Steps>


# Create an earnings call agent
Source: https://dev.writer.com/no-code/earnings-call-agent



This agent takes information from an earnings call transcript and puts it together in a summary report. The report covers results for the period, future plans, and management opinions. It uses [Palmyra Financial](/home/models#palmyra-fin), a Writer model specifically trained for financial analysis with a large context window to handle the length of earnings call transcripts.

![Earnings call agent](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/earnings-agent.png)

Below are the steps to create this earnings call agent. To follow along, first log in to [AI Studio](https://app.writer.com/aistudio).

<Steps>
  <Step title="Create a new agent with text generation capabilities">
    From the [AI Studio home page](https://app.writer.com/aistudio), click **Build an agent** in the top right corner. Then, select **Text generation** as the type of agent you want to create.
  </Step>

  <Step title="Define your inputs">
    This agent requires the earnings call transcript as input.

    Define one input of type **File upload** with the name: **Earnings Call Transcript**. You can specify whether to allow the user to add a URL, upload a file, or paste text. You can also specify the file type to be uploaded.

    *Optional: You could also add text inputs for company name and reporting period if you want those to be dynamic.*
  </Step>

  <Step title="Add the quarterly results prompt">
    This agent uses multiple prompts to break down the task: one for summarizing results, one for forward-looking guidance, and one for management commentary.

    Add a prompt of type with the name **Quarterly Results** and select **Palmyra Financial** as the model.

    Add the following prompt:

    ```
    You are a financial analyst who excels at producing summaries of financial reports.

    Here is your report to analyze:

    <report>@File input</report>

    Instructions:

    - Analyze the dates given in the report to determine what timeframe the report is for
    - Financial reports are often produced on a quarterly basis.
    - Extract key business result here for the quarter the earnings call is for
    - These highlights should be all about the numbers
    - You must pull out as many of these as you can find in the earnings call.
    - You must pull out a minimum of 5 results, but you should write more if there are more key results to share.
    - Copy the most relevant portion of the earnings call for each result you find here. Each result should have a supporting extract copied from the document. Do not modify the extract, just copy it exactly as it appears in the earnings call.
    - Output as HTML instead of Markdown

    Output:
    ```
  </Step>

  <Step title="Add the future guidance prompt">
    Add a prompt of type with the name **Future Guidance** and select **Palmyra Financial** as the model.

    Add the following prompt:

    ```
    You are a financial analyst who excels at producing summaries of financial reports.

    Here is your report to analyze:

    <report>@File input</report>

    Instructions:

    - If this report contains information about future quarters:
    - Extract as many statistics from the future quarter guidance as you can
    - There should be at least 5 of these statistics
    - Remember to focus on the numbers
    - Output as HTML, not Markdown

    Output:
    ```
  </Step>

  <Step title="Add the management commentary prompt">
    Add a prompt of type with the name **Management Commentary** and select **Palmyra Financial** as the model.

    Add the following prompt:

    ```
    You are a financial analyst who excels at producing summaries of financial reports. The management of the company the earnings call is for will cover a variety of themes during the earnings call. 

    Here is your report to analyze:

    <report>@File input</report>

    Instructions:

    - Pull out a list of at least 5 themes
    - Each theme should have a longer quote from the report that covers what the management of the company has to say about it. These can be quite lengthy and should give detail about the selected theme. Include a quote to go with each theme.
    - Output as HTML, not Markdown

    Output:
    ```
  </Step>

  <Step title="Add the participants prompt">
    Add a prompt of type with the name **Participants** and select **Palmyra Financial** as the model.

    Add the following prompt:

    ```
    You are a financial analyst who excels at producing summaries of financial reports. Your specific goal is to extract any and all participants from financial call transcripts or reports. Include any names and titles of participants.

    Here is your report to analyze:

    <report>@File input</report>

    Instructions:

    - Pull out all participants from the report
    - Include all participants as a bulleted list
    - If included, share the title/job name of each participant
    - Output as HTML, not Markdown

    Output:
    ```
  </Step>

  <Step title="Format your output">
    Add the following to the **Output formatting** section:

    ```
    <h3>Participants:</h3>
    @Participants
    <h3>Quarterly Report:</h3>
    @Quarterly Results
    <h3>Future Guidance:</h3>
    @Future Guidance
    <h3>Management Commentary:</h3>
    @Management
    ```
  </Step>

  <Step title="Test and refine your output">
    Review the generated summary. If it's not capturing the right information or the tone is off, tweak your prompts. Consider adding more specific instructions or examples to guide the model.
  </Step>

  <Step title="Deploy your agent">
    Once you're happy with the summary quality, [deploy your agent](/no-code/deploying-an-agent) so others can use it. Developers can also [invoke this agent with the API](/api-guides/applications) and [use it with tool calling](/api-guides/applications-tool-calling) to integrate into other agentic workflows.
  </Step>
</Steps>


# Editing an agent
Source: https://dev.writer.com/no-code/editing-an-agent



You can edit a deployed agent's name, configuration, and metadata (in Agent Guide) and then push the changes to the deployed instances of the agent. To edit your deployed agent:

<Steps>
  <Step title="Click Unlock to edit">
    Click **Unlock to edit** to change either the agent configuration or the agent itself.
    ![Editing an agent](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/edit-button.png)
  </Step>

  <Step title="Edit the agent">
    Edit the agent's name, configuration, or metadata (in Agent Guide).
    ![Editing an agent](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/edit-agent.png)
  </Step>

  <Step title="Push name or metadata changes only">
    If you've only edited the agent's name or metadata, click the down arrow and select **Push configuration changes only** or **Push guide changes only**.
    ![Push name or metadata changes](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/push-config-button.png)
  </Step>

  <Step title="Push all changes">
    If you want to push all changes, click **Push all changes** to update the deployed instances of your agent.
    ![Editing an agent](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/push-button.png)
  </Step>
</Steps>


# No-code agents
Source: https://dev.writer.com/no-code/introduction



No-code tools let you build agents **without writing any code** to compress your workflowsâ€”automate repetitive tasks, create branded content, and develop knowledge assistants based on your company's data. Simply define the required inputs, the instructions for the agent to follow, and the desired output structure. Once you've built the agent, deploy it and edit it at any time.

![Agent capabilities](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/agent-capabilities.png)

You can build no-code agents for:

1. **Recurring** **tasks** that require repetitive processing, such as creating
   recurring content.
2. **Time-intensive tasks** that require extensive back-and-forth communication between
   contributors to complete.
3. **Structured** **tasks** that require the same information
   to be requested and always produce the same result.
4. **Voice-specific** **tasks** that require a particular tone, style, or format.

<Tip>Explore the pre-built, no-code agents in [Templates](https://app.writer.com/aistudio/templates). When you find one
you like, click "Try in builder" to copy and test it. If it meets your needs,
you can deploy it immediately and edit it after deployment.</Tip>


# Create a newsletter generation agent
Source: https://dev.writer.com/no-code/newsletter-agent



Newsletters need to easy-to-understand and jargon-free, and can take hours to writeâ€”especially if you're sending them weekly. Creating an agent can help you get these newsletters out faster and written in a way that your customers can understand.

![newsletter agent showing inputs, prompts, and the generated newsletter content preview.](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/newsletter.png)

Below are the steps to create this newsletter agent. To follow along, first log in to [AI Studio](https://app.writer.com/aistudio).

<Steps>
  <Step title="Create a new agent with text generation capabilities">
    From the [AI Studio home page](https://app.writer.com/aistudio), click **Build an agent** in the top right corner. Then, select **Text generation** as the type of agent you want to create.
  </Step>

  <Step title="Define your inputs">
    This example is a newsletter that always includes three key components:

    * Communication about new features, products, or white papers
    * A customer spotlight
    * Information about the latest blog post

    Each of these components is an input. Define three inputs, each of the type **File upload**, with the names:

    * Feature info/whitepapers
    * Customer Spotlight
    * Blog to promote
  </Step>

  <Step title="Write your prompts">
    There are several ways to break up the prompts for generating a newsletter. In this example, create two prompts: one to generate the subject line and one to generate the body of the newsletter.

    The prompt for the subject line is:

    > Create a subject line for a weekly newsletter about the new features, customer spotlights, and featured blog posts.

    The prompt for the body of the newsletter is:

    > Create a newsletter for Writer customers. The newsletter should include:
    >
    > * communication about new features, products, or white papers. These items to highlight are in `@Feature info/whitepapers`
    > * a customer spotlight. The customer spotlight information is in `@Customer Spotlight`
    > * a blog article to promote, which is in `@Blog to promote`
    >
    > Avoid jargon and complex language. Although the newsletter may cover fairly complex topics, it should be accessible to everyone.
    > The newsletter should follow this format:
    >
    > * a greeting and introduction
    > * new features/products/whitepaper communications
    > * the customer spotlight
    > * blog article to promote
    >
    > Include suggestions for images that can break up each section.
  </Step>

  <Step title="Format your output">
    Decide how you want your output to look in the Output formatting section. You can use [Markdown](https://www.markdownguide.org/) to format your output.

    In this example, the output is a newsletter with a subject line and body:

    > @subject\_line
    >
    > @body
  </Step>

  <Step title="Test and refine your output">
    The first version of your newsletter may not be what you're looking for. That's okay! The more you tweak your prompts and provide examples, the better your output will be.

    It can also be helpful to provide examples in your prompts of newsletters and subject lines you think are the best. That way, Writer can learn from what you consider to be the best newsletters.
  </Step>

  <Step title="Deploy your agent">
    Once you're happy with how everything looks, [deploy your agent](/no-code/deploying-an-agent) so that everyone can use it. Developers can also [invoke this agent with the API](/api-guides/applications) and [use it with tool calling](/api-guides/applications-tool-calling) to integrate into other agentic workflows.
  </Step>
</Steps>


# Research
Source: https://dev.writer.com/no-code/research



A no-code agent with the research capability can perform web research on a specific topic. You can use the pre-built research type or create a custom one that can be tailored to a specific topic and writing style.

![Research screen](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/research-assistant.png)

## Building an agent with research capabilities

To build an agent with research capabilities, first choose the **Research assistant** option after clicking **Build an agent** in AI Studio.

![Create a research agent](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/build-options.png)

## Selecting the type of research

The first step is to select the type of research from the **Research** menu to incorporate into your agent. You have the option of choosing from a selection of pre-built research that specialize in popular topics, or creating a custom one that can be tailored to a specific topic and writing style.

!["Research" drop-down menu displaying all options](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/research-assistant-menu.png)

### Pre-built research

The **Research** menu starts with this selection of pre-built research:

* **Auto research**: Specializes in gathering information about cars and automotive topics.
* **Finance research**: Use this research for topics related to finance and investing.
* **Business research**: This research is designed to help with business-related topics.
* **Travel research**: For topics about travel and tourism, use this research.

### Custom research

**Custom research**, the final option in the **Research** menu, allows you to create research tailored to your specific needs. When you select this option, the **Edit instructions** link will appear.

!["Research" menu, with "Custom research" selected and Edit instructions" link](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/custom-assistant.png)

Click this link to open the **Custom instructions** window, where you can specify how the research should behave, what topics it should cover, and how it should respond to user queries.

!["Custom instructions" window](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/custom-instructions.png)

## Giving the research search parameters

The **Search type** options allow you to specify how the research should search for information.

!["Search type" menu, with "Web search" selected](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/search-type.png)

You can choose from the following:

* **Web search**: The research will search the web for information.
* **Specific URLs**: The research will limit its search to the web sites or pages you specify. When you select this option, a text field will appear where you can enter one or more URLs of the sources you want the research to search. Note that the URLs you provide must start with `http://` or `https://`.

![Search type menu, with "Specific URLs" selected, and text field for entering URLs](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/specific-urls.png)


# Text generation
Source: https://dev.writer.com/no-code/text-generation



Agents with the text generation capability can generate text based on specific inputs. These no-code agents are ideal for long- or short-form structured content, such as blog posts, FAQs, press releases, and newsletters.

![Agent with text generation](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/text-generation-agent.png)

## Building an agent with text generation

To build an agent with text generation capabilities, choose the **Text generation** option after clicking **Build an agent** in AI Studio.

![Create a text generation agent](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/build-options.png)

An agent with text generation capabilities consists of:

* [Adding inputs](/no-code/text-generation#inputs)
* [Writing prompts](/no-code/text-generation#prompts)
* [Formatting outputs](/no-code/text-generation#output-formatting)
* [Choosing a voice](/no-code/text-generation#voice)

## Inputs

An input is content information for your text generation. It generates the desired outputâ€”the content your text generation will produce.

For example, if you're building a blog post, the input would include the blog post topic, outline, keywords, reference materials, research sources, and existing knowledge about the topic.

### Types of inputs

There are four types of inputs:

1. Text input: A text input allows users to enter text directly into the text generation.
2. Dropdown: A dropdown input allows users to select one option from a list.
3. File upload: A file upload input allows users to upload a file, such as an image or PDF.
4. Image upload: An image upload input allows users to drag-and-drop or choose an image.

### Adding an input

Once you've decided what type of input you want to add, you'll need to:

<Steps>
  <Step title="Add an input">
    Click **Add input** and select the type of input you want to add.
    ![Adding an input](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/text-input.png)
  </Step>

  <Step title="Name your input">
    Give your input a name that clearly communicates its purpose to users. This
    will help them understand what information they need to provide.
    ![Adding an input](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/adding-input.png)
  </Step>

  <Step title="Decide whether the input is required or optional">
    If it's required, users must enter information in that field in order to use
    the text generation. If it's optional, they can skip it.
  </Step>

  <Step title="Add placeholder text or descriptions">
    Provide placeholder text or descriptions to clarify what information is required. This ensures that users fully understand what they need to enter.
  </Step>

  <Step title="Control what users can upload">
    If you selected a file upload input, you can restrict the type of file users can upload. For example, if your agent expects a specific type of an .XLSX file, restrict other file types from being allowed. This will guide users to use the agent as intended.
  </Step>
</Steps>

## Prompts

A prompt is a message that you send to the model. It can be a single prompt consisting of a few lines, or a complex prompt consisting of multiple stepsâ€”each with its own prompt that relies on multiple inputs. You can even use prompting techniques such as chain-of-thought (CoT) prompting, where one prompt output becomes an input to the next prompt, and so onâ€”creating a chain of thought.

<Tip>Check out our [prompting guide](/home/prompting) for strategies on how to write effective prompts.</Tip>

### Adding prompts

You can add multiple prompts to your text generation.

<Steps>
  <Step title="Add a prompt">
    Click **Add prompt** and select the type of prompt you want to add.
    ![Adding a prompt](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/add-prompt.png)
  </Step>

  <Step title="Choose a model">
    Select the [model](/home/models) you want to use for your prompt, as well as any parameters like temperature, top P, and max length.
    ![Choosing a model](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/model-params.png)
  </Step>

  <Step title="Write your prompt">
    Write your prompt using the guidelines below and our [prompting guide](/home/prompting).
  </Step>
</Steps>

### How to use prompts effectively

You can ask the model to perform various tasks, but it's best to break down your prompts into smaller, more specific "asks." This is especially important for complex, multi-step text generation. Otherwise, you risk overwhelming the model by asking it to perform too many tasks at once.

For example, instead of asking it to create an entire blog post at once, you might write one prompt asking it to create a title, another to create an opening paragraph, and so on.

Follow these [strategies](/home/prompting) to write good prompts.

![post-version-a](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/post-version-a.png)

### Renaming prompts

You can rename prompts from generic names like "Prompt 1" and "Prompt 2" to any custom name.

This will help you to:

1. Stay organized and keep track of your prompts
2. Know exactly what each prompt accomplishes
3. Write your prompts
4. Format your output

![Renaming prompts](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/renaming-prompts.png)

### Referencing inputs

To reference your input, `@` it within the prompt.

For example, if you're writing a prompt to generate social posts based on a blog post, do the following:

1. **Input:** `Blog post`
2. **Prompt 1:** instructions for creating a social post

In your prompt, reference `@Blog post` so that Writer understands that the social post should be based on the blog input.

![Reference an input](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/reference-inputs.png)

<Tip>
  If you have more than one input, you can `@` each one within a single
  prompt.
</Tip>

### Prompt chaining

You can reference other prompts within a prompt by using the `@` symbol, a feature known as prompt chaining.

For example, if you have a long blog post, you might want to summarize it in your first prompt, and use that summary to generate a social media post in your second prompt:

<Steps>
  <Step title="Input">`Long blog`</Step>

  <Step title="Prompt 1">
    Instructions for generating a summary of the `@Long blog` post.
  </Step>

  <Step title="Prompt 2">
    Instructions for generating a social media post based on `Prompt 1`.
  </Step>
</Steps>

In the second prompt, you'd reference `@Prompt 1` to indicate that you want the social media post to be based on the blog summary.

![Referencing a prompt](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/prompt-chaining.png)

## Output formatting

Next, format your outputâ€”the final assembled text generation. To do this, take all your prompt outputs (if you have more than one), format their style, add any static text such as a disclaimer, and combine them together.

You can use Markdown or HTML to specify how you'd like your output to be formatted.

For example, you can use the following formatting:

<CardGroup cols={2}>
  <Card title="Heading Tags" icon="heading">
    Use `<h1>`, `</h1>`, `<h2>`, `</h2>`, and `<h3>`, `</h3>` to denote heading
    text.
  </Card>

  <Card title="Bold Text" icon="bold">
    Use `<strong>` and `</strong>` to denote bolded text.
  </Card>
</CardGroup>

![Output formatting](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/output-formatting.png)

You don't have to include every prompt in your output formatting. For example, a prompt might be used only to summarize and then to create a LinkedIn post (based on the summary). If you don't want to include the summary in your output, you don't have to.

<Tip>
  Because you don't need to reference every prompt in your final output, you can leave interim prompts in your text generation for A/B testing or to get feedback. Combined with the `Rerun` option, this is a great way to efficiently iterate on your text generation.
</Tip>

The simplest text generation will have only one prompt. A more complex text generation might have multiple section headers, each with its own prompt output.

Before adding even more prompts to your text generation, ask yourself:

1. Does the user want this content?
2. Do I need these inputs to generate this output?

## Voice

With voice calibration, you can create outputs that sound just like you, faster. Voice allows you to build your different voices in Writer, and see them in action across the platform in the content you generate. To learn more about voice calibration, see [how to calibrate voice](https://support.writer.com/article/250-how-to-calibrate-voice-for-your-content).

<Note>
  At this time, only English is supported in Writer voice profiles.
</Note>

For an agent with text generation capabilities, you can choose to:

* Automatically generate all outputs using a voice selected by you
* Allow user to choose which voice to apply to their output
* Generate all outputs using Writer's default voice
* Allow users to choose from any voice in their team

![Voice](https://mintlify.s3.us-west-1.amazonaws.com/writer/images/no-code/voice.png)


