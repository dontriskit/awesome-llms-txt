# Overview
Source: https://unkey.com/docs/analytics/overview

Unkey tracks everything for you

Consumption based billing for APIs is getting more and more popular, but it's tedious to build in house. For low frequency events, it's quite possible to emit usage events directly to Stripe or similar, but this becomes very noisy quickly. Furthermore if you want to build end-user facing or internal analytics, you need to be able to query the events from Stripe, which often does not provide the granularity required.

Most teams end up without end-user facing analytics, or build their own system to store and query usage metrics.

Since Unkey already stores and aggregates verification events by time, outcome and identity, we can offer this data via an API.

## Available data

Unkey stores an event for every single verification, the relevent fields are described below:

| Data           | Type          | Explanation                                                                            |
| -------------- | ------------- | -------------------------------------------------------------------------------------- |
| `request_id`   | String        | Each request has a unique id, making it possible to retrieve later.                    |
| `time`         | Int64         | A unix milli timestamp.                                                                |
| `key_space_id` | String        | Each workspace may have multiple key spaces. Each API you create has its own keyspace. |
| `key_id`       | String        | The individual key being verified.                                                     |
| `outcome`      | String        | The outcome of the verification. `VALID`, `RATE_LIMITED` etc.                          |
| `identity_id`  | String        | The identity connected to this key.                                                    |
| `tags`         | Array(String) | Arbitrary tags you may add during the verification to filter later.                    |

We can return this data aggregated by `hour`, `day`, `month`, `tag`, `tags`, `identity`, `key` and `outcome`.
As well as filter by `identity_id`, `key_space_id`, `key_id`, `tags`, `outcome`, `start` and `end` time.

## Example

For an internal dashboard you want to find the top 5 users of a specific endpoint. In order to let Unkey know about the endpoint, you specify it as a tag when verifying keys:

```bash Tagging a verification {6}
curl -XPOST 'https://api.unkey.dev/v1/keys.verifyKey' \
  -H 'Content-Type: application/json' \
  -d '{
    "key": "<API_KEY>",
    "apiId": "api_<API_ID>",
    "tags": [ "path=/my/endpoint" ],
  }'
```

You can now query `api.unkey.dev/v1/analytics.getVerifications` via query parameters.
While we can't provide raw SQL access, we wanted to stay as close to SQL semantics as possible, so you didn't need to learn a new concept and to keep the translation layer simple.

| Name      | Value                             | Explanation                                                                    |
| --------- | --------------------------------- | ------------------------------------------------------------------------------ |
| `start`   | 1733749385000                     | A unix milli timestamp to limit the query to a specific time frame.            |
| `end`     | 1736431397000                     | A unix milli timestamp to limit the query to a specific time frame.            |
| `apiId`   | api\_262b3iR7gkmP7aUyZ24uihcijsCe | The API ID to filter keys.                                                     |
| `groupBy` | identity                          | We're not interested in individual keys, but the user/org.                     |
| `orderBy` | total                             | We want to see the most active users, by how many verifications they're doing. |
| `order`   | desc                              | We're ordering from most active to least active user.                          |
| `limit`   | 5                                 | Only return the top 5.                                                         |

Below is a curl command putting everythign together:

```bash
curl 'https://api.unkey.dev/v1/analytics.getVerifications?start=1733749385000&end=1736431397000&apiId=api_262b3iR7gkmP7aUyZ24uihcijsCe&groupBy=identity&orderBy=total&order=desc&limit=5' \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer <UNKEY_ROOT_KEY>'
```

You'll receive a json response with a breakdown of each outcome, per identity ordered by `total`.

<CodeGroup>
  ```json First Row
  [
    {
      "valid": 186,
      "notFound": 0,
      "forbidden": 0,
      "usageExceeded": 0,
      "rateLimited": 184,
      "unauthorized": 0,
      "disabled": 182,
      "insufficientPermissions": 0,
      "expired": 0,
      "total": 552,
      "apiId": "api_262b3iR7gkmP7aUyZ24uihcijsCe",
      "identity": {
        "id": "test_2ipPuAgat7xuVNGpK6AuPQ2Lbk11",
        "externalId": "user_2rNBR4YXxKwzM8bzVrCR5q6dFlc"
      }
    },
    ...
  ]
  ```

  ```json Full Response
  [
    {
      "valid": 186,
      "notFound": 0,
      "forbidden": 0,
      "usageExceeded": 0,
      "rateLimited": 184,
      "unauthorized": 0,
      "disabled": 182,
      "insufficientPermissions": 0,
      "expired": 0,
      "total": 552,
      "apiId": "api_262b3iR7gkmP7aUyZ24uihcijsCe",
      "identity": {
        "id": "test_2ipPuAgat7xuVNGpK6AuPQ2Lbk11",
        "externalId": "user_2rNBR4YXxKwzM8bzVrCR5q6dFlc"
      }
    },
    {
      "valid": 190,
      "notFound": 0,
      "forbidden": 0,
      "usageExceeded": 0,
      "rateLimited": 161,
      "unauthorized": 0,
      "disabled": 200,
      "insufficientPermissions": 0,
      "expired": 0,
      "total": 551,
      "apiId": "api_262b3iR7gkmP7aUyZ24uihcijsCe",
      "identity": {
        "id": "test_2ipPuAiGJ3L3TUNKA6gp5eLeuyj7",
        "externalId": "user_2rLz6cM63ZQ2v3IU0mryKbHetjK"
      }
    },
    {
      "valid": 197,
      "notFound": 0,
      "forbidden": 0,
      "usageExceeded": 0,
      "rateLimited": 154,
      "unauthorized": 0,
      "disabled": 200,
      "insufficientPermissions": 0,
      "expired": 0,
      "total": 551,
      "apiId": "api_262b3iR7gkmP7aUyZ24uihcijsCe",
      "identity": {
        "id": "test_2ipPuAwJVE4Hdet3dyEpYreP8ob7",
        "externalId": "user_2rLwFchrbyIDb4LUfFp4CpTG0L3"
      }
    },
    {
      "valid": 191,
      "notFound": 0,
      "forbidden": 0,
      "usageExceeded": 0,
      "rateLimited": 184,
      "unauthorized": 0,
      "disabled": 171,
      "insufficientPermissions": 0,
      "expired": 0,
      "total": 546,
      "apiId": "api_262b3iR7gkmP7aUyZ24uihcijsCe",
      "identity": {
        "id": "test_2ipPuB23PVchmbkt9mMjjcpvLM8N",
        "externalId": "user_2rLwCGvQKtnfnemH8HTL4cxWBFo"
      }
    },
    {
      "valid": 207,
      "notFound": 0,
      "forbidden": 0,
      "usageExceeded": 0,
      "rateLimited": 171,
      "unauthorized": 0,
      "disabled": 162,
      "insufficientPermissions": 0,
      "expired": 0,
      "total": 540,
      "apiId": "api_262b3iR7gkmP7aUyZ24uihcijsCe",
      "identity": {
        "id": "test_2ipPuApEvEAXJo9UParPL6inHLLJ",
        "externalId": "user_2rLDPPVfeNB2hn1ARMh2808CdwG"
      }
    }
  ]

  ```
</CodeGroup>


# Quickstarts
Source: https://unkey.com/docs/analytics/quickstarts

Power your own dashboard, reports or usage-based billing

These scenarios should give you a good starting point to understand what is possible and what you need to do.
They are in no particular order and don't build upon each other.

We are using cURL here for demo purposes, but you can use any of our [SDKs](/libraries) for this as well.

<Info>
  Almost all query parameters can be combined to build powerful queries.

  If you run into issues or something doesn't seem possible, please get in touch, so we can figure it out together: [support@unkey.dev](mailto:support@unkey.dev)
</Info>

Detailed explanations about each individual parameter can be found in the [api-reference](/api-reference/analytics/get_verifications).

## User's usage over the past 24h

Assuming you have an identity with `externalId=user_123` and an API with `apiId=api_123`.

```bash
curl 'https://api.unkey.dev/v1/analytics.getVerifications?start=1736673687000&end=1736760087000&externalId=user_123&groupBy=hour&apiId=api_123' \
 -H 'Authorization: Bearer unkey_XXX'
```

This will return 24 elements, one per hour over the last 24h. Each element tells you about the outcomes of verifications in that interval.

```json
[
  {
    "time": 1736672400000,
    "valid": 15125,
    "notFound": 0,
    "forbidden": 0,
    "usageExceeded": 1225,
    "rateLimited": 0,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 0,
    "total": 16350
  },
  {
    "time": 1736676000000,
    "valid": 765,
    "notFound": 0,
    "forbidden": 0,
    "usageExceeded": 0,
    "rateLimited": 0,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 0,
    "total": 765
  },
  ... 21 elements omited
  {
    "time": 1736755200000,
    "valid": 20016,
    "notFound": 0,
    "forbidden": 0,
    "usageExceeded": 0,
    "rateLimited": 0,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 51,
    "total": 20067
  }
]
```

## Daily usage of a user per key in the last month

Assuming you have an identity with `externalId=user_123` and an API with `apiId=api_123`.

```bash
curl 'https://api.unkey.dev/v1/analytics.getVerifications?start=1734168087000&end=1736760087000&externalId=user_123&groupBy=key&groupBy=day&apiId=api_123' \
 -H 'Authorization: Bearer unkey_XXX'
```

This returns 1 element per active key per day and includes the keyId.

```json
[
  // ...
  {
    "time": 1736726400000,
    "valid": 13,
    "notFound": 0,
    "forbidden": 0,
    "usageExceeded": 0,
    "rateLimited": 10,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 0,
    "total": 23,
    "keyId": "key_2zeYsLbpULnEUsvYeFGMeJzACp4j"
  },
  {
    "time": 1736726400000,
    "valid": 5,
    "notFound": 0,
    "forbidden": 0,
    "usageExceeded": 6,
    "rateLimited": 0,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 0,
    "total": 11,
    "keyId": "key_2zeViCGkJpu5zQ8G12jcBoXWy4KH"
  }
]
```

## Total usage per month for an identity

Assuming you have an identity with `externalId=user_123` and an API with `apiId=api_123`.
You should set your `start` to the beginning of the month and `end` to now or end of the month.

```bash
curl 'https://api.unkey.dev/v1/analytics.getVerifications?start=1734168087000&end=1736760087000&externalId=user_123&groupBy=month&apiId=api_123' \
 -H 'Authorization: Bearer unkey_XXX'
```

This returns one element per month.

```json
[
  {
    "time": 1733011200000,
    "valid": 1356136098,
    "notFound": 0,
    "forbidden": 0,
    "usageExceeded": 0,
    "rateLimited": 925255,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 0,
    "total": 1357061353
  }
]
```

## Showing usage in the current billing period

If you want to show a guage or similar to your user about their consumption in the current billing period.

```bash
curl 'https://api.unkey.dev/v1/analytics.getVerifications?start=1734168087000&end=1736760087000&externalId=user_123&groupBy=day&apiId=api_123' \
 -H 'Authorization: Bearer unkey_XXX'
```

This will return one element per day, which you can either display in a chart, or sum up to have a total value.

```json
[
  // ...
 {
   "time": 1736553600000,
   "valid": 98267,
   "notFound": 0,
   "forbidden": 0,
   "usageExceeded": 0,
   "rateLimited": 6816,
   "unauthorized": 0,
   "disabled": 0,
   "insufficientPermissions": 0,
   "expired": 0,
   "total": 105083
 },
 {
   "time": 1736640000000,
   "valid": 20125,
   "notFound": 0,
   "forbidden": 0,
   "usageExceeded": 0,
   "rateLimited": 2525,
   "unauthorized": 0,
   "disabled": 6261,
   "insufficientPermissions": 0,
   "expired": 0,
   "total": 28911
 }
]
```

## Internal dashboard showing top 10 users by API usage over the past 30 days

```bash
curl 'https://api.unkey.dev/v1/analytics.getVerifications?start=1734168087000&end=1736760087000&orderBy=total&order=desc&limit=10&groupBy=identity&apiId=api_123' \
 -H 'Authorization: Bearer unkey_XXX'
```

Returns 10 elements, ordered from most total verifications to least. Each element includes the `identityId` as well as the `externalId` for your reference.

```json
[
  {
    "identity": { "id": "id_123", "externalId": "user_123"},
    "valid": 54,
    "notFound": 0,
    "forbidden": 3,
    "usageExceeded": 6,
    "rateLimited": 10,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 0,
    "total": 73
  },
  {
    "identity": { "id": "id_456", "externalId": "user_6dg"},
    "valid": 24,
    "notFound": 0,
    "forbidden": 1,
    "usageExceeded": 32,
    "rateLimited": 10,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 0,
    "total": 67
  },
  ...
]

```

## Filter by tags

Find out how many verifications were done, where the tag `myTag` was specified.
You can combine this with other parameters to group by days for example.

<Note>
  You can provide multiple tags by providing them as separate query paramters: `?tag=myTag&tag=myOthertag`.
  Filtering multiple tags is a logical `OR`. The result includes all verifications where at least one of the filtered tags was specified.
</Note>

```bash
curl 'https://api.unkey.dev/v1/analytics.getVerifications?start=1734168087000&end=1736760087000&tag=myTag&apiId=api_123' \
 -H 'Authorization: Bearer unkey_XXX'
```

This returns 1 element, a sum of all verifications in the selected time, where the tag `myTag` was specified.

```json

[
  {
    "valid": 5,
    "notFound": 0,
    "forbidden": 0,
    "usageExceeded": 0,
    "rateLimited": 0,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 0,
    "total": 5
  }
]
```

## Filter by key

This only includes verifications of a specific key. You can provide multiple keyIds to filter verifications of any one of those keys.

```bash
curl 'https://api.unkey.dev/v1/analytics.getVerifications?start=1734168087000&end=1736760087000&keyId=key_123&apiId=api_123' \
 -H 'Authorization: Bearer unkey_XXX'
```

```json
[
  {
    "valid": 14,
    "notFound": 0,
    "forbidden": 0,
    "usageExceeded": 0,
    "rateLimited": 10,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 0,
    "total": 24
  }
]
```

## Grouping by tags

To understand usage across your tags, you can group by tags, breaking down all verifications and summing them up per tag combination.

<Note>
  Note this is plural: `&groupBy=tags`.
</Note>

```bash
curl 'https://api.unkey.dev/v1/analytics.getVerifications?start=1734168087000&end=1736760087000&groupBy=tags&apiId=api_123' \
 -H 'Authorization: Bearer unkey_XXX'
```

You'll receive an array of elements. Each element corresponds to one tag combination.

```json
[
  {
    "valid": 50,
    "notFound": 0,
    "forbidden": 3,
    "usageExceeded": 6,
    "rateLimited": 10,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 0,
    "total": 69,
    "tags": [] // these did not have tags specified
  },
  {
    "valid": 1,
    "notFound": 0,
    "forbidden": 0,
    "usageExceeded": 0,
    "rateLimited": 0,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 0,
    "total": 1,
    "tags": [
      "a",
      "b"
    ]
  },
  {
    "valid": 2,
    "notFound": 0,
    "forbidden": 0,
    "usageExceeded": 0,
    "rateLimited": 0,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 0,
    "total": 2,
    "tags": [
      "a",
      "c"
    ]
  },
  {
    "valid": 2,
    "notFound": 0,
    "forbidden": 0,
    "usageExceeded": 0,
    "rateLimited": 0,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 0,
    "total": 2,
    "tags": [
      "a"
    ]
  }
]
```

## Breakdown by individual tag

If you want to see usage for an individual tag, regardless of combination with other tags, you can group by tag.

<Note>
  Note this is singular `&groupBy=tag`.
</Note>

```bash
curl 'https://api.unkey.dev/v1/analytics.getVerifications?start=1734168087000&end=1736760087000&groupBy=tag&apiId=api_123' \
 -H 'Authorization: Bearer unkey_XXX'
```

You'll receive one element per unique tag.

```json
[
  {
    "valid": 1,
    "notFound": 0,
    "forbidden": 0,
    "usageExceeded": 0,
    "rateLimited": 0,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 0,
    "total": 1,
    "tag": "b"
  },
  {
    "valid": 2,
    "notFound": 0,
    "forbidden": 0,
    "usageExceeded": 0,
    "rateLimited": 0,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 0,
    "total": 2,
    "tag": "c"
  },
  {
    "valid": 5,
    "notFound": 0,
    "forbidden": 0,
    "usageExceeded": 0,
    "rateLimited": 0,
    "unauthorized": 0,
    "disabled": 0,
    "insufficientPermissions": 0,
    "expired": 0,
    "total": 5,
    "tag": "a"
  }
]
```


# Get Verifications
Source: https://unkey.com/docs/api-reference/analytics/get_verifications

get /v1/analytics.getVerifications

<Note>
  To use this endpoint, your root key must have the `api.*.read_api` permission.
</Note>

Retrieve usage data from unkey to power your dashboards, reports or usage-based billing.

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jan 01 2025 | Introduced endpoint |


# Create an API
Source: https://unkey.com/docs/api-reference/apis/create

post /v1/apis.createApi

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Dec 06 2023 | Introduced endpoint |


# Delete an API
Source: https://unkey.com/docs/api-reference/apis/delete

post /v1/apis.deleteApi
Permanently delete an API and revoke all keys associated with it

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Dec 06 2023 | Introduced endpoint |


# Delete all keys of an API
Source: https://unkey.com/docs/api-reference/apis/delete-keys

post /v1/apis.deleteKeys

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| May 26 2024 | Introduced endpoint |


# Retrieve an API
Source: https://unkey.com/docs/api-reference/apis/get

get /v1/apis.getApi

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Dec 06 2023 | Introduced endpoint |


# List keys for an API
Source: https://unkey.com/docs/api-reference/apis/list-keys

get /v1/apis.listKeys

## Changelog

| Date        | Changes                       |
| ----------- | ----------------------------- |
| Dec 06 2023 | Introduced endpoint           |
| May 15 2024 | Return updatedAt timestamp    |
| Aug 01 2024 | Return identities             |
| Aug 01 2024 | Added filtering by externalId |


# Authentication
Source: https://unkey.com/docs/api-reference/authentication

Securely authenticating with the Unkey API

Almost all Unkey API endpoints require authentication using a root key. Root keys provide access to your Unkey resources based on their assigned permissions.

## Bearer Authentication

Authentication is performed using HTTP Bearer authentication in the `Authorization` header:

```bash
Authorization: Bearer unkey_1234567890
```

Example request:

```bash
curl -X POST "https://api.unkey.dev/v1/keys.createKey" \
  -H "Authorization: Bearer unkey_1234567890" \
  -H "Content-Type: application/json" \
  -d '{ "apiId": "api_1234" }'
```

## Security Best Practices

Never expose your root key in client-side code or include it in public repositories. For frontend applications, always use a backend server to proxy requests to the Unkey API.

## Root Key Management

Root keys can be created and managed through the Unkey dashboard. We recommend:

1. **Using Different Keys for Different Environments**: Maintain separate root keys for development, staging, and production
2. **Rotating Keys Regularly**: Create new keys periodically and phase out old ones
3. **Setting Clear Key Names**: Name your keys according to their use case for better manageability

## Key Permissions System

Unkey implements a sophisticated RBAC (Role-Based Access Control) system for root keys. Permissions are defined as tuples of:

* **ResourceType**: The category of resource (api, ratelimit, rbac, identity)
* **ResourceID**: The specific resource instance
* **Action**: The operation to perform on that resource

### Available Resource Types

| Resource Type | Description                                       |
| ------------- | ------------------------------------------------- |
| `api`         | API-related resources, such as endpoints and keys |
| `ratelimit`   | Rate limiting resources and configuration         |
| `rbac`        | Permissions and roles management                  |
| `identity`    | User and identity management                      |

### Permission Examples

Specific permission to manage a single API:

```
api.api_1234.read_api
api.api_1234.update_api
```

Wildcard permission to manage all rate limit namespaces:

```
ratelimit.*.create_namespace
ratelimit.*.read_namespace
```

When creating root keys, you can specify exactly what actions they're allowed to perform.

## Authentication Errors

If your authentication fails, you'll receive a 401 Unauthorized or 403 Forbidden response with an error message:

```json
{
  "meta": {
    "requestId": "req_abc123xyz789"
  },
  "error": {
    "title": "Unauthorized",
    "detail": "The provided root key is invalid or has been revoked",
    "status": 401,
    "type": "https://unkey.com/docs/errors/unauthorized"
  }
}
```

If your key is valid but lacks sufficient permissions, you'll receive a 403 Forbidden response:

```json
{
  "meta": {
    "requestId": "req_abc123xyz789"
  },
  "error": {
    "title": "Forbidden",
    "detail": "Your key does not have the required 'api.api_1234.update_api' permission",
    "status": 403,
    "type": "https://unkey.com/docs/errors/forbidden"
  }
}
```

Common authentication issues include:

* Missing the Authorization header
* Invalid key format
* Revoked or expired root key
* Using a key with insufficient permissions


# Overview
Source: https://unkey.com/docs/api-reference/errors-v2/overview

Understanding Unkey's structured error system

<Warning>These errors are only for the v2 API, which is not yet GA.</Warning>

## Introduction

Unkey's error system uses a structured approach to organize and identify errors across the platform. This system makes it easier to understand, debug, and handle errors consistently.

## Error Code Format

All Unkey error codes follow a consistent URN-like format:

```
err:system:category:specific
```

For example: `err:unkey:authentication:missing`

This format breaks down as follows:

* **err**: Standard prefix for all error codes
* **system**: The service area or responsibility domain (e.g., unkey, user)
* **category**: The error type or classification (e.g., authentication, data)
* **specific**: The exact error condition (e.g., missing, malformed)

## Systems

The "system" component identifies where the error originated:

* **unkey**: Errors originating from Unkey's internal systems
* **github**: Errors related to GitHub integration
* **aws**: Errors related to AWS integration

## Categories

The "category" component provides a second level of classification, for example:

* **authentication**: Errors related to the authentication process
* **authorization**: Errors related to permissions and access control
* **application**: Errors related to application operations and system integrity
* **data**: Errors related to data operations and resources
* **limits**: Rate limiting or quota-related errors

## Error Response Format

When an error occurs, the API returns a consistent JSON response format:

```json
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "Authentication credentials were not provided",
    "status": 401,
    "title": "Unauthorized",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/authentication/missing"
  }
}
```

Key fields:

* **requestId**: Unique identifier for the request (important for support)
* **detail**: Human-readable explanation of the error
* **status**: HTTP status code
* **title**: Short summary of the error type
* **type**: URL to detailed documentation about this error

## Documentation Integration

All error codes have a corresponding documentation page accessible via the `type` URL in the error response. These pages provide detailed information about:

* What caused the error
* How to fix the issue
* Common mistakes that lead to this error
* Related errors you might encounter


# err:unkey:application:assertion_failed
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/application/assertion_failed

A runtime assertion or invariant check failed

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "A system integrity check failed while processing your request",
    "status": 500,
    "title": "Internal Server Error",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/application/assertion_failed"
  }
}
```

## What Happened?

This error occurs when Unkey's internal system detects an inconsistency or violation of its expected invariants during the processing of your request. Unlike validation errors which occur when your input is invalid, assertion failures happen when the system's internal state doesn't match what was expected.

Possible causes include:

* Data corruption or inconsistency in Unkey's database
* Bugs in Unkey's business logic
* Race conditions or timing issues
* System state that violates core assumptions
* Incompatible changes between different parts of the system

This type of error is generally not caused by anything you did wrong in your request, but rather indicates an internal issue with Unkey's system integrity.

## How To Fix

Since this is an internal system error, there's usually nothing you can directly do to fix it. However, you can try the following:

1. **Retry the request**: Some assertion failures may be due to temporary conditions that resolve themselves
2. **Contact Unkey support**: Report the error with the request ID to help Unkey address the underlying issue
3. **Check for workarounds**: In some cases, using a different API endpoint or approach might avoid the issue

When contacting support, be sure to include:

* The full error response, including the request ID
* The API endpoint you were calling
* The request payload (with sensitive information redacted)
* Any patterns you've noticed (e.g., if it happens consistently or intermittently)

## Important Notes

* Assertion failures indicate bugs or data integrity issues that Unkey needs to fix
* Unlike many other errors, changing your request is unlikely to resolve the issue
* These errors are typically logged and monitored by Unkey's engineering team
* If you encounter this error consistently, there may be an underlying issue with your account data

## Related Errors

* [err:unkey:application:unexpected\_error](./unexpected_error) - A more general internal error
* [err:unkey:application:service\_unavailable](./service_unavailable) - When a service is temporarily unavailable


# err:unkey:application:invalid_input
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/application/invalid_input

Client provided input that failed validation

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The request contains invalid input that failed validation",
    "status": 400,
    "title": "Bad Request",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/application/invalid_input",
    "errors": [
      {
        "location": "body.limit",
        "message": "must be greater than or equal to 1",
        "fix": "Provide a limit value of at least 1"
      }
    ]
  }
}
```

## What Happened?

This error occurs when your request contains input data that doesn't meet Unkey's validation requirements. This could be due to missing required fields, values that are out of allowed ranges, incorrectly formatted data, or other validation failures.

Common validation issues include:

* Missing required fields
* Values that exceed minimum or maximum limits
* Strings that don't match required patterns
* Invalid formats for IDs, emails, or other structured data
* Type mismatches (e.g., providing a string where a number is expected)

Here's an example of a request that would trigger this error:

```bash
# Attempting to create a rate limit with an invalid limit value of 0
curl -X POST https://api.unkey.com/v2/ratelimit.limit \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "namespace": "api.requests",
    "identifier": "user_123",
    "limit": 0,
    "duration": 60000
  }'
```

## How To Fix

To fix this error, carefully review the error details provided in the response. The `errors` array contains specific information about what failed validation:

1. Check the `location` field to identify which part of your request is problematic
2. Read the `message` field for details about why validation failed
3. Look at the `fix` field (if available) for guidance on how to correct the issue
4. Modify your request to comply with the validation requirements

Here's the corrected version of our example request:

```bash
# Corrected request with a valid limit value
curl -X POST https://api.unkey.com/v2/ratelimit.limit \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "namespace": "api.requests",
    "identifier": "user_123",
    "limit": 100,
    "duration": 60000
  }'
```

## Common Mistakes

* **Ignoring schema requirements**: Not checking the API documentation for field requirements
* **Range violations**: Providing values outside of allowed ranges (too small, too large)
* **Format errors**: Not following the required format for IDs, emails, or other structured data
* **Missing fields**: Omitting required fields in API requests
* **Type errors**: Sending the wrong data type (e.g., string instead of number)

## Related Errors

* [err:unkey:application:assertion\_failed](./assertion_failed) - When a runtime assertion or invariant check fails
* [err:unkey:application:protected\_resource](./protected_resource) - When attempting to modify a protected resource


# err:unkey:application:protected_resource
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/application/protected_resource

Attempt to modify a protected resource

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The resource you are attempting to modify is protected and cannot be changed",
    "status": 403,
    "title": "Forbidden",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/application/protected_resource"
  }
}
```

## What Happened?

This error occurs when you attempt to modify or delete a resource that is marked as protected in the Unkey system. Protected resources have special status that prevents them from being changed or removed, typically because they are system resources, defaults, or otherwise critical to proper system operation.

Common scenarios that trigger this error:

* Attempting to delete a default API or workspace
* Trying to modify system-created roles or permissions
* Attempting to change protected settings or configurations
* Trying to remove or alter resources that are required for system integrity

Here's an example of a request that might trigger this error:

```bash
# Attempting to delete a protected default API
curl -X DELETE https://api.unkey.com/v1/apis.deleteApi \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "apiId": "api_default_protected"
  }'
```

## How To Fix

Since protected resources are deliberately shielded from modification, the solution is usually to work with or around them rather than trying to change them:

1. **Work with the protected resource**: Use the resource as-is and build your workflows around it
2. **Create a new resource**: Instead of modifying a protected resource, create a new one with your desired configuration
3. **Use alternatives**: Look for alternative ways to achieve your goal without modifying protected resources
4. **Contact support**: If you believe you have a legitimate need to modify a protected resource, contact Unkey support

For example, instead of deleting a protected API, you might create a new one:

```bash
curl -X POST https://api.unkey.com/v2/apis.createApi \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "name": "My Custom API"
  }'
```

## Important Notes

* Protected resources are designated as such for system stability and security reasons
* Even with admin or owner permissions, protected resources typically cannot be modified
* This protection is separate from permission-based restrictions and applies even to workspace owners
* The protection status of a resource is not typically exposed in API responses until you try to modify it

## Related Errors

* [err:unkey:authorization:forbidden](../authorization/forbidden) - When an operation is not allowed for policy reasons
* [err:unkey:authorization:insufficient\_permissions](../authorization/insufficient_permissions) - When you lack permissions for an operation


# err:unkey:application:service_unavailable
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/application/service_unavailable

A service is temporarily unavailable

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The service is temporarily unavailable. Please try again later.",
    "status": 503,
    "title": "Service Unavailable",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/application/service_unavailable"
  }
}
```

## What Happened?

This error occurs when a component of the Unkey platform is temporarily unavailable or unable to process your request. Unlike an unexpected error, this is a known state where the system has detected that it cannot currently provide the requested service.

Possible causes of this error:

* Scheduled maintenance
* High load or capacity issues
* Dependent service outages
* Regional infrastructure problems
* Database overload or maintenance

Here's an example of a request that might receive this error during a service disruption:

```bash
curl -X POST https://api.unkey.com/v1/keys.createKey \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "apiId": "api_123abc",
    "name": "My API Key"
  }'
```

## How To Fix

Since this is a temporary service issue, the best approach is to wait and retry. Here are some strategies:

1. **Implement retry logic**: Add automatic retries with exponential backoff to your code
2. **Check service status**: Visit the Unkey status page for updates on service availability
3. **Try alternate regions**: If Unkey offers region-specific endpoints, try an alternate region
4. **Wait and retry manually**: If it's a one-time operation, simply try again later

Here's an example of a robust retry strategy:

```bash
# Bash script with retry logic
max_attempts=5
attempt=0
backoff_time=1

while [ $attempt -lt $max_attempts ]; do
  response=$(curl -s -w "\n%{http_code}" \
    -X POST https://api.unkey.com/v1/keys.createKey \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer unkey_YOUR_API_KEY" \
    -d '{
      "apiId": "api_123abc",
      "name": "My API Key"
    }')
    
  http_code=$(echo "$response" | tail -n1)
  body=$(echo "$response" | sed '$ d')
  
  if [ $http_code -eq 503 ]; then
    attempt=$((attempt+1))
    if [ $attempt -eq $max_attempts ]; then
      echo "Service still unavailable after $max_attempts attempts"
      exit 1
    fi
    
    echo "Service unavailable, retrying in $backoff_time seconds... (Attempt $attempt/$max_attempts)"
    sleep $backoff_time
    backoff_time=$((backoff_time*2))
  else
    echo "$body"
    exit 0
  fi
done
```

## Important Notes

* This error is temporary, and the service will typically recover automatically
* For critical applications, implement circuit breakers to prevent cascading failures
* If the service remains unavailable for an extended period, check Unkey's status page or contact support
* Include the `requestId` from the error response when contacting support

## Related Errors

* [err:unkey:application:unexpected\_error](./unexpected_error) - When an unhandled error occurs
* [err:unkey:authorization:workspace\_disabled](../authorization/workspace_disabled) - When the workspace is disabled (a different type of unavailability)


# err:unkey:application:unexpected_error
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/application/unexpected_error

An unhandled or unexpected error occurred

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "An unexpected error occurred while processing your request",
    "status": 500,
    "title": "Internal Server Error",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/application/unexpected_error"
  }
}
```

## What Happened?

This error occurs when the Unkey system encounters an internal error that wasn't anticipated or couldn't be handled gracefully. This is generally not caused by anything you did wrong in your request, but rather indicates an issue within Unkey's systems.

Possible causes of this error:

* Temporary infrastructure issues
* Database connectivity problems
* Bugs in the Unkey service
* Resource constraints or timeouts
* Unexpected edge cases not handled by the application logic

Here's an example of a request that might trigger this error if there's an internal issue:

```bash
# A valid request that could trigger an unexpected error if there's an internal issue
curl -X POST https://api.unkey.com/v1/keys.createKey \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "apiId": "api_123abc",
    "name": "My API Key"
  }'
```

## How To Fix

Since this is an internal error, there's usually little you can do to directly fix it, but you can try the following:

1. **Retry the request**: Many unexpected errors are temporary and will resolve on a retry
2. **Check Unkey status**: Visit the Unkey status page to see if there are any ongoing service issues
3. **Contact support**: If the error persists, contact Unkey support with your request ID
4. **Implement retry logic**: For critical operations, implement exponential backoff retry logic in your code

Here's an example of implementing retry logic with exponential backoff:

```javascript
// Pseudocode for retry with exponential backoff
async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 300) {
  let retries = 0;
  while (true) {
    try {
      return await fn();
    } catch (error) {
      if (error.status !== 500 || retries >= maxRetries) {
        throw error; // Either not a 500 error or we've exceeded retries
      }

      // Exponential backoff with jitter
      const delay = baseDelay * Math.pow(2, retries) * (0.8 + Math.random() * 0.4);
      console.log(`Retrying after ${delay}ms (attempt ${retries + 1}/${maxRetries})`);
      await new Promise(resolve => setTimeout(resolve, delay));
      retries++;
    }
  }
}
```

## Important Notes

* Always include the `requestId` when contacting support about this error
* This error may indicate a bug in Unkey's systems that needs to be fixed
* Unlike most other errors, this one usually can't be resolved by changing your request
* If you encounter this error consistently with a specific API call, there may be an edge case that Unkey's team needs to address

## Related Errors

* [err:unkey:application:service\_unavailable](./service_unavailable) - When a service is temporarily unavailable


# err:unkey:authentication:key_not_found
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/authentication/key_not_found

The authentication key was not found

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The provided API key was not found",
    "status": 401,
    "title": "Unauthorized",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/authentication/key_not_found"
  }
}
```

## What Happened?

This error occurs when you've provided a properly formatted API key in your request to the Unkey API, but the key doesn't exist in Unkey's system. The key might have been deleted, revoked, or you might be using an incorrect key.

Common causes include:

* Using an API key that has been deleted
* Using an API key from a different workspace or environment
* Typographical errors when entering the key
* Using a test key in production or vice versa

Here's an example of a request with a non-existent API key:

```bash
# Request to Unkey API with a non-existent key
curl -X POST https://api.unkey.com/v1/keys.listKeys \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_NONEXISTENT_KEY"
```

## How To Fix

To fix this error, you need to use a valid API key when making requests to the Unkey API:

1. **Check your Unkey dashboard**: Verify you're using the correct Unkey API key from the [Unkey dashboard](https://app.unkey.com)
2. **Create a new key if needed**: If your key was deleted, create a new one
3. **Use the correct environment**: Make sure you're using the appropriate key for your environment (development, production, etc.)

Here's how to check and use the correct Unkey API key:

1. Log in to your Unkey dashboard
2. Navigate to the API keys section
3. Copy the appropriate API key for your environment
4. Use the key in your request as shown below

```bash
curl -X POST https://api.unkey.com/v1/keys.listKeys \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_VALID_API_KEY"
```

## Common Mistakes

* **Using revoked Unkey keys**: API keys that have been revoked will return this error
* **Environment mismatch**: Using development keys in production or vice versa
* **Workspace confusion**: Using keys from one workspace in another workspace's API calls
* **Copy-paste errors**: Inadvertently omitting part of the key when copying
* **Expired keys**: Keys that have expired will return this error
* **Using demo keys**: Using example keys from documentation

## Related Errors

* [err:unkey:authentication:missing](./missing) - When no authentication credentials are provided
* [err:unkey:authentication:malformed](./malformed) - When the API key is provided but formatted incorrectly


# err:unkey:authentication:malformed
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/authentication/malformed

Authentication credentials were incorrectly formatted

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "Authentication credentials were incorrectly formatted",
    "status": 401,
    "title": "Unauthorized",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/authentication/malformed"
  }
}
```

## What Happened?

This error occurs when your request includes authentication credentials, but they are not formatted correctly. The Unkey API expects API keys to be provided in a specific format in the Authorization header.

Common causes include:

* Missing the "Bearer" prefix before your API key
* Including extra spaces or characters
* Using incorrect casing (e.g., "bearer" instead of "Bearer")
* Providing a malformed or truncated API key

Here's an example of a request with incorrectly formatted credentials:

```bash
# Missing the "Bearer" prefix
curl -X POST https://api.unkey.com/v1/keys.listKeys \
  -H "Content-Type: application/json" \
  -H "Authorization: unkey_YOUR_API_KEY"
```

## How To Fix

To fix this error, ensure your Authorization header follows the correct format:

1. **Use the correct format**: Ensure your Authorization header follows the format `Bearer unkey_YOUR_API_KEY`
2. **Check for extra spaces or characters**: Make sure there are no invisible characters or line breaks
3. **Verify the API key format**: Your Unkey API key should start with `unkey_`

Here's the correctly formatted request:

```bash
curl -X POST https://api.unkey.com/v1/keys.listKeys \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY"
```

When properly authenticated, you'll receive a successful response like this:

```json
{
  "meta": {
    "requestId": "req_8f7g6h5j4k3l2m1n"
  },
  "data": {
    "keys": [
      {
        "keyId": "key_123abc456def",
        "name": "Production API Key"
      }
    ]
  }
}
```

## Common Mistakes

* **Authorization header format**: Must be exactly `Bearer unkey_YOUR_API_KEY` with a single space after "Bearer"
* **Incorrect casing**: Using "bearer" instead of "Bearer"
* **API key format**: Your Unkey API key should start with `unkey_` and contain no spaces
* **Using wrong key type**: Ensure you're using a root key for management API calls
* **Copying errors**: Check for invisible characters or line breaks that might have been copied
* **Extra characters**: Including quotes or other characters around the API key
* **Truncated keys**: Accidentally cutting off part of the API key when copying

## Related Errors

* [err:unkey:authentication:missing](./missing) - When no authentication credentials are provided
* [err:unkey:authentication:key\_not\_found](./key_not_found) - When the provided API key doesn't exist


# err:unkey:authentication:missing
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/authentication/missing

Authentication credentials were not provided in the request

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "Authentication credentials were not provided",
    "status": 401,
    "title": "Unauthorized",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/authentication/missing"
  }
}
```

## What Happened?

This error occurs when you make a request to the Unkey API without including your API key in the Authorization header. The Unkey API requires authentication for most endpoints to verify your identity and permissions.

Here's an example of a request that would trigger this error:

```bash
# Request to Unkey API without an API key
curl -X POST https://api.unkey.com/v1/keys.listKeys \
  -H "Content-Type: application/json"
```

Authentication is required to:

* Verify your identity
* Ensure you have permission to perform the requested operation
* Track usage and apply appropriate rate limits
* Maintain security and audit trails

## How To Fix

To fix this error, you need to include your Unkey API key in the Authorization header of your request:

1. **Get your Unkey API key**: Obtain your API key from the [Unkey dashboard](https://app.unkey.com)
2. **Add the Authorization header**: Include your Unkey API key with the format `Bearer unkey_YOUR_API_KEY`

Here's the corrected request:

```bash
curl -X POST https://api.unkey.com/v1/keys.listKeys \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY"
```

When properly authenticated, you'll receive a successful response like this:

```json
{
  "meta": {
    "requestId": "req_8f7g6h5j4k3l2m1n"
  },
  "data": {
    "keys": [
      {
        "keyId": "key_123abc456def",
        "name": "Production API Key"
      }
    ]
  }
}
```

## Common Mistakes

* **Missing the `Bearer` prefix**: Unkey requires the format `Bearer unkey_YOUR_API_KEY` with a space after "Bearer"
* **Headers lost in proxies**: Some proxy servers or API gateways might strip custom headers
* **Expired or revoked keys**: Using keys that are no longer valid
* **Wrong environment**: Using development keys in production or vice versa

## Related Errors

* [err:unkey:authentication:malformed](./malformed) - When the API key is provided but formatted incorrectly
* [err:unkey:authentication:key\_not\_found](./key_not_found) - When the provided API key doesn't exist


# err:unkey:authorization:forbidden
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/authorization/forbidden

The operation is not allowed

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "This operation is not allowed",
    "status": 403,
    "title": "Forbidden",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/authorization/forbidden"
  }
}
```

## What Happened?

This error occurs when you attempt an operation that is prohibited by Unkey's platform policies, even if your API key has high-level permissions. Unlike the "insufficient\_permissions" error which relates to permission roles, this error indicates that the operation itself is not allowed regardless of permissions.

Common scenarios that trigger this error:

* Trying to perform operations on protected or system resources
* Attempting to modify resources that are in a state that doesn't allow modifications
* Trying to exceed account limits or quotas
* Performing operations that violate platform policies

Here's an example of a request that might trigger this error:

```bash
# Attempting to delete a protected system resource
curl -X POST https://api.unkey.com/v2/apis.deleteApi \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_ADMIN_KEY" \
  -d '{
    "apiId": "api_system_protected"
  }'
```

## How To Fix

This error indicates a fundamental restriction rather than a permission issue. The operation you're trying to perform may be:

1. **Not supported by the Unkey platform**: Some operations are simply not available
2. **Blocked due to your account's current state or limitations**: Your account may not have access to certain features
3. **Prevented by safety mechanisms**: System protections may prevent certain destructive operations

Possible solutions include:

* **Check Unkey's documentation**: Understand which operations have fundamental restrictions
* **Consider your account state**: Some operations may be blocked due to your account state or plan
* **Use alternative approaches**: Find supported ways to accomplish similar goals
* **If you're trying to modify a resource in a specific state**, check if it needs to be in a different state first
* **If you're hitting account limits**, consider upgrading your plan
* **Contact Unkey support** if you believe this restriction shouldn't apply to your use case

## Common Mistakes

* **Attempting to modify system resources**: Some Unkey resources are protected and cannot be modified
* **Order-dependent operations**: Trying to perform operations out of their required sequence
* **Plan limitations**: Attempting operations not available on your current plan
* **Resource state issues**: Trying to modify resources that are in a state that doesn't allow changes
* **Ignoring documentation warnings**: Not reading warnings about restricted operations
* **Testing security boundaries**: Deliberately trying to access protected resources
* **Outdated documentation**: Following outdated documentation that suggests now-forbidden operations

## Related Errors

* [err:unkey:authorization:insufficient\_permissions](./insufficient_permissions) - When the authenticated entity lacks specific permissions
* [err:unkey:authorization:key\_disabled](./key_disabled) - When the authentication key is disabled
* [err:unkey:authorization:workspace\_disabled](./workspace_disabled) - When the associated workspace is disabled


# err:unkey:authorization:insufficient_permissions
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/authorization/insufficient_permissions

The authenticated entity lacks sufficient permissions for the requested operation

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The authenticated API key does not have permission to perform this operation",
    "status": 403,
    "title": "Forbidden",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/authorization/insufficient_permissions"
  }
}
```

## What Happened?

This error occurs when your API key is valid and properly authenticated, but it doesn't have the necessary permissions to perform the requested operation. In Unkey, different API keys can have different permission levels.

Common scenarios that trigger this error:

* Using a read-only key to perform write operations
* Using a key limited to specific resources to access other resources
* Attempting to access resources across workspaces with a workspace-scoped key
* Using a key with limited permissions to perform administrative actions

Here's an example of a request using a key with insufficient permissions:

```bash
# Using a read-only key to create a new API key
curl -X POST https://api.unkey.com/v1/keys.createKey \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_READ_ONLY_KEY" \
  -d '{
    "apiId": "api_123",
    "name": "New API Key"
  }'
```

## How To Fix

You need to use an API key with the appropriate permissions for the operation you're trying to perform. Here are some steps to resolve this issue:

1. **Check permissions**: Verify the permissions of your current Unkey API key in the [Unkey dashboard](https://app.unkey.com)
2. **Create a new key**: If needed, create a new Unkey API key with the required permissions
3. **Use role-based keys**: Consider using separate keys for different operations based on their permission requirements

Here's an example using a key with the appropriate permissions:

```bash
curl -X POST https://api.unkey.com/v1/keys.createKey \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_ADMIN_KEY" \
  -d '{
    "apiId": "api_123",
    "name": "New API Key"
  }'
```

## Common Mistakes

* **Using development keys in production**: Keys may have different permissions across environments
* **Mixing key scopes**: Using a key scoped to one resource to access another
* **Role misunderstanding**: Not understanding the specific permissions granted to each role
* **Workspace boundaries**: Attempting to cross workspace boundaries with a limited key
* **Permission level confusion**: Not understanding what operations require elevated permissions
* **Expired or downgraded privileges**: Using a key whose permissions have been reduced since it was issued

## Related Errors

* [err:unkey:authorization:forbidden](./forbidden) - When the operation is not allowed for policy reasons
* [err:unkey:authorization:key\_disabled](./key_disabled) - When the authentication key is disabled


# err:unkey:authorization:key_disabled
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/authorization/key_disabled

The authentication key is disabled

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The API key used for authentication has been disabled",
    "status": 403,
    "title": "Forbidden",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/authorization/key_disabled"
  }
}
```

## What Happened?

This error occurs when you try to use a disabled Unkey API key (one that starts with `unkey_`) to authenticate with the Unkey API. The key exists in the system but has been disabled and can no longer be used for authentication.

Here's an example of a request that would trigger this error:

```bash
# Request to Unkey API with a disabled key
curl -X POST https://api.unkey.com/v1/keys.listKeys \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_DISABLED_KEY"
```

API keys can be disabled for various reasons:

* Administrative action to revoke access
* Security concerns or suspected compromise
* Temporary deactivation during maintenance or investigation
* Automated disabling due to suspicious activity
* Usage policy violations

## How To Fix

If you encounter this error when using the Unkey API, you have two options:

1. **Get a new Unkey root key**: If your key was permanently disabled, create a new API key with the appropriate permissions in the [Unkey dashboard](https://app.unkey.com/settings/root-keys)

2. **Re-enable your existing key**: If you have administrative access and the key was temporarily disabled, you can re-enable it through the dashboard

To re-enable your Unkey root key:

1. Log in to your Unkey dashboard
2. Navigate to the API keys section
3. Search for the key you want to re-enable
4. Click "Enable"

Then update your API calls to use the re-enabled key:

```bash
curl -X POST https://api.unkey.com/v1/keys.listKeys \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_REACTIVATED_KEY"
```

## Common Mistakes

* **Using old or archived root keys**: Keys from previous projects or configurations may have been disabled
* **Shared root keys**: When keys are shared among team members, they may be disabled by another administrator
* **Security triggers**: Unusual usage patterns may automatically disable keys as a security precaution
* **Environment confusion**: Using disabled staging/development keys in production environments
* **Account status changes**: Keys may be disabled due to billing or account status changes
* **Rotation policies**: Keys that should have been rotated according to security policies

## Related Errors

* [err:unkey:authorization:insufficient\_permissions](./insufficient_permissions) - When the authenticated entity lacks sufficient permissions
* [err:unkey:authorization:workspace\_disabled](./workspace_disabled) - When the associated workspace is disabled
* [err:unkey:authentication:key\_not\_found](../authentication/key_not_found) - When the provided API key doesn't exist at all


# err:unkey:authorization:workspace_disabled
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/authorization/workspace_disabled

The associated workspace is disabled

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The workspace associated with this API key has been disabled",
    "status": 403,
    "title": "Forbidden",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/authorization/workspace_disabled"
  }
}
```

## What Happened?

This error occurs when you attempt to use an Unkey API key that belongs to a disabled workspace. When a workspace is disabled in Unkey, all API keys associated with that workspace stop working, regardless of their individual status.

Here's an example of a request that would trigger this error:

```bash
# Request to Unkey API with a key from a disabled workspace
curl -X POST https://api.unkey.com/v1/keys.listKeys \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_KEY_FROM_DISABLED_WORKSPACE"
```

A workspace might be disabled for various reasons:

* Billing issues or unpaid invoices
* Administrative action due to terms of service violations
* At the workspace owner's request
* During investigation of suspicious activity
* As part of account closure process
* Exceeding usage limits or quotas

## How To Fix

If you encounter this error when using the Unkey API, you need to address the workspace issue:

1. **Check billing status**: If the workspace was disabled due to billing issues, settle any outstanding payments in the [Unkey dashboard](https://app.unkey.com/settings/billing)

2. **Contact workspace administrator**: If you're not the workspace administrator, contact them to determine why the workspace was disabled

3. **Contact Unkey support**: If you believe the workspace was disabled in error, or you need assistance resolving the issue, contact [Unkey support](mailto:support@unkey.dev)

4. **Use a key from a different workspace**: If you have access to multiple workspaces, you can temporarily use a key from an active workspace while resolving the issue

Once the workspace is re-enabled, all API keys associated with it should become usable again (unless individually disabled).

## Common Mistakes

* **Billing oversights**: Missed payment notifications can lead to workspace suspension
* **Usage violations**: Excessive usage or pattern violations may trigger workspace disabling
* **Administrative changes**: Organizational changes might lead to workspaces being temporarily disabled
* **Using old workspaces**: Attempting to use keys from deprecated or archived workspaces
* **Plan limitation violations**: Exceeding the limits of your current plan
* **Account transfer issues**: Workspaces may be temporarily disabled during ownership transfers

## Related Errors

* [err:unkey:authorization:key\_disabled](./key_disabled) - When the specific authentication key is disabled
* [err:unkey:authorization:insufficient\_permissions](./insufficient_permissions) - When the authenticated entity lacks sufficient permissions
* [err:unkey:data:workspace\_not\_found](../data/workspace_not_found) - When the requested workspace doesn't exist


# err:unkey:data:api_not_found
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/data/api_not_found

The requested API was not found

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The requested API could not be found",
    "status": 404,
    "title": "Not Found",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/data/api_not_found"
  }
}
```

## What Happened?

This error occurs when you're trying to perform an operation on an API that doesn't exist in the Unkey system. In Unkey, APIs are resources that you create to organize and manage your keys.

Common scenarios that trigger this error:

* Using an incorrect API ID in your requests
* Referencing an API that has been deleted
* Attempting to access an API in a workspace you don't have access to
* Typos in API names when using name-based lookups

Here's an example of a request that would trigger this error:

```bash
# Attempting to create a key for a non-existent API
curl -X POST https://api.unkey.com/v1/keys.createKey \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "apiId": "api_nonexistent",
    "name": "hello world"
  }'
```

## How To Fix

Verify that you're using the correct API ID and that the API still exists in your workspace:

1. List all APIs in your workspace to find the correct ID
2. Check if the API has been deleted and recreate it if necessary
3. Verify you're working in the correct workspace
4. Ensure proper permissions to access the API

Here's how to list all APIs in your workspace:

```bash
curl -X GET https://api.unkey.com/v1/apis.listApis \
  -H "Authorization: Bearer unkey_YOUR_API_KEY"
```

If you need to create a new API, use the `apis.createApi` endpoint:

```bash
curl -X POST https://api.unkey.com/v1/apis.createApi \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "name": "My New API"
  }'
```

## Common Mistakes

* **Copy-paste errors**: Using incorrect API IDs from documentation examples
* **Deleted APIs**: Attempting to reference APIs that have been deleted
* **Environment confusion**: Looking for an API in production that only exists in development
* **Workspace boundaries**: Trying to access an API that exists in another workspace

## Related Errors

* [err:unkey:data:workspace\_not\_found](./workspace_not_found) - When the requested workspace doesn't exist
* [err:unkey:data:key\_not\_found](./key_not_found) - When the requested key doesn't exist
* [err:unkey:authorization:insufficient\_permissions](../authorization/insufficient_permissions) - When you don't have permission to access an API


# err:unkey:data:audit_log_not_found
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/data/audit_log_not_found

The requested audit log was not found

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The requested audit log could not be found",
    "status": 404,
    "title": "Not Found",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/data/audit_log_not_found"
  }
}
```

## What Happened?

This error occurs when you're trying to retrieve or operate on a specific audit log entry that doesn't exist in the Unkey system. Audit logs record important actions and events that occur within your workspace.

Common scenarios that trigger this error:

* Using an incorrect audit log ID
* Requesting an audit log entry that has been deleted or expired
* Trying to access audit logs from a different workspace
* Typographical errors in audit log identifiers

Here's an example of a request that would trigger this error:

```bash
# Attempting to get a non-existent audit log entry
curl -X GET https://api.unkey.com/v1/audit.getLog \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "logId": "log_nonexistent"
  }'
```

## How To Fix

Verify that you're using the correct audit log ID and that the log entry still exists in your workspace:

1. Check the audit log ID in your request for typos or formatting errors
2. Use the list audit logs endpoint to find valid log IDs
3. Verify you're working in the correct workspace
4. Consider that audit logs might have a retention period after which they're automatically deleted

Here's how to list recent audit logs in your workspace:

```bash
curl -X GET https://api.unkey.com/v1/audit.listLogs \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "limit": 10
  }'
```

## Common Mistakes

* **Expired logs**: Trying to access audit logs beyond the retention period
* **Copy-paste errors**: Using incorrect log IDs from documentation examples
* **Workspace boundaries**: Attempting to access logs from another workspace
* **Permission issues**: Trying to access logs you don't have permission to view

## Related Errors

* [err:unkey:authorization:insufficient\_permissions](../authorization/insufficient_permissions) - When you don't have permission to access audit logs
* [err:unkey:data:workspace\_not\_found](./workspace_not_found) - When the requested workspace doesn't exist


# err:unkey:data:identity_already_exists
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/data/identity_already_exists

The requested identity already exists

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "An identity with this external ID already exists",
    "status": 409,
    "title": "Conflict",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/data/identity_already_exists"
  }
}
```

## What Happened?

This error occurs when you're trying to create an identity with an external ID that already exists in your Unkey workspace. External IDs must be unique within a workspace to avoid confusion and maintain data integrity.

Common scenarios that trigger this error:

* Creating an identity with an external ID that's already in use
* Re-creating a previously deleted identity with the same external ID
* Migration or import processes that don't check for existing identities
* Duplicate API calls due to retries or network issues

Here's an example of a request that would trigger this error:

```bash
# Attempting to create an identity with an external ID that already exists
curl -X POST https://api.unkey.com/v2/identities.createIdentity \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "externalId": "user_123",
    "meta": {
      "name": "John Doe",
      "email": "john@example.com"
    }
  }'
```

## How To Fix

When you encounter this error, you have several options:

1. **Use a different external ID**: If creating a new identity, use a unique external ID
2. **Update the existing identity**: If you want to modify an existing identity, use the update endpoint instead
3. **Get the existing identity**: If you just need the identity information, retrieve it rather than creating it
4. **Implement upsert logic**: Use a get-or-create pattern in your code

Here's how to update an existing identity:

```bash
curl -X POST https://api.unkey.com/v1/identities.updateIdentity \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "externalId": "user_123",
    "meta": {
      "name": "John Doe",
      "email": "updated_email@example.com"
    }
  }'
```

Or implement a get-or-create pattern in your code:

```javascript
// Pseudocode for get-or-create pattern
async function getOrCreateIdentity(externalId, meta) {
  try {
    // Try to create the identity
    return await createIdentity(externalId, meta);
  } catch (error) {
    // If it already exists (409 error), get it instead
    if (error.status === 409) {
      return await getIdentity(externalId);
    }
    // Otherwise, rethrow the error
    throw error;
  }
}
```

## Common Mistakes

* **Not checking for existing identities**: Failing to check if an identity already exists before creating it
* **Retry loops**: Repeatedly trying to create the same identity after a failure
* **Case sensitivity**: Not accounting for case sensitivity in external IDs
* **Cross-environment duplication**: Using the same external IDs across development and production environments

## Related Errors

* [err:unkey:data:identity\_not\_found](./identity_not_found) - When the requested identity doesn't exist
* [err:unkey:authorization:insufficient\_permissions](../authorization/insufficient_permissions) - When you don't have permission to perform operations on identities


# err:unkey:data:identity_not_found
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/data/identity_not_found

The requested identity was not found

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The requested identity could not be found",
    "status": 404,
    "title": "Not Found",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/data/identity_not_found"
  }
}
```

## What Happened?

This error occurs when you're trying to perform an operation on an identity that doesn't exist in the Unkey system. Identities in Unkey are used to represent users or entities that own or use API keys.

Common scenarios that trigger this error:

* Using an incorrect identity ID or external ID
* Referencing an identity that has been deleted
* Trying to update or get information about a non-existent identity
* Typos in identity identifiers

Here's an example of a request that would trigger this error:

```bash
# Attempting to get a non-existent identity
curl -X POST https://api.unkey.com/v1/identities.getIdentity \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "identityId": "ident_nonexistent"
  }'
```

## How To Fix

Verify that you're using the correct identity ID or external ID and that the identity still exists in your workspace:

1. Check the identity ID in your request for typos or formatting errors
2. List all identities in your workspace to find the correct ID
3. If the identity has been deleted, you may need to recreate it

Here's how to list identities in your workspace:

```bash
curl -X GET https://api.unkey.com/v1/identities.listIdentities \
  -H "Authorization: Bearer unkey_YOUR_API_KEY"
```

If you need to create a new identity, use the `identities.createIdentity` endpoint:

```bash
curl -X POST https://api.unkey.com/v2/identities.createIdentity \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "externalId": "user_123",
    "meta": {
      "name": "John Doe",
      "email": "john@example.com"
    }
  }'
```

## Common Mistakes

* **Incorrect identifiers**: Using wrong identity IDs or external IDs
* **Deleted identities**: Attempting to reference identities that have been removed
* **Case sensitivity**: External IDs might be case-sensitive
* **Workspace boundaries**: Trying to access identities from another workspace

## Related Errors

* [err:unkey:data:identity\_already\_exists](./identity_already_exists) - When trying to create an identity that already exists
* [err:unkey:data:key\_not\_found](./key_not_found) - When the requested key doesn't exist
* [err:unkey:authorization:insufficient\_permissions](../authorization/insufficient_permissions) - When you don't have permission to perform operations on identities


# err:unkey:data:key_auth_not_found
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/data/key_auth_not_found

The requested key authentication was not found

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The requested key authentication could not be found",
    "status": 404,
    "title": "Not Found",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/data/key_auth_not_found"
  }
}
```

## What Happened?

This error occurs when you're trying to perform an operation on a key authentication record that doesn't exist in the Unkey system. Key authentication records contain information about how API keys are authenticated.

Common scenarios that trigger this error:

* Using an incorrect key authentication ID
* Referencing a key authentication record that has been deleted
* Attempting to update authentication settings for a non-existent record
* Typos in identifiers

Here's an example of a request that might trigger this error:

```bash
# Attempting to update a non-existent key authentication record
curl -X POST https://api.unkey.com/v1/keys.updateKeyAuth \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "keyAuthId": "kauth_nonexistent",
    "enabled": true
  }'
```

## How To Fix

Verify that you're using the correct key authentication ID and that the record still exists:

1. Check the key authentication ID in your request for typos or formatting errors
2. Verify the key authentication record exists by looking up the associated key
3. If the record has been deleted, you may need to recreate the key or its authentication settings

Here's how to get information about a key's authentication settings:

```bash
curl -X POST https://api.unkey.com/v1/keys.getKey \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "keyId": "key_your_key_id"
  }'
```

## Common Mistakes

* **Copy-paste errors**: Incorrect IDs due to copy-paste mistakes
* **Deleted records**: Attempting to reference authentication records for deleted keys
* **Misunderstanding relationships**: Confusing key IDs with key authentication IDs
* **Workspace boundaries**: Trying to access authentication records from another workspace

## Related Errors

* [err:unkey:data:key\_not\_found](./key_not_found) - When the requested key doesn't exist
* [err:unkey:authentication:key\_not\_found](../authentication/key_not_found) - When an API key used for authentication doesn't exist
* [err:unkey:authorization:key\_disabled](../authorization/key_disabled) - When the authentication key is disabled


# err:unkey:data:key_not_found
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/data/key_not_found

The requested key was not found

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The requested API key could not be found",
    "status": 404,
    "title": "Not Found",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/data/key_not_found"
  }
}
```

## What Happened?

This error occurs when you're trying to perform an operation on a specific API key using its ID, but the key with that ID doesn't exist in the system. This is different from the authentication error `err:unkey:authentication:key_not_found`, which occurs during the authentication process.

Common scenarios that trigger this error:

* Attempting to update, delete, or get information about a key that has been deleted
* Using an incorrect or malformed key ID
* Trying to access a key that exists in a different workspace
* Reference to a key that hasn't been created yet

Here's an example of a request that would trigger this error:

```bash
# Attempting to get details for a non-existent key
curl -X POST https://api.unkey.com/v1/keys.getKey \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "keyId": "key_nonexistent"
  }'
```

## How To Fix

Verify that you're using the correct key ID and that the key still exists in your workspace:

1. Check the key ID in your request for typos or formatting errors
2. Confirm the key exists by listing all keys in your workspace via the [Unkey dashboard](https://unkey.com/dashboard) or the API
3. Verify you're working in the correct workspace
4. If you need to create a new key, use the `keys.createKey` endpoint

Here's how to list all keys to find the correct ID:

```bash
curl -X POST https://api.unkey.com/v1/keys.listKeys \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "apiId": "api_your_api_id"
  }'
```

## Common Mistakes

* **Copy-paste errors**: Incorrect key IDs due to copy-paste mistakes
* **Deleted keys**: Attempting to reference keys that have been deleted
* **Environment confusion**: Looking for a key in production that only exists in development
* **Workspace boundaries**: Trying to access a key that exists in another workspace

## Related Errors

* [err:unkey:authentication:key\_not\_found](../authentication/key_not_found) - When an API key used for authentication doesn't exist
* [err:unkey:data:api\_not\_found](./api_not_found) - When the requested API doesn't exist
* [err:unkey:data:workspace\_not\_found](./workspace_not_found) - When the requested workspace doesn't exist


# err:unkey:data:permission_not_found
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/data/permission_not_found

The requested permission was not found

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The requested permission could not be found",
    "status": 404,
    "title": "Not Found",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/data/permission_not_found"
  }
}
```

## What Happened?

This error occurs when you're trying to perform an operation on a permission that doesn't exist in the Unkey system. Permissions in Unkey are used to control access to resources and operations.

Common scenarios that trigger this error:

* Using an incorrect permission ID or name
* Referencing a permission that has been deleted
* Trying to assign a permission that doesn't exist in the current workspace
* Typos in permission names when using name-based lookups

Here's an example of a request that would trigger this error:

```bash
# Attempting to assign a non-existent permission to a role
curl -X POST https://api.unkey.com/v1/roles.addPermission \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "roleId": "role_123abc",
    "permissionId": "perm_nonexistent"
  }'
```

## How To Fix

Verify that you're using the correct permission ID or name and that the permission still exists in your workspace:

1. List all permissions in your workspace to find the correct ID
2. Check if the permission has been deleted and recreate it if necessary
3. Verify you're working in the correct workspace

Here's how to list all permissions in your workspace:

```bash
curl -X GET https://api.unkey.com/v1/permissions.listPermissions \
  -H "Authorization: Bearer unkey_YOUR_API_KEY"
```

If you need to create a new permission, use the appropriate API endpoint:

```bash
curl -X POST https://api.unkey.com/v1/permissions.createPermission \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "name": "read:keys",
    "description": "Allows reading key information"
  }'
```

## Common Mistakes

* **Incorrect identifiers**: Using wrong permission IDs or names
* **Deleted permissions**: Referencing permissions that have been removed
* **Case sensitivity**: Permissions names might be case-sensitive
* **Workspace boundaries**: Trying to use permissions from another workspace

## Related Errors

* [err:unkey:data:role\_not\_found](./role_not_found) - When the requested role doesn't exist
* [err:unkey:data:api\_not\_found](./api_not_found) - When the requested API doesn't exist
* [err:unkey:authorization:insufficient\_permissions](../authorization/insufficient_permissions) - When you don't have permission to perform operations on permissions


# err:unkey:data:ratelimit_namespace_not_found
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/data/ratelimit_namespace_not_found

The requested rate limit namespace was not found

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The requested rate limit namespace could not be found",
    "status": 404,
    "title": "Not Found",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/data/ratelimit_namespace_not_found"
  }
}
```

## What Happened?

This error occurs when you're trying to perform an operation on a rate limit namespace that doesn't exist in the Unkey system. Rate limit namespaces are used to organize and manage rate limits for different resources or operations.

Common scenarios that trigger this error:

* Using an incorrect namespace ID or name
* Referencing a namespace that has been deleted
* Trying to modify a namespace that doesn't exist in the current workspace
* Typos in namespace names when using name-based lookups

Here's an example of a request that would trigger this error:

```bash
# Attempting to get overrides for a non-existent namespace
curl -X POST https://api.unkey.com/v2/ratelimit.listOverrides \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "namespaceName": "nonexistent_namespace"
  }'
```

## How To Fix

Verify that you're using the correct namespace ID or name and that the namespace still exists in your workspace:

1. Check the namespace ID or name in your request for typos or formatting errors
2. List all namespaces in your workspace to find the correct ID or name
3. If the namespace has been deleted, you may need to recreate it

Here's how to use the correct namespace in a rate limit operation:

```bash
# Creating a rate limit using a valid namespace
curl -X POST https://api.unkey.com/v2/ratelimit.limit \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "namespace": "your_valid_namespace",
    "identifier": "user_123",
    "limit": 100,
    "duration": 60000
  }'
```

## Common Mistakes

* **Typos in namespace names**: Small typographical errors in namespace names
* **Case sensitivity**: Namespace names might be case-sensitive
* **Deleted namespaces**: Referencing namespaces that have been removed
* **Workspace boundaries**: Trying to use namespaces from another workspace

## Related Errors

* [err:unkey:data:ratelimit\_override\_not\_found](./ratelimit_override_not_found) - When the requested rate limit override doesn't exist
* [err:unkey:authorization:insufficient\_permissions](../authorization/insufficient_permissions) - When you don't have permission to perform operations on rate limits
* [err:unkey:data:workspace\_not\_found](./workspace_not_found) - When the requested workspace doesn't exist


# err:unkey:data:ratelimit_override_not_found
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/data/ratelimit_override_not_found

The requested rate limit override was not found

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The requested rate limit override could not be found",
    "status": 404,
    "title": "Not Found",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/data/ratelimit_override_not_found"
  }
}
```

## What Happened?

This error occurs when you're trying to perform an operation on a rate limit override that doesn't exist in the Unkey system. Rate limit overrides are used to create custom rate limits for specific identifiers within a namespace.

Common scenarios that trigger this error:

* Using an incorrect override ID
* Referencing an override that has been deleted
* Trying to get or modify an override for an identifier that doesn't have one
* Using the wrong namespace when looking up an override

Here's an example of a request that would trigger this error:

```bash
# Attempting to get a non-existent rate limit override
curl -X POST https://api.unkey.com/v2/ratelimit.getOverride \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "namespaceId": "ns_123abc",
    "identifier": "user_without_override"
  }'
```

## How To Fix

Verify that you're using the correct namespace and identifier, and that the override still exists:

1. Check the namespace ID and identifier in your request for typos
2. List all overrides in the namespace to confirm if the one you're looking for exists
3. If the override has been deleted or never existed, you may need to create it

Here's how to list overrides in a namespace:

```bash
curl -X POST https://api.unkey.com/v2/ratelimit.listOverrides \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "namespaceId": "ns_123abc"
  }'
```

If you need to create a new override, use the `ratelimit.setOverride` endpoint:

```bash
curl -X POST https://api.unkey.com/v2/ratelimit.setOverride \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "namespaceId": "ns_123abc",
    "identifier": "user_123",
    "limit": 200,
    "duration": 60000
  }'
```

## Common Mistakes

* **Wrong identifier**: Using an incorrect user identifier when looking up overrides
* **Deleted overrides**: Attempting to reference overrides that have been removed
* **Namespace mismatch**: Looking in the wrong namespace for an override
* **Assuming defaults are overrides**: Trying to get an override for an identifier that's using default limits

## Related Errors

* [err:unkey:data:ratelimit\_namespace\_not\_found](./ratelimit_namespace_not_found) - When the requested rate limit namespace doesn't exist
* [err:unkey:authorization:insufficient\_permissions](../authorization/insufficient_permissions) - When you don't have permission to perform operations on rate limit overrides
* [err:unkey:data:workspace\_not\_found](./workspace_not_found) - When the requested workspace doesn't exist


# err:unkey:data:role_not_found
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/data/role_not_found

The requested role was not found

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The requested role could not be found",
    "status": 404,
    "title": "Not Found",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/data/role_not_found"
  }
}
```

## What Happened?

This error occurs when you're trying to perform an operation on a role that doesn't exist in the Unkey system. Roles in Unkey are collections of permissions that can be assigned to users or API keys.

Common scenarios that trigger this error:

* Using an incorrect role ID or name
* Referencing a role that has been deleted
* Trying to assign a role that doesn't exist in the current workspace
* Typos in role names when using name-based lookups

Here's an example of a request that would trigger this error:

```bash
# Attempting to add a permission to a non-existent role
curl -X POST https://api.unkey.com/v1/roles.addPermission \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "roleId": "role_nonexistent",
    "permissionId": "perm_123abc"
  }'
```

## How To Fix

Verify that you're using the correct role ID or name and that the role still exists in your workspace:

1. List all roles in your workspace to find the correct ID
2. Check if the role has been deleted and recreate it if necessary
3. Verify you're working in the correct workspace

Here's how to list all roles in your workspace:

```bash
curl -X GET https://api.unkey.com/v1/roles.listRoles \
  -H "Authorization: Bearer unkey_YOUR_API_KEY"
```

If you need to create a new role, use the appropriate API endpoint:

```bash
curl -X POST https://api.unkey.com/v1/roles.createRole \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "name": "API Reader",
    "description": "Can read API information"
  }'
```

## Common Mistakes

* **Incorrect identifiers**: Using wrong role IDs or names
* **Deleted roles**: Referencing roles that have been removed
* **Case sensitivity**: Role names might be case-sensitive
* **Workspace boundaries**: Trying to use roles from another workspace

## Related Errors

* [err:unkey:data:permission\_not\_found](./permission_not_found) - When the requested permission doesn't exist
* [err:unkey:data:api\_not\_found](./api_not_found) - When the requested API doesn't exist
* [err:unkey:authorization:insufficient\_permissions](../authorization/insufficient_permissions) - When you don't have permission to perform operations on roles


# err:unkey:data:workspace_not_found
Source: https://unkey.com/docs/api-reference/errors-v2/unkey/data/workspace_not_found

The requested workspace was not found

```json Example
{
  "meta": {
    "requestId": "req_2c9a0jf23l4k567"
  },
  "error": {
    "detail": "The requested workspace could not be found",
    "status": 404,
    "title": "Not Found",
    "type": "https://unkey.com/docs/api-reference/errors-v2/unkey/data/workspace_not_found"
  }
}
```

## What Happened?

This error occurs when you're trying to perform an operation on a workspace that doesn't exist in the Unkey system. This can happen when referencing a workspace by ID or name in API calls.

Common scenarios that trigger this error:

* Using an incorrect workspace ID
* Referencing a workspace that has been deleted
* Attempting to access a workspace you don't have permission to see
* Typos in workspace names when using name-based lookups

Here's an example of a request that would trigger this error:

```bash
# Attempting to list keys in a non-existent workspace
curl -X POST https://api.unkey.com/v1/keys.listKeys \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer unkey_YOUR_API_KEY" \
  -d '{
    "workspaceId": "ws_nonexistent"
  }'
```

## How To Fix

Verify that you're using the correct workspace ID or name and that the workspace still exists:

1. Check your Unkey dashboard to see a list of workspaces you have access to
2. Verify the workspace ID or name in your API calls
3. Ensure you have permission to access the workspace
4. If needed, create a new workspace through the dashboard or API

To find your correct workspace ID, you can:

```bash
# List workspaces you have access to
curl -X GET https://api.unkey.com/v1/workspaces.listWorkspaces \
  -H "Authorization: Bearer unkey_YOUR_API_KEY"
```

## Common Mistakes

* **Deleted workspaces**: Attempting to reference workspaces that have been deleted
* **Copy-paste errors**: Using incorrect IDs from documentation examples
* **Permission issues**: Trying to access workspaces you've been removed from
* **Case sensitivity**: Using incorrect casing in workspace name lookups

## Related Errors

* [err:unkey:authorization:workspace\_disabled](../authorization/workspace_disabled) - When the workspace exists but is disabled
* [err:unkey:data:api\_not\_found](./api_not_found) - When the requested API doesn't exist
* [err:unkey:data:key\_not\_found](./key_not_found) - When the requested key doesn't exist


# INSUFFICIENT_PERMISSIONS
Source: https://unkey.com/docs/api-reference/errors/code/BAD_REQUEST



## Problem

You do not have permission to perform this action. In most cases this means the root key you are using, is lacking permissions.

## Solution

Go to the [Unkey Dashboard](https://app.unkey.com/settings/root-keys) and add the required permissions to your key.


# CONFLICT
Source: https://unkey.com/docs/api-reference/errors/code/CONFLICT



## Problem

Another resource already uses this identifier. For example workspace slugs must be unique globally.

## Solution

Please choose a different name/identifier.

If that doesn't help, ask for help on [Discord](https://unkey.com/discord)


# DELETE_PROTECTED
Source: https://unkey.com/docs/api-reference/errors/code/DELETE_PROTECTED



## Problem

The resource you are trying to delete is protected and cannot be deleted.

## Solution

Go to the [Unkey Dashboard](https://app.unkey.com) and remove the protection from the resource you are trying to delete.


# DISABLED
Source: https://unkey.com/docs/api-reference/errors/code/DISABLED



## Problem

The key has been disabled.

## Solution

Enable this key using the [updateKey endpoint](/api-reference/keys/update) or web interface.

If that doesn't help, ask for help on [Discord](https://unkey.com/discord)


# EXPIRED
Source: https://unkey.com/docs/api-reference/errors/code/EXPIRED



## Problem

The key has expired and can no longer be used.

## Solution

Check the `expires` field and update the key if necessary.

If that doesn't help, ask for help on [Discord](https://unkey.com/discord)


# FORBIDDEN
Source: https://unkey.com/docs/api-reference/errors/code/FORBIDDEN



## Problem

We were able to authenticate you but you do not have access to the requested resources.

## Solution

Use the correct key and/or double check you are requesting the correct resources.

If that doesn't help, ask for help on [Discord](https://unkey.com/discord)


# INSUFFICIENT_PERMISSIONS
Source: https://unkey.com/docs/api-reference/errors/code/INSUFFICIENT_PERMISSIONS



## Problem

You do not have permission to perform this action. In most cases this means the root key you are using, is lacking permissions.

## Solution

Go to the [Unkey Dashboard](https://app.unkey.com/settings/root-keys) and add the required permissions to your key.


# INTERNAL_SERVER_ERROR
Source: https://unkey.com/docs/api-reference/errors/code/INTERNAL_SERVER_ERROR



## Problem

Something unexpected happened and we did not handle the error well.

## Solution

Please get in touch on [Discord](https://unkey.com/discord) and provide the full error response.


# NOT_FOUND
Source: https://unkey.com/docs/api-reference/errors/code/NOT_FOUND



## Problem

The requested resource could not be found. It may have been deleted or does not exist.

## Solution

Please ensure that you are providing the correct resource identifier or check if the resource has been deleted.

If that doesn't help, ask for help on [Discord](https://unkey.com/discord)


# TOO_MANY_REQUESTS
Source: https://unkey.com/docs/api-reference/errors/code/TOO_MANY_REQUESTS



## Problem

You have made too many requests in a short period of time.

## Solution

Please wait a bit and try again or increase the ratelimit on your API key.

If that doesn't help, ask for help on [Discord](https://unkey.com/discord)


# UNAUTHORIZED
Source: https://unkey.com/docs/api-reference/errors/code/UNAUTHORIZED



## Problem

We were unable to authorize your request. Either your key was missing, malformed or does not have the required permissions.

## Solution

Check the `message` field and double check you are sending the key correctly in the `Authorization` header.

If that doesn't help, ask for help on [Discord](https://unkey.com/discord)


# Introduction
Source: https://unkey.com/docs/api-reference/errors/introduction

Machine and human readable error codes

The Unkey API returns machine readable error codes to quickly identify the type of error as well as link to the docs and a `requestId`. Please always include the `requestId` in your error report.

```json
{
  error: {
    code: "UNAUTHORIZED",
    message: "We were unable to authorize your request. Either your key was missing, malformed or does not have the required permissions.",
    docs: "https://unkey.api/docs/api-reference/errors/code/BAD_REQUEST",
    requestId: "req_1234567890"
  }
}

```

If you can't debug something on your own or think there is a bug, please get in touch with us on [Discord](https://unkey.com/discord) or [Email](mailto:support@unkey.dev) and provide the full error response.


# Create an identity
Source: https://unkey.com/docs/api-reference/identities/create-identity

post /v1/identities.createIdentity

<Info>
  Identities are in public beta. Please report any issues to [support@unkey.dev](mailto:support@unkey.dev)
</Info>

Create a new identity in the system. This might not be necessary as newly created keys automatically create an identity if required.

Identities map your users, organisations or other entities to keys. They can be used to share metadata and limits.

<Info>
  [Read more about identities](/concepts/identities/overview)
</Info>

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 17 2024 | Introduced endpoint |


# Delete an identity
Source: https://unkey.com/docs/api-reference/identities/delete-identity

post /v1/identities.deleteIdentity

<Info>
  Identities are in public beta. Please report any issues to [support@unkey.dev](mailto:support@unkey.dev)
</Info>

Delete an identity. This will not revoke the keys associated with the identity.

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 17 2024 | Introduced endpoint |


# Get an identity
Source: https://unkey.com/docs/api-reference/identities/get-identity

get /v1/identities.getIdentity

<Info>
  Identities are in public beta. Please report any issues to [support@unkey.dev](mailto:support@unkey.dev)
</Info>

Retrieve an identity either by `identityId` or by `externalId`.

The response will include the identity as well as its configured rate limits.

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 17 2024 | Introduced endpoint |


# List identities
Source: https://unkey.com/docs/api-reference/identities/list-identities

get /v1/identities.listIdentities

<Info>
  Identities are in public beta. Please report any issues to [support@unkey.dev](mailto:support@unkey.dev)
</Info>

List all identities in the system. This will return a paginated list of identities.

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 17 2024 | Introduced endpoint |


# Update an identity
Source: https://unkey.com/docs/api-reference/identities/update-identity

post /v1/identities.updateIdentity

<Info>
  Identities are in public beta. Please report any issues to [support@unkey.dev](mailto:support@unkey.dev)
</Info>

Update an identity's metadata or limits.

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 17 2024 | Introduced endpoint |


# Add Permissions
Source: https://unkey.com/docs/api-reference/keys/add-permissions

post /v1/keys.addPermissions
Add one or more permissions to a key.

Adds permissions to a key. Existing permissions are not removed.

<Note>
  To use this endpoint, your root key must have the `rbac.*.add_permission_to_key` and potentially the `rbac.*.create_permission` permissions.
</Note>

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 08 2024 | Introduced endpoint |


# Add Roles
Source: https://unkey.com/docs/api-reference/keys/add-roles

post /v1/keys.addRoles
Add one or more roles to a key.

Adds roles to a key. Existing roles are not removed.

<Note>
  To use this endpoint, your root key must have the `rbac.*.add_role_to_key` and potentially the `rbac.*.create_role` permissions.
</Note>

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 08 2024 | Introduced endpoint |


# Create a key
Source: https://unkey.com/docs/api-reference/keys/create

post /v1/keys.createKey

Create a new key.

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Dec 06 2023 | Introduced endpoint |


# Delete a key
Source: https://unkey.com/docs/api-reference/keys/delete

post /v1/keys.deleteKey
Deleted keys are no longer valid and will not be able to be used to authenticate requests.

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Dec 06 2023 | Introduced endpoint |


# Retrieve a key by ID
Source: https://unkey.com/docs/api-reference/keys/get

get /v1/keys.getKey

## Changelog

| Date        | Changes                    |
| ----------- | -------------------------- |
| Dec 06 2023 | Introduced endpoint        |
| May 15 2024 | Return updatedAt timestamp |
| Aug 01 2024 | Return identities          |


# Remove Permissions
Source: https://unkey.com/docs/api-reference/keys/remove-permissions

post /v1/keys.removePermissions
Remove one or more permissions from a key.

<Note>
  To use this endpoint, your root key must have the `rbac.*.remove_permission_from_key` permission.
</Note>

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 08 2024 | Introduced endpoint |


# Remove Roles
Source: https://unkey.com/docs/api-reference/keys/remove-roles

post /v1/keys.removeRoles
Remove one or more roles from a key.

<Note>
  To use this endpoint, your root key must have the `rbac.*.remove_role_from_key` permission.
</Note>

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 08 2024 | Introduced endpoint |


# Set Permissions
Source: https://unkey.com/docs/api-reference/keys/set-permissions

post /v1/keys.setPermissions
Overwrite the permissions of a key with a new set of permissions.

Sets the permissions of a key to a new set of permissions. This endpoint overwrites the existing permissions of the key with the new set.
Existing permissions that are not included in the new set are removed.

You can provide either permission ids or permission names in the request body. If you provide a name, we will create the permission if it does not exist.

<Note>
  To use this endpoint, your root key must have the `rbac.*.add_permission_to_key` and potentially the `rbac.*.create_permission` permissions.
</Note>

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 08 2024 | Introduced endpoint |


# Set Roles
Source: https://unkey.com/docs/api-reference/keys/set-roles

post /v1/keys.setRoles
Overwrite the roles of a key with a new set of roles.

Sets the roles of a key to a new set of roles. This endpoint overwrites the existing roles of the key with the new set.
Existing roles that are not included in the new set are removed.

You can provide either role ids or role names in the request body. If you provide a name, we will create the role if it does not exist.

<Note>
  To use this endpoint, your root key must have the `rbac.*.add_role_to_key` and potentially the `rbac.*.create_role` permissions.
</Note>

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 08 2024 | Introduced endpoint |


# Update a key
Source: https://unkey.com/docs/api-reference/keys/update

post /v1/keys.updateKey
Updates the configuration of an existing key. Omit fields to leave unchanged.

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Dec 06 2023 | Introduced endpoint |


# Update a key's remaining limit
Source: https://unkey.com/docs/api-reference/keys/update-remaining

post /v1/keys.updateRemaining

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Dec 06 2023 | Introduced endpoint |


# Retrieve usage numbers
Source: https://unkey.com/docs/api-reference/keys/verifications

get /v1/keys.getVerifications
Filter by `keyId` or `ownerId`.

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jan 08 2024 | Introduced endpoint |


# Verify a key
Source: https://unkey.com/docs/api-reference/keys/verify

post /v1/keys.verifyKey

## Changelog

| Date        | Changes              |
| ----------- | -------------------- |
| Dec 06 2023 | Introduced endpoint  |
| Jul 08 2024 | Added `EXPIRED` code |


# Returns data about a key
Source: https://unkey.com/docs/api-reference/keys/whoami

post /v1/keys.whoami

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Oct 07 2024 | Introduced endpoint |

You may not always have easy access to the `keyId` and therefore can't use [`/v1/keys.getKey`](/api-reference/keys/get).
This offers an escape hatch to send us the real key instead.


# Migrate key to Unkey
Source: https://unkey.com/docs/api-reference/migrations/create-keys

post /v1/migrations.createKeys

Add existing keys to unkey by specifying the key hash and other settings.

This endpoint supports bulk inserts of up to 100 keys at a time. If you have more keys, you can call this endpoint multiple times.
If any operation fails (e.g., due to a duplicate key), everything will be rolled back and no keys are created.

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| May 08 2024 | Introduced endpoint |


# Overview
Source: https://unkey.com/docs/api-reference/overview

General information about the API.

The Unkey API uses HTTP RPC-style methods and generally follow the schema:

```
https://api.unkey.dev/{version}/{service}.{method}
```

For example `GET https://api.unkey.dev/v1/apis.listKeys` to list all keys for an API.

## HTTP Methods

We strictly use only `GET` and `POST` methods. `PUT` and `DELETE` are not used.

### `GET`

`GET` methods are used for reading data. Filtering, sorting, or pagination is done via query parameters.

```http
curl "https://api.unkey.dev/v1/keys.getKey?keyId=key_123" \
  -H "Authorization: Bearer <ROOT_KEY>"
```

### `POST`

`POST` methods are used for creating, updating, and deleting data. Data is passed as `application/json` in the request body.

```http
curl -XPOST "https://api.unkey.dev/v1/keys.createKey" \
  -H "Authorization: Bearer <ROOT_KEY>" \
  -H "Content-Type: application/json" \
  -d '{"apiId": "api_123", "name": "My Key"}'
```


# Create A Permission
Source: https://unkey.com/docs/api-reference/permissions/create-permission

post /v1/permissions.createPermission

<Note>
  To use this endpoint, your root key must have the `rbac.*.create_permission` permission.
</Note>

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 08 2024 | Introduced endpoint |


# Create A Role
Source: https://unkey.com/docs/api-reference/permissions/create-role

post /v1/permissions.createRole

<Note>
  To use this endpoint, your root key must have the `rbac.*.create_role` permission.
</Note>

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 08 2024 | Introduced endpoint |


# Delete A Permission
Source: https://unkey.com/docs/api-reference/permissions/delete-permission

post /v1/permissions.deletePermission

<Note>
  To use this endpoint, your root key must have the `rbac.*.delete_permission` permission.
</Note>

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 08 2024 | Introduced endpoint |


# Delete A Role
Source: https://unkey.com/docs/api-reference/permissions/delete-role

post /v1/permissions.deleteRole

<Note>
  To use this endpoint, your root key must have the `rbac.*.delete_role` permission.
</Note>

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 08 2024 | Introduced endpoint |


# Get Permission
Source: https://unkey.com/docs/api-reference/permissions/get-permission

get /v1/permissions.getPermission

<Note>
  To use this endpoint, your root key must have the `rbac.*.read_permission` permission.
</Note>

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 08 2024 | Introduced endpoint |


# Get Role
Source: https://unkey.com/docs/api-reference/permissions/get-role

get /v1/permissions.getRole

<Note>
  To use this endpoint, your root key must have the `rbac.*.read_role` permission.
</Note>

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 08 2024 | Introduced endpoint |


# List Permissions
Source: https://unkey.com/docs/api-reference/permissions/list-permissions

get /v1/permissions.listPermissions

<Note>
  To use this endpoint, your root key must have the `rbac.*.read_permission` permission.
</Note>

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 08 2024 | Introduced endpoint |


# List Roles
Source: https://unkey.com/docs/api-reference/permissions/list-roles

get /v1/permissions.listRoles

<Note>
  To use this endpoint, your root key must have the `rbac.*.read_role` permission.
</Note>

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Jul 08 2024 | Introduced endpoint |


# Delete Override
Source: https://unkey.com/docs/api-reference/ratelimits/delete-override

post /v1/ratelimits.deleteOverride
Delete an override from the system.

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Nov 25 2024 | Introduced endpoint |


# Get Override
Source: https://unkey.com/docs/api-reference/ratelimits/get-override

get /v1/ratelimits.getOverride
Retrieve the configured override by `namespaceId` or `namespaceName`.

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Nov 25 2024 | Introduced endpoint |


# Ratelimit
Source: https://unkey.com/docs/api-reference/ratelimits/limit

post /v1/ratelimits.limit
Ratelimit an action based on an identifier.

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Mar 16 2024 | Introduced endpoint |


# List Overrides
Source: https://unkey.com/docs/api-reference/ratelimits/list-overrides

get /v1/ratelimits.listOverrides
Retrieve a list of configured overrides by `namespaceId` or `namespaceName`.

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Nov 25 2024 | Introduced endpoint |


# Set Override
Source: https://unkey.com/docs/api-reference/ratelimits/set-override

post /v1/ratelimits.setOverride

Create or update an override to set specific limits for an identifier.

There is no `update` endpoint. Instead you should call this endpoint again to overwrite your override.

## Changelog

| Date        | Changes             |
| ----------- | ------------------- |
| Nov 25 2024 | Introduced endpoint |


# Analytics
Source: https://unkey.com/docs/apis/features/analytics

Per key and per API analytics

Unkey offers both per key and per API analytics that allow you to drive business decisions.

## Per API Analytics

Our per API analytics offer a broad overview of the usage for a specific API with total keys, active keys and verifications in the last 30 days.

<Frame caption="Per API Analytics">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/images/per-api-analytics.png" alt="Per API Analytics" />
</Frame>

## Per Key Analytics

Our per key analytics give you a deep dive into each individual key, giving usage data, key data and where the requests originated from. This data can be useful for finding your top users, and where verifications are coming from.

<Frame caption="Per key Analytics">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/images/per-key-analytics.png" alt="Per key analytics" />
</Frame>

## Tags

You can add tags to verification requests to aggregate or filter data when querying.

For example you might want to add the path of your API as a tag: `path=/v1/my-path` and then later retrieve a breakdown of api key usage per unique path.

Unkey does not parse tags in any special way.
The only limitations are:

* Tags are strings.
* You can specify up to 10 tags per request.
* Each tag must be between (including) 1 and 128 characters.

That being said, having some structure for your tags could be benefitial for you.
A common theme is treating them as key-value pairs and specifying them with either a colon or equal-sign as delimiter.

```
key:value
key=value
```

Since Unkey does not know what API routes your user has called or which resources they interact with, we encourage you to record these in the tags.
Here's an example tags for a fictional blog API:

```json
[
  "path=/v1/posts.createPost",
  "postId=post_1asofijqknslkfqWF",
  "region=us-east-1",
  "apiVersion=f8ad21bd", // a git sha of your deployment or semver
]
```

### Using tags

Tags can be added in the request body.

```bash Providing Tags {7-10}
curl --request POST \
  --url https://api.unkey.dev/v1/keys.verifyKey \
  --header 'Content-Type: application/json' \
  --data '{
  "apiId": "api_1234",
  "key": "sk_1234",
  "tags": [
    "tag1",
    "path=/v1/my-resource/123"
  ]
}'
```

### Querying tags

We have only rolled out tag ingestion so far to allow you to start recording data as early as possible.

We're working on new query capabilities including filtering and aggregating by tags.


# Example
Source: https://unkey.com/docs/apis/features/authorization/example

RBAC in the almost-real world

Let's look at an example app for allowing your users to manage domains.

As part of the API, your users will be able to perform CRUD operations against domains or individual dns records.

<Steps>
  <Step titleSize="h2" title="Creating permissions">
    Users of our app can have the following permissions:

    * `domain.delete_domain`
    * `domain.dns.create_record`
    * `domain.dns.read_record`
    * `domain.dns.update_record`
    * `domain.dns.delete_record`
    * `domain.create_domain`
    * `domain.read_domain`
    * `domain.update_domain`

    Create them in your [dashboard](https://app.unkey.com/authorization/permissions).

    <Frame>
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/apis/features/authorization/domains-permissions.png" alt="Example permissions" />
    </Frame>
  </Step>

  <Step titleSize="h2" title="Creating roles">
    And we define the following roles:

    * `admin`: An admin can do everything
    * `dns.manager`: Can create, read, update and delete dns records but not access the domain itself
    * `read-only`: Can read domain or dns record information.

    <Frame>
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/apis/features/authorization/domains-roles.png" alt="Example roles" />
    </Frame>

    Create them in your [dashboard](https://app.unkey.com/authorization/roles) too.
  </Step>

  <Step titleSize="h2" title="Connecting">
    For each role, we need to connect the permissions it should have.
    Go to [/app/authorization/roles](https://app.unkey.com/authorization/roles) and click on the role to go to the permissions screen.

    <Tabs>
      <Tab title="admin">
        <Frame>
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/apis/features/authorization/domains-roles-admin.png" alt="Admin roles" />
        </Frame>
      </Tab>

      <Tab title="dns.manager">
        <Frame>
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/apis/features/authorization/domains-roles-dns.manager.png" alt="dns.manager roles" />
        </Frame>
      </Tab>

      <Tab title="read-only">
        <Frame>
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/apis/features/authorization/domains-roles-read-only.png" alt="read-only roles" />
        </Frame>
      </Tab>
    </Tabs>
  </Step>

  <Step title="Create a key">
    Now that we have permissions and roles in place, we can connect them to keys.

    <Tabs>
      <Tab title="Dashboard">
        1. In the sidebar, click on one of your APIs

        2. In the breakcrumb navigation on the top click Reqests and then keys
           <Frame>
             <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/apis/features/authorization/api-keys-navigation.png" alt="Breadcrumb Navigation" />
           </Frame>

        3. Select one of your existing keys by clicking on it

        4. Scroll down to the `Roles` section if not visible

        You should now be on `/app/keys/key_auth_???/key_???`

        <Frame>
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/apis/features/authorization/api-key-screen.png" alt="Unconnected roles and permissions" />
        </Frame>

        You can connect a role to your key by clicking on the checkbox.

        Let's give this key the `dns.manager` and `read-only` roles.
        A toast message should come up in the lower corner when the action has been completed.

        <Frame>
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/apis/features/authorization/role-add-example.png" alt="Unconnected roles and permissions" />
        </Frame>

        As you can see, now the key now contains 2 `roles` and 5 `permissions` shown just above the Roles section:
      </Tab>

      <Tab title="API">
        You can attach roles to a key when creating it by providing the role names as an array:

        ```bash
        curl -XPOST \
          --url https://api.unkey.dev/v1/keys.createKey \
          -H "Authorization: Bearer ${ROOT_KEY}" \
          -H "Content-Type: application/json" \
          -d '{
            "apiId": "${API_ID}",
            "roles": [
              "role1", "role2", "role3"
            ]
          }'
        ```

        See [here](/api-reference/keys/create) for details.
      </Tab>
    </Tabs>
  </Step>

  <Step title="Verifying Permissions">
    Now you can verify this key and perform permission checks. [Read more](/apis/features/authorization/verifying)
  </Step>
</Steps>


# Overview
Source: https://unkey.com/docs/apis/features/authorization/introduction

Access Control with Roles and Permissions

Role-Based Access Control (RBAC) is a security paradigm that restricts system access to authorized actors. It is based on the principle of assigning roles to actors and defining what actions or resources each role can access. We are taking this one step further and allowing you to attach arbitrary permissions to keys, for more flexibility (Coming in Q2).


# Roles and Permissions
Source: https://unkey.com/docs/apis/features/authorization/roles-and-permissions



In RBAC, roles represent a collection of permissions. Each role defines a set of actions or operations that a user with that role can perform. Permissions can be associated with various resources within your application, such as endpoints, data objects, or functionality.

Common roles may include:

* `Administrator`: Has full access to all resources and functionality.
* `Editor`: Can create, read, update, and delete specific resources.
* `Viewer`: Can only view resources but cannot modify them.

## Roles

Creating, updating and deleting roles is available in the dashboard.

### Create

1. Go to [/app/authorization/roles](https://app.unkey.com/authorization/roles)
2. Click `Create New Role`
3. Enter a unique name for your role and optionally a human readable description.
4. Click `Create`

After the role is created, you are forwarded and can update/delete the role or connect existing permissions.

### Update

1. Go to [/app/authorization/roles](https://app.unkey.com/authorization/roles)
2. Click on the role you want to update
3. Click `Update Role`
4. Make changes to the name, description or both
5. Click `Save`

### Delete

1. Go to [/app/authorization/roles](https://app.unkey.com/authorization/roles)
2. Click on the role you want to delete
3. Click `Delete Role`
4. Enter the name of the role to confirm
5. Click `Delete Role`

## Permissions

Creating, updating and deleting permissions is available in the dashboard.

### Create

1. Go to [/app/authorization/permissions](https://app.unkey.com/authorization/permissions)
2. Click `Create New Permission`
3. Enter a unique name for your permissoin and optionally a human readable description.
4. Click `Create New Permission`

### Update

1. Go to [/app/authorization/permissions](https://app.unkey.com/authorization/permissions)
2. Click on the permission you want to update
3. Click `Update Role`
4. Make changes to the name, description or both
5. Click `Save`

### Delete

1. Go to [/app/authorization/permisions](https://app.unkey.com/authorization/permisions)
2. Click on the permission you want to delete
3. Click `Delete`
4. Enter the name of the permission to confirm
5. Click `Delete`

## Connecting roles and permissions

After you have created at least 1 role and 1 permission, you can start associating them with each other.

Go to [/app/authorization/roles](https://app.unkey.com/authorization/roles) and click on the role to go to the permissions screen.
Now you can click the checkboxes to connect the role and permission.

A checked box means the role will grant the permission to keys.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/apis/features/authorization/domains-roles-read-only.png" alt="Read-only roles" />
</Frame>

## Connecting roles to keys

1. In the sidebar, click on one of your APIs
2. In the breakcrumb navigation on the top click Reqests and then keys
   <Frame>
     <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/apis/features/authorization/api-keys-navigation.png" alt="Breadcrumb Navigation" />
   </Frame>
3. Select one of your existing keys by clicking on it
4. Scroll down to the `Roles` section if not visible

You should now be on `/app/keys/key_auth_???/key_???`

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/apis/features/authorization/api-key-screen.png" alt="Unconnected roles and permissions" />
</Frame>

You can connect a role to your key by clicking on the checkbox.

Let's give this key the `dns.manager` and `read-only` roles.
A toast message should come up in the lower corner when the action has been completed.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/apis/features/authorization/role-add-example.png" alt="Unconnected roles and permissions" />
</Frame>

As you can see, now the key now contains 2 `roles` and 5 `permissions` shown just above the Roles section:

## Creating keys

When a user of your app creates a new key, you can attach zero, one or multiple previously created roles to the key.

```bash
curl -XPOST \
  --url https://api.unkey.dev/v1/keys.createKey \
  -H "Authorization: Bearer ${ROOT_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
    "apiId": "${API_ID}",
    "roles": [
      "role1", "role2", "role3"
    ]
  }'
```

See [here](/api-reference/keys/create) for details.


# Verifying
Source: https://unkey.com/docs/apis/features/authorization/verifying

Verifying permissions through the API

Once a key is generated, you can verify it using the [verify](/api-reference/keys/verify) endpoint. Our system verifies whether the key has the necessary permissions to perform the requested action(s). If the user's role grants the required permissions, the request is allowed to proceed; otherwise, access is denied.

<Tabs>
  <Tab title="Single Permission">
    This will return valid if the key has the permission: `admin`

    ```bash Single Permission

    curl --request POST \
      --url https://api.unkey.dev/v1/keys.verifyKey \
      --header 'Content-Type: application/json' \
      --data '{
        "apiId": "api_1234",
        "key": "sk_1234",
        "authorization": {
          "permissions": "admin"
        }
      }'
    ```
  </Tab>

  <Tab title="Nested Query">
    This will return valid if the key has either `admin` or both `dns.record.read` and `dns.record.update` permissions.

    ```bash Nested Query
    curl --request POST \
      --url https://api.unkey.dev/v1/keys.verifyKey \
      --header 'Content-Type: application/json' \
      --data '{
        "apiId": "api_1234",
        "key": "sk_1234",
        "authorization": {
          "permissions": {
            "or": [
              "admin",
              {
                "and": [
                  "dns.record.read",
                  "dns.record.update"
                ]
              }
            ]
          }
        }
      }'
    ```
  </Tab>
</Tabs>

Sometimes you just don't know what permissions are required before loading resources from your database.
In these cases you can manually check permissions as well.

<Steps>
  <Step title="Verify">
    Verify the key and all permissions that you already know before needing to query your database.

    If the response is invalid, you can return early.
  </Step>

  <Step title="Query your database">
    The key is at least valid, so you can query our database to fetch more information.
  </Step>

  <Step title="Verify Permissions">
    The verification response from step 1 includes all permissions attached to the keys and looks something like this:

    ```json
    {
      valid: true,
      permissions: ["permission1", "permission2", ...]
      //... omited for brevity
    }
    ```

    Use the attached permissions and the context loaded from your database to determine if you should proceed handling the request or returning an authorization error.
  </Step>
</Steps>


# Disabling Keys
Source: https://unkey.com/docs/apis/features/enabled

Enable or disable a key. Disabled keys will not validate.

This feature is useful for disabling a key temporarily. While disabled the key will act as an invalid key.

Example:
Suppose you have a customer that has not paid their bill. You may not want to delete the key and wait for the account balance to be current. The key can be disabled temporarily, preventing access until it is enabled.

Unkey allows you to disable a key on an individual basis.

### Example

Let's disable a key temperarily blocking access with that key.

```bash
curl --request POST \
  --url https://api.unkey.dev/v1/keys.updateKey \
  --header 'Authorization: Bearer <token>' \
  --header 'Content-Type: application/json' \
  --data '{
  "enabled": false,
  "keyId": "<keyId>"
}'
```

Now, when you verify the updated key it will show as invalid.

```bash
curl --request POST \
  --url https://api.unkey.dev/v1/keys.verifyKey \
  --header 'Content-Type: application/json' \
  --data '{
		"key": "<NEW_KEY>"
	}'
```

```json
{
  "keyId": "<KEY_ID>",
  "valid": false,
  "meta": {},
  "enabled": false
}
```

<Note>
  The returned `enabled` value can be changed with the updateKey endpoint to re-enable the key.
</Note>


# Environments
Source: https://unkey.com/docs/apis/features/environments

Separate your keys into live and test environments.

For many applications it's useful to provide keys for developing and testing to your users. They can
not interact with real production resources and may have lower ratelimits but use the exact same
flow as your `live` keys.

Unkey allows you to set an arbitrary value as `environment` for each key, so you can model your
domain however you want. In practice we often see two distinct environments being used a lot:

* `live` Live keys are used in production and affect real resources.
* `test` Test keys allow you to develop and test your code without modifying real resources. It's
  great to ensure your code is working manually or can be used in automated tests.

You may also want to associate different ratelimits per environment or bill usage differently.
Perhaps test keys have lower limits but are free to use.

### Creating a key with an environment

Using the prefix to indicate the environment is optional but highly recommended. It can prevent
your user from accidentally using keys interchangably and modifying resources unintentionally.

<CodeGroup>
  ```bash Test
  curl --request POST \
    --url https://api.unkey.dev/v1/keys.createKey \
    --header 'Authorization: Bearer <token>' \
    --header 'Content-Type: application/json' \
    --data '{
      "environment": "test",
      "prefix": "sk_test"
    }'
  ```

  ```bash Live
  curl --request POST \
    --url https://api.unkey.dev/v1/keys.createKey \
    --header 'Authorization: Bearer <token>' \
    --header 'Content-Type: application/json' \
    --data '{
      "environment": "live",
      "prefix": "sk_live"
    }'
  ```
</CodeGroup>

For more details, see the [API reference](/api-reference/keys/create)

### Verifying a key

When you are using different environments, you obviously need a way to know what environment the
used key is in.
We provide this as part of the verification response:

```bash
curl --request POST \
  --url https://api.unkey.dev/v1/keys.verifyKey \
  --header 'Content-Type: application/json' \
  --data '{
    "apiId": "api_1234",
    "key": "sk_1234"
  }'
```

The response would look something like this:

```json
{
  "valid": true,
  "environment": "test",
  // ... omited
}

```


# Modes
Source: https://unkey.com/docs/apis/features/ratelimiting/modes

Latency or consistency? Choose the right mode for your usecase.

Unkey offers `fixed window` rate limiting out of the box for all API keys. This means that you can set a limit on how many requests a key can make in a given time window. If the limit is exceeded, the key will be blocked from making further requests until the window resets.

We provide 2 ways of rate limiting, optimized for different usecases.

## Local, fast rate limiting at the edge

API key validation is very sensitive to latency because it is in the critical path of your application. Therefore minimizing the latency impact of rate limiting is a key priority.

Rate limiting at the edge comes with no latency increase and effectively rate limits your users at each edge location. To make this possible, each edge location maintains their own rate limiting and updates with the global state asynchronously, thus a user could exceed your rate limit if they go through different edge locations.

This way of limiting is effective to protect your application because there is a guaranteed upper bound after all edge locations the user is accessing have reached their limit.

### Example

```bash
curl --request POST \
  --url https://api.unkey.dev/v1/keys.createKey \
  --header 'Authorization: Bearer <UNKEY>' \
  --header 'Content-Type: application/json' \
  --data '{
	"apiId":"<API_ID>",
	"prefix":"xyz",
	"byteLength":16,
	"ownerId":"<USER_ID>",
	"ratelimit":{
		"async": true, // edge rate limiting
		"limit": 10,
		"duration": 1000
	}
}'
```

## Global consensus rate limiting

If having a strict rate limit that must not be exceeded, even when verifying keys in multiple regions, is required, then this is a good option.

This way of limiting is guaranteed to be consistent globally, but it comes with a higher latency impact.

Typically most of your traffic should pass, and we recommend using the local rate limiting to provide a better user experience and only use global rate limiting when you really need to.

### Example

```bash
curl --request POST \
  --url https://api.unkey.dev/v1/keys.createKey \
  --header 'Authorization: Bearer <UNKEY>' \
  --header 'Content-Type: application/json' \
  --data '{
	"apiId":"<API_ID>",
	"prefix":"xyz",
	"byteLength":16,
	"ownerId":"<USER_ID>",
	"ratelimit":{
		"async": false, // origin rate limiting
		"limit":10,
		"duration": 1000
	}
}'
```


# Overview
Source: https://unkey.com/docs/apis/features/ratelimiting/overview

How rate limiting works in unkey

Ratelimits are a way to control the amount of requests a key can make in a given timeframe. This is useful to prevent abuse and to protect your API from being overwhelmed.

<Note>
  The field `ratelimit` is deprecated. Please use `ratelimits` instead.
</Note>

Ratelimits are configured on a per-key or per-identity basis and can be managed through the dashboard or the API. In order to use a ratelimiting when verifying a key, you need to specify at least the name.

```json
{
  // ...
  "ratelimits": [
    {
      "name": "my-ratelimit",
    }
  ]
```

If you do not specify at least one ratelimit, the request will not get ratelimited.

As part of the migration towards the new ratelimiting system, there is a magic ratelimit called `default` that will be applied to all requests automatically. The default ratelimit is the one you have previously configured on the key itself. If you want to disable this, please got to the key's settings and delete the limit or use the [updateKey endpoint](https://www.unkey.com/docs/api-reference/keys/update)


# Refill
Source: https://unkey.com/docs/apis/features/refill

Refill remaining key verifications on a set interval

This feature is useful for creating an API key that automatically refills daily or monthly.
Daily refills trigger each night at midnight, while monthly refills are triggered on the first day of each month.

Example:
Suppose you are selling API access, and a customer has purchased 1000 API uses per month. On the first day of the month, the 1000 uses will be refilled for that key.

Unkey allows you to set a refill interval and increment on individual keys, and we take care of refilling a key on its set interval.

### Example

Let's create a new key that can be used 100 times a day.

```bash
curl --request POST \
  --url https://api.unkey.dev/v1/keys.createKey \
  --header 'Authorization: Bearer <UNKEY>' \
  --header 'Content-Type: application/json' \
  --data '{
    "apiId":"<API_ID>",
    "remaining": 100,
    "refill": {
      "interval": "daily",
      "amount": 100
    }
  }'
```

Now, when you verify the new key, you will receive the remaining verifications. After all of them are used up, the key becomes invalid.

```bash
curl --request POST \
  --url https://api.unkey.dev/v1/keys.verifyKey \
  --header 'Content-Type: application/json' \
  --data '{
		"key": "<NEW_KEY>"
	}'
```

```json
{
  "keyId": "<KEY_ID>",
  "valid": true,
  "meta": {},
  "remaining": 99
}
```

<Note>
  The returned `remaining` value represents how many verifications are remaining
  after the current one. A value of 3, means you can verify the key successfully
  3 more times.
</Note>


# Usage limited keys
Source: https://unkey.com/docs/apis/features/remaining

Limiting the usage of keys

Sometimes you would like to create an api key and automatically invalidate it after a certain number of uses.

Example:
You are selling API access and a customer has purchased 1000 api requests from you.

Unkey allows you to set/update usage limits on individual keys and we take care of invalidating a key after it has reached its limit.

### Example

Let's create a new key, which can be used 100 times.

```bash
curl --request POST \
  --url https://api.unkey.dev/v1/keys.createKey \
  --header 'Authorization: Bearer <UNKEY>' \
  --header 'Content-Type: application/json' \
  --data '{
	"apiId":"<API_ID>",
	"remaining": 100
}'
```

Now when you verify the new key, you will receive back the remaining verifications and after all of them are used up, the key is invalid.

```bash
curl --request POST \
  --url https://api.unkey.dev/v1/keys.verifyKey \
  --header 'Content-Type: application/json' \
  --data '{
      "apiId":"<API_ID>",
      "key": "<NEW_KEY>"
	}'
```

```json
{
	"valid": true,
	"remaining": 99
}
```

<Note>
  The returned `remaining` value represents how many verifications are remaining after the current one.
  A value of 3, means you can verify the key successfully 3 more times.
</Note>

## Custom cost

By default we deduct `1` from the remaining verifications, but in some cases you need to deduct more.

You can override this in the request body. In this example unkey would deduct `4` for every valid verification.
If a key would only have 3 remaining, the request would be rejected, as there is not enough remaining left.

<Note>
  There is a special case when you set `cost = 0`. In this case, the request will always be valid, but will not deduct anything.
</Note>

```bash {7-9}
curl --request POST \
  --url https://api.unkey.dev/v1/keys.verifyKey \
  --header 'Content-Type: application/json' \
  --data '{
    "apiId":"<API_ID>",
    "key": "<NEW_KEY>",
    "remaining": {
      "cost": 4
    }
  }'
```


# Key Revocation
Source: https://unkey.com/docs/apis/features/revocation

Keys can be revoked at any time, from the API or the dashboard.

In the event that a key is compromised, you can revoke it at any time. Once the key is revoked, it can take up to 60 seconds for the key to be invalidated. Once invalidated, the key will no longer be able to be used to authenticate requests.


# Temporary Keys
Source: https://unkey.com/docs/apis/features/temp-keys

How to create temporary API Keys in Unkey

## What are temporary API Keys?

Temporary API Keys are API Keys that expire after a certain amount of time. They are useful for when you want to give a user access to your API for a limited amount of time. For example, you might want to give a user access to your API for 1 hour, or 1 day, or 1 week. You can do this by creating a temporary API Key that expires after a certain amount of time.

## How to create a temporary API Key

To create a temporary API Key, you need to make a `POST` request to the `/v1/keys` endpoint. You can read about all the parameters you can send in the [API Reference](/api-reference/keys/create).

```bash
curl --request POST \
  --url https://api.unkey.dev/v1/keys.createKey \
  --header 'Authorization: Bearer <UNKEY>' \
  --header 'Content-Type: application/json' \
  --data '{
	"apiId":"<API_ID>",
	"prefix":"xyz",
	"byteLength":16,
	"ownerId":"USER_ID",
	"expires": 1718718673000,
}'
```

Once the key is created, you can send it to your user. They can then use it to access your API. Once the key expires, they will no longer be able to access your API and the key will be deleted.


# IP Whitelisting
Source: https://unkey.com/docs/apis/features/whitelist

Unkey offers IP whitelisting to restrict requests to a specific set of IP addresses.

This is useful for restricting access to your API to a specific set of IP addresses, such as your own servers or a set of trusted partners. This feature is available as an addon or with an Enterprise plan.

<Frame caption="IP Whitelisting">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/images/ip-whitelist.png" alt="IP Whitelist example" />
</Frame>


# Overview
Source: https://unkey.com/docs/apis/introduction

Protect your public APIs

Unkey provides a simple feature rich API key management system. You can use Unkey to protect your public APIs with ease. Below is an example of implementing Unkey in your API.

<CodeGroup>
  ```ts Typescript
  import { verifyKey } from '@unkey/api';

  const { result, error } = await verifyKey({
    apiId: "api_123",
    key: "xyz_123"
  })

  if ( error ) {
    // handle network error
  }

  if ( !result.valid ) {
    // reject unauthorized request
  }
  ```

  ```py Python
  import asyncio
  import os
  import unkey

  async def main() -> None:
    client = unkey.Client(api_key=os.environ["API_KEY"])
    await client.start()

    result = await client.keys.verify_key("prefix_abc123")

    if result.is_ok:
      print(data.valid)
    else:
      print(result.unwrap_err())

  ```

  ```go Golang
  package main
  import (
  	"fmt"
  	unkey "github.com/WilfredAlmeida/unkey-go/features"
  )
  func main() {
  	apiKey := "key_3ZZ7faUrkfv1YAhffAcnKW74"
  	response, err := unkey.KeyVerify(apiKey)
  	if err != nil {
  		fmt.Println("Error:", err)
  		return
  	}
  	if response.Valid {
  		fmt.Println("Key is valid")
  	} else {
  		fmt.Println("Key is invalid")
  	}
  }
  ```

  ```bash cURL
  curl --request POST \
    --url https://api.unkey.dev/v1/keys.verifyKey \
    --header 'Content-Type: application/json' \
    --data '{
      "apiId": "api_1234",
      "key": "sk_1234"
    }'
  ```
</CodeGroup>

## Features

Below are some of the key features of Unkey API key management system, for you to explore.

<CardGroup cols={2}>
  <Card title="Ratelimiting" href="/apis/features/ratelimiting">
    Key based ratelimiting
  </Card>

  <Card title="Usage limited keys" href="/apis/features/remaining">
    Set usage limits per key
  </Card>

  <Card title="Temporary Keys" href="/apis/features/temp-keys">
    Keys that expire after a set time
  </Card>

  <Card title="Refillable Keys" href="/apis/features/refill">
    Refill your remaining keys on a set schedule
  </Card>

  <Card title="Analytics" href="/apis/features/analytics">
    Rich analytics on your API and keys
  </Card>

  <Card title="Environments" href="/apis/features/environments">
    Separate your keys into live and test environments
  </Card>

  <Card title="Authorization" href="/apis/features/authorization/introduction">
    Access Control with Roles and Permissions
  </Card>
</CardGroup>


# Overview
Source: https://unkey.com/docs/audit-log/introduction

Audit logs for your workspace, allowing you to see the history of all the resource requests made inside your workspace.

We automatically capture all mutations, including key creation, permission changes and configuration changes.

## Accessing Audit Logs

To access the Audit Logs, click [here](https://app.unkey.com/audit) or on the **Audit Logs** option in the left navigation bar.

# Audit logs in detail

The audit logs table displays the following fields:

* **Actor**: who was responsible for the change. This can be either a user (for actions taken in the web app) or a key (for actions taken via the API).
* **Event**: the type of change. You can filter by type of events using the UI. Click to expand for more detail.
* **Location**: the IP address of the actor who made the change.

# Feature requests

Need additional functionality from audit logs, beyond what is provided currently? [Get in touch](mailto:support@unkey.dev)!

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/audit-log.png" />
</Frame>


# Event Types
Source: https://unkey.com/docs/audit-log/types

Available audit log event types

## Workspaces

Workspace actions that will create a new audit log item.

* `workspace.create` - A workspace is created.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/workspace_create.png" />
</Frame>

* `workspace.update` - A workspace is updated.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/workspace_update.png" />
</Frame>

## API

API actions that will create a new audit log item.

* `api.create` - An API is created.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/api_create.png" />
</Frame>

* `api.update` - An API is updated.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/api_update.png" />
</Frame>

* `api.delete` - An API is deleted.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/api_delete.png" />
</Frame>

## Keys

Key actions that will create a new audit log item.

* `key.create` - A key is created.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/key_create.png" />
</Frame>

* `key.update` - A key is updated.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/key_update.png" />
</Frame>

* `key.delete` - A key is deleted.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/key_delete.png" />
</Frame>

## Ratelimit

Ratelimit actions that will create a new audit log item.

### Ratelimit Namespace

* `ratelimitNamespace.update` - A ratelimit namespace is updated.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/ratelimitnamespace_create.png" />
</Frame>

* `ratelimitNamespace.update` - A ratelimit namespace is updated.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/ratelimitnamespace_update.png" />
</Frame>

* `ratelimitNamespace.delete` - A ratelimit namespace is deleted.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/ratelimitnamespace_delete.png" />
</Frame>

### Ratelimit Override

* `ratelimitOverride.create` - A ratelimit override is created.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/ratelimitoverride_create.png" />
</Frame>

* `ratelimitOverride.update` - A ratelimit override is updated.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/ratelimitoverride_update.png" />
</Frame>

## Role

Role actions that will create a new audit log item.

* `role.create` - A role is created.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/role_create.png" />
</Frame>

* `role.update` - A role is updated.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/role_update.png" />
</Frame>

* `role.delete` - A role is deleted.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/role_delete.png" />
</Frame>

## Permission

Permission actions that will create a new audit log item.

* `permission.create` - A permission is created.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/permission_create.png" />
</Frame>

* `permission.update` - A permission is updated.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/permission_update.png" />
</Frame>

* `permission.delete` - A permission is deleted.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/permission_delete.png" />
</Frame>

## Authorization

Authorization actions that will create a new audit log item.

* `authorization.connect_role_and_permission` - A role and permission are connected

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/auth_connect_role_permission.png" />
</Frame>

* `authorization.disconnect_role_and_permissions` - A role and permission are disconnected.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/auth_disconnect_role_permission.png" />
</Frame>

* `authorization.connect_role_and_key` - A role and key are connected.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/auth_connect_role_key.png" />
</Frame>

* `authorization.disconnect_role_and_key` - A role and key are disconnected.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/auth_disconnect_role_key.png" />
</Frame>

* `authorization.connect_permission_and_key` - A permission and key are connected.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/auth_connect_permission_key.png" />
</Frame>

* `authorization.disconnect_permission_and_key` - A permission and key are disconnected.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/audit-log/types/auth_disconnect_permission_key.png" />
</Frame>


# Overview
Source: https://unkey.com/docs/concepts/identities/overview

Identities are a representations of a user, an org or a machine in your application.

<Tip>
  Identities are in in public beta, please report any issues you encounter: [support](mailto:support@unkey.dev).
</Tip>

Identities are used to map your users, organizations, or even machine-users in Unkey and allow you to share metadata and configuration across multiple keys.
An identity is directly linked via a unique identifier from your system and you can associate as many keys as you want with an identity.

## Use cases

### Multiple keys for the same user

It is very common to issue multiple keys for the same user, but managing metadata and configuration for each key can be cumbersome and error-prone. By associating all keys with the same identity, you can share metadata and configuration across all keys.

Instead of updating each key, you can update the identity and all keys associated with it will automatically get the updated metadata and configuration.

### Sharing ratelimits across multiple keys

If you have multiple keys for the same user, you can set ratelimits for the identity and share it across all keys. This way, you can ensure that the user does not exceed the ratelimits across all of their keys.

[Read more](/concepts/identities/ratelimits) about how to share ratelimits across multiple keys.

### Aggregated analytics

If you are building a multi-tenant product, you can associate all keys of an organization with the organization's identity. This way, you can aggregate analytics across all keys of the organization and provide insights to the organization admin or drive your billing.

## Data model

<ParamField body="id" type string required>
  The unique identifier of the identity in Unkey. You may use this to reference the identity in other API calls.
</ParamField>

<ParamField body="externalId" type="string" required>
  The id of the identity in your system. This is used to link the identity in Unkey to your system.
  For example your user id, or organization id if you are linking an organization.

  If you are using a 3rd party auth provider like Clerk, WorkOS, or Auth0, they will provide you a unique id for users and organizations. This is what you should use as the externalId.

  We want to build deeper integrations with them, so if you are using one of these, please let us know so we can prioritize it.
</ParamField>

<ParamField body="meta" type="json">
  A JSON object that can store any additional information about the identity.
  We do not make assumptions about this data, it's entirely up to you to decide what to store here.
</ParamField>


# Ratelimits
Source: https://unkey.com/docs/concepts/identities/ratelimits

Identities can be used to share ratelimits across multiple keys

<Tip>
  Identities are in in public beta, please report any issues you encounter: [support](mailto:support@unkey.dev).
</Tip>

## Sharing ratelimits

Identities allow you to share ratelimits across multiple keys. Let's say you want to limit a specific user to 100 requests per second:
If you just set each key to `100 RPS` then the user can make `100 * number of keys` requests per second, which probably isn't what you want. Of course you could limit the number of keys a user can have or do some math to divide 100 by the number of keys they have, but that's not fixing the actual problem, it's just a workaround.

Instead, you should create an identity for the user, set the ratelimit on the identity to `100 RPS` and then associate all keys of the user with the identity. This way, the user can only make `100 RPS` across all of their keys.

## Multiple ratelimits

You can set multiple ratelimits for an identity and check against some or all of them when verifying a key.
Let's say you are building an app that uses AI under the hood and you want to limit your customers to 500 requests per hour, but also ensure that they don't blow up your bill by using too many tokens.

In this case you would create an identity for the user and then create two ratelimits:

1. `{name: "requests", limit: 500, duration: 3600000}` -> 500 requests per hour
2. `{name: "tokens", limit: 20000, duration: 86400000}` -> 20k tokens per day

Now if either one of those limits is exceeded, the request is denied.

<Info>
  API reference for verifying: [/api-reference/keys/verify](https://www.unkey.com/docs/api-reference/keys/verify)

  API reference for creating identities: [/api-reference/identities/create-identity](https://www.unkey.com/docs/api-reference/identities/create-identity)
</Info>


# Vercel
Source: https://unkey.com/docs/integrations/vercel

Zero Config API Authenciation on Vercel

## Prerequisites

* Created your [Unkey account](https://app.unkey.com/auth/sign-up)
* Created an API in the [Unkey dashboard](https://app.unkey.com/apis)
* [Vercel account](https://vercel.com/signup)

## Adding Vercel Integration

Prefer a video? Checkout this video that walks through the steps below.

<div class="aspect-w-16 aspect-h-9 sm:h-[400px] sm:w-[640px] h-[240px] mx-4 md:mx-0">
  <iframe height="100%" width="100%" src="https://www.youtube-nocookie.com/embed/fDKkicMZiCc?si=ksblX5j1-OUvNLpf&controls=0" title="YouTube video player" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowFullScreen />
</div>

<Steps>
  <Step titleSize="h3" title="Install" stepNumber={1}>
    The first step is to install the Vercel integration from the [Marketplace](https://vercel.com/integrations/unkey) or you can install it from the [Unkey Dashboard](https://app.unkey.com/settings/vercel).

    <Frame caption="Add integration">
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/images/add-integration.png" alt="Add your integration" />
    </Frame>
  </Step>

  <Step titleSize="h3" title="Select project" stepNumber={2}>
    Next you need to select your project in Vercel that you want to use with Unkey's integration.

    <Frame caption="Select project">
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/images/select-project.png" alt="Select project" />
    </Frame>
  </Step>

  <Step titleSize="h3" title="Select API" stepNumber={3}>
    Now you can set the Unkey API you want to use for each environment in Vercel.

    <Frame caption="Select API">
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/images/select-api.png" alt="Select API" />
    </Frame>
  </Step>

  <Step titleSize="h3" title="Integration complete" stepNumber={4}>
    That's it! You can now use Unkey's API authentication with your Vercel project. You will see that if you navigate to your Vercel project's environment variables, you will see we have added them.
  </Step>
</Steps>

## How to update a root key

Our integration uses Vercel's sensitive environment variable for the `UNKEY_ROOT_KEY`. To reissue a new root key, you can simply navigate to the Vercel integration settings and click the 3 dot menu and select "Reroll the key"

<Frame caption="Update your root key">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/images/reroll-key.png" alt="Update your root key" />
</Frame>


# Welcome to Unkey
Source: https://unkey.com/docs/introduction

API management redefined

Unkey provides an easy to use API management platform, including API key management, standalone ratelimiting and LLM caching.

## New to Unkey?

Start using Unkey with your existing project, or start from scratch.

<CardGroup cols={2}>
  <Card title="Quickstart" icon="bolt-lightning" href="/quickstart">
    Get started with Unkey with your favorite language.
  </Card>

  <Card title="API Keys" icon="file-lock" href="/apis/introduction">
    Learn how to use API Keys to protect, and scale your APIs
  </Card>

  <Card title="Standalone Ratelimiting" icon="shield" href="/ratelimiting/introduction">
    Protect public or private endpoints
  </Card>
</CardGroup>

## Start building

Ready to use Unkey to power your API?

<CardGroup cols={2}>
  <Card title="Unkey API Reference" icon="database" href="/api-reference">
    Learn about our API that helps you manage APIs, keys, ratelimits and analytical data.
  </Card>

  <Card title="SDKs" icon="brackets-curly" href="/libraries">
    Integrate Unkey into your application with one of our SDKs
  </Card>

  <Card title="Tutorials" icon="code" href="https://www.unkey.com/blog?tag=tutorials">
    Learn how to work with Unkey through tutorials
  </Card>
</CardGroup>

## Join the community

Join the Unkey community to ask questions, discuss best practices, and share tips.

<CardGroup cols={3}>
  <Card title="Discord" icon="discord" href="https://unkey.com/discord" />

  <Card title="GitHub" icon="github" href="https://github.com/unkeyed" />

  <Card title="Twitter / X" icon="x-twitter" href="https://x.com/unkeydev" />
</CardGroup>


# create_key
Source: https://unkey.com/docs/libraries/ex/functions/create_key

Create an api key for your users

> @spec create\_key(map) :: map()

Creates an API key for your users.

## Request

<ParamField body="apiId" type="string" required>
  Choose an `API` where this key should be created.
</ParamField>

<ParamField body="prefix" type="string">
  To make it easier for your users to understand which product an api key belongs to, you can add prefix them.

  For example Stripe famously prefixes their customer ids with `cus_` or their api keys with `sk_live_`.

  The underscore is automtically added if you are defining a prefix, for example: `"prefix": "abc"` will result in a key like `abc_xxxxxxxxx`
</ParamField>

<ParamField body="byteLength" type="int" default={16}>
  The bytelength used to generate your key determines its entropy as well as its length.
  Higher is better, but keys become longer and more annoying to handle.

  The default is `16 bytes`, or 2<sup>128</sup> possible combinations
</ParamField>

<ParamField body="ownerId" type="string">
  Your user's Id. This will provide a link between Unkey and your customer record.

  When validating a key, we will return this back to you, so you can clearly identify your user from their api key.
</ParamField>

<ParamField body="meta" type="object">
  This is a place for dynamic meta data, anything that feels useful for you should go here

  Example:

  ```json
  {
    "billingTier": "PRO",
    "trialEnds": "2023-06-16T17:16:37.161Z"
  }
  ```
</ParamField>

<ParamField body="expires" type="int">
  You can auto expire keys by providing a unix timestamp in milliseconds.

  Once keys expire they will automatically be deleted and are no longer valid.
</ParamField>

<ParamField body="ratelimit" type="Object">
  Unkey comes with per-key ratelimiting out of the box.

  <Expandable title="properties">
    <ParamField body="type" type="string" default="fast" required>
      Either `fast` or `consistent`.

      Read more [here](/apis/features/ratelimiting)
    </ParamField>

    <ParamField body="limit" type="int" required>
      The total amount of burstable requests.
    </ParamField>

    <ParamField body="refillRate" type="int" required>
      How many tokens to refill during each `refillInterval`
    </ParamField>

    <ParamField body="refillInterval" type="int" required>
      Determines the speed at which tokens are refilled.

      In milliseconds
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="remaining" type="int">
  Optionally limit the number of times a key can be used. This is different from time-based expiration using `expires`.

  Example:

  ```json
  "remaining": 10
  ```

  The created key can be verified successfully 10 times, afterwards it is invalidated automatically.

  Read more [here](/apis/features/remaining)
</ParamField>

## Response

<ResponseField name="key" type="string" required>
  The newly created api key
</ResponseField>

<ResponseField name="keyId" type="string" required>
  A unique id to reference this key for updating or revoking. This id can not be
  used to verify the key.
</ResponseField>

<RequestExample>
  ```elixir
     try do
          expiry =
            DateTime.utc_now()
            |> DateTime.add(100_000)
            |> DateTime.to_unix(:millisecond)

          opts =
            UnkeyElixirSdk.create_key(%{
              "apiId" => "api_7oKUUscTZy22jmVf9THxDA",
              "prefix" => "xyz",
              "byteLength" => 16,
              "ownerId" => "glamboyosa",
              "meta" => %{"hello" => "world"},
              "expires" => expiry,
              "ratelimit" => %{
                "type" => "fast",
                "limit" => 10,
                "refillRate" => 1,
                "refillInterval" => 1000
              },
              "remaining" => 10
            })

          Logger.info(opts)
        catch
          err ->
            Logger.error(err)
        end
  ```
</RequestExample>

<ResponseExample>
  ```json
  {
  	"key": "xyz_AS5HDkXXPot2MMoPHD8jnL",
       "keyId": "key_cm9vdCBvZiBnb29kXa",
  }
  ```
</ResponseExample>


# delete_key
Source: https://unkey.com/docs/libraries/ex/functions/delete_key

delete a key

> @spec delete\_key(binary) :: :ok

Delete an api key for your users

Returns `:ok`

## Request

<ParamField path="keyId" type="string" required>
  The ID of the key you want to revoke.
</ParamField>

## Response

Returns an atom `:ok`

<RequestExample>
  ```elixir
     try do
       :ok = UnkeyElixirSdk.delete_key("xyz_AS5HDkXXPot2MMoPHD8jnL")

      catch
          err ->
            Logger.error(err)
        end
  ```
</RequestExample>

<ResponseExample>
  ```elixir
  :ok
  ```
</ResponseExample>


# update_key
Source: https://unkey.com/docs/libraries/ex/functions/update_key

Updates the configuration of a key

> @spec update\_key(binary(), map()) :: :ok

Updates the configuration of a key.

Takes in a `key_id` argument and a map whose members are optional
but must have at most 1 member present.

To delete a field, set it to `nil`.

## Request

<ParamField path="keyId" type="string" required>
  The ID of the key you want to modify.
</ParamField>

<ParamField body="name" type="string | nil">
  Update the name of the key.
</ParamField>

<ParamField body="ownerId" type="string | nil">
  Update the owner id of the key.
</ParamField>

<ParamField body="meta" type="JSON | nil">
  Update the metadata of a key. You will have to provide the full metadata
  object, not just the fields you want to update.
</ParamField>

<ParamField body="expires" type="int | nil">
  Update the expire time of a key.

  The expire time is a unix timestamp in milliseconds.
</ParamField>

<ParamField body="ratelimit" type="Object | nil">
  Unkey comes with per-key ratelimiting out of the box.

  <Expandable title="properties">
    <ParamField body="type" type="string" required>
      Either `fast` or `consistent`.

      Read more [here](/apis/features/ratelimiting)
    </ParamField>

    <ParamField body="limit" type="int" required>
      The total amount of burstable requests.
    </ParamField>

    <ParamField body="refillRate" type="int" required>
      How many tokens to refill during each `refillInterval`
    </ParamField>

    <ParamField body="refillInterval" type="int" required>
      Determines the speed at which tokens are refilled.

      In milliseconds
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="remaining" type="int | nil">
  Update the expire time of a key.

  The expire time is a unix timestamp in milliseconds.
</ParamField>

## Response

Returns an atom `:ok`

<RequestExample>
  ```elixir
     try do
       :ok = UnkeyElixirSdk.update_key("key_cm9vdCBvZiBnb29kXa", %{
                  "name" => "my_new_key",
                  "ratelimit" => %{
                  "type" => "fast",
                  "limit" => 15,
                  "refillRate" => 2,
                  "refillInterval" => 500
                  },
                  "remaining" => 3
              })

      catch
          err ->
            Logger.error(err)
        end
  ```
</RequestExample>

<ResponseExample>
  ```elixir
  :ok
  ```
</ResponseExample>


# update_remaining
Source: https://unkey.com/docs/libraries/ex/functions/update_remaining

Updates the `remaining` value of a key

> @spec update\_remaining(map()) :: :ok

Updates the `remaining` value for a specified key.

## Request

<ParamField path="keyId" type="string" required>
  The ID of the key you want to modify.
</ParamField>

<ParamField body="op" type="increment | decrement | set">
  The operation you want to perform on the remaining count.

  Available options: "increment" | "decrement" | "set"
</ParamField>

<ParamField body="value" type="integer | nil">
  The value you want to set, add or subtract the remaining count by
</ParamField>

## Response

<ResponseField name="remaining" type="integer | nil" required>
  The updated `remaining` value.
</ResponseField>

<RequestExample>
  ```elixir
     try do
       opts = UnkeyElixirSdk.update_remaining(%{
              "keyId": "key_123",
              "op": "increment",
              "value": 1
              })

      catch
          err ->
            Logger.error(err)
        end
  ```
</RequestExample>

<ResponseExample>
  ```elixir
  %{"remaining"=> 100}
  ```
</ResponseExample>


# verify_key
Source: https://unkey.com/docs/libraries/ex/functions/verify_key

Verify a key

> @spec verify\_key(binary, map()) :: map()

Verify a key from your users. You only need to send the api key from your user.
Optionally, pass in a second param, a map with the key `apiId` which sends the `apiId` along.

## Request

<ParamField body="key" type="string" required>
  The key you want to verify.
</ParamField>

<ParamField body="apiId" type="string" required>
  The `API` of the key you want to verify.
</ParamField>

## Response

<ResponseField name="valid" type="boolean" required>
  Whether or not this key is valid and has passed the ratelimit. If `false` you
  should not grant access to whatever the user is requesting
</ResponseField>

<ResponseField name="ownerId" type="string">
  If you have set an `ownerId` on this key it is returned here. You can use this
  to clearly authenticate a user in your system.
</ResponseField>

<ResponseField name="meta" type="object">
  This is the `meta` data you have set when creating the key.

  Example:

  ```json
  {
    "billingTier": "PRO",
    "trialEnds": "2023-06-16T17:16:37.161Z"
  }
  ```
</ResponseField>

<RequestExample>
  ```elixir
     try do
       is_verified = UnkeyElixirSdk.verify_key("xyz_AS5HDkXXPot2MMoPHD8jnL", %{
        "apiId" => "api_7oKUUscTZy22jmVf9THxDA"
       })

      catch
          err ->
            Logger.error(err)
        end
  ```
</RequestExample>

<ResponseExample>
  ```ts
  {
  	valid: true,
  	ownerId: "glamboyosa",
  	meta: {
  		hello: "world"
  	}
  }
  ```
</ResponseExample>


# Overview
Source: https://unkey.com/docs/libraries/ex/overview

Elixir client for unkey

[Elixir SDK](https://github.com/glamboyosa/unkey-elixir-sdk) for interacting with the platform programatically.

## Installation

The package can be installed from Hex PM by adding `unkey_elixir_sdk` to your list of dependencies in `mix.exs`:

> Note: This project uses Elixir version `1.13`.

```elixir
def deps do
  [
    {:unkey_elixir_sdk, "~> 0.2.0"}
  ]
end
```

## Start the GenServer

In order to start this package we can either start it under a supervision tree (most common).

The GenServer takes a map with two properties.

* token: Your [Unkey](https://unkey.com) root key used to make requests. You can create one [here](https://app.unkey.com/settings/root-keys) **required**
* base\_url: The base URL endpoint you will be hitting i.e. `https://api.unkey.dev/v1/keys` (optional).

```elixir
 children = [
      {UnkeyElixirSdk, %{token: "yourunkeyrootkey"}}
    ]


# Now we start the supervisor with the children and a strategy
{:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)

# After started, we can query the supervisor for information
Supervisor.count_children(pid)
#=> %{active: 1, specs: 1, supervisors: 0, workers: 1}
```

You can also call the `start_link` function instead.

```elixir
{:ok, _pid} = UnkeyElixirSdk.start_link(%{token: "yourunkeyrootkey", base_url: "https://api.unkey.dev/v1/keys"})
```


# Overview
Source: https://unkey.com/docs/libraries/go/overview

Go SDK for Unkey

## SDK Installation

```bash
go get github.com/unkeyed/unkey/sdks/golang
```

## Example

```go
package main

import (
	"context"
	unkey "github.com/unkeyed/unkey/sdks/golang"
	"github.com/unkeyed/unkey/sdks/golang/models/components"
	"github.com/unkeyed/unkey/sdks/golang/models/operations"
	"log"
)

func main() {
	s := unkey.New(
		unkey.WithSecurity("<YOUR_BEARER_TOKEN_HERE>"),
	)

	request := operations.CreateAPIRequestBody{
		Name: "my-api",
	}

	ctx := context.Background()
	res, err := s.CreateAPI(ctx, request)
	if err != nil {
		log.Fatal(err)
	}
	if res != nil {
		// handle response
	}
}

```

## Error Handling

Handling errors in this SDK should largely match your expectations.  All operations return a response object or an error, they will never return both.  When specified by the OpenAPI spec document, the SDK will return the appropriate subclass.

| Error Object                     | Status Code | Content Type     |
| -------------------------------- | ----------- | ---------------- |
| sdkerrors.ErrBadRequest          | 400         | application/json |
| sdkerrors.ErrUnauthorized        | 401         | application/json |
| sdkerrors.ErrForbidden           | 403         | application/json |
| sdkerrors.ErrNotFound            | 404         | application/json |
| sdkerrors.ErrConflict            | 409         | application/json |
| sdkerrors.ErrTooManyRequests     | 429         | application/json |
| sdkerrors.ErrInternalServerError | 500         | application/json |
| sdkerrors.SDKError               | 4xx-5xx     | */*              |

### Example

```go
package main

import (
	"context"
	"errors"
	unkey "github.com/unkeyed/unkey/sdks/golang"
	"github.com/unkeyed/unkey/sdks/golang/models/components"
	"github.com/unkeyed/unkey/sdks/golang/models/operations"
	"github.com/unkeyed/unkey/sdks/golang/models/sdkerrors"
	"log"
)

func main() {
	s := unkey.New(
		unkey.WithSecurity("<YOUR_BEARER_TOKEN_HERE>"),
	)

	request := operations.CreateAPIRequestBody{
		Name: "my-api",
	}

	ctx := context.Background()
	res, err := s.CreateAPI(ctx, request)
	if err != nil {

		var e *sdkerrors.ErrBadRequest
		if errors.As(err, &e) {
			// handle error
			log.Fatal(e.Error())
		}

		var e *sdkerrors.ErrUnauthorized
		if errors.As(err, &e) {
			// handle error
			log.Fatal(e.Error())
		}

		var e *sdkerrors.ErrForbidden
		if errors.As(err, &e) {
			// handle error
			log.Fatal(e.Error())
		}

		var e *sdkerrors.ErrNotFound
		if errors.As(err, &e) {
			// handle error
			log.Fatal(e.Error())
		}

		var e *sdkerrors.ErrConflict
		if errors.As(err, &e) {
			// handle error
			log.Fatal(e.Error())
		}

		var e *sdkerrors.ErrTooManyRequests
		if errors.As(err, &e) {
			// handle error
			log.Fatal(e.Error())
		}

		var e *sdkerrors.ErrInternalServerError
		if errors.As(err, &e) {
			// handle error
			log.Fatal(e.Error())
		}

		var e *sdkerrors.SDKError
		if errors.As(err, &e) {
			// handle error
			log.Fatal(e.Error())
		}
	}
}

```


# Overview
Source: https://unkey.com/docs/libraries/nuxt/overview

Nuxt module for unkey

If you are using Nuxt, you can benefit from an almost zero-config experience with the `@unkey/nuxt` module.

## Install

<Tabs>
  <Tab title="bun">
    ```bash
      bun install @unkey/nuxt
    ```
  </Tab>

  <Tab title="pnpm">
    ```bash
      pnpm add @unkey/nuxt
    ```
  </Tab>

  <Tab title="yarn">
    ```bash
      yarn add @unkey/nuxt
    ```
  </Tab>

  <Tab title="npm">
    ```bash
      npm install @unkey/nuxt
    ```
  </Tab>
</Tabs>

## Configuration

`@unkey/nuxt` just requires your root key. Create an `.env` file in your project and add the following:

```env
NUXT_UNKEY_TOKEN=<your api key>
```

This can also be configured at runtime by setting the `NUXT_UNKEY_TOKEN` environment variable.

From this point onward, `@unkey/nuxt` will automatically:

1. verify any API requests with an `Authorization: Bearer xxx` header.
2. register a `useUnkey()` helper that allows access to an automatically configured unkey instance.

## Usage

### Automatic verification

You can access the automatically-verified `unkey` context on the server with `event.context.unkey` in your server routes or `useRequestEvent().context.unkey` in the Vue part of your app.

For example:

<Tabs>
  <Tab title="~/server/api/test.ts">
    ```ts
    export default defineEventHandler(async (event) => {
      if (!event.context.unkey.valid) {
        throw createError({ statusCode: 403, message: "Invalid API key" })
      }

      // return authorised information
      return {
        // ...
      };
    });
    ```
  </Tab>

  <Tab title="~/app.vue">
    ```html
    <template>
      <div>
        <pre>Was verified: {{ wasVerified }}</pre>
      </div>
    </template>

    <script setup>
    const wasVerified = useState(() => ({ unkey: useRequestEvent()?.context?.unkey.valid }))
    </script>
    ```
  </Tab>
</Tabs>

## Unkey helper

For more about how to use the configured helper provided by `useUnkey()`, you can see the API docs for [the TypeScript client](/libraries/ts/sdk/overview).

For example:

```ts
const unkey = useUnkey();

const created = await unkey.keys.create({
  apiId: "api_7oKUUscTZy22jmVf9THxDA",
  prefix: "xyz",
  byteLength: 16,
  ownerId: "chronark",
  meta: {
    hello: "world",
  },
  expires: 1686941966471,
  ratelimit: {
    async: true,
    duration: 1000,
    limit: 10,
    refillRate: 1,
    refillInterval: 1000,
  },
});

console.log(created.key);
```

### Disable telemetry

By default, Unkey collects anonymous telemetry data to help us understand how our SDKs are used.

If you wish to disable this, you can do so by passing a boolean flag to the constructor:

```ts
const unkey = useUnkey({ disableTelemetry: true })
```


# Async
Source: https://unkey.com/docs/libraries/py/async

Using unkey.py synchronous or asynchronous

```python
# Synchronous Example
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.liveness.check()

if res.object is not None:
    # handle response
    pass
```

The same SDK client can also be used to make asychronous requests by importing asyncio.

```python
# Asynchronous Example
import asyncio
import os
from unkey_py import Unkey

async def main():
    s = Unkey(
        bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
    )
    res = await s.liveness.check_async()
    if res.object is not None:
        # handle response
        pass

asyncio.run(main())
```


# Overview
Source: https://unkey.com/docs/libraries/py/overview

Developer-friendly & type-safe Python SDK for Unkey's API.

## SDK Installation

The SDK can be installed with either *pip* or *poetry* package managers.

### PIP

*PIP* is the default package installer for Python, enabling easy installation and management of packages from PyPI via the command line.

```bash
pip install unkey.py
```

### Poetry

*Poetry* is a modern tool that simplifies dependency management and package publishing by using a single `pyproject.toml` file to handle project metadata and dependencies.

```bash
poetry add unkey.py
```

## IDE Support

### PyCharm

Generally, the SDK will work well with most IDEs out of the box. However, when using PyCharm, you can enjoy much better integration with Pydantic by installing an additional plugin.

* [PyCharm Pydantic Plugin](https://docs.pydantic.dev/latest/integrations/pycharm/)

## SDK Example Usage

### Example

```python
# Synchronous Example
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.liveness.check()

if res.object is not None:
    # handle response
    pass
```

The same SDK client can also be used to make asychronous requests by importing asyncio.

```python
# Asynchronous Example
import asyncio
import os
from unkey_py import Unkey

async def main():
    s = Unkey(
        bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
    )
    res = await s.liveness.check_async()
    if res.object is not None:
        # handle response
        pass

asyncio.run(main())
```

## Available Resources and Operations

<details open>
  <summary>Available methods</summary>

  ### [apis](/libraries/py/services/apis)

  * [get](/libraries/py/services/apis#get)
  * [create](/libraries/py/services/apis#create)
  * [list\_keys](/libraries/py/services/apis#list_keys)
  * [delete](/libraries/py/services/apis#delete)
  * [delete\_keys](/libraries/py/services/apis#delete_keys)

  ### [identities](/libraries/py/services/identities)

  * [create](/libraries/py/services/identities#create)
  * [get](/libraries/py/services/identities#get)
  * [list](/libraries/py/services/identities#list)
  * [update](/libraries/py/services/identities#update)
  * [delete](/libraries/py/services/identities#delete)

  ### [keys](/libraries/py/services/keys)

  * [get](/libraries/py/services/keys#get)
  * [whoami](/libraries/py/services/keys#whoami)
  * [delete](/libraries/py/services/keys#delete)
  * [create](/libraries/py/services/keys#create)
  * [verify](/libraries/py/services/keys#verify)
  * [update](/libraries/py/services/keys#update)
  * [update\_remaining](/libraries/py/services/keys#update_remaining)
  * [get\_verifications](/libraries/py/services/keys#get_verifications)
  * [add\_permissions](/libraries/py/services/keys#add_permissions)
  * [remove\_permissions](/libraries/py/services/keys#remove_permissions)
  * [set\_permissions](/libraries/py/services/keys#set_permissions)
  * [add\_roles](/libraries/py/services/keys#add_roles)
  * [remove\_roles](/libraries/py/services/keys#remove_roles)
  * [set\_roles](/libraries/py/services/keys#set_roles)

  ### [migrations](/libraries/py/services/migrations)

  * [create\_keys](/libraries/py/services/migrations#create_keys)
  * [enqueue](/libraries/py/services/migrations#enqueue)

  ### [permissions](/libraries/py/services/permissions)

  * [create](/libraries/py/services/permissions#create)
  * [delete](/libraries/py/services/permissions#delete)
  * [get](/libraries/py/services/permissions#get)
  * [list](/libraries/py/services/permissions#list)
  * [create\_role](/libraries/py/services/permissions#create_role)
  * [delete\_role](/libraries/py/services/permissions#delete_role)
  * [get\_role](/libraries/py/services/permissions#get_role)
  * [list\_roles](/libraries/py/services/permissions#list_roles)

  ### [ratelimits](/libraries/py/services/ratelimits)

  * [limit](/libraries/py/services/ratelimits#limit)
</details>

## Pagination

Some of the endpoints in this SDK support pagination. To use pagination, you make your SDK calls as usual, but the
returned response object will have a `Next` method that can be called to pull down the next group of results. If the
return value of `Next` is `None`, then there are no more pages to be fetched.

Here's an example of one such pagination call:

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.identities.list(limit=100)

if res.object is not None:
    while True:
        # handle items

        res = res.next()
        if res is None:
            break

```

## Retries

Some of the endpoints in this SDK support retries. If you use the SDK without any configuration, it will fall back to the default retry strategy provided by the API. However, the default retry strategy can be overridden on a per-operation basis, or across the entire SDK.

To change the default retry strategy for a single API call, simply provide a `RetryConfig` object to the call:

```python
import os
from unkey.utils import BackoffStrategy, RetryConfig
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.liveness.check(,
    RetryConfig("backoff", BackoffStrategy(1, 50, 1.1, 100), False))

if res.object is not None:
    # handle response
    pass

```

If you'd like to override the default retry strategy for all operations that support retries, you can use the `retry_config` optional parameter when initializing the SDK:

```python
import os
from unkey.utils import BackoffStrategy, RetryConfig
from unkey_py import Unkey

s = Unkey(
    retry_config=RetryConfig("backoff", BackoffStrategy(1, 50, 1.1, 100), False),
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.liveness.check()

if res.object is not None:
    # handle response
    pass

```

## Error Handling

Handling errors in this SDK should largely match your expectations. All operations return a response object or raise an exception.

By default, an API error will raise a models.SDKError exception, which has the following properties:

| Property        | Type             | Description           |
| --------------- | ---------------- | --------------------- |
| `.status_code`  | *int*            | The HTTP status code  |
| `.message`      | *str*            | The error message     |
| `.raw_response` | *httpx.Response* | The raw HTTP response |
| `.body`         | *str*            | The response content  |

When custom error responses are specified for an operation, the SDK may also raise their associated exceptions. You can refer to respective *Errors* tables in SDK docs for more details on possible exception types for each operation. For example, the `check_async` method may raise the following exceptions:

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

### Example

```python
import os
from unkey_py import Unkey, models

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = None
try:
    res = s.liveness.check()

    if res.object is not None:
        # handle response
        pass

except models.ErrBadRequest as e:
    # handle e.data: models.ErrBadRequestData
    raise(e)
except models.ErrUnauthorized as e:
    # handle e.data: models.ErrUnauthorizedData
    raise(e)
except models.ErrForbidden as e:
    # handle e.data: models.ErrForbiddenData
    raise(e)
except models.ErrNotFound as e:
    # handle e.data: models.ErrNotFoundData
    raise(e)
except models.ErrConflict as e:
    # handle e.data: models.ErrConflictData
    raise(e)
except models.ErrTooManyRequests as e:
    # handle e.data: models.ErrTooManyRequestsData
    raise(e)
except models.ErrInternalServerError as e:
    # handle e.data: models.ErrInternalServerErrorData
    raise(e)
except models.SDKError as e:
    # handle exception
    raise(e)
```

## Server Selection

### Select Server by Index

You can override the default server globally by passing a server index to the `server_idx: int` optional parameter when initializing the SDK client instance. The selected server will then be used as the default on the operations that use it. This table lists the indexes associated with the available servers:

| # | Server                  | Variables |
| - | ----------------------- | --------- |
| 0 | `https://api.unkey.dev` | None      |

#### Example

```python
import os
from unkey_py import Unkey

s = Unkey(
    server_idx=0,
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.liveness.check()

if res.object is not None:
    # handle response
    pass

```

### Override Server URL Per-Client

The default server can also be overridden globally by passing a URL to the `server_url: str` optional parameter when initializing the SDK client instance. For example:

```python
import os
from unkey_py import Unkey

s = Unkey(
    server_url="https://api.unkey.dev",
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.liveness.check()

if res.object is not None:
    # handle response
    pass

```

## Custom HTTP Client

The Python SDK makes API calls using the [httpx](https://www.python-httpx.org/) HTTP library.  In order to provide a convenient way to configure timeouts, cookies, proxies, custom headers, and other low-level configuration, you can initialize the SDK client with your own HTTP client instance.
Depending on whether you are using the sync or async version of the SDK, you can pass an instance of `HttpClient` or `AsyncHttpClient` respectively, which are Protocol's ensuring that the client has the necessary methods to make API calls.
This allows you to wrap the client with your own custom logic, such as adding custom headers, logging, or error handling, or you can just pass an instance of `httpx.Client` or `httpx.AsyncClient` directly.

For example, you could specify a header for every request that this sdk makes as follows:

```python
from unkey_py import Unkey
import httpx

http_client = httpx.Client(headers={"x-custom-header": "someValue"})
s = Unkey(client=http_client)
```

or you could wrap the client with your own custom logic:

```python
from unkey_py import Unkey
from unkey_py.httpclient import AsyncHttpClient
import httpx

class CustomClient(AsyncHttpClient):
    client: AsyncHttpClient

    def __init__(self, client: AsyncHttpClient):
        self.client = client

    async def send(
        self,
        request: httpx.Request,
        *,
        stream: bool = False,
        auth: Union[
            httpx._types.AuthTypes, httpx._client.UseClientDefault, None
        ] = httpx.USE_CLIENT_DEFAULT,
        follow_redirects: Union[
            bool, httpx._client.UseClientDefault
        ] = httpx.USE_CLIENT_DEFAULT,
    ) -> httpx.Response:
        request.headers["Client-Level-Header"] = "added by client"

        return await self.client.send(
            request, stream=stream, auth=auth, follow_redirects=follow_redirects
        )

    def build_request(
        self,
        method: str,
        url: httpx._types.URLTypes,
        *,
        content: Optional[httpx._types.RequestContent] = None,
        data: Optional[httpx._types.RequestData] = None,
        files: Optional[httpx._types.RequestFiles] = None,
        json: Optional[Any] = None,
        params: Optional[httpx._types.QueryParamTypes] = None,
        headers: Optional[httpx._types.HeaderTypes] = None,
        cookies: Optional[httpx._types.CookieTypes] = None,
        timeout: Union[
            httpx._types.TimeoutTypes, httpx._client.UseClientDefault
        ] = httpx.USE_CLIENT_DEFAULT,
        extensions: Optional[httpx._types.RequestExtensions] = None,
    ) -> httpx.Request:
        return self.client.build_request(
            method,
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            timeout=timeout,
            extensions=extensions,
        )

s = Unkey(async_client=CustomClient(httpx.AsyncClient()))
```

## Authentication

### Per-Client Security Schemes

This SDK supports the following security scheme globally:

| Name          | Type | Scheme      | Environment Variable |
| ------------- | ---- | ----------- | -------------------- |
| `bearer_auth` | http | HTTP Bearer | `UNKEY_BEARER_AUTH`  |

To authenticate with the API the `bearer_auth` parameter must be set when initializing the SDK client instance. For example:

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.liveness.check()

if res.object is not None:
    # handle response
    pass

```

## Debugging

You can setup your SDK to emit debug logs for SDK requests and responses.

You can pass your own logger class directly into your SDK.

```python
from unkey_py import Unkey
import logging

logging.basicConfig(level=logging.DEBUG)
s = Unkey(debug_logger=logging.getLogger("unkey_py"))
```

You can also enable a default debug logger by setting an environment variable `UNKEY_DEBUG` to true.

# Development

## Maturity

This SDK is in beta, and there may be breaking changes between versions without a major version update. Therefore, we recommend pinning usage
to a specific package version. This way, you can install the same version each time without breaking changes unless you are intentionally
looking for the latest version.

## Contributions

While we value open-source contributions to this SDK, this library is generated programmatically. Any manual changes added to internal files will be overwritten on the next generation.
We look forward to hearing your feedback. Feel free to open a PR or an issue with a proof of concept and we'll do our best to include it in a future release.

### SDK Created by [Speakeasy](https://www.speakeasy.com/?utm_source=unkey\&utm_campaign=python)


# Apis
Source: https://unkey.com/docs/libraries/py/services/apis



## get

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.apis.get(api_id="api_1234")

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                            | Required             | Description                                                         | Example   |
| --------- | --------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- | --------- |
| `api_id`  | *str*                                                                                                           | :heavy\_check\_mark: | N/A                                                                 | api\_1234 |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md) | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |           |

### Response

**[models.GetAPIResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/getapiresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## create

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.apis.create(request={
    "name": "my-api",
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                             | Required             | Description                                                         |
| --------- | ---------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.CreateAPIRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/createapirequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)  | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.CreateAPIResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/createapiresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## list\_keys

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.apis.list_keys(request={
    "api_id": "api_1234",
    "limit": 100,
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                            | Required             | Description                                                         |
| --------- | --------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.ListKeysRequest](https://github.com/unkeyed/unkey-py/tree/main/docs/models/listkeysrequest.md)          | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md) | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.ListKeysResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/listkeysresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## delete

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.apis.delete(request={
    "api_id": "api_1234",
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                             | Required             | Description                                                         |
| --------- | ---------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.DeleteAPIRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/deleteapirequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)  | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.DeleteAPIResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/deleteapiresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrDeleteProtected     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## delete\_keys

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.apis.delete_keys(request={
    "api_id": "api_1234",
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                               | Required             | Description                                                         |
| --------- | ------------------------------------------------------------------------------------------------------------------ | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.DeleteKeysRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/deletekeysrequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)    | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.DeleteKeysResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/deletekeysresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |


# Identities
Source: https://unkey.com/docs/libraries/py/services/identities



## create

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.identities.create(request={
    "external_id": "user_123",
    "ratelimits": [
        {
            "name": "tokens",
            "limit": 10,
            "duration": 1000,
        },
        {
            "name": "tokens",
            "limit": 10,
            "duration": 1000,
        },
    ],
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                                       | Required             | Description                                                         |
| --------- | -------------------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.CreateIdentityRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/createidentityrequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)            | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.CreateIdentityResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/createidentityresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## get

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.identities.get(identity_id="id_1234", external_id="id_1234")

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter     | Type                                                                                                            | Required             | Description                                                         | Example  |
| ------------- | --------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- | -------- |
| `identity_id` | *Optional\[str]*                                                                                                | :heavy\_minus\_sign: | N/A                                                                 | id\_1234 |
| `external_id` | *Optional\[str]*                                                                                                | :heavy\_minus\_sign: | N/A                                                                 | id\_1234 |
| `retries`     | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md) | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |          |

### Response

**[models.GetIdentityResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/getidentityresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## list

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.identities.list(limit=100)

if res.object is not None:
    while True:
        # handle items

        res = res.next()
        if res is None:
            break

```

### Parameters

| Parameter     | Type                                                                                                            | Required             | Description                                                         | Example |
| ------------- | --------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- | ------- |
| `environment` | *Optional\[str]*                                                                                                | :heavy\_minus\_sign: | N/A                                                                 |         |
| `limit`       | *Optional\[int]*                                                                                                | :heavy\_minus\_sign: | N/A                                                                 | 100     |
| `cursor`      | *Optional\[str]*                                                                                                | :heavy\_minus\_sign: | N/A                                                                 |         |
| `retries`     | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md) | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |         |

### Response

**[models.ListIdentitiesResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/listidentitiesresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## update

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.identities.update(request={
    "identity_id": "id_1234",
    "external_id": "user_1234",
    "ratelimits": [
        {
            "name": "tokens",
            "limit": 10,
            "duration": 1000,
        },
        {
            "name": "tokens",
            "limit": 10,
            "duration": 1000,
        },
        {
            "name": "tokens",
            "limit": 10,
            "duration": 1000,
        },
    ],
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                                       | Required             | Description                                                         |
| --------- | -------------------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.UpdateIdentityRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/updateidentityrequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)            | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.UpdateIdentityResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/updateidentityresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## delete

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.identities.delete(request={
    "identity_id": "id_1234",
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                                       | Required             | Description                                                         |
| --------- | -------------------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.DeleteIdentityRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/deleteidentityrequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)            | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.DeleteIdentityResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/deleteidentityresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |


# Keys
Source: https://unkey.com/docs/libraries/py/services/keys



## get

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.keys.get(key_id="key_1234")

if res.key is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                            | Required             | Description                                                         | Example   |
| --------- | --------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- | --------- |
| `key_id`  | *str*                                                                                                           | :heavy\_check\_mark: | N/A                                                                 | key\_1234 |
| `decrypt` | *OptionalNullable\[bool]*                                                                                       | :heavy\_minus\_sign: | N/A                                                                 |           |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md) | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |           |

### Response

**[models.GetKeyResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/getkeyresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## whoami

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.keys.whoami(request={
    "key": "sk_123",
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                            | Required             | Description                                                         |
| --------- | --------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.WhoamiRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/whoamirequestbody.md)      | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md) | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.WhoamiResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/whoamiresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## delete

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.keys.delete(request={
    "key_id": "key_1234",
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                             | Required             | Description                                                         |
| --------- | ---------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.DeleteKeyRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/deletekeyrequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)  | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.DeleteKeyResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/deletekeyresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## create

### Example Usage

```python
import os
import unkey
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.keys.create(request={
    "api_id": "api_123",
    "name": "my key",
    "external_id": "team_123",
    "meta": {
        "billingTier": "PRO",
        "trialEnds": "2023-06-16T17:16:37.161Z",
    },
    "roles": [
        "admin",
        "finance",
    ],
    "permissions": [
        "domains.create_record",
        "say_hello",
    ],
    "expires": 1623869797161,
    "remaining": 1000,
    "refill": {
        "interval": unkey.CreateKeyInterval.DAILY,
        "amount": 100,
    },
    "ratelimit": {
        "limit": 10,
        "type": unkey.CreateKeyType.FAST,
        "duration": 60000,
    },
    "enabled": False,
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                             | Required             | Description                                                         |
| --------- | ---------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.CreateKeyRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/createkeyrequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)  | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.CreateKeyResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/createkeyresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## verify

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.keys.verify(request={
    "key": "sk_1234",
    "api_id": "api_1234",
    "ratelimits": [
        {
            "name": "tokens",
            "limit": 500,
            "duration": 3600000,
        },
        {
            "name": "tokens",
            "limit": 20000,
            "duration": 86400000,
        },
    ],
})

if res.v1_keys_verify_key_response is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                                 | Required             | Description                                                         |
| --------- | -------------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.V1KeysVerifyKeyRequest](https://github.com/unkeyed/unkey-py/tree/main/docs/models/v1keysverifykeyrequest.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)      | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.VerifyKeyResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/verifykeyresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## update

### Example Usage

```python
import os
import unkey
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.keys.update(request={
    "key_id": "key_123",
    "name": "Customer X",
    "external_id": "user_123",
    "meta": {
        "roles": [
            "admin",
            "user",
        ],
        "stripeCustomerId": "cus_1234",
    },
    "expires": 0,
    "ratelimit": {
        "limit": 10,
        "type": unkey.UpdateKeyType.FAST,
        "refill_rate": 1,
        "refill_interval": 60,
    },
    "remaining": 1000,
    "refill": {
        "interval": unkey.UpdateKeyInterval.DAILY,
        "amount": 100,
    },
    "enabled": True,
    "roles": [
        {
            "id": "perm_123",
        },
        {
            "name": "dns.record.create",
        },
        {
            "name": "dns.record.delete",
            "create": True,
        },
    ],
    "permissions": [
        {
            "id": "perm_123",
        },
        {
            "name": "dns.record.create",
        },
        {
            "name": "dns.record.delete",
            "create": True,
        },
    ],
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                             | Required             | Description                                                         |
| --------- | ---------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.UpdateKeyRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/updatekeyrequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)  | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.UpdateKeyResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/updatekeyresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## update\_remaining

### Example Usage

```python
import os
import unkey
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.keys.update_remaining(request={
    "key_id": "key_123",
    "op": unkey.Op.SET,
    "value": 1,
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                                         | Required             | Description                                                         |
| --------- | ---------------------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.UpdateRemainingRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/updateremainingrequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)              | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.UpdateRemainingResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/updateremainingresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## get\_verifications

### Example Usage

```python
import os
import unkey
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.keys.get_verifications(request={
    "key_id": "key_1234",
    "owner_id": "chronark",
    "start": 1620000000000,
    "end": 1620000000000,
    "granularity": unkey.Granularity.DAY,
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                                   | Required             | Description                                                         |
| --------- | ---------------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.GetVerificationsRequest](https://github.com/unkeyed/unkey-py/tree/main/docs/models/getverificationsrequest.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)        | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.GetVerificationsResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/getverificationsresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## add\_permissions

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.keys.add_permissions(request={
    "key_id": "<id>",
    "permissions": [
        {},
    ],
})

if res.response_bodies is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                                       | Required             | Description                                                         |
| --------- | -------------------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.AddPermissionsRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/addpermissionsrequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)            | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.AddPermissionsResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/addpermissionsresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## remove\_permissions

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.keys.remove_permissions(request={
    "key_id": "<id>",
    "permissions": [
        {
            "id": "perm_123",
        },
        {
            "name": "dns.record.create",
        },
    ],
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                                             | Required             | Description                                                         |
| --------- | -------------------------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.RemovePermissionsRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/removepermissionsrequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)                  | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.RemovePermissionsResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/removepermissionsresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## set\_permissions

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.keys.set_permissions(request={
    "key_id": "<id>",
    "permissions": [
        {
            "id": "perm_123",
        },
        {
            "name": "dns.record.create",
        },
        {
            "name": "dns.record.delete",
            "create": True,
        },
    ],
})

if res.response_bodies is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                                       | Required             | Description                                                         |
| --------- | -------------------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.SetPermissionsRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/setpermissionsrequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)            | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.SetPermissionsResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/setpermissionsresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## add\_roles

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.keys.add_roles(request={
    "key_id": "<id>",
    "roles": [
        {
            "id": "role_123",
        },
        {
            "name": "dns.record.create",
        },
        {
            "name": "dns.record.delete",
            "create": True,
        },
    ],
})

if res.response_bodies is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                            | Required             | Description                                                         |
| --------- | --------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.AddRolesRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/addrolesrequestbody.md)  | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md) | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.AddRolesResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/addrolesresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## remove\_roles

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.keys.remove_roles(request={
    "key_id": "<id>",
    "roles": [
        {
            "id": "role_123",
        },
        {
            "name": "dns.record.create",
        },
    ],
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                                 | Required             | Description                                                         |
| --------- | -------------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.RemoveRolesRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/removerolesrequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)      | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.RemoveRolesResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/removerolesresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## set\_roles

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.keys.set_roles(request={
    "key_id": "<id>",
    "roles": [
        {
            "id": "role_123",
        },
        {
            "name": "dns.record.create",
        },
        {
            "name": "dns.record.delete",
            "create": True,
        },
    ],
})

if res.response_bodies is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                            | Required             | Description                                                         |
| --------- | --------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.SetRolesRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/setrolesrequestbody.md)  | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md) | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.SetRolesResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/setrolesresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |


# Migrations
Source: https://unkey.com/docs/libraries/py/services/migrations



## create\_keys

### Example Usage

```python
import os
import unkey
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.migrations.create_keys(request=[
    {
        "api_id": "api_123",
        "name": "my key",
        "start": "unkey_32kq",
        "owner_id": "team_123",
        "meta": {
            "billingTier": "PRO",
            "trialEnds": "2023-06-16T17:16:37.161Z",
        },
        "roles": [
            "admin",
            "finance",
        ],
        "permissions": [
            "domains.create_record",
            "say_hello",
        ],
        "expires": 1623869797161,
        "remaining": 1000,
        "refill": {
            "interval": unkey.V1MigrationsCreateKeysInterval.DAILY,
            "amount": 100,
        },
        "ratelimit": {
            "limit": 10,
            "refill_rate": 1,
            "refill_interval": 60,
            "type": unkey.V1MigrationsCreateKeysType.FAST,
        },
        "enabled": False,
    },
])

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                            | Required             | Description                                                         |
| --------- | --------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [List\[models.RequestBody\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/.md)                     | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md) | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.V1MigrationsCreateKeysResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/v1migrationscreatekeysresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## enqueue

### Example Usage

```python
import os
import unkey
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.migrations.enqueue(request={
    "migration_id": "<id>",
    "api_id": "<id>",
    "keys": [
        {
            "name": "my key",
            "start": "unkey_32kq",
            "owner_id": "team_123",
            "meta": {
                "billingTier": "PRO",
                "trialEnds": "2023-06-16T17:16:37.161Z",
            },
            "roles": [
                "admin",
                "finance",
            ],
            "permissions": [
                "domains.create_record",
                "say_hello",
            ],
            "expires": 1623869797161,
            "remaining": 1000,
            "refill": {
                "interval": unkey.V1MigrationsEnqueueKeysInterval.DAILY,
                "amount": 100,
            },
            "ratelimit": {
                "limit": 10,
                "duration": 60000,
                "type": unkey.V1MigrationsEnqueueKeysType.FAST,
            },
            "enabled": False,
        },
    ],
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                                                         | Required             | Description                                                         |
| --------- | -------------------------------------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.V1MigrationsEnqueueKeysRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/v1migrationsenqueuekeysrequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)                              | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.V1MigrationsEnqueueKeysResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/v1migrationsenqueuekeysresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |


# Permissions
Source: https://unkey.com/docs/libraries/py/services/permissions



## create

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.permissions.create(request={
    "name": "record.write",
    "description": "record.write can create new dns records for our domains.",
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                                           | Required             | Description                                                         |
| --------- | ------------------------------------------------------------------------------------------------------------------------------ | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.CreatePermissionRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/createpermissionrequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)                | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.CreatePermissionResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/createpermissionresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## delete

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.permissions.delete(request={
    "permission_id": "perm_123",
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                                           | Required             | Description                                                         |
| --------- | ------------------------------------------------------------------------------------------------------------------------------ | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.DeletePermissionRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/deletepermissionrequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)                | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.DeletePermissionResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/deletepermissionresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## get

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.permissions.get(permission_id="perm_123")

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter       | Type                                                                                                            | Required             | Description                                                         | Example   |
| --------------- | --------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- | --------- |
| `permission_id` | *str*                                                                                                           | :heavy\_check\_mark: | N/A                                                                 | perm\_123 |
| `retries`       | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md) | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |           |

### Response

**[models.GetPermissionResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/getpermissionresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## list

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.permissions.list()

if res.response_bodies is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                            | Required             | Description                                                         |
| --------- | --------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md) | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.ListPermissionsResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/listpermissionsresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## create\_role

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.permissions.create_role(request={
    "name": "dns.records.manager",
    "description": "dns.records.manager can read and write dns records for our domains.",
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                               | Required             | Description                                                         |
| --------- | ------------------------------------------------------------------------------------------------------------------ | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.CreateRoleRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/createrolerequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)    | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.CreateRoleResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/createroleresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## delete\_role

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.permissions.delete_role(request={
    "role_id": "role_123",
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                               | Required             | Description                                                         |
| --------- | ------------------------------------------------------------------------------------------------------------------ | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.DeleteRoleRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/deleterolerequestbody.md) | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md)    | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.DeleteRoleResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/deleteroleresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## get\_role

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.permissions.get_role(role_id="role_123")

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                            | Required             | Description                                                         | Example   |
| --------- | --------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- | --------- |
| `role_id` | *str*                                                                                                           | :heavy\_check\_mark: | N/A                                                                 | role\_123 |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md) | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |           |

### Response

**[models.GetRoleResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/getroleresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |

## list\_roles

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.permissions.list_roles()

if res.response_bodies is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                            | Required             | Description                                                         |
| --------- | --------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md) | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.ListRolesResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/listrolesresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |


# Ratelimits
Source: https://unkey.com/docs/libraries/py/services/ratelimits



## limit

### Example Usage

```python
import os
from unkey_py import Unkey

s = Unkey(
    bearer_auth=os.getenv("UNKEY_BEARER_AUTH", ""),
)

res = s.ratelimits.limit(request={
    "identifier": "user_123",
    "limit": 10,
    "duration": 60000,
    "namespace": "email.outbound",
    "cost": 2,
    "resources": [
        {
            "type": "organization",
            "id": "org_123",
            "name": "unkey",
        },
    ],
})

if res.object is not None:
    # handle response
    pass

```

### Parameters

| Parameter | Type                                                                                                            | Required             | Description                                                         |
| --------- | --------------------------------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------------- |
| `request` | [models.LimitRequestBody](https://github.com/unkeyed/unkey-py/tree/main/docs/models/limitrequestbody.md)        | :heavy\_check\_mark: | The request object to use for the request.                          |
| `retries` | [Optional\[utils.RetryConfig\]](https://github.com/unkeyed/unkey-py/tree/main/docs/models/utils/retryconfig.md) | :heavy\_minus\_sign: | Configuration to override the default retry behavior of the client. |

### Response

**[models.LimitResponse](https://github.com/unkeyed/unkey-py/tree/main/docs/models/limitresponse.md)**

### Errors

| Error Type                    | Status Code | Content Type     |
| ----------------------------- | ----------- | ---------------- |
| models.ErrBadRequest          | 400         | application/json |
| models.ErrUnauthorized        | 401         | application/json |
| models.ErrForbidden           | 403         | application/json |
| models.ErrNotFound            | 404         | application/json |
| models.ErrConflict            | 409         | application/json |
| models.ErrTooManyRequests     | 429         | application/json |
| models.ErrInternalServerError | 500         | application/json |
| models.SDKError               | 4XX, 5XX    | \*/\*            |


# Overview
Source: https://unkey.com/docs/libraries/rs/overview

Rust client for unkey

# Unkey for Rust

An asynchronous Rust SDK for the [Unkey API](https://unkey.com/docs/introduction).

All the API key management features you love, now with more type safety!

## MSRV

The minimum supported Rust verision for the project is `1.63.0`.

## Setup

### Using `cargo`

```bash
$ cargo add unkey
```

### Manually

Add the following to your `Cargo.toml` dependencies array:

```toml
unkey = "0.4"
```

## Getting Started

### Examples

#### Verifying a key

```rust
use unkey::models::VerifyKeyRequest;
use unkey::Client;

async fn verify_key() {
    let c = Client::new("unkey_ABC");
    let req = VerifyKeyRequest::new("test_DEF", "api_JJJ");

    match c.verify_key(req).await {
        Ok(res) => println!("{res:?}"),
        Err(err) => eprintln!("{err:?}"),
    }
}
```

#### Creating a key

```rust
use unkey::models::CreateKeyRequest;
use unkey::Client;

async fn create_key() {
    let c = Client::new("unkey_ABC");
    let req = CreateKeyRequest::new("api_123")
        .set_prefix("test")
        .set_remaining(100)
        .set_name("test_name")
        .set_owner_id("jonxslays");

    match c.create_key(req).await {
        Ok(res) => println!("{res:?}"),
        Err(err) => eprintln!("{err:?}"),
    }
}
```

#### Updating a key

```rust
use unkey::models::{Refill, RefillInterval, UpdateKeyRequest};
use unkey::Client;

async fn update_key() {
    let c = Client::new("unkey_ABC");
    let req = UpdateKeyRequest::new("key_XYZ")
        .set_name(Some("new_name")) // Update the keys name
        .set_ratelimit(None) // Remove any ratelimit on the key
        .set_expires(None) // Remove any expiration date
        .set_refill(Some(Refill::new(100, RefillInterval::Daily)));

    match c.update_key(req).await {
        Ok(_) => println!("Success"), // Nothing on success
        Err(err) => eprintln!("{err:?}"),
    }
}
```

#### Revoking a key

```rust
use unkey::models::RevokeKeyRequest;
use unkey::Client;

async fn revoke_key() {
    let c = Client::new("unkey_ABC");
    let req = RevokeKeyRequest::new("key_XYZ");

    match c.revoke_key(req).await {
        Ok(_) => println!("Success"), // Nothing on success
        Err(err) => eprintln!("{err:?}"),
    }
}
```

#### Listing api keys

```rust
use unkey::models::ListKeysRequest;
use unkey::Client;

async fn list_keys() {
    let c = Client::new("unkey_ABC");
    let req = ListKeysRequest::new("api_123");

    match c.list_keys(req).await {
        Ok(res) => println!("{res:?}"),
        Err(err) => eprintln!("{err:?}"),
    }
}
```

#### Getting api information

```rust
use unkey::models::GetApiRequest;
use unkey::Client;

async fn get_api() {
    let c = Client::new("unkey_ABC");
    let req = GetApiRequest::new("api_123");

    match c.get_api(req).await {
        Ok(res) => println!("{res:?}"),
        Err(err) => eprintln!("{err:?}"),
    }
}
```

#### Getting key details

```rust
use unkey::models::GetKeyRequest;
use unkey::Client;

async fn get_key() {
    let c = Client::new("unkey_ABC");
    let req = GetKeyRequest::new("key_123");

    match c.get_key(req).await {
        Ok(res) => println!("{res:?}"),
        Err(err) => eprintln!("{err:?}"),
    }
}
```

#### Update remaining verifications

```rust
use unkey::models::{UpdateOp, UpdateRemainingRequest};
use unkey::Client;

async fn update_remaining() {
    let c = Client::new("unkey_ABC");
    let req = UpdateRemainingRequest::new("key_123", Some(100), UpdateOp::Set);

    match c.update_remaining(req).await {
        Ok(res) => println!("{res:?}"),
        Err(err) => eprintln!("{err:?}"),
    }
}
```

***

### Project Links

* [Documentation](https://docs.rs/unkey)
* [Repository](https://github.com/Jonxslays/unkey)
* [Crate](https://crates.io/crates/unkey)

### Other useful links

* [The Client](https://docs.rs/unkey/latest/unkey/struct.Client.html)
* [Models](https://docs.rs/unkey/latest/unkey/models/index.html)


# Get API
Source: https://unkey.com/docs/libraries/springboot-java/api/get

Retrieve information about an API

Pass the optional and required parameters as per the official [API docs](https://unkey.com/docs/api-reference/apis/list-keys). See the DTO reference below for more information.

```java
package com.example.myapp;

import com.unkey.unkeysdk.dto.GetAPIResponse;

@RestController
public class APIController {

    private static IAPIService apiService = new APIService();

    @GetMapping("/get-api")
    public GetAPIResponse getAPI(
            @RequestParam String apiId,
            @RequestHeader("Authorization") String authToken) {
        // Delegate the creation of the key to the IAPIService from the SDK
        return apiService.getAPI(apiId, authToken);
    }
}

```

### DTOs Reference

The DTOs used in the code for a better understanding of request and response bodies.

#### Response

```java
public class GetAPIResponse {
    private String id;
    private String name;
    private String workspaceId;
}
```


# List Keys
Source: https://unkey.com/docs/libraries/springboot-java/api/list

List API keys

Pass the optional and required parameters as per the official [API docs](https://unkey.com/docs/api-reference/apis/list-keys). See the DTO reference below for more information.

```java
package com.example.myapp;

import com.unkey.unkeysdk.dto.GetAPIResponse;

@RestController
public class APIController {

    private static IAPIService apiService = new APIService();

    @GetMapping("/keys")
    public ListKeysResponse listKeys(
            @RequestParam String apiId,
            @RequestBody(required = false) ListKeysRequest listKeyRquest,
            @RequestHeader("Authorization") String authToken) {
        // Delegate the creation of the key to the IAPIService from the SDK
        return iapiService.listKeys(listKeyRquest, apiId, authToken);
    }
}

```

### DTOs Reference

The DTOs used in the code for a better understanding of request and response bodies.

#### Request

```java
public class ListKeysRequest {
    private String apiId;
    private Integer limit;
    private Integer offset;
    private String ownerId;
}
```

#### Response

```java
public class ListKeysResponse {
    private List<KeyAttributes> keys;
    private Integer total;
}
```

```java
public class KeyAttributes {
    private String id;
    private String apiId;
    private String workspaceId;
    private String start;
    private String name;
    private String ownerId;
    private Meta meta;
    private Long createdAt;
    private Long expires;
    private Integer remaining;
    private KeyRateLimit ratelimit;
}
```


# Create
Source: https://unkey.com/docs/libraries/springboot-java/functions/create

Create an api key for your users

Pass the optional and required parameters as per the official [API docs](https://unkey.com/docs/api-reference/apis/list-keys). See the DTO reference below for more information.

```java
package com.example.myapp;

import com.unkey.unkeysdk.dto.KeyCreateResponse;
import com.unkey.unkeysdk.dto.KeyCreateRequest;

@RestController
public class APIController {

    private static IKeyService keyService = new KeyService();

    @PostMapping("/createKey")
    public KeyCreateResponse createKey(
            @RequestBody KeyCreateRequest keyCreateRequest,
            @RequestHeader("Authorization") String authToken) {
        // Delegate the creation of the key to the KeyService from the SDK
        return keyService.createKey(keyCreateRequest, authToken);
    }
}

```

### DTOs Reference

The DTOs used in the code for a better understanding of request and response bodies.

#### Request

```java
public class KeyCreateRequest {
    @NonNull
    private String apiId;
    private String prefix;
    private String name;
    private Integer byteLength;
    private String ownerId;
    private Meta meta;
    private Integer expires;
    private Integer remaining;
    private KeyRateLimit ratelimit;
}
```

```java
public class Meta {
    private Map<String, String> meta;
}
```

```java
public class KeyRateLimit {
    private String type;
    private Integer limit;
    private Integer refillRate;
    private Integer refillInterval;
}
```

#### Response

```java
public class KeyCreateResponse {
    @NonNull
    private String key;
    @NonNull
    private String keyId;
}
```


# revoke
Source: https://unkey.com/docs/libraries/springboot-java/functions/revoke

Revoke an api key

Pass the optional and required parameters as per the official [API docs](https://unkey.com/docs/api-reference/apis/list-keys). See the DTO reference below for more information.

```java
package com.example.myapp;

import com.unkey.unkeysdk.dto.KeyDeleteRequest;

@RestController
public class APIController {

    private static IKeyService keyService = new KeyService();

    @DeleteMapping("/delete")
    public ResponseEntity<String> updateKey(
            @RequestBody KeyDeleteRequest keyId,
            @RequestHeader("Authorization") String authToken) {
        // Delegate the creation of the key to the KeyService
        return keyService.deleteKey(authToken, keyId);
    }
}

```

### DTOs Reference

The DTOs used in the code for a better understanding of request and response bodies.

#### Request

```java
public class KeyDeleteRequest {
    private String keyId;
}
```

#### Response

"OK"


# Update
Source: https://unkey.com/docs/libraries/springboot-java/functions/update

Update an api key

Pass the optional and required parameters as per the official [API docs](https://unkey.com/docs/api-reference/apis/list-keys). See the DTO reference below for more information.

```java
package com.example.myapp;

@RestController
public class APIController {

    private static IKeyService keyService = new KeyService();

    @PutMapping("/update")
    public ResponseEntity<String> updateKey(
            @RequestParam String keyId,
            @RequestBody Map<String, Object> keyUpdateRequest,
            @RequestHeader("Authorization") String authToken
    ) {
        // Delegate the creation of the key to the KeyService
        return keyService.updateKey(keyUpdateRequest, authToken, keyId);
    }
}

```

### DTOs Reference

The DTOs used in the code for a better understanding of request and response bodies.

#### Request

Take the reference from the official [API docs](https://unkey.com/docs/api-reference/keys/update) for update request parameters.
Only pass the parameters you want to update.

#### Response

"OK"


# Verify
Source: https://unkey.com/docs/libraries/springboot-java/functions/verify

Verify an api key

Pass the optional and required parameters as per the official [API docs](https://unkey.com/docs/api-reference/apis/list-keys). See the DTO reference below for more information.

```java
package com.example.myapp;

import com.unkey.unkeysdk.dto.KeyVerifyRequest;
import com.unkey.unkeysdk.dto.KeyVerifyResponse;

@RestController
public class APIController {

    private static IKeyService keyService = new KeyService();

    @PostMapping("/verify")
    public KeyVerifyResponse verifyKey(
            @RequestBody KeyVerifyRequest keyVerifyRequest) {
        // Delegate the creation of the key to the KeyService from the SDK
        return keyService.verifyKey(keyVerifyRequest);
    }
}

```

### DTOs Reference

The DTOs used in the code for a better understanding of request and response bodies.

```java
public class KeyVerifyResponse {
    @NonNull
    private Boolean valid;
    private String code;
    private String ownerId;
    private Long expires;
    private Object meta;
    private KeyVerifyRateLimit ratelimit;
    private Long remaining;
}
```

```java
public class KeyVerifyRateLimit {
    private Integer limit;
    private Integer remaining;
    private Long reset;
}
```

```java
public class KeyVerifyRequest {
    @NonNull
    private String key;
    private String apiId;
}
```


# Overview
Source: https://unkey.com/docs/libraries/springboot-java/overview

Spring Boot client for unkey

## Configure Build File

Add the Unkey SDK dependency to your `build.gradle` file:

```groovy
plugins {
    id 'java'
    id 'org.springframework.boot' version '2.5.4'
    id 'io.spring.dependency-management' version '1.0.11.RELEASE'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'

java {
    sourceCompatibility = 1.8
}

repositories {
    mavenCentral()
    maven {
        name = "GitHubPackages"
        url = uri("https://maven.pkg.github.com/shreyanshtomar/my-registry")
    }
}

dependencies {
    //..other dependencies
    implementation 'com.unkey:unkey-springboot-sdk:0.0.1-SNAPSHOT'
}
```

## Unkey Root Key

When requesting resources, you will need your root key — you can create a new one in the [settings](https://app.unkey.com/settings/root-keys).

Always keep your root key safe and reset it if you suspect it has been compromised.


# @unkey/cache
Source: https://unkey.com/docs/libraries/ts/cache/overview

Cache middleware with types

<Card icon="github" title="github.com/unkeyed/unkey/tree/main/packages/cache" href="https://github.com/unkeyed/unkey/tree/main/packages/cache" />

## Motivation

Everyone needs caching, but it's often poorly implemented. Not from a technical perspective but from a usability perspective. Caching should be easy to use, typesafe, and composable.

How caching looks like in many applications:

```ts
const cache = new Some3rdPartyCache(...)

type User = { email: string };

let user = await cache.get("userId") as User | undefined | null;
if (!user){
  user = await database.get(...)
  await cache.set("userId", user, Date.now() + 60_000)
}

// use user

```

There are a few annoying things about this code:

* Manual type casting
* No support for stale-while-revalidate
* Only checks a single cache

Most people would build a small wrapper around this to make it easier to use and so did we:
This library is the result of a rewrite of our own caching layer after some developers were starting to replicate it. It's used in production by Unkey any others.

## Features

* **Typescript**: Fully typesafe
* **Tiered Cache**: Multiple caches in series to fall back on
* **Metrics**: Middleware for collecting metrics
* **Stale-While-Revalidate**: Async loading of data from your origin
* **Encryption**: Middleware for automatic encryption of cache values
* **Composable**: Mix and match primitives to build what you need

## Quickstart

<Tabs>
  <Tab title="npm">
    ```bash
     npm install @unkey/cache
    ```
  </Tab>

  <Tab title="pnpm">
    ```bash
     pnpm add @unkey/cache
    ```
  </Tab>

  <Tab title="yarn">
    ```bash
     yarn add @unkey/cache
    ```
  </Tab>

  <Tab title="bun">
    ```bash
    bun install @unkey/cache
    ```
  </Tab>
</Tabs>

<CodeGroup>
  ```ts Hello World
  import { createCache, DefaultStatefulContext, Namespace } from "@unkey/cache";
  import { MemoryStore } from "@unkey/cache/stores";

  /**
  * Define the type of your data,
  * or perhaps generate the types from your database
  */
  type User = {
    id: string;
    email: string;
  };

  /**
  * In serverless you'd get this from the request handler
  * See /docs/libraries/ts/cache/overview#context
  */
  const ctx = new DefaultStatefulContext();

  const memory = new MemoryStore({ persistentMap: new Map() });

  const cache = createCache({
    user: new Namespace<User>(ctx, {
      stores: [memory],
      fresh: 60_000, // Data is fresh for 60 seconds
      stale: 300_000, // Data is stale for 300 seconds
    })
  });

  await cache.user.set("userId", { id: "userId", email: "user@email.com" });
  const user = await cache.user.get("userId")
  console.log(user)
  ```

  ```ts Tiered Caches
  import { createCache, DefaultStatefulContext, Namespace } from "@unkey/cache";
  import { CloudflareStore, MemoryStore } from "@unkey/cache/stores";

  /**
   * In serverless you'd get this from the request handler
   * See /docs/libraries/ts/cache/overview#context
   */
  const ctx = new DefaultStatefulContext();

  /**
   * Define the type of your data, or perhaps generate the types from your database
   */
  type User = {
    id: string;
    email: string;
  };

  const memory = new MemoryStore({ persistentMap: new Map() });

  const cloudflare = new CloudflareStore({
    domain: "cache.unkey.dev",
    zoneId: env.CLOUDFLARE_ZONE_ID!,
    cloudflareApiKey: env.CLOUDFLARE_API_KEY!,
  });


  const cache = createCache({
    user: new Namespace<User>(ctx, {
      /**
       * Specifying first `memory`, then `cloudflare` will automatically check both stores
       * in order.
       * If a value is found in memory, it is returned, else it will check cloudflare,
       * and if it's found in cloudflare, the value is backfilled to memory.
       */
      stores: [memory, cloudflare],
      fresh: 60_000, // Data is fresh for 60 seconds
      stale: 300_000, // Data is stale for 300 seconds
    });
  });

  async function main() {
    await cache.user.set("userId", { id: "userId", email: "user@email.com" });

    const user = await cache.user.get("userId");

    console.info(user);
  }

  main();
  ```

  ```ts Multiple Namespaces
  import { createCache, DefaultStatefulContext, Namespace } from "@unkey/cache";
  import { CloudflareStore, MemoryStore } from "@unkey/cache/stores";

  /**
   * In serverless you'd get this from the request handler
   * See /docs/libraries/ts/cache/overview#context
   */
  const ctx = new DefaultStatefulContext();

  /**
   * Define the type of your data, or perhaps generate the types from your database
   */
  type User = {
    id: string;
    email: string;
  };

  const memory = new MemoryStore({ persistentMap: new Map() });

  const cloudflare = new CloudflareStore({
    domain: "cache.unkey.dev",
    zoneId: env.CLOUDFLARE_ZONE_ID!,
    cloudflareApiKey: env.CLOUDFLARE_API_KEY!,
  });


  type ApiKey = {
    hash: string;
    ownerId: string;
    permissions: string[];
  };

  const cache = createCache({
    user: new Namespace<User>(ctx, {
      stores: [memory, cloudflare],
      fresh: 60_000, // Data is fresh for 60 seconds
      stale: 300_000, // Data is stale for 300 seconds
    }),
    apiKey:new Namespace<ApiKey>(ctx, {
      stores: [memory],
      fresh: 10_000, // Data is fresh for 10 seconds
      stale: 60_000, // Data is stale for 60 seconds
    }),
  });

  async function main() {
    await cache.user.set("userId", { id: "userId", email: "user@email.com" });
    const user = await cache.user.get("userId");
    console.info(user);



    await cache.apiKey.set("hash", {hash:"hash", ownerId: "me", permissions: ["do_many_things"]})
  }

  main();

  ```
</CodeGroup>

```ts
import { Namespace, createCache } from "@unkey/cache";
import { MemoryStore, CloudflareStore} from "@unkey/cache/stores";

/**
* Define your data types.
* You can hopefully reuse some of these from your database models.
*/
type User = {
  email: string;
};

type Account = {
  name: string;
};

/**
* Configure the swr cache defaults.
*/
const fresh = 60_000; // fresh for 1 minute
const stale = 900_000; // stale for 15 minutes

/**
* Create your store instances
*/
const memory = new MemoryStore({
    persistentMap: new Map()
});
const cloudflare = new CloudflareStore({
  cloudflareApiKey: "<CLOUDFLARE_API_KEY>",
  zoneId: "<CLOUDFLARE_ZONE_ID>",
  domain: "<YOUR_CACHE_DOMAIN>",
})

/**
* Create your cache instance
*/
const cache = createCache({
  account: new Namespace<Account>(ctx, {
    stores: [memory],
    fresh, // use the defaults defined above or a custom value
    stale,
  }),
  user: new Namespace<User>(ctx, {
    // tiered cache, checking memory first, then cloudflare
    stores: [memory, cloudflare],
    fresh,
    stale,
  }),
});

await cache.account.set("key", { name: "x" });

const user = await cache.user.get("user_123");

// typescript error, because `email` is not a key of `Account`
await cache.account.set("key", { email: "x" });
```

## Concepts

### Namespaces

Namespaces are a way to define the type of data in your cache and apply settings to it. They are used to ensure that you don't accidentally store the wrong type of data in a cache, which otherwise can happen easily when you're changing your data structures.

Each namespace requires a type parameter and is instantiated with a set of stores and cache settings.

```ts Constructor
new Namespace<TValue>(ctx, opts)
```

<ParamField path="TValue" type="type">
  The type of data stored in this namespace, for example:

  ```ts
  type User = {
    email: string;
  };
  ```
</ParamField>

<ParamField path="ctx" type="Context">
  An execution context, such as a request or a worker instance.

  [Read more](/libraries/ts/cache/overview#context)

  ```ts
  interface Context {
    waitUntil: (p: Promise<unknown>) => void;
  }
  ```

  On Cloudflare workers or Vercel edge functions, you receive a context from the `fetch` handler.

  Otherwise you can use this:

  ```ts
  import { DefaultStatefulContext } from "@unkey/cache";
  const ctx = new DefaultStatefulContext();
  ```
</ParamField>

<ParamField path="opts" type="NamespaceOptions">
  <Expandable>
    <ParamField path="stores" required type="Store[]">
      An array of stores to use for this namespace. When providing multiple stores, the cache will be checked in order of the array until a value is found or all stores have been checked.

      You should order the stores from fastest to slowest, so that the fastest store is checked first.
    </ParamField>

    <ParamField path="fresh" requried type="number">
      The time in milliseconds that a value is considered fresh. Cache hits within this time will return the cached value.

      Must be less than `stale`.
    </ParamField>

    <ParamField path="stale" requried type="number">
      The time in milliseconds that a value is considered stale. Cache hits within this time will return the cached value and trigger a background refresh.

      Must be greater than `fresh`.
    </ParamField>
  </Expandable>
</ParamField>

```ts Example namespace with two stores
import { Namespace, DefaultStatefulContext, MemoryStore, CloudflareStore } from "@unkey/cache";

type User = {
  email: string;
}

const memory = new MemoryStore({
  persistentMap: new Map(),
});

const cloudflare = new CloudflareStore({
  cloudflareApiKey: c.env.CLOUDFLARE_API_KEY,
  zoneId: c.env.CLOUDFLARE_ZONE_ID,
  domain: "cache.unkey.dev",
})

const ctx = new DefaultStatefulContext()

const namespace = new Namespace<User>(ctx, {
  stores: [memory, cloudflare],
  fresh: 60_000,
  stale: 900_000,
});
```

### Tiered Cache

Different caches have different characteristics, some may be fast but volatile, others may be slow but persistent. By using a tiered cache, you can combine the best of both worlds.
In almost every case, you want to use a fast in-memory cache as the first tier. There is no reason not to use it, as it doesn't add any latency to your application.

The goal of this implementation is that it's invisible to the user. Everything behaves like a single cache.
You can add as many tiers as you want.

#### Reading from the cache

When using a tiered cache, all stores will be checked in order until a value is found or all stores have been checked.
If a value is found in a store, it will be backfilled to the previous stores in the list asynchronously.

```mermaid
sequenceDiagram
  autonumber
  App->>Cache: get key
  Cache->>+Tier1: get key
  Tier1->>-Cache: undefined
  Cache->>+Tier2: get key
  Tier2->>-Cache: value
  Cache->>App: value
  Cache-->>Tier1: async set key value
```

#### Writing to the cache

When setting or deleting a key, every store will be updated in parallel.

```mermaid
sequenceDiagram
  autonumber
  App->>Cache: set key value
  par
    Cache->>Tier1: set key value
    Tier1->>Cache: ack
  and
    Cache->>Tier2: set key value
    Tier2->>Cache: ack
  end
  Cache->>App: ack
```

#### Example

```ts
import { DefaultStatefulContext, Namespace, createCache } from "@unkey/cache";
import { CloudflareStore, MemoryStore } from "@unkey/cache/stores";

/**
 * In serverless you'd get this from the request handler
 * See https://unkey.com/docs/libraries/ts/cache/overview#context
 */
const ctx = new DefaultStatefulContext();

/**
 * Define the type of your data, or perhaps generate the types from your database
 */
type User = {
  id: string;
  email: string;
};

const memory = new MemoryStore({ persistentMap: new Map() });

/**
 * @see https://unkey.com/docs/libraries/ts/cache/overview#cloudflare
 */
const cloudflare = new CloudflareStore({
  domain: "cache.unkey.dev",
  zoneId: env.CLOUDFLARE_ZONE_ID!,
  cloudflareApiKey: env.CLOUDFLARE_API_KEY!,
});

const userNamespace = new Namespace<User>(ctx, {
  /**
   * Specifying first `memory`, then `cloudflare` will automatically check both stores in order
   * If a value is found in memory, it is returned, else it will check cloudflare, and if it's found
   * in cloudflare, the value is backfilled to memory.
   */
  stores: [memory, cloudflare],
  fresh: 60_000, // Data is fresh for 60 seconds
  stale: 300_000, // Data is stale for 300 seconds
});

const cache = createCache({ user: userNamespace });

async function main() {
  await cache.user.set("userId", { id: "userId", email: "user@email.com" });

  const user = await cache.user.get("userId");

  console.log(user);
}

main();
```

### Stale-While-Revalidate

To make data fetching as easy as possible, the cache offers a `swr` method, that acts as a pull through cache. If the data is fresh, it will be returned from the cache, if it's stale it will be returned from the cache and a background refresh will be triggered and if it's not in the cache, the data will be synchronously fetched from the origin.

```ts
const user = await cache.user.swr("userId", async (userId) => {
  return database.exec("SELECT * FROM users WHERE id = ?", userId)
});
```

<ParamField path="key" type="string">
  The cache key to fetch, just like when using `.get(key)`
</ParamField>

<ParamField path="loadFromOrigin" type="(key: string) => Promise<TValue | undefined>">
  A callback function that will be called to fetch the data from the origin if it's stale or not in the cache.
</ParamField>

To understand what's happening under the hood, let's look at the different scenarios. `swr` works with tiered caches, but for simplicity, these charts may only show a single store.

<Tabs>
  <Tab title="Fresh Cache Hit">
    ```mermaid
    sequenceDiagram
      autonumber
      App->>Cache: swr(key, loadFromOrigin)
      Cache->>+Tier1: get key
      Tier1->>-Cache: fresh value
      Cache->>App: value
    ```
  </Tab>

  <Tab title="Stale Cache Hit">
    ```mermaid
    sequenceDiagram
      autonumber
      App->>Cache: swr(key, loadFromOrigin)
      Cache->>+Tier1: get key
      Tier1->>-Cache: stale value
      Cache->>App: value
      alt async
        Cache->>Origin: loadFromOrigin
        Origin->>Cache: value
        Cache->>Tier1: set key value
      end
    ```
  </Tab>

  <Tab title="Cache Miss">
    ```mermaid
    sequenceDiagram
      autonumber
      App->>Cache: swr(key, loadFromOrigin)
      Cache->>+Tier1: get key
      Tier1->>-Cache: undefined
      Cache->>+Tier2: get key
      Tier2->>-Cache: undefined
      Cache->>Origin: loadFromOrigin
      Origin->>Cache: value
      Cache->>App: value
      alt async
         Cache->>Tier1: set key value
         Cache->>Tier2: set key value
      end
    ```
  </Tab>
</Tabs>

#### Example

```ts
import { DefaultStatefulContext, Namespace, createCache } from "@unkey/cache"
import { CloudflareStore, MemoryStore } from "@unkey/cache/stores";

/**
 * In serverless you'd get this from the request handler
 * See https://unkey.com/docs/libraries/ts/cache/overview#context
 */
const ctx = new DefaultStatefulContext();

/**
 * Define the type of your data, or perhaps generate the types from your database
 */
type User = {
  id: string;
  email: string;
};

const memory = new MemoryStore({ persistentMap: new Map() });

/**
 * @see https://unkey.com/docs/libraries/ts/cache/overview#cloudflare
 */
const cloudflare = new CloudflareStore({
  domain: "cache.unkey.dev",
  zoneId: env.CLOUDFLARE_ZONE_ID!,
  cloudflareApiKey: env.CLOUDFLARE_API_KEY!,
});

const userNamespace = new Namespace<User>(ctx, {
  /**
   * Specifying first `memory`, then `cloudflare` will automatically check both stores in order
   * If a value is found in memory, it is returned, else it will check cloudflare, and if it's found
   * in cloudflare, the value is backfilled to memory.
   */
  stores: [memory, cloudflare],
  fresh: 60_000, // Data is fresh for 60 seconds
  stale: 300_000, // Data is stale for 300 seconds
});

const cache = createCache({ user: userNamespace });

async function main() {
  await cache.user.set("userId", { id: "userId", email: "user@email.com" });

  const user = await cache.user.swr("userId", async (userId)=>{
    // @ts-expect-error we don't have a db in this example
    return db.getUser(userId)

  });

  console.info(user);
}

main();
```

### Context

In serverless functions it's not always trivial to run some code after you have returned a response. This is where the context comes in. It allows you to register promises that should be awaited before the function is considered done.
Fortunately many providers offer a way to do this.

In order to be used in this cache library, the context must implement the following interface:

```ts
export interface Context {
  waitUntil: (p: Promise<unknown>) => void;
}
```

For stateful applications, you can use the `DefaultStatefulContext`:

```ts
import { DefaultStatefulContext } from "@unkey/cache";
const ctx = new DefaultStatefulContext()
```

Vendor specific documentation:

* [Cloudflare Workers](https://developers.cloudflare.com/workers/runtime-apis/context/)
* [Vercel Serverless](https://vercel.com/docs/functions/functions-api-reference#waituntil)
* [Vercel Edge and Middleware](https://vercel.com/docs/functions/edge-middleware/middleware-api#waituntil)

## Primitives

### Stores

Stores are the underlying storage mechanisms for your cache. They can be in-memory, on-disk, or remote. You can use multiple stores in a namespace to create a tiered cache.
The order of stores in a namespace is important. The cache will check the stores in order until it finds a value or all stores have been checked.

<Info>
  You can create your own store by implementing the `Store` interface.
  [Read more.](/libraries/ts/cache/interface/store)
</Info>

Below are the available stores:

#### Memory

The memory store is an in-memory cache that is fast but only as persistent as your memory. In serverless environments, this means that the cache is lost when the function is cold-started.

```ts
import { MemoryStore } from "@unkey/cache/stores";

const memory = new MemoryStore({
  persistentMap: new Map(),
});
```

Ensure that the `Map` is instantiated in a persistent scope of your application. For Cloudflare workers or serverless functions in general, this is the global scope.

#### Cloudflare

The Cloudflare store uses cloudflare's [`Cache` API](https://developers.cloudflare.com/workers/runtime-apis/cache/) to store cache values. This is a remote cache that is shared across all instances of your worker but isolated per datacenter. It's still pretty fast, but needs a network request to access the cache.

```ts
import { CloudflareStore } from "@unkey/cache/stores";

const cloudflare = new CloudflareStore({
  cloudflareApiKey: "<CLOUDFLARE_API_KEY>",
  zoneId: "<CLOUDFLARE_ZONE_ID>",
  domain: "<YOUR_CACHE_DOMAIN>",
  cacheBuster: "<CACHE_STORE_VERSION>",
})
```

<ParamField path="cloudflareApiKey" type="string">
  The Cloudflare API key to use for cache purge operations.

  The api key must have the `Cache Purge` permission. You can create a new API token with this permission in the [Cloudflare dashboard](https://dash.cloudflare.com/profile/api-tokens).
</ParamField>

<ParamField path="zoneId" type="string">
  The Cloudflare zone ID where the cache is stored. You can find this in the Cloudflare dashboard.
</ParamField>

<ParamField path="domain" type="string">
  The domain to use for the cache. This must be a valid domain within the zone specified by `zoneId`.

  <Warning>
    If the domain is not valid in the specified zone, the cache will not work and cloudflare does not provide an error message. You will just get cache misses.

    For example, we use `domain: "cache.unkey.dev"` in our API.
  </Warning>
</ParamField>

<ParamField path="cacheBuster" type="string" default="v1">
  As your data changes, it is important to keep backwards compatibility in mind. If your cached values are no longer backwards compatible, it can cause problems. For example when a value changes from optional to required. In these cases you should purge the entire cache by setting a new `cacheBuster` value. The `cacheBuster` is used as part of the cache key and changes ensure you are not reading old data anymore.
</ParamField>

#### Upstash Redis

The Upstash Redis store uses the [Serverless Redis](https://upstash.com/docs/redis/overall/getstarted) offering from Upstash to store cache values. This is a serverless database with Redis compatibility.

```ts
import { UpstashRedisStore } from "@unkey/cache/stores";
import { Redis } from "@upstash/redis";

const redis = new Redis({
  url: <UPSTASH_REDIS_REST_URL>,
  token: <UPSTASH_REDIS_REST_TOKEN>,
})

const redisStore = new UpstashRedisStore({
  redis
})
```

<ParamField path="redis" type="Redis">
  The Upstash Redis client to use for cache operations.
</ParamField>

#### libSQL (Turso)

The libSQL store can use an [embedded SQLite database](https://docs.turso.tech/features/embedded-replicas/introduction), or a remote [Turso](https://turso.tech) database to store cache values.

You must create a table in your Turso database with the following schema:

```sql
CREATE TABLE IF NOT EXISTS cache (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  freshUntil INTEGER NOT NULL,
  staleUntil INTEGER NOT NULL
);
```

<CodeGroup>
  ```ts Remote Only
  import { LibSQLStore } from "@unkey/cache/stores";
  import { createClient } from "@libsql/client";

  const client = createClient({
    url: "libsql://...",
    authToken: "...",
  });

  const store = new LibSQLStore({
    client,
  });
  ```

  ```ts Embedded Replicas
  import { LibSQLStore } from "@unkey/cache/stores";
  import { createClient } from "@libsql/client";

  const client = createClient({
    url: "file:dev.db",
    syncUrl: "libsql://...",
    authToken: "...",
  });

  const store = new LibSQLStore({
    client,
  });
  ```
</CodeGroup>

<ParamField path="client" type="Client" required="true">
  The [libSQL client](https://docs.turso.tech/sdk/ts) to use for cache
  operations.
</ParamField>

<ParamField path="tableName" type="string" default="cache">
  The name of the database table name to use for cache operations.
</ParamField>

### Middlewares

#### Metrics

The metrics middleware collects metrics about cache hits, misses, and backfills. It's useful for debugging and monitoring your cache usage.

Using the metrics middleware requires a metrics sink. You can build your own sink by implementing the `Metrics` interface.
For example we are using [axiom](https://axiom.co?ref=unkey).

```ts
interface Metrics<TMetric extends Record<string, unknown> = Record<string, unknown>> {
  /**
   * Emit a new metric event
   *
   */
  emit(metric: TMetric): void;

  /**
   * flush persists all metrics to durable storage.
   * You must call this method before your application exits, metrics are not persisted automatically.
   */
  flush(): Promise<void>;
}
```

Wrap your store with the metrics middleware to start collecting metrics.

```ts
import { withMetrics } from "@unkey/cache/middleware";

const metricsSink = // your metrics sink
const metricsMiddleware = withMetrics(metricsSink);

const memory = new MemoryStore({ persistentMap: new Map() });

new Namespace<User>(ctx, {
  // Wrap the store with the metrics middleware
  stores: [metricsMiddleware.wrap(memory)],
  // ...
});
```

The following metrics are emitted:

```ts
type Metric =
  | {
      metric: "metric.cache.read";
      key: string;
      hit: boolean;
      status?: "fresh" | "stale";
      latency: number;
      tier: string;
      namespace: string;
    }
  | {
      metric: "metric.cache.write";
      key: string;
      latency: number;
      tier: string;
      namespace: string;
    }
  | {
      metric: "metric.cache.remove";
      key: string;
      latency: number;
      tier: string;
      namespace: string;
    };
```

#### Encryption

When dealing with sensitive data, you might want to encrypt your cache values at rest.
You can encrypt a store by wrapping it with the `EncryptedStore`.

All you need is a 32 byte base64 encoded key.
You can generate one with openssl:

```bash Generate a new encryption key
openssl rand -base64 32
```

```ts Example
import { withEncryption } from "@unkey/cache/middleware";

const encryptionKey = "<BASE64_KEY>"
const encryptionMiddleware = await withEncryption(encryptionKey)

const memory = new Memory({..}) // or any other store

const store = encryptionMiddleware.wrap(memory);

```

Values will be encrypted using `AES-256-GCM` and persisted in the underlying store.

<Info>
  You can rotate your encryption key at any point, but this will essentially purge the cache.

  A SHA256 hash of the encryption key is used in the cache key, to allow for rotation without causing decryption errors.
</Info>

## Contributing

If you have a store or middleware you'd like to see in this library, please open an [issue](https://github.com/unkeyed/unkey/issues/new) or a pull request.


# @unkey/hono
Source: https://unkey.com/docs/libraries/ts/hono

Hono.js middleware for authenticating API keys

> Hono - \[炎] means flame🔥 in Japanese - is a small, simple, and ultrafast web framework for the Edges. It works on any JavaScript runtime: Cloudflare Workers, Fastly Compute\@Edge, Deno, Bun, Vercel, Netlify, Lagon, AWS Lambda, Lambda\@Edge, and Node.js.

`@unkey/hono` offers a middleware for authenticating API keys with [unkey](https://unkey.com).

<Card icon="github" title="github.com/unkeyed/unkey/tree/main/packages/hono" href="https://github.com/unkeyed/unkey/tree/main/packages/hono" />

## Install

<Tabs>
  <Tab title="npm">
    ```bash
     npm install @unkey/hono
    ```
  </Tab>

  <Tab title="pnpm">
    ```bash
     pnpm add @unkey/hono
    ```
  </Tab>

  <Tab title="yarn">
    ```bash
     yarn add @unkey/hono
    ```
  </Tab>

  <Tab title="bun">
    ```bash
    bun install @unkey/hono
    ```
  </Tab>
</Tabs>

Let's dive straight in. The minimal setup looks like this. All you need is your api id. Go to [/app/api](https://app.unkey.com/apis), select your API and copy the id.

By default it tries to grab the api key from the `Authorization` header and then verifies it with unkey.
The result of the verification will be written to the context and can be access with `c.get("unkey")`.

```ts
import { Hono } from "hono"
import { type UnkeyContext, unkey } from "@unkey/hono";

const app = new Hono<{ Variables: { unkey: UnkeyContext } }>();

app.use("*", unkey({
  apiId: "<UNKEY_API_ID>"
}));


app.get("/somewhere", (c) => {
  // access the unkey response here to get metadata of the key etc
  const ... = c.get("unkey")

  return c.text("yo")
})
```

## Customizing the middleware

### Header

By default the middleware tries to grab the api key from the `Authorization` header. You can change this by passing a custom header name to the middleware.

```ts
app.use(
  "*",
  unkey({
    getKey: (c) => c.req.header("x-api-key"),
  })
);
```

If the header is missing the middleware will return a `401` error response like this

```ts
c.json({ error: "unauthorized" }, { status: 401 });
```

To customize the response in case the header is missing, just return a response from the `getKey` function.

```ts
app.use(
  "*",
  unkey({
    getKey: (c) => {
      const key = c.req.header("x-api-key");
      if (!key) {
        return c.text("missing api key", 401);
      }
      return key;
    },
  })
);
```

### Handle errors

If omited, the middleware will throw an `HTTPException` like hono [recommends](https://hono.dev/api/exception)

To handle errors globally you can pass an `onError` handler to the middleware.
The handler will be called with the context and the error.

<Expandable title="UnkeyError">
  <ResponseField name="code" type="string" required>
    The machine readable error code
  </ResponseField>

  <ResponseField name="docs" type="string" required>
    A link to the docs to read more about this error type.
  </ResponseField>

  <ResponseField name="message" type="string" required>
    A human readable message to help debugging the error.
  </ResponseField>

  <ResponseField name="requestId" type="string" required>
    A trace id useful to debug it on Unkey's side, please provide this to
    support if you need help.
  </ResponseField>
</Expandable>

```ts
app.use(
  "*",
  unkey({
    onError: (c, err) => {
      // handle error
      return c.text("unauthorized", 401);
    },
  })
);
```

### Handle invalid keys

By default the middleware will not do anything with the verification response other than writing it to the context.
However you most likely would like to just return a `401` response if the key is invalid and not continue with the request.

To do this you can pass a `handleInvalidKey` handler to the middleware.
See [here](/libraries/ts/sdk/keys/verify#response) for the full `result` object.

```ts
app.use(
  "*",
  unkey({
    handleInvalidKey: (c, result) => {
      return c.json({
          error: "unauthorized",
          reason: result.code,
        }, 401);
    },
  })
);
```

### Disable telemetry

By default, Unkey collects anonymous telemetry data to help us understand how our SDKs are used.

If you wish to disable this, you can do so by passing a boolean flag to the constructor:

```ts
app.use(
  "*",
  unkey({ disableTelemetry: true })
)
```


# @unkey/nextjs
Source: https://unkey.com/docs/libraries/ts/nextjs

Next.js SDK for Unkey

The official Next.js SDK for Unkey. Use this within your [route handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) as a simple, type-safe way to verify API keys.

<Card icon="github" title="github.com/unkeyed/unkey/tree/main/packages/nextjs" href="https://github.com/unkeyed/unkey/tree/main/packages/nextjs" />

## Install

<Tabs>
  <Tab title="npm">
    ```bash
     npm install @unkey/nextjs
    ```
  </Tab>

  <Tab title="pnpm">
    ```bash
     pnpm add @unkey/nextjs
    ```
  </Tab>

  <Tab title="yarn">
    ```bash
     yarn add @unkey/nextjs
    ```
  </Tab>

  <Tab title="bun">
    ```bash
    bun install @unkey/nextjs
    ```
  </Tab>
</Tabs>

Protecting API routes is as simple as wrapping them with the `withUnkey` handler:

```ts
import { NextRequestWithUnkeyContext, withUnkey } from '@unkey/nextjs';

export const POST = withUnkey(async (req) => {

  // Process the request here
  // You have access to the verification response using `req.unkey`
  console.log(req.unkey);

  return new Response('Your API key is valid!');
},{ apiId: process.env.UNKEY_API_ID! });
```

That's it! Since this is just handling key verification, there's no need to specify a root key as an environment variable.

If you want to customize how `withUnkey` processes incoming requests, you can do so as follows:

### `getKey`

By default, withUnkey will look for a bearer token located in the `authorization` header. If you want to customize this, you can do so by passing a getter
in the configuration object:

```ts
export const GET = withUnkey(async (req) => {
  // ...
}, {
	getKey: (req) => new URL(req.url).searchParams.get("key"),
});
```

### `onError`

You can specify custom error handling. By default errors will be logged to the console, and `withUnkey` will return a NextResponse with status 500.

```ts
export const GET = withUnkey(async (req) => {
  // ...
}, {
	onError: async (req, res) => {
      await analytics.trackEvent(`Error ${res.code}: ${res.message}`)
      return new NextResponse("Unkey error", { status: 500 })
    }
});
```

### `handleInvalidKey`

Specify what to do if Unkey reports that your key is invalid.

```ts
export const GET = withUnkey(async (req) => {
  // ...
}, {
	handleInvalidKey: (req, res) => {
      return new Response("Unauthorized", { status: 401 })
    }
});
```

### Disable telemetry

By default, Unkey collects anonymous telemetry data to help us understand how our SDKs are used.

If you wish to disable this, you can do so by passing a boolean flag to the constructor:

```ts
export const GET = withUnkey(async (req) => {
  // ...
}, { disableTelemetry: true });
```


# Delete Override
Source: https://unkey.com/docs/libraries/ts/ratelimit/override/delete-override

Deletes an override

## Request

<ParamField body="identifier" type="string" required>
  Identifier of your user, this can be their userId, an email, an ip or anything else. Wildcards ( \* ) can be used to match multiple identifiers, More info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
</ParamField>

<Warning>
  Either `namespaceId` or `namespaceName` is required. Not both.
</Warning>

<ParamField body="namespaceId" type="string">
  The id of the namespace. Either namespaceId or namespaceName must be provided
</ParamField>

<ParamField body="namespaceName" type="string">
  Namespaces group different limits together for better analytics. You might have a namespace for your public API and one for internal tRPC routes. Wildcards can also be used, more info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
</ParamField>

## Response

No response, but if no error is returned the override has been deleted successfully.

<RequestExample>
  ```ts
  await unkey.deleteOverride({
      identifier: "user_123",
      namespaceName: "email.outbound",
  })

  ```

  ```ts
  await unkey.deleteOverride({
      identifier: "user_123",
      namespaceId:"rlns_12345", 
  })
  ```
</RequestExample>


# Get Override
Source: https://unkey.com/docs/libraries/ts/ratelimit/override/get-override

Gets a ratelimit override

## Request

<ParamField body="identifier" type="string" required>
  Identifier of your user, this can be their userId, an email, an ip or anything else. Wildcards ( \* ) can be used to match multiple identifiers, More info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
</ParamField>

<Warning>
  Either `namespaceId` or `namespaceName` is required. Not both.
</Warning>

<ParamField body="namespaceId" type="string">
  The id of the namespace. Either namespaceId or namespaceName must be provided
</ParamField>

<ParamField body="namespaceName" type="string">
  Namespaces group different limits together for better analytics. You might have a namespace for your public API and one for internal tRPC routes. Wildcards can also be used, more info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
</ParamField>

## Response

<ResponseField name="result">
  <Expandable title="properties" defaultOpen>
    <ParamField body="id" type="string" required>
      Identifier of the override requested
    </ParamField>

    <ParamField body="identifier" type="string" required>
      Identifier of your user, this can be their userId, an email, an ip or anything else. Wildcards ( \* ) can be used to match multiple identifiers, More info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
    </ParamField>

    <ParamField body="limit" type="number" required>
      How many requests may pass in a given window.
    </ParamField>

    <ParamField body="duration" type="number" required>
      The window duration in milliseconds.
    </ParamField>

    <ParamField body="async" type="boolean">
      Async will return a response immediately, lowering latency at the cost of accuracy.
    </ParamField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```ts
  const override = await unkey.getOverride({
    identifier:"user.example", 
    namespaceName: "email.outbound"
  });

  ```

  ```ts
  const override = await unkey.getOverride({
    identifier:"user.example", 
    namespaceId: "rlns_1234",  
  });
  ```
</RequestExample>

<ResponseExample>
  ```ts
  {
    result: {
      id: "rlor_4567",
      identifier: "user.example",
      limit: 10,
      duration: 60000,
      async: false
    }
  }
  ```
</ResponseExample>


# List Overrides
Source: https://unkey.com/docs/libraries/ts/ratelimit/override/list-overrides

Lists all overrides

## Request

<Warning>
  Either `namespaceId` or `namespaceName` is required. Not both.
</Warning>

<ParamField body="namespaceId" type="string">
  The id of the namespace. Either namespaceId or namespaceName must be provided
</ParamField>

<ParamField body="namespaceName" type="string">
  Namespaces group different limits together for better analytics. You might have a namespace for your public API and one for internal tRPC routes. Wildcards can also be used, more info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
</ParamField>

## Response

<ResponseField name="result">
  <Expandable title="properties" defaultOpen>
    <ResponseField name="overrides" type="Array" required>
      <Expandable>
        <ParamField body="id" type="string" required>
          Identifier of the override requested
        </ParamField>

        <ParamField body="identifier" type="string" required>
          Identifier of your user, this can be their userId, an email, an ip or anything else. Wildcards ( \* ) can be used to match multiple identifiers, More info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
        </ParamField>

        <ParamField body="limit" type="number" required>
          How many requests may pass in a given window.
        </ParamField>

        <ParamField body="duration" type="number" required>
          The window duration in milliseconds.
        </ParamField>

        <ParamField body="async" type="boolean" optional>
          Async will return a response immediately, lowering latency at the cost of accuracy.
        </ParamField>
      </Expandable>
    </ResponseField>

    <ResponseField name="total" type="number" required>
      The total number of overrides
    </ResponseField>

    <ResponseField name="cursor" type="string" optional>
      The cursor to use for pagination
    </ResponseField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```ts
  const overrides = await unkey.listOverrides({ 
      namespaceName: "email.outbound"
  });
  ```

  ```ts
  const overrides = await unkey.listOverrides({  
      nameSpaceId:"rlns_12345",  
  });
  ```
</RequestExample>

<ResponseExample>
  ```ts
  {
    result: {
      overrides: [
         {
          id: 'rlor_1234',
          identifier: 'customer_123',
          limit: 10,
          duration: 50000,
          async: false
        }
      ],
      total: 1,
      cursor: 'rlor_1234'
    }
  }
  ```
</ResponseExample>


# Overview
Source: https://unkey.com/docs/libraries/ts/ratelimit/override/overview

Ratelimit overrides

Ratelimit overrides are a way to override the ratelimit for specific users or group using an identifier.

## Configure your override

```ts
import { Override } from "@unkey/ratelimit"

const unkey = new Override({
  rootKey: process.env.UNKEY_ROOT_KEY,
})
```

## Use it

```ts
async function handler(request) {

  const identifier = request.getUserId() // or ip or anything else you want

  const override = await unkey.setOverride({
      identifier: identifier,
      limit: 10,
      duration: 60000,
      namespaceName: "email.outbound",
      async: true
  })
  if (override.error){
    // handle the error here
    console.error(override.error.message);
    return;
  }
  // handle the request here
}
```

There are four main functions to interact with overrides:

* [setOverride](/libraries/ts/ratelimit/override/set-override) Sets an override for a ratelimit.
* [getOverride](/libraries/ts/ratelimit/override/get-override) Gets a ratelimit override.
* [deleteOverride](/libraries/ts/ratelimit/override/delete-override) Deletes an override.
* [listOverrides](/libraries/ts/ratelimit/override/list-overrides) Lists all overrides for a namnespace.


# Set Override
Source: https://unkey.com/docs/libraries/ts/ratelimit/override/set-override

Sets an override for a ratelimit

## Request

<ParamField body="identifier" type="string" required>
  Identifier of your user, this can be their userId, an email, an ip or anything else. Wildcards ( \* ) can be used to match multiple identifiers, More info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
</ParamField>

<ParamField body="limit" type="number" required>
  How many requests may pass in a given window.
</ParamField>

<ParamField body="duration" type="number" required>
  The window duration in milliseconds.
</ParamField>

<Warning>
  Either `namespaceId` or `namespaceName` is required. Not both.
</Warning>

<ParamField body="namespaceId" type="string">
  The id of the namespace. Either namespaceId or namespaceName must be provided
</ParamField>

<ParamField body="namespaceName" type="string">
  Namespaces group different limits together for better analytics. You might have a namespace for your public API and one for internal tRPC routes. Wildcards can also be used, more info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
</ParamField>

<ParamField body="async" type="boolean" default="false">
  Async will return a response immediately, lowering latency at the cost of accuracy.
</ParamField>

## Response

<ResponseField name="result">
  <Expandable title="properties" defaultOpen>
    <ResponseField name="overrideId" type="string" required>
      The id of the override that was set.
    </ResponseField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```ts
  const override = await unkey.setOverride({
      identifier: "user_123",
      limit: 10,
      duration: 60000,
      namespaceName: "email.outbound",
      async: true
  })
  ```

  ```ts
  const override = await unkey.setOverride({
      identifier: "user_123", 
      limit: 5, 
      duration: 50000, 
      namespaceId: "rlns_1234",
      async: false
  })
  ```
</RequestExample>

<ResponseExample>
  ```ts
  { 
    result: {
       overrideId: 'rlor_12345' 
    }
  }
  ```
</ResponseExample>


# Ratelimit
Source: https://unkey.com/docs/libraries/ts/ratelimit/ratelimit

Serverless ratelimiting

> ( Globally consistent, fast ) - choose two

`@unkey/ratelimit` is a library for fast global ratelimiting in serverless functions.

**TLDR:**

```ts
const { success } = await unkey.limit("my-user-id")
if (!success){
  // reject request
}
// handle request
```

<Card icon="github" title="github.com/unkeyed/unkey/tree/main/packages/ratelimit" href="https://github.com/unkeyed/unkey/tree/main/packages/ratelimit" />

## Install

<Tabs>
  <Tab title="npm">
    ```bash
    npm install @unkey/ratelimit
    ```
  </Tab>

  <Tab title="pnpm">
    ```bash
    pnpm add @unkey/ratelimit
    ```
  </Tab>

  <Tab title="yarn">
    ```bash
    yarn add @unkey/ratelimit
    ```
  </Tab>

  <Tab title="bun">
    ```bash
    bun install @unkey/ratelimit
    ```
  </Tab>
</Tabs>

## Configure your ratelimiter

```ts
import { Ratelimit } from "@unkey/ratelimit"

const unkey = new Ratelimit({
  rootKey: process.env.UNKEY_ROOT_KEY,
  namespace: "my-app",
  limit: 10,
  duration: "30s",
  async: true
})
```

## Use it

```ts
async function handler(request) {

const identifier = request.getUserId() // or ip or anything else you want

const ratelimit = await unkey.limit(identifier)
if (!ratelimit.success){
  return new Response("try again later", { status: 429 })
}

// handle the request here

}
```

## Making it bullet proof

Everything we do is built for scale and stability.
We built on some of the world's most stable platforms ([Planetscale](https://planetscale.com/) and [Cloudflare](https://www.cloudflare.com)) and run an extensive test suite before and after every deployment.

Even so, we would be fools if we wouldn't explain how you can put in safe guards along the way.

In case of severe network degredations or other unforseen events, you might want to put an upper bound on how long you are willing to wait for a response from unkey.
By default the SDK will reject a request if it hasn't received a response from unkey within 5 seconds. You can tune this via the `timeout` config in the constructor (see below).

The SDK captures most errors and handles them on its own, but we also encourage you to add a `onError` handler to configure what happens in case something goes wrong.

Both `fallback` property of the `timeout` config and `onError` config are callback functions. They receive the original request identifier as one of their parameters, which you can use to determine whether to reject the request.

```ts
import { Ratelimit } from "@unkey/ratelimit"

// In this example we decide to let requests pass, in case something goes wrong.
// But you can of course also reject them if you want.
const fallback = (identifier: string) => ({ success: true, limit: 0, reset: 0, remaining: 0 })

const unkey = new Ratelimit({
  // ... standard stuff
  timeout: {
    ms: 3000, // only wait 3s at most before returning the fallback
    fallback
  },
  onError: (err, identifier) => {
    console.error(`${identifier} - ${err.message}`)
    return fallback(identifier)
  }
})

const { success } = await unkey.limit(identifier)
```

***

## API

### `new Ratelimit(config: RatelimitConfig)`

Create a new instance for ratelimiting by providing the necessary configuration.

<ParamField body="RatelimitConfig" type="object" required>
  <Expandable title="RatelimitConfig">
    <ParamField body="limit" type="number" required>
      How many requests may pass in the given duration.
    </ParamField>

    <ParamField body="duration" type="Duration | number" required placeholder="60s">
      How long the window should be.

      Either a type string literal like `60s`, `20m` or plain milliseconds.
    </ParamField>

    <ParamField body="rootKey" type="string" required>
      The unkey root key. You can create one at [app.unkey.com/settings/root-keys](https://app.unkey.com/settings/root-keys)

      Make sure the root key has permissions to use ratelimiting.
    </ParamField>

    <ParamField body="namespace" type="string" required placeholder="tRPC">
      Namespaces allow you to separate different areas of your app and have isolated limits.
      Make sure the root key has permissions to use ratelimiting.
    </ParamField>

    <ParamField body="timeout" type="object | false" default={{ms: 5000,fallback: { success: false, limit: 0, remaining: 0, reset: Date.now()} }}>
      Configure a timeout to prevent network issues from blocking your function for too long.

      Disable it by setting `timeout: false`

      <Warning>
        Timeouts rely on `Date.now()`. In cloudflare workers time doesn't progress unless there is some io happening, which means the timeout might not work as expected.
        Other runtimes are working.
      </Warning>

      <Expandable defaultOpen>
        <ParamField body="ms" type="number" default={5000}>
          Time in milliseconds until the response is returned.
        </ParamField>

        <ParamField body="fallback" type="object" default={{ success: false, limit: 0, remaining: 0, reset: Date.now()} }>
          A custom response to return when the timeout is reached.

          The important bit is the `success` value, choose whether you want to let requests pass or not.
        </ParamField>
      </Expandable>
    </ParamField>

    <ParamField body="onError" type="() => RatelimitResponse | Promise<RatelimitResponse>">
      Configure what happens for unforeseen errors

      Example letting requests pass:

      ```ts
        onError: ()=> ({ success: true, limit: 0, remaining: 0, reset: 0})
      ```

      Example rejecting the request:

      ```ts
        onError: ()=> ({ success: true, limit: 0, remaining: 0, reset: 0})
      ```
    </ParamField>
  </Expandable>
</ParamField>

### `.limit(identifier: string, opts: LimitOptions): Promise<RatelimitResponse>`

Check whether a specific identifier is currently allowed to do something or if they have currently exceeded their limit.

<ParamField body="LimitOptions" type="object" required>
  <Expandable title="LimitOptions">
    <ParamField body="cost" type="number" default={1}>
      Expensive requests may use up more resources. You can specify a cost to the request and
      we'll deduct this many tokens in the current window. If there are not enough tokens left,
      the request is denied.

      **Example:**

      1. You have a limit of 10 requests per second you already used 4 of them in the current
         window.

      2. Now a new request comes in with a higher cost:

      ```ts
      const res = await rl.limit("identifier", { cost: 4 })
      ```

      3. The request passes and the current limit is now at `8`

      4. The same request happens again, but would not be rejected, because it would exceed the
         limit in the current window: `8 + 4 > 10`
    </ParamField>

    <ParamField body="async" type="boolean" default={false}>
      Do not wait for a response from the origin. Faster but less accurate.

      We observe a 97%+ accuracy when using `async` mode with significantly lower latency.
    </ParamField>

    <ParamField body="meta" type=" Record<string, string | number | boolean | null>;">
      Record arbitrary data about this request. This does not affect the limit itself but can help you debug later.
    </ParamField>

    <ParamField
      body="resources"
      type="Array<{
type: string;
id: string;
name?: string;
meta?: Record<string, string | number | boolean | null>;
}>"
    >
      Specify which resources this request would access and we'll create a papertrail for you.

      See [app.unkey.com/audit](https://app.unkey.com/audit) for details.
    </ParamField>
  </Expandable>
</ParamField>

### `RatelimitResponse`

<ParamField body="RatelimitResponse" type="object">
  <Expandable title="RatelimitResponse">
    <ParamField body="success" type="boolean" required>
      Whether the request may pass(true) or exceeded the limit(false).
    </ParamField>

    <ParamField body="limit" type="number" required>
      Maximum number of requests allowed within a window.
    </ParamField>

    <ParamField body="remaining" type="number" required>
      How many requests the user has left within the current window.
    </ParamField>

    <ParamField body="reset" type="number" required>
      Unix timestamp in milliseconds when the limits are reset.
    </ParamField>
  </Expandable>
</ParamField>


# Create
Source: https://unkey.com/docs/libraries/ts/sdk/apis/create

Create a new API

## Request

<ParamField body="name" type="string" required>
  The name of the API
</ParamField>

## Response

<ResponseField name="result">
  <Expandable title="properties" defaultOpen>
    <ResponseField name="apiId" type="string" required>
      The id of the newly created API
    </ResponseField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```ts
  await unkey.apis.create({ name: "Unkey production" });
  ```
</RequestExample>

##

<ResponseExample>
  ```ts
  {
    result: {
      apiId : "api_123"
    }
  }
  ```
</ResponseExample>


# Delete
Source: https://unkey.com/docs/libraries/ts/sdk/apis/delete

Permanently delete an API and revoke all keys associated with it.

## Request

<ParamField body="apiId" type="string" required>
  The id of the api to be deleted.
</ParamField>

## Response

No response, but if no error is returned the API has been deleted successfully.

<RequestExample>
  ```ts
  await unkey.apis.delete({ apiId: "api_123" });
  ```
</RequestExample>


# Get
Source: https://unkey.com/docs/libraries/ts/sdk/apis/get

Retrieve the configuration of an API

## Request

<ParamField body="apiId" type="string" required>
  The id of the api to retrieve.
</ParamField>

## Response

<ResponseField name="result">
  <Expandable title="properties" defaultOpen>
    <ResponseField name="id" type="string" required>
      The id of the api.
    </ResponseField>

    <ResponseField name="name" type="string" required>
      The human readable name you gave this api.
    </ResponseField>

    <ResponseField name="workspaceId" type="string" required>
      The id of the workspace in which this api is.
    </ResponseField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```ts
  const api = await unkey.apis.get({
    apiId: "api_123",
  });

  console.log(api);
  ```
</RequestExample>

<ResponseExample>
  ```ts
  {
    result: {
      id: 'api_123',
      name: 'My API',
      workspaceId: 'ws_123'
    }
  }
  ```
</ResponseExample>


# List Keys
Source: https://unkey.com/docs/libraries/ts/sdk/apis/list-keys

Get a list of keys belonging to an API

## Request

<ParamField body="apiId" type="string" required>
  The ID of the api you want to retrieve.
</ParamField>

<ParamField body="limit" type="int" default={100}>
  Limit the number of returned keys, the maximum is 100.
</ParamField>

<ParamField body="offset" type="int" default={0}>
  Specify an offset for pagination.

  *Example:*
  An offset of `4` will skip the first 4 keys and return keys starting at the 5th position.
</ParamField>

<ParamField body="ownerId" type="string">
  Filter by `ownerId`.

  If provided, this will only return keys where the `ownerId` matches.
</ParamField>

## Response

<ResponseField name="result">
  <Expandable title="properties" defaultOpen>
    <ResponseField name="keys" type="Array" required>
      <Expandable>
        <ResponseField name="id" type="string" required>
          The unique key id, use this to reference the key directly when fetching or revoking.
        </ResponseField>

        <ResponseField name="apiId" type="string" required>
          The API id where this key belongs to.
        </ResponseField>

        <ResponseField name="workspaceId" type="string" required>
          The workspace id where this key belongs to.
        </ResponseField>

        <ResponseField name="start" type="string" required>
          The first few characters of the key. This can be useful when displaying it your users, so they can match it.
        </ResponseField>

        <ResponseField name="name" type="string">
          The name you gave this key.
        </ResponseField>

        <ResponseField name="ownerId" type="string">
          Your user's Id. This will provide a link between Unkey and your customer record.

          When validating a key, we will return this back to you, so you can clearly identify your user from their api key.
        </ResponseField>

        <ResponseField name="meta" type="object">
          This is a place for dynamic meta data, anything that feels useful for you should go here

          Example:

          ```json
          {
            "billingTier": "PRO",
            "trialEnds": "2023-06-16T17:16:37.161Z"
          }
          ```
        </ResponseField>

        <ResponseField name="createdAt" type="int" required>
          When the key was created, unix timestamp in milliseconds.
        </ResponseField>

        <ResponseField name="expires" type="int">
          If set, this is when the key ceases to exist, unix timestamp in milliseconds.
          Once keys expire they will automatically be deleted and are no longer valid.
        </ResponseField>

        <ResponseField name="remaining" type="int">
          How many more times this key can be used.
        </ResponseField>

        <ResponseField name="ratelimit" type="Object">
          The ratelimit of this key, if configured.

          <Expandable title="properties">
            <ResponseField name="type" type="string" default="fast" required>
              Either `fast` or `consistent`.

              Read more [here](/apis/features/ratelimiting)
            </ResponseField>

            <ResponseField name="limit" type="int" required>
              The total amount of burstable requests.
            </ResponseField>

            <ResponseField name="refillRate" type="int" required>
              How many tokens to refill during each `refillInterval`
            </ResponseField>

            <ResponseField name="refillInterval" type="int" required>
              Determines the speed at which tokens are refilled.

              In milliseconds
            </ResponseField>
          </Expandable>
        </ResponseField>
      </Expandable>
    </ResponseField>

    {" "}

    <ResponseField name="total" type="int" required>
      How many keys in total there are in this API. Useful to paginate through this
      endpoint.
    </ResponseField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```ts
  const listKeys = await unkey.apis.listKeys({
    apiId: "api_QUGih1EMtBy9eSSf3vujmF",
    limit: 100,
  })

  console.log(listKeys)

  ```
</RequestExample>

<ResponseExample>
  ```ts
  {
    "keys": [
      {
        "id": "key_HPnfviesBEKHnZBFFiY4fg",
        "apiId": "api_QUGih1EMtBy9eSSf3vujmF",
        "workspaceId": "ws_o17fS1LvwtRswPdncAcUM",
        "start": "key_Crg",
        "createdAt": 1687642066782,
        "expires": null,
        "ratelimit": {
          "type": "fast",
          "limit": 11,
          "refillRate": 11,
          "refillInterval": 11
        }
      },
      ...
    ],
    "total": 4
  }
  ```
</ResponseExample>


# Create
Source: https://unkey.com/docs/libraries/ts/sdk/keys/create

Create an api key for your users

## Request

<ParamField body="apiId" type="string" required>
  Choose an `API` where this key should be created.
</ParamField>

<ParamField body="prefix" type="string">
  To make it easier for your users to understand which product an api key belongs to, you can add prefix them.

  For example Stripe famously prefixes their customer ids with `cus_` or their api keys with `sk_live_`.

  The underscore is automtically added if you are defining a prefix, for example: `"prefix": "abc"` will result in a key like `abc_xxxxxxxxx`
</ParamField>

<ParamField body="byteLength" type="int" default={16}>
  The bytelength used to generate your key determines its entropy as well as its length.
  Higher is better, but keys become longer and more annoying to handle.

  The default is `16 bytes`, or 2<sup>128</sup> possible combinations
</ParamField>

<ParamField body="ownerId" type="string">
  Your user's Id. This will provide a link between Unkey and your customer record.

  When validating a key, we will return this back to you, so you can clearly identify your user from their api key.
</ParamField>

<ParamField body="name" type="string">
  A way to easily identify the key by giving it a name.
</ParamField>

<ParamField body="meta" type="object">
  This is a place for dynamic meta data, anything that feels useful for you should go here

  Example:

  ```json
  {
    "billingTier": "PRO",
    "trialEnds": "2023-06-16T17:16:37.161Z"
  }
  ```
</ParamField>

<ParamField body="expires" type="int">
  You can auto expire keys by providing a unix timestamp in milliseconds.

  Once keys expire they will automatically be deleted and are no longer valid.
</ParamField>

<ParamField body="ratelimit" type="Object">
  Unkey comes with per-key ratelimiting out of the box.

  <Expandable title="properties">
    <ParamField body="async" type="boolean" default={true} required>
      Either `true` (for fast rate limiting) or `false` (for consistent rate limiting).

      Read more [here](/apis/features/ratelimiting)
    </ParamField>

    <ParamField body="duration" type="int" required>
      Rate limiting duration in milliseconds.
    </ParamField>

    <ParamField body="limit" type="int" required>
      The total amount of burstable requests.
    </ParamField>

    <ParamField body="refillRate" type="int" required>
      How many tokens to refill during each `refillInterval`
    </ParamField>

    <ParamField body="refillInterval" type="int" required>
      Determines the speed at which tokens are refilled.

      In milliseconds
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="remaining" type="number">
  Add how many times a key can be used, for example 100. Read more
  [here](/apis/features/remaining)
</ParamField>

<ParamField body="refill" type="Object">
  Unkey allows automatic refill on 'remaining' on a 'daily' or 'monthly' interval.

  <Expandable title="properties">
    <ParamField body="interval" type="string" required>
      Either `daily` or `monthly`.
    </ParamField>

    <ParamField body="amount" type="int" required>
      The amount to refill 'remaining'.

      Read more [here](/apis/features/refill)
    </ParamField>

    <ParamField body="refillDay" type="int">
      value from `1` to `31`.

      The day each month to refill 'remaining'. If no value is given, The 1st will be used as a default.

      Read more [here](/apis/features/refill)
    </ParamField>
  </Expandable>

  <ParamField body="enabled" type="boolean">
    Sets if the key is enabled or disabled.
  </ParamField>
</ParamField>

## Response

<ResponseField name="result">
  <Expandable title="properties" defaultOpen>
    <ResponseField name="key" type="string" required>
      The newly created api key
    </ResponseField>

    <ResponseField name="keyId" type="string" required>
      A unique identifier for this key. Use it later to update or revoke the key.
    </ResponseField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```ts
  const created = await unkey.keys.create({
  	apiId:"api_7oKUUscTZy22jmVf9THxDA",
  	prefix:"xyz",
  	byteLength:16,
  	ownerId:"chronark",
  	meta:{
  		hello: "world"
  	},
  	expires: 1686941966471,
  	ratelimit: {
        type: "async",
        duration: 1000,
  	  limit: 10,
  	},
  	remaining: 1000,
      refill: {
        interval: "monthly",
        amount: 100,
        refillDay: 15,
      },
    enabled: true
  })

  console.log(created)

  ```
</RequestExample>

<ResponseExample>
  ```ts
  {
    result: {
      key: "xyz_AS5HDkXXPot2MMoPHD8jnL"
      keyId: "key_YALWkHZaA4neUa1JJoXTAw"
  	}
  }
  ```
</ResponseExample>


# Delete
Source: https://unkey.com/docs/libraries/ts/sdk/keys/delete

Delete an api key for your users

## Request

<ParamField path="keyId" type="string" required>
  The ID of the key you want to revoke.
</ParamField>

## Response

No response, but if no error is returned the key has been revoked successfully.

<RequestExample>
  ```ts
  await unkey.keys.delete({ keyId: "key_123" });
  ```
</RequestExample>


# Get
Source: https://unkey.com/docs/libraries/ts/sdk/keys/get

Get the configuration for an api key

## Request

<ParamField path="keyId" type="string" required>
  The ID of the key you want to retrieve.
</ParamField>

## Response

<ResponseField name="result" type="object">
  <Expandable defaultOpen>
    <ResponseField name="id" type="string" required>
      The id of the key
    </ResponseField>

    <ResponseField name="start" type="string" required>
      The first few characters of the key to visually identify it.
    </ResponseField>

    <ResponseField name="workspaceId" type="string" required example="ws_1234">
      The id of the workspace that owns the key
    </ResponseField>

    <ResponseField name="apiId" type="string">
      The id of the api that this key is for
    </ResponseField>

    <ResponseField name="name" type="string">
      The name of the key, give keys a name to easily identify their purpose
    </ResponseField>

    <ResponseField name="ownerId" type="string" example="user_1234">
      The id of the tenant associated with this key. Use whatever reference you have in your system to identify the tenant. When verifying the key, we will send this field back to you, so you know who is accessing your API.
    </ResponseField>

    <ResponseField name="meta" type="JSON">
      Any additional metadata you want to store with the key
    </ResponseField>

    <ResponseField name="createdAt" type="integer" required>
      The unix timestamp in milliseconds when the key was created
    </ResponseField>

    <ResponseField name="deletedAt" type="integer">
      The unix timestamp in milliseconds when the key was deleted. We don't delete the key outright, you can restore it later.
    </ResponseField>

    <ResponseField name="expires" type="integer">
      The unix timestamp in milliseconds when the key will expire. If this field is null or undefined, the key is not expiring.
    </ResponseField>

    <ResponseField name="remaining" type="integer">
      The number of requests that can be made with this key before it becomes invalid. If this field is null or undefined, the key has no request limit.
    </ResponseField>

    <ResponseField name="refill" type="object">
      Unkey allows you to refill remaining verifications on a key on a regular interval.

      <Expandable>
        <ResponseField name="interval" type="enum" required>
          Determines the rate at which verifications will be refilled.

          Available options:

          * `daily`: Refills occur every day
          * `monthly`: Refills occur once a month (see `refillDay` for specific day)
        </ResponseField>

        <ResponseField name="amount" type="number" required>
          Resets `remaining` to this value every interval.
        </ResponseField>

        <ResponseField name="refillDay" type="integer" default={1}>
          value from `1` to `31`.

          The day each month to refill 'remaining'. If no value is given, The 1st will be used as a default.

          Read more [here](/apis/features/refill)
        </ResponseField>

        <ResponseField name="lastRefillAt" type="number" required>
          The unix timestamp in miliseconds when the key was last refilled.
        </ResponseField>
      </Expandable>
    </ResponseField>

    <ResponseField name="ratelimit" type="object" required>
      <Expandable>
        <ResponseField name="type" type="fast | consistent" required default="fast">
          Fast ratelimiting doesn't add latency, while consistent ratelimiting is more accurate.
        </ResponseField>

        <ResponseField name="limit" type="integer" required>
          The total amount of burstable requests.
        </ResponseField>

        <ResponseField name="refillRate" type="integer" required>
          How many tokens to refill during each refillInterval.
        </ResponseField>

        <ResponseField name="refillInterval" type="integer" required>
          Determines the speed at which tokens are refilled, in milliseconds.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```ts
  const { result, error } = await unkey.keys.get({ keyId: "key_123" });
  ```
</RequestExample>

<ResponseExample>
  ```ts Success

  const { result, error } = await unkey.keys.get({ keyId: "key_123" });

  if (error){
    // error will be undefined if the request was successful
  }


  // result
  {
    keyId: "key_123",
    apiId: "api_123",
    remaining: 1024,
    expires: 1630540800000,
  }
  ```

  ```ts Error
  const { result, error } = await unkey.keys.get({ keyId: "key_123" });

  if (error){
    console.log(error.message);
    // => "Key not found"
  }


  ```
</ResponseExample>


# Update
Source: https://unkey.com/docs/libraries/ts/sdk/keys/update

Update an api key for your users

All json fields are optional, so you can update only the fields you need.
To delete a field, set it to `null`.

## Request

<ParamField path="keyId" type="string" required>
  The ID of the key you want to update.
</ParamField>

<ParamField body="name" type="string | null">
  Update the name of the key.
</ParamField>

<ParamField body="ownerId" type="string | null">
  Update the owner id of the key.
</ParamField>

<ParamField body="meta" type="JSON | null">
  Update the metadata of a key. You will have to provide the full metadata
  object, not just the fields you want to update.
</ParamField>

<ParamField body="expires" type="int | null">
  Update the expire time of a key.

  The expire time is a unix timestamp in milliseconds.
</ParamField>

<ParamField body="ratelimit" type="Object | null">
  Unkey comes with per-key ratelimiting out of the box.

  <Expandable title="properties">
    <ParamField body="type" type="string" required>
      Either `fast` or `consistent`.

      Read more [here](/apis/features/ratelimiting)
    </ParamField>

    <ParamField body="limit" type="int" required>
      The total amount of burstable requests.
    </ParamField>

    <ParamField body="refillRate" type="int" required>
      How many tokens to refill during each `refillInterval`
    </ParamField>

    <ParamField body="refillInterval" type="int" required>
      Determines the speed at which tokens are refilled.

      In milliseconds
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="remaining" type="int | null">
  Update the remaining usage of a key.
</ParamField>

<ParamField body="refill" type="Object">
  Unkey allows automatic refill on 'remaining' on a 'daily' or 'monthly' interval.

  <Expandable title="properties">
    <ParamField body="interval" type="string" required>
      Either `daily` or `monthly`.
    </ParamField>

    <ParamField body="amount" type="int" required>
      The amount to refill 'remaining'.

      Read more [here](/apis/features/refill)
    </ParamField>

    <ParamField body="refillDay" type="int" default={1}>
      value from `1` to `31`.

      The day each month to refill 'remaining'. If no value is given, The 1st will be used as a default.

      Read more [here](/apis/features/refill)
    </ParamField>
  </Expandable>

  <ParamField body="enabled" type="boolean">
    Sets if the key is enabled or disabled.
  </ParamField>
</ParamField>

## Response

<ResponseField name="result">
  <Expandable title="properties" defaultOpen>
    <ResponseField name="key" type="string" required>
      The updated key.
    </ResponseField>

    <ResponseField name="keyId" type="string" required>
      The updated key id.
    </ResponseField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```ts
  await unkey.keys.update({
    keyId: "xyz_AS5HDkXXPot2MMoPHD8jnL",
    ownerId: "new owner",
    remaining: 300,
    refil: {
      interval: "monthly",
      amount: 100,
      refillDay: 15,
    },
    enabled: true
  });
  ```
</RequestExample>

<ResponseExample>
  ```ts
  {
    result: {
      key: "xyz_AS5HDkXXPot2MMoPHD8jnL"
      keyId: "key_YALWkHZaA4neUa1JJoXTAw"
  	}
  }
  ```
</ResponseExample>


# Update Remaining
Source: https://unkey.com/docs/libraries/ts/sdk/keys/update-remaining

Update the remaining usage of a key.

## Request

<ParamField path="keyId" type="string" required>
  The ID of the key you want to update.
</ParamField>

<ParamField body="op" type="string" required>
  Name of the operation to perform. The options are `increment`, `decrement` and `set`.
</ParamField>

<ParamField body="value" type="integer" required>
  The number to increment, decrement or set the remaining usage of a key.
</ParamField>

## Response

<ResponseField name="result">
  <Expandable title="properties" defaultOpen>
    <ResponseField name="remaining" type="integer | null" required>
      The remaining usage of the key.
    </ResponseField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```ts
  await unkey.keys.updateRemaining({
    keyId: "xyz_AS5HDkXXPot2MMoPHD8jnL",
    value: 300,
    op: "set"
  });
  ```
</RequestExample>

<ResponseExample>
  ```ts
  {
    result: {
      "remaining": 300
    }
  }
  ```
</ResponseExample>


# Verifications
Source: https://unkey.com/docs/libraries/ts/sdk/keys/verifications

Get usage information about your API keys

## Request

<Warning>
  Either `ownerId` or `keyId` is required. Not both.
</Warning>

<ParamField body="keyId" type="string" required>
  The ID of the key you want to check.
</ParamField>

<ParamField body="ownerId" type="string" required>
  The `ownerId` associated with one or more keys you want to check.
</ParamField>

<ParamField body="start" type="integer">
  The unix timestamp in milliseconds to start the query from. Defaults to 30 days ago.
</ParamField>

<ParamField body="end" type="integer">
  The unix timestamp in milliseconds to end the query at. Defaults to now.
</ParamField>

<ParamField body="granularity" type={"day"} default="day">
  The granularity of the data. Only `day` is supported at this time.
</ParamField>

## Response

<ResponseField name="result" type="object">
  <Expandable defaultOpen>
    <ResponseField name="verifications" type="Array" required>
      <Expandable defaultOpen>
        <ResponseField name="time" type="integer" required>
          The timestamp of the usage data
        </ResponseField>

        <ResponseField name="success" type="integer" required>
          The number of successful requests.
        </ResponseField>

        <ResponseField name="rateLimited" type="integer" required>
          The number of requests that were rate limited
        </ResponseField>

        <ResponseField name="usageExceeded" type="integer" required>
          The number of requests that exceeded the usage limit.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```ts
  const { result, error } = await unkey.keys.getVerifications({ keyId: "key_123" });
  ```
</RequestExample>

<ResponseExample>
  ```ts Success

  const { result, error } = await unkey.keys.getVerifications({ keyId: "key_123" });

  if (error){
    // error will be undefined if the request was successful
  }


  // result
  {
    verifications: [
      {
        time: 1620000000000,
        success: 100,
        rateLimited: 0,
        usageExceeded: 0
      },
      {
        time: 1640000000000,
        success: 142,
        rateLimited: 11,
        usageExceeded: 20
      },
      // ...
    ]

  }
  ```

  ```ts Error
  const { result, error } = await unkey.keys.getVerifications({ keyId: "key_123" });

  if (error){
    console.log(error.message);
    // => "Key not found"
  }


  ```
</ResponseExample>


# Verify
Source: https://unkey.com/docs/libraries/ts/sdk/keys/verify

Verify a key

Verify a key from your users.

## Request

<ParamField body="key" type="string" required>
  The key you want to verify.
</ParamField>

<ParamField body="apiId" type="string">
  The api this key belongs to. This will be required soon.
</ParamField>

<ParamField body="ratelimit" type="object">
  Override the behavior of the ratelimit for this verification.

  <Expandable title="properties" defaultOpen>
    <ParamField body="cost" type="number" default={1}>
      The cost of this verification. This will be subtracted from the ratelimit.
      Use this if you need to ratelimit based on what the user is trying to access. For example, you may want to ratelimit a user based on the tokens they are using in the context of LLM APIs.
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result">
  <Expandable title="properties" defaultOpen>
    <ResponseField name="keyId" type="string" required>
      The id of the key you are verifying.
    </ResponseField>

    <ResponseField name="valid" type="boolean" required>
      Whether or not this key is valid and has passed the ratelimit. If `false` you
      should not grant access to whatever the user is requesting
    </ResponseField>

    <ResponseField name="name" type="string">
      The name of the key you are verifying.
    </ResponseField>

    <ResponseField name="ownerId" type="string">
      If you have set an `ownerId` on this key it is returned here. You can use this
      to clearly authenticate a user in your system.
    </ResponseField>

    <ResponseField name="meta" type="object">
      This is the `meta` data you have set when creating the key.

      Example:

      ```json
      {
        "billingTier": "PRO",
        "trialEnds": "2023-06-16T17:16:37.161Z"
      }
      ```
    </ResponseField>

    <ResponseField name="expires" type="int">
      The unix timestamp in milliseconds indicating when this key expires.
    </ResponseField>

    <ResponseField name="ratelimit" type="object">
      The current ratelimit state.

      <Expandable title="properties">
        <ResponseField name="limit" type="int" required>
          Current limit after this verification.
        </ResponseField>

        <ResponseField name="remaining" type="int" required>
          Remaining limit inside this burst window.
        </ResponseField>

        <ResponseField name="reset" type="int" required>
          A unix timestamp in millisecond when the ratelimit gets refilled the next time.
        </ResponseField>
      </Expandable>
    </ResponseField>

    <ResponseField name="remaining" type="int">
      Shows how many more times this key may be verified before being invalidated.
      Only applies to keys where you have set a `remaining` count.
    </ResponseField>

    <ResponseField name="code" type="string">
      If the key is invalid this field will be set to the reason why it is invalid.

      Possible values are:

      * `NOT_FOUND` - The key does not exist
      * `FORBIDDEN` - You are not allowed to verify this key. For example because of additional security
        checks like `IP whitelists`
      * `USAGE_EXCEEDED` - The key has been used up and is no longer valid
      * `RATE_LIMITED` - The verification has been blocked due to ratelimiting
      * `DISABLED` - the key is disabled
    </ResponseField>

    <ResponseField name="enabled" type="bool">
      Shows if the key is enabled or disabled.
    </ResponseField>

    <ResponseField name="permissions" type="string[]">
      A list of all the permissions this key is connected to.
    </ResponseField>

    <ResponseField name="environment" type="string">
      The environment of the key, this is what what you set when you crated the key
    </ResponseField>

    <ResponseField name="identity" type="Object">
      The associated identity of this key.

      <Expandable title="properties">
        <ParamField body="identity.id" type="string" required />

        <ParamField body="identity.externalId" type="string" required />

        <ParamField body="identity.meta" type="object" required>
          A free form JSON object. You can store any data you want here. As long as its properly formatted JSON.

          <Expandable title="properties">
            <ParamField body="identity.meta.{key}" type="any | null" />
          </Expandable>
        </ParamField>
      </Expandable>
    </ResponseField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```ts
  import { verifyKey } from "@unkey/api";

  const { result, error } = await verifyKey({ key: "key_123", apiId: "api_123" });

  if (error) {
    // handle potential network or bad request error
    // a link to our docs will be in the `error.docs` field
    console.error(error.message);
    return;
  }

  if (!result.valid) {
    // do not grant access
    return;
  }

  // process request
  console.log(result);
  ```
</RequestExample>

<ResponseExample>
  ```ts
  {
    result: {
    "keyId": "key_1234",
    "valid": true,
    "name": "Customer X",
    "ownerId": "user_123",
    "meta": {
      "roles": [
        "admin",
        "user"
      ],
      "stripeCustomerId": "cus_1234"
    },
    "expires": 123,
    "ratelimit": {
      "limit": 10,
      "remaining": 9,
      "reset": 3600000
    },
    "remaining": 1000,
    "code": "VALID",
    "enabled": true,
    "permissions": [
      "dns.record.update",
      "dns.record.delete"
    ],
    "environment": "test",
    "identity": {
      "id": "<string>",
      "externalId": "<string>",
      "meta": {}
    }
  }
  }

  ```
</ResponseExample>


# Overview
Source: https://unkey.com/docs/libraries/ts/sdk/overview

Typescript client for unkey

<Warning>
  Currently the latest version on npm is `v2.0.0-alpha.x`, which was released on the main channel by accident.
  Due to npm's policy, we can not take it back down.

  v2 is coming, but it's not ready yet and lacks some api methods. Please install `@unkey/api@0.35` for now.
</Warning>

If you prefer a typed experience over calling http endpoints directly, you can use our sdk `@unkey/api`.

## Install

<Tabs>
  <Tab title="npm">
    ```bash
     npm install @unkey/api@0.35
    ```
  </Tab>

  <Tab title="pnpm">
    ```bash
     pnpm add @unkey/api@0.35
    ```
  </Tab>

  <Tab title="yarn">
    ```bash
     yarn add @unkey/api@0.35
    ```
  </Tab>

  <Tab title="bun">
    ```bash
     bun install @unkey/api@0.35
    ```
  </Tab>
</Tabs>

## Unkey Root Key

When creating, revoking or updating resources, you will need your root key — you can create a new one in the [settings](https://app.unkey.com/settings/root-keys).
Afterwards you need to provide it to the client:

```ts
import { Unkey } from "@unkey/api";

const unkey = new Unkey({ rootKey: "<UNKEY_ROOT_KEY>" });
```

Always keep your root key safe and reset it `if` you suspect it has been compromised.

## Response format

Because forgetting to handle thrown errors properly in javascript is often forgotten, we have decided to explicitly return errors to be handled. Fortunately typescript helps us here and everything is typesafe.

Every method returns either an `error` or a `result` field, never both and never none.

<CodeGroup>
  ```ts Success
  {
    result: T // the result depends on what method you called
  }
  ```

  ```ts Error
  {
    error: {
      // A machine readable error code
      code: ErrorCode;

      // A link to our documentation explaining this error in more detail
      docs: string;

      // A human readable short explanation
      message: string;

      // The request id for easy support lookup
      requestId: string;
    }
  }
  ```
</CodeGroup>

## Checking for errors

To check for errors you use the `error` property, our errors are easy to read and provide a link to our documentation for more information.

```ts
import { verifyKey } from "@unkey/api";

const { result, error } = await verifyKey("key_123");

if (error) {
  // handle potential network or bad request error
  // a link to our docs will be in the `error.docs` field
  console.error(error.message);
  return;
}

if (!result.valid) {
  // do not grant access
  return;
}

// process request
console.log(result);
```

## Options

The constructor accepts some options to customize the behavior:

### Base Url

Run all requests against your own instance of unkey hosted on your own infrastructure.

<ParamField body="baseUrl" type="string" default="https://api.unkey.dev">
  ```ts
  const unkey = new Unkey({
    //...
    baseUrl: "https://my.domain"
  })
  ```
</ParamField>

### Retries

By default the client will retry on network errors, you can customize this behavior:

<ParamField body="retry">
  <Expandable defaultOpen>
    <ParamField body="attempts" type="integer">
      How often to retry
    </ParamField>

    <ParamField body="backoff" type="(retryCount: number) => number">
      A function that returns how many milliseconds to wait until the next attempt is made.
    </ParamField>
  </Expandable>
</ParamField>

```ts
const unkey = new Unkey({
  // ...
  retry: {
    attempts: 3,
    backoff: (retryCount) => retryCount * 1000
  }
})
```

### Cache

Configure the `fetch` cache behavior.

<Warning>
  As of October 2023, the `cache` option is not yet implemented in cloudflare workers and will throw an error if used.
</Warning>

<ParamField body="cache" type="string">
  Available options are: `default`, `force-cache`, `no-cache`, `no-store`, `only-if-cached` or `reload`.
</ParamField>

```ts
const unkey = new Unkey({
  // ...
  cache: "no-cache"
})
```

### Disable telemetry

By default, Unkey collects anonymous telemetry data to help us understand which versions of our SDK is being used, and in which environment.

If you wish to disable this, you can do so by passing a boolean flag to the constructor:

```ts
const unkey = new Unkey({
  disableTelemetry: true
})
```


# Limit
Source: https://unkey.com/docs/libraries/ts/sdk/ratelimits/limit

Serverless ratelimiting

<Note>
  We have a dedicated package for ratelimiting in serverless functions. It's built with Cloudflare workers and Durable Objects to orchestrate low latency ratelimiting at the edge, without sacrificing consistency.

  Check out the documentation for the [`@unkey/ratelimit` package](/libraries/ts/ratelimit).
</Note>

## Request

<ParamField body="limit" type="number" required>
  How many requests may pass in the given duration.
</ParamField>

<ParamField body="duration" type="Duration | number" required placeholder="60s">
  How long the window should be.

  Either a type string literal like `60s`, `20m` or plain milliseconds.
</ParamField>

<ParamField body="identifier" type="string" required>
  A unique identifier for the request. This can be a user id, an IP address or a session id.
</ParamField>

<ParamField body="namespace" type="string">
  The route or resource of what is being ratelimited for example `trpc.user.update`
</ParamField>

<ParamField body="cost" type="number" default={1}>
  Expensive requests may use up more resources. You can specify a cost to the request and
  we'll deduct this many tokens in the current window. If there are not enough tokens left,
  the request is denied.

  **Example:**

  1. You have a limit of 10 requests per second you already used 4 of them in the current
     window.

  2. Now a new request comes in with a higher cost:

  ```ts
  const res = await rl.limit("identifier", { cost: 4 })
  ```

  3. The request passes and the current limit is now at `8`

  4. The same request happens again, but would not be rejected, because it would exceed the
     limit in the current window: `8 + 4 > 10`
</ParamField>

<ParamField body="async" type="boolean" default={false}>
  Do not wait for a response from the origin. Faster but less accurate.

  We observe a 97%+ accuracy when using `async` mode with significantly lower latency.
</ParamField>

<ParamField body="meta" type=" Record<string, string | number | boolean | null>;">
  Record arbitrary data about this request. This does not affect the limit itself but can help you debug later.
</ParamField>

<ParamField
  body="resources"
  type="Array<{
type: string;
id: string;
name?: string;
meta?: Record<string, string | number | boolean | null>;
}>"
>
  Specify which resources this request would access and we'll create a papertrail for you.

  See [app.unkey.com/audit](https://app.unkey.com/audit) for details.
</ParamField>

## Response

<ResponseField name="result">
  <Expandable title="properties" defaultOpen>
    <ResponseField name="success" type="boolean" required>
      Whether the request may pass(true) or exceeded the limit(false).
    </ResponseField>

    <ResponseField name="limit" type="integer" required>
      Maximum number of requests allowed within a window.
    </ResponseField>

    <ResponseField name="remaining" type="integer" required>
      How many requests the user has left within the current window.
    </ResponseField>

    <ResponseField name="reset" type="number" required>
      Unix timestamp in milliseconds when the limits are reset.
    </ResponseField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```ts
  await unkey.ratelimits.limit({
      duration: 600,
      identifier: "userId",
      limit: 2000,
      namespace: "test"
    })
  ```
</RequestExample>

<ResponseExample>
  ```ts
  {
    result: {
      "success": true,
      "limit": 2000,
      "reset": 1630000000000,
      "remaining": 300
    }
  }
  ```
</ResponseExample>


# Delete Override
Source: https://unkey.com/docs/libraries/ts/sdk/ratelimits/overrides/delete-override

Deletes an override

## Request

<ParamField body="identifier" type="string" required>
  Identifier of your user, this can be their userId, an email, an ip or anything else. Wildcards ( \* ) can be used to match multiple identifiers, More info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
</ParamField>

<Warning>
  Either `namespaceId` or `namespaceName` is required. Not both.
</Warning>

<ParamField body="namespaceId" type="string">
  The id of the namespace. Either namespaceId or namespaceName must be provided
</ParamField>

<ParamField body="namespaceName" type="string">
  Namespaces group different limits together for better analytics. You might have a namespace for your public API and one for internal tRPC routes. Wildcards can also be used, more info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
</ParamField>

## Response

No response, but if no error is returned the override has been deleted successfully.

<RequestExample>
  ```ts
  await unkey.ratelimits.deleteOverride({
      identifier: "user_123",
      namespaceName: "email.outbound",
  })
  ```

  ```ts
  await unkey.ratelimits.deleteOverride({
      identifier: "user_123",
      namespaceId: "rlns_1234",
  })
  ```
</RequestExample>


# Get Override
Source: https://unkey.com/docs/libraries/ts/sdk/ratelimits/overrides/get-override

Gets a ratelimit override

## Request

<ParamField body="identifier" type="string" required>
  Identifier of your user, this can be their userId, an email, an ip or anything else. Wildcards ( \* ) can be used to match multiple identifiers, More info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
</ParamField>

<Warning>
  Either `namespaceId` or `namespaceName` is required. Not both.
</Warning>

<ParamField body="namespaceId" type="string">
  The id of the namespace. Either namespaceId or namespaceName must be provided
</ParamField>

<ParamField body="namespaceName" type="string">
  Namespaces group different limits together for better analytics. You might have a namespace for your public API and one for internal tRPC routes. Wildcards can also be used, more info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
</ParamField>

## Response

<ResponseField name="result">
  <Expandable title="properties" defaultOpen>
    <ParamField body="id" type="string" required>
      Identifier of the override requested
    </ParamField>

    <ParamField body="identifier" type="string" required>
      Identifier of your user, this can be their userId, an email, an ip or anything else. Wildcards ( \* ) can be used to match multiple identifiers, More info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
    </ParamField>

    <ParamField body="limit" type="number" required>
      How many requests may pass in a given window.
    </ParamField>

    <ParamField body="duration" type="number" required>
      The window duration in milliseconds.
    </ParamField>

    <ParamField body="async" type="boolean">
      Async will return a response immediately, lowering latency at the cost of accuracy.
    </ParamField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```ts
  const override = await unkey.ratelimits.getOverride({
    identifier:"user.example",
    nameSpaceId:"rlns_12345",
  });
  ```

  ```ts
  const override = await unkey.ratelimits.getOverride({
    identifier:"user.example",
    namespaceName: "email.outbound"
  });
  ```
</RequestExample>

<ResponseExample>
  ```ts
  {
    result: {
      id: "rlor_4567",
      identifier: "user.example",
      limit: 10,
      duration: 60000,
      async: false
    }
  }
  ```
</ResponseExample>


# List Overrides
Source: https://unkey.com/docs/libraries/ts/sdk/ratelimits/overrides/list-overrides

Lists all overrides

## Request

<Warning>
  Either `namespaceId` or `namespaceName` is required. Not both.
</Warning>

<ParamField body="namespaceId" type="string">
  The id of the namespace. Either namespaceId or namespaceName must be provided
</ParamField>

<ParamField body="namespaceName" type="string">
  Namespaces group different limits together for better analytics. You might have a namespace for your public API and one for internal tRPC routes. Wildcards can also be used, more info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
</ParamField>

## Response

<ResponseField name="result">
  <Expandable title="properties" defaultOpen>
    <ResponseField name="overrides" type="Array" required>
      <Expandable>
        <ParamField body="id" type="string" required>
          Identifier of the override requested
        </ParamField>

        <ParamField body="identifier" type="string" required>
          Identifier of your user, this can be their userId, an email, an ip or anything else. Wildcards ( \* ) can be used to match multiple identifiers, More info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
        </ParamField>

        <ParamField body="limit" type="number" required>
          How many requests may pass in a given window.
        </ParamField>

        <ParamField body="duration" type="number" required>
          The window duration in milliseconds.
        </ParamField>

        <ParamField body="async" type="boolean">
          Async will return a response immediately, lowering latency at the cost of accuracy.
        </ParamField>
      </Expandable>
    </ResponseField>

    <ResponseField name="total" type="number" required>
      The total number of overrides
    </ResponseField>

    <ResponseField name="cursor" type="string">
      The cursor to use for pagination
    </ResponseField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```ts
  const overrides = await unkey.ratelimits.listOverrides({
      nameSpaceId:"rlns_12345",
  });
  ```

  ```ts
  const overrides = await unkey.ratelimits.listOverrides({
      namespaceName: "email.outbound"
  });
  ```
</RequestExample>

<ResponseExample>
  ```ts
  {
    result: {
      overrides: [
         {
          id: 'rlor_1234',
          identifier: 'customer_123',
          limit: 10,
          duration: 50000,
          async: false
        }
      ],
      total: 1,
      cursor: 'rlor_1234'
    }
  }
  ```
</ResponseExample>


# Set Override
Source: https://unkey.com/docs/libraries/ts/sdk/ratelimits/overrides/set-override

Sets an override for a ratelimit

## Request

<ParamField body="identifier" type="string" required>
  Identifier of your user, this can be their userId, an email, an ip or anything else. Wildcards ( \* ) can be used to match multiple identifiers, More info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
</ParamField>

<ParamField body="limit" type="number" required>
  How many requests may pass in a given window.
</ParamField>

<ParamField body="duration" type="number" required>
  The window duration in milliseconds.
</ParamField>

<Warning>
  Either `namespaceId` or `namespaceName` is required. Not both.
</Warning>

<ParamField body="namespaceId" type="string">
  The id of the namespace. Either namespaceId or namespaceName must be provided
</ParamField>

<ParamField body="namespaceName" type="string">
  Namespaces group different limits together for better analytics. You might have a namespace for your public API and one for internal tRPC routes. Wildcards can also be used, more info can be found at [https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules](https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules)
</ParamField>

<ParamField body="async" type="boolean" default="false">
  Async will return a response immediately, lowering latency at the cost of accuracy.
</ParamField>

## Response

<ResponseField name="result">
  <Expandable title="properties" defaultOpen>
    <ResponseField name="overrideId" type="string" required>
      The id of the override that was set.
    </ResponseField>
  </Expandable>
</ResponseField>

<RequestExample>
  ```ts
  const override = await unkey.ratelimits.setOverride({
      identifier: "user_123",
      limit: 10,
      duration: 60000,
      namespaceId: "rlns_1234",
      async: true
  })
  ```

  ```ts
  const override = await unkey.ratelimits.setOverride({
      identifier: "user_123",
      limit: 10,
      duration: 60000,
      namespaceName: "email.outbound",
      async: true
  })
  ```
</RequestExample>

<ResponseExample>
  ```ts
  {
    result: {
       overrideId: 'rlor_12345'
    }
  }
  ```
</ResponseExample>


# Overview
Source: https://unkey.com/docs/migrations/introduction

Migrate your API to Unkey

Wherever you are coming from, we make it easy to migrate your existing API to Unkey.

The challenge with migrating an existing API is that you need to move all of the existing keys and permissions to Unkey. This can be a daunting task, especially if you have a lot of keys.

Common migrations can be done entirely via self-serve APIs, while more complex migrations may require some manual intervention. We are here to help you with your migration.

<Note>
  Every system is slightly different, please contact us at [support@unkey.dev](mailto:support@unkey.dev) for help with migrating your keys.
</Note>


# Migrate keys to Unkey
Source: https://unkey.com/docs/migrations/keys



## Prerequisites

* Created your [Unkey account](https://app.unkey.com/auth/sign-up)
* Created an API in the [Unkey dashboard](https://app.unkey.com/apis)
* Create a [root key](https://app.unkey.com/settings/root-keys) with the `api.*.create_key` permission

<Info>
  If you plan to encrypt your keys, please contact us at [support@unkey.dev](mailto:support@unkey.dev) to flag you in.

  The root key used for migrating must have the `api.*.encrypt_key` permission to encrypt keys.
</Info>

Extracting keys from your current system is likely the hardest part. It depends on how your keys are stored and how you can access them.
Some providers have APIs to list all keys, while others require you to manually export them, some can provide the real key, and some only provide a hashed version.

Regardless of how you get your keys, you will need to provide either the plaintext key or the hash, as well as other settings to Unkey via the [migrations.createKeys](/api-reference/migrations/create-keys) endpoint.

## Nodejs Example

<CodeGroup>
  ```js Hash

  const { createHash } = require("node:crypto")

  function hash(key) {
    return {
      value: createHash("sha256").update(key).digest("base64"),
      variant: "sha256_base64",
    }
  }

  const keys = [
    {
      hash: hash("my-secret-key"),
      ownerId: "hello",
      apiId: "<UNKEY_API_ID>", // the id of the API you created
      //... other settings
    },
    {
      hash: hash("my-other-secret-key"),
      name: "name",
      apiId: "<UNKEY_API_ID>", // the id of the API you created
      //... other settings
    },
  ]

  fetch("https://api.unkey.dev/v1/migrations.createKeys", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer <UNKEY_ROOT_KEY>",
    },
    body: JSON.stringify(keys)
  })
  .then(res=>res.json())
  .then(res=>{console.log(res)})

  ```

  ```js Plaintext


  const keys = [
    {
      plaintext: "my_plaintext_key",
      ownerId: "hello",
      apiId: "<UNKEY_API_ID>", // the id of the API you created
      //... other settings
    },
    {
      plaintext: "my_other_plaintext_key",
      name: "name",
      apiId: "<UNKEY_API_ID>", // the id of the API you created
      //... other settings
    },
  ]

  fetch("https://api.unkey.dev/v1/migrations.createKeys", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer <UNKEY_ROOT_KEY>", // requires `api.*.encrypt_key` permissions
    },
    body: JSON.stringify(keys)
  })
  .then(res=>res.json())
  .then(res=>{console.log(res)})

  ```
</CodeGroup>


# Bun
Source: https://unkey.com/docs/quickstart/apis/bun

Authentication for Bun's http server

## Prerequisites

* Created your [Unkey account](https://app.unkey.com/auth/sign-up)
* Created an API in the [Unkey dashboard](https://app.unkey.com/apis)

<Card title="Skip the tutorial" icon="link" href="https://github.com/unkeyed/examples/tree/main/bun-server">
  Don't want to read the tutorial? Click this to get an example ready to test.
</Card>

## Creating a bun server protected by Unkey

<Steps titleSize="h3">
  <Step title="Create a new Bun project">
    First we need a bun project, so create a new directory and init bun.

    ```bash
    mkdir unkey-with-bun
    cd unkey-with-bun
    bun init -y
    ```
  </Step>

  <Step title="Install">
    Now install the `@unkey/api` package

    ```bash
    bun install @unkey/api@0.35
    ```
  </Step>

  <Step title="Modify the server">
    Open up the file called `index.ts` and add the following code

    ```ts index.ts
    import { verifyKey } from "@unkey/api";

    const server = Bun.serve({
      async fetch(req) {
        const key = req.headers.get("Authorization")?.replace("Bearer ", "");
        if (!key) {
          return new Response("Unauthorized", { status: 401 });
        }

        const { result, error } = await verifyKey(key);
        if (error) {
          // This may happen on network errors
          // We already retry the request 5 times, but if it still fails, we return an error
          console.error(error);
          return Response.json("Internal Server Error", { status: 500 });
        }

        if (!result.valid) {
          return new Response("Unauthorized", { status: 401 });
        }

        return Response.json(result);
      },
      port: 8000,
    });
    console.log(`Listening on ${server.url}`);
    ```
  </Step>

  <Step title="Running the server">
    ```bash
    bun run index.ts
    ```
  </Step>

  <Step title="Try it out">
    Go to `https://app.unkey.com` and create a new key. Then verify it with our new server:

    ```bash
    curl http://localhost:8000 -H "Authorization: Bearer <KEY>"
    ```

    It should return `{"keyId":"key_id","valid":true,"meta":{},"enabled":true,"permissions":[],"code":"VALID"}` and potentially more information about the key, depending on what you set up in the dashboard.
  </Step>
</Steps>

## What is next?

Now that you've seen the power of Unkey, check out some resources below to continue your journey.

<CardGroup cols={3}>
  <Card title="Discord" icon="discord" href="https://unkey.com/discord">Join our Discord to chat with us and the community</Card>

  <Card title="Unkey API Reference" icon="database" href="/api-reference">
    Learn about our API that helps you manage APIs, keys, ratelimits and analytical data.
  </Card>

  <Card title="SDKs" icon="brackets-curly" href="/libraries">
    Check out our SDKs and how they fit into your Bun application.
  </Card>
</CardGroup>


# Express
Source: https://unkey.com/docs/quickstart/apis/express

Authentication for your Express server

## Prerequisites

* Created your [Unkey account](https://app.unkey.com/auth/sign-up)
* Created an API in the [Unkey dashboard](https://app.unkey.com/apis)

<Card title="Skip the tutorial" icon="link" href="https://github.com/unkeyed/examples/tree/main/express">
  Don't want to read the tutorial? Click this to get an example ready to test.
</Card>

## Creating an express server

<Steps titleSize="h3">
  <Step title="Create express application">
    First run the following:

    ```bash
    mkdir unkey-with-express
    npm init -y
    npm install cors dotenv express ts-node
    npm install -D @types/cors @types/express ts-node-dev typescript
    ```

    Then update your package.json to have the following

    ```json
    "scripts": {
        "start": "ts-node ./index.ts",
        "build": "tsc",
        "serve": "node dist/index.js"
      },
    ```
  </Step>

  <Step title="Install">
    Now install the `@unkey/api` package

    ```bash
    npm install @unkey/api@0.35
    ```
  </Step>

  <Step title="Creating the server">
    Create a file called `server.ts` and add the following code

    ```ts server.ts
    import express, { Request, Response, Application } from 'express';
    import dotenv from 'dotenv';
    import { verifyKey } from '@unkey/api';
    //For env File
    dotenv.config();

    const app: Application = express();
    const port = process.env.PORT || 8000;
    const apiId = process.env.UNKEY_API_ID // copy this from the dashboard

    app.get('/', (req: Request, res: Response) => {
      res.send('Welcome to Express & TypeScript Server');
    });

    // This endpoint is protected by Unkey
    app.get('/secret', async (req: Request, res: Response) => {
      const authHeader = req.headers["authorization"]
      const key = authHeader?.toString().replace("Bearer ", "");
      if (!key) {
        return res.status(401).send("Unauthorized")
      }

      const { result, error } = await verifyKey({ key, apiId });
      if (error) {
        // This may happen on network errors
        // We already retry the request 5 times, but if it still fails, we return an error
        console.error(error);
        res.status(500);
        return res.status(500).send("Internal Server Error")
      }

      if (!result.valid) {
        res.status(401);
        return res.status(401).send("Unauthorized")
      }

      return res.status(200).send(JSON.stringify(result));
    })
    app.listen(port, () => {
      console.log(`Server is listening at http://localhost:${port}`);
    });
    ```
  </Step>

  <Step title="Running the server">
    ```bash
    npm run start
    ```
  </Step>

  <Step title="Try it out">
    Go to [https://app.unkey.com](https://app.unkey.com) and create a new key. Then verify it with our new server:

    ```bash
    curl 'http://localhost:8000/secret' \
      -H 'Authorization:Bearer <YOUR_KEY>'
    ```

    It should return `{"keyId":"key_id","valid":true,"meta":{},"enabled":true,"permissions":[],"code":"VALID"}` and potentially more information about the key, depending on what you set up in the dashboard.
  </Step>
</Steps>

## What is next?

Now that you've seen the power of Unkey, check out some resources below to continue your journey.

<CardGroup cols={3}>
  <Card title="Discord" icon="discord" href="https://unkey.com/discord">Join our Discord to chat with us and the community</Card>

  <Card title="Unkey API Reference" icon="database" href="/api-reference">
    Learn about our API that helps you manage APIs, keys, ratelimits and analytical data.
  </Card>

  <Card title="SDKs" icon="brackets-curly" href="/libraries">
    Check out our SDKs and how they fit into your Express application.
  </Card>
</CardGroup>


# Hono
Source: https://unkey.com/docs/quickstart/apis/hono

API Authentication in Hono

## Prerequisites

* Created your [Unkey account](https://app.unkey.com/auth/sign-up)
* Created an API in the [Unkey dashboard](https://app.unkey.com/apis)

<Card title="Skip the tutorial" icon="link" href="https://github.com/unkeyed/examples/tree/main/hono">
  Don't want to read the tutorial? Click this to get an example ready to test.
</Card>

<Steps titleSize="h3">
  <Step title="Create Hono Application">
    Run the following command to create your Hono project

    <Tabs>
      <Tab title="npm">
        ```bash
        npm create hono@latest
        ```
      </Tab>

      <Tab title="pnpm">
        ```bash
        pnpm create hono@latest
        ```
      </Tab>

      <Tab title="yarn">
        ```bash
        yarn create hono@latest
        ```
      </Tab>

      <Tab title="bun">
        ```bash
          bun create hono@latest
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Install">
    Now install the `@unkey/hono` package

    <Tabs>
      <Tab title="npm">
        ```bash
          npm install @unkey/hono
        ```
      </Tab>

      <Tab title="pnpm">
        ```bash
          pnpm add @unkey/hono
        ```
      </Tab>

      <Tab title="yarn">
        ```bash
          yarn add @unkey/hono
        ```
      </Tab>

      <Tab title="bun">
        ```bash
          bun install @unkey/hono
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Update index to use our Hono SDK">
    Create a new route and add the following code

    ```ts /src/index.ts
    import { Hono } from "hono";
    import { unkey, UnkeyContext } from "@unkey/hono";

    const app = new Hono<{ Variables: { unkey: UnkeyContext } }>();

    app.use("*", unkey());

    app.get("/", (c) => {
    	return c.text("Hello Hono!");
    });

    export default app;
    ```
  </Step>

  <Step title="Running it">
    <Tabs>
      <Tab title="bun">
        ```bash
          bun run dev
        ```
      </Tab>

      <Tab title="pnpm">
        ```bash
          pnpm run dev
        ```
      </Tab>

      <Tab title="yarn">
        ```bash
          yarn run dev
        ```
      </Tab>

      <Tab title="npm">
        ```bash
          npm run dev
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Try it out">
    Go to [https://app.unkey.com](https://app.unkey.com) and create a new key. Then verify it with our new server:

    ```bash
    curl -XPOST 'http://localhost:8787/' \
      -H "Authorization: Bearer <KEY>"
    ```

    It should return `Hello Hono!"`
  </Step>
</Steps>

## What is next?

Now that you've seen the power of Unkey, check out some resources below to continue your journey.

<CardGroup cols={3}>
  <Card title="Discord" icon="discord" href="https://unkey.com/discord">Join our Discord to chat with us and the community</Card>

  <Card title="Unkey API Reference" icon="database" href="/api-reference">
    Learn about our API that helps you manage APIs, keys, ratelimits and analytical data.
  </Card>

  <Card title="Hono SDK" icon="brackets-curly" href="/libraries/ts/hono">
    Check out our Hono SDK and how they fit into your API.
  </Card>
</CardGroup>


# Next.js
Source: https://unkey.com/docs/quickstart/apis/nextjs

API Authentication in Next.js

## Prerequisites

* Created your [Unkey account](https://app.unkey.com/auth/sign-up)
* Created an API in the [Unkey dashboard](https://app.unkey.com/apis)

<Card title="Skip the tutorial">
  We also have a [Next.js example](https://github.com/unkeyed/examples/tree/main/nextjs) ready to deploy on Vercel.

  [![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Funkeyed%2Funkey%2Ftree%2Fmain%2Fexamples%2Fnextjs\&project-name=unkey-with-nextjs\&repository-name=unkey-with-nextjs\&integration-ids=oac_D84Ib6K2pS6CDQXxQbzsYxsh)
</Card>

<Steps titleSize="h3">
  <Step title="Create Next.js Application">
    Run the following command to init your Next.js project

    <Tabs>
      <Tab title="npm">
        ```bash
          npx create-next-app@latest
        ```
      </Tab>

      <Tab title="pnpm">
        ```bash
        pnpm create next-app@latest
        ```
      </Tab>

      <Tab title="yarn">
        ```bash
          yarn create-next-app@latest
        ```
      </Tab>

      <Tab title="bun">
        ```bash
          bunx create-next-app
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Install">
    Now install the `@unkey/nextjs` package

    <Tabs>
      <Tab title="npm">
        ```bash
          npm install @unkey/nextjs
        ```
      </Tab>

      <Tab title="pnpm">
        ```bash
          pnpm add @unkey/nextjs
        ```
      </Tab>

      <Tab title="yarn">
        ```bash
          yarn add @unkey/nextjs
        ```
      </Tab>

      <Tab title="bun">
        ```bash
          bun install @unkey/nextjs
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Creating a protected route">
    Create a new route and add the following code

    ```ts /app/protected/route.ts
    import { NextRequestWithUnkeyContext, withUnkey } from '@unkey/nextjs';
    import { NextResponse } from 'next/server';

    export const POST = withUnkey(async (req) => {
      if (!req.unkey.valid) {
        return new NextResponse('unauthorized', { status: 403 });
      }

      // Process the request here
      // You have access to the verification response using `req.unkey`
      console.log(req.unkey);
      return new NextResponse('Your API key is valid!');
    });
    ```
  </Step>

  <Step title="Running it">
    <Tabs>
      <Tab title="bun">
        ```bash
          bun run dev
        ```
      </Tab>

      <Tab title="pnpm">
        ```bash
          pnpm run dev
        ```
      </Tab>

      <Tab title="yarn">
        ```bash
          yarn run dev
        ```
      </Tab>

      <Tab title="npm">
        ```bash
          npm run dev
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Try it out">
    Go to [https://app.unkey.com](https://app.unkey.com) and create a new key. Then verify it with our new server:

    ```bash
    curl -XPOST 'http://localhost:3000/protected' \
      -H "Authorization: Bearer <KEY>"
    ```

    It should return `"Your API key is valid!"` and log out `{"keyId":"key_id","valid":true,"meta":{},"enabled":true,"permissions":[],"code":"VALID"}` and potentially more information about the key, depending on what you set up in the dashboard.
  </Step>
</Steps>

## What is next?

Now that you've seen the power of Unkey, check out some resources below to continue your journey.

<CardGroup cols={3}>
  <Card title="Discord" icon="discord" href="https://unkey.com/discord">Join our Discord to chat with us and the community</Card>

  <Card title="Unkey API Reference" icon="database" href="/api-reference">
    Learn about our API that helps you manage APIs, keys, ratelimits and analytical data.
  </Card>

  <Card title="Next.js SDK" icon="brackets-curly" href="/libraries/ts/nextjs">
    Check out our Next.js SDK and how they fit into your Next application.
  </Card>
</CardGroup>


# Quickstart
Source: https://unkey.com/docs/quickstart/identities/shared-ratelimits

Create your first identity and key with Unkey

This quickstart will guide you through creating your first identity with shared ratelimits and a key that is connected to the identity.

The example is written in TypeScript, purposefully using the `fetch` API to make requests as transparent as possible. You can use any language or library to make requests to the Unkey API.

### Requirements

You will need your api id and root key to make requests to the Unkey API. You can find these in the Unkey dashboard.

```ts
const apiId = "api_XXX";
const rootKey = "unkey_XXX";
```

The root key requires the following permissions:

```ts
"identity.*.create_identity"
"identity.*.read_identity"
"identity.*.update_identity"
"api.*.create_key"
```

### Create an Identity

To create an identity, you need to make a request to the `/v1/identities.createIdentity` endpoint. You can specify an `externalId` and `meta` object to store additional information about the identity.

Unkey does not care what the `externalId` is, but it must be unique for each identity. Commonly used are user or organization ids. The `meta` object can be used to store any additional information you want to associate with the identity.

```ts
const externalId = "user_1234abc";

const createIdentityResponse = await fetch("https://api.unkey.dev/v1/identities.createIdentity", {
    method: "POST",
    headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${rootKey}`,
    },
    body: JSON.stringify({
        externalId,
        meta: {
        stripeCustomerId: "cus_123",
        },
    }),
});

const { identityId } = await createIdentityResponse.json<{
    identityId: string;
}>();
```

### Retrieve an Identity

Let's retrieve the identity to make sure it got created successfully

```ts
const getIdentityResponse = await fetch(`https://api.unkey.dev/v1/identities.getIdentity?identityId=${identityId}`, {
    method: "GET",
    headers: {
        Authorization: `Bearer ${rootKey}`,
    }
});

const identity = await getIdentityResponse.json<{
    id: string;
    externalId: string;
    meta: unknown;
    ratelimits: Array<{ name: string; limit: number; duration: number }>;
}>();
```

### Create a Key

Let's create a key and connect it to the identity

```ts
const createKeyResponse = await fetch(`https://api.unkey.dev/v1/keys.createKey`, {
    method: "POST",
    headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${rootKey}`,
    },
    body: JSON.stringify({
        apiId: apiId,
        prefix: "acme",
        // by providing the same externalId as the identity, we connect the key to the identity
        externalId: externalId, 
    }),
});

const key = await createKeyResponse.json<{
    keyId: string;
    key: string;
}>();
```

### Verify the Key

When you verify the key, you will receive the identity that the key is connected to and can act accordingly in your API handler.

```ts
const verifyKeyResponse = await fetch(`https://api.unkey.dev/v1/keys.verifyKey`, {
    method: "POST",
    headers: {
    "Content-Type": "application/json",
    },
    body: JSON.stringify({
        apiId: apiId,
        key: key.key,
    }),
});

const verified = await verifyKeyResponse.json<{
    valid: boolean;
    identity: {
        id: string;
        externalId: string;
        meta: unknown;
    };
}>();
```

### Ratelimits

Ratelimits can be set on the identity level. Ratelimits set on the identity level are shared across all keys connected to the identity.

```ts

const updateRes = await fetch("https://api.unkey.dev/v1/identities.updateIdentity", {
    method: "POST",
    headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${rootKey}`,
    },
    body: JSON.stringify({
        identityId: identity.id,
        ratelimits: [
        /**
         * We define a limit that allows 10 requests per day
         */
        {
            name: "requests",
            limit: 10,
            duration: 24 * 60 * 60 * 1000, // 24h
        },
        /**
         * And a second limit that allows 1000 tokens per minute
         */
        {
            name: "tokens",
            limit: 1000,
            duration: 60 * 1000, // 1 minute
        },
        ],
    }),
});
```

### Verify the Key with Ratelimits

Now let's verify the key again and specify the limits

In this case, we pretend like a user is requesting to use 200 tokens. We specify the `requests` ratelimit to enforce a limit of 10 requests per day and the `tokens` ratelimit to enforce a limit of 1000 tokens per minute. Additionally we specify the cost of the tokens to be 200.

```ts
const verifiedWithRatelimitsResponse = await fetch(`https://api.unkey.dev/v1/keys.verifyKey`, {
    method: "POST",
    headers: {
        "Content-Type": "application/json",
    },
    body: JSON.stringify({
        apiId: apiId,
        key: key.key,
        ratelimits: [
            {
                name: "requests",
            },
            {
                name: "tokens",
                cost: 200,
            },
        ],
    }),
});

const verifiedWithRatelimits = await verifiedWithRatelimitsResponse.json<{
    valid: boolean;
    identity: {
        id: string;
        externalId: string;
        meta: unknown;
    };
}>();
  
```

That's it, you have successfully created an identity and key with shared ratelimits. You can now use the key to verify requests and enforce ratelimits in your API handler.


# Public API Protection
Source: https://unkey.com/docs/quickstart/onboarding/onboarding-api

Get started with API keys

## 1. Create your Unkey account

The first step to using Unkey is to create an account. You can do this by visiting [app.unkey.com](https://app.unkey.com) or by clicking the Dashboard button in the top right of your screen.

<Frame caption="Create your account">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/images/sign-up.png" alt="Sign Up Page for Unkey" />
</Frame>

## 2. Choose how you want to use Unkey

As soon as you create your account you will be asked to choose how you want to use Unkey. Your options are:

* **API Keys**: This is used for protecting your public API.
* **Ratelimiting**: This is global low latency ratelimiting for your application.

> You can of course use both, but for now we'll just choose API Keys.

<Frame caption="Choose how to use Unkey">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/images/choose-unkey.png" alt="Choose Unkey usage" />
</Frame>

## 3. Create your first API

Next we will get you to create your first API. This is the API that you will be protecting with Unkey. You can create as many APIs as you like, but for now we'll just create one.

<Frame caption="Create your API">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/images/create-first-api.png" alt="Create your API" />
</Frame>

## 4. Follow the Unkey tutorial

Next we will show you the basics of how to use Unkey. You can skip this step if you like, but we recommend you follow along.

<Frame caption="Follow the Unkey tutorial">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/images/create-root-key.png" alt="Unkey tutorial" />
</Frame>

## 5. Next Steps

You should get to know our [API reference](/api-reference/authentication), as you can add additonal fields to your request when issuing a key.

You can also check out the [Features](/apis/features/ratelimiting) section for more information on how to use Unkey.


# Ratelimiting
Source: https://unkey.com/docs/quickstart/onboarding/onboarding-ratelimiting

Get started with standalone ratelimiting

## 1. Create your Unkey account

The first step to using Unkey is to create an account. You can do this by visiting [app.unkey.com](https://app.unkey.com) or by clicking the Dashboard button in the top right of your screen.

<Frame caption="Create your account">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/images/sign-up.png" alt="Sign Up Page for Unkey" />
</Frame>

## 2. Choose how you want to use Unkey

As soon as you create your account you will be asked to choose how you want to use Unkey. Your options are:

* **API Keys**: This is used for protecting your public API.
* **Ratelimiting**: This is global low latency ratelimiting for your application.

> You can of course use both, but for this choose Ratelimiting.

<Frame caption="Choose how to use Unkey">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/images/choose-unkey.png" alt="Choose Unkey usage" />
</Frame>

## 3. Follow the Unkey tutorial

Next we will show you the basics of how to use Unkey Ratelimiting. You can skip this step if you like, but we recommend you follow along.

<Frame caption="Follow the Unkey tutorial">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/images/onboard-ratelimit.png" alt="Unkey Ratelimit" />
</Frame>

## 4. Next Steps

You should get to know our [API reference](/api-reference/ratelimits/limit), as you can add additonal fields to your request when ratelimiting endpoints.


# Bun
Source: https://unkey.com/docs/quickstart/ratelimiting/bun

Ratelimiting endpoints with Bun's http server

## Prerequisites

* Created your [Unkey account](https://app.unkey.com/auth/sign-up)
* Created an [Unkey root key](https://app.unkey.com/settings/root-keys) with `ratelimit.*.create_namespace` and `ratelimit.*.limit` permissions.

## Creating a bun server protected by Unkey

<Steps titleSize="h3">
  <Step title="Create a new Bun project">
    First we need a bun project, so create a new directory and init bun.

    ```bash
    mkdir unkey-with-bun
    cd unkey-with-bun
    bun init -y
    ```
  </Step>

  <Step title="Install">
    Now install the `@unkey/ratelimit` package

    ```bash
    bun install @unkey/ratelimit
    ```
  </Step>

  <Step title="Add Root Key to env">
    Add your root key to your `.env` file

    ```bash
    UNKEY_ROOT_KEY="YOUR_KEY"
    ```
  </Step>

  <Step title="Modify the server">
    Open up the file called `index.ts` and add the following code

    ```ts index.ts
    import { Ratelimit } from "@unkey/ratelimit";

    /**
    This can be a seperate util for easy configurable ratelimiting across
    multiple routes.

    namespace = The route identifier you would like to ratelimit
    limit = The amount of requests
    duration = amount of time to limit against for example "30s"

    **/
    const limiter = new Ratelimit({
      namespace: "bun-example",
      limit: 2,
      duration: "30s",
      rootKey: process.env.UNKEY_ROOT_KEY
    })

    const server = Bun.serve({
      async fetch(req) {
        const identifier = req.getUserId() // or ip or anything else you want

        const ratelimit = await limiter.limit(identifier)
        if (!ratelimit.success){
          return Response("try again later", { status: 429 })
        }
        return return new Response("Success", { status: 200 });
      },
      port: 8000,
    });
    console.log(`Listening on ${server.url}`);
    ```
  </Step>

  <Step title="Running the server">
    ```bash
    bun run index.ts
    ```
  </Step>

  <Step title="Try it out">
    ```bash
    curl http://localhost:8000
    ```

    You will need to curl a few times to see the ratelimiting error. Once you do, you, you will need to wait to perform the action again.
  </Step>
</Steps>

## What is next?

Now that you've seen the power of Unkey, check out some resources below to continue your journey.

<CardGroup cols={3}>
  <Card title="Discord" icon="discord" href="https://unkey.com/discord">Join our Discord to chat with us and the community</Card>

  <Card title="Unkey API Reference" icon="database" href="/api-reference">
    Learn about our API that helps you manage APIs, keys, ratelimits and analytical data.
  </Card>

  <Card title="SDKs" icon="brackets-curly" href="/libraries">
    Check out our SDKs and how they fit into your Bun application.
  </Card>
</CardGroup>


# Express
Source: https://unkey.com/docs/quickstart/ratelimiting/express

Ratelimiting endpoints with Express

## Prerequisites

* Created your [Unkey account](https://app.unkey.com/auth/sign-up)
* Created an [Unkey root key](https://app.unkey.com/settings/root-keys) with `ratelimit.*.create_namespace` and `ratelimit.*.limit` permissions.

## Creating an express server

<Steps titleSize="h3">
  <Step title="Create express application">
    First run the following:

    ```bash
    mkdir unkey-with-express
    npm init -y
    npm install cors dotenv express ts-node
    npm install -D @types/cors @types/express ts-node-dev typescript
    ```

    Then update your package.json to have the following

    ```json
    "scripts": {
        "start": "ts-node ./index.ts",
        "build": "tsc",
        "serve": "node dist/index.js"
      },
    ```
  </Step>

  <Step title="Install">
    Now install the `@unkey/ratelimit` package

    ```bash
    npm install @unkey/ratelimit
    ```
  </Step>

  <Step title="Add Root Key to env">
    Add your root key to your `.env` file

    ```bash
    UNKEY_ROOT_KEY="YOUR_KEY"
    ```
  </Step>

  <Step title="Creating the server">
    Create a file called `server.ts` and add the following code

    ```ts server.ts
    import express, { Request, Response, Application } from 'express';
    import dotenv from 'dotenv';
    import { Ratelimit } from '@unkey/ratelimit';
    //For env File
    dotenv.config();

    const app: Application = express();
    const port = process.env.PORT || 8000;

    /**
    This can be a seperate util for easy configurable ratelimiting across
    multiple routes.

    namespace = The route identifier you would like to ratelimit
    limit = The amount of requests
    duration = amount of time to limit against for example "30s"

    **/
    const limiter = new Ratelimit({
        namespace: "express-example",
        limit: 2,
        duration: "30s",
        rootKey: process.env.UNKEY_ROOT_KEY
    });


    app.get('/', (req: Request, res: Response) => {
      res.send('Welcome to Express & TypeScript Server');
    });

    // This endpoint is protected by Unkey
    app.get('/secret', async (req: Request, res: Response) => {
      const identifier = req.getUserId() // or ip or anything else you want

      const ratelimit = await limiter.limit(identifier)
      if (!ratelimit.success){
        res.status(429).send("Please try again later")
      }

      return res.status(200).send("ok");
    })
    app.listen(port, () => {
      console.log(`Server is listening at http://localhost:${port}`);
    });
    ```
  </Step>

  <Step title="Running the server">
    ```bash
    npm run start
    ```
  </Step>

  <Step title="Try it out">
    ```bash
    curl 'http://localhost:8000/secret'
    ```

    You will need to curl a few times to see the ratelimiting error. Once you do, you, you will need to wait to perform the action again.
  </Step>
</Steps>

## What is next?

Now that you've seen the power of Unkey, check out some resources below to continue your journey.

<CardGroup cols={3}>
  <Card title="Discord" icon="discord" href="https://unkey.com/discord">Join our Discord to chat with us and the community</Card>

  <Card title="Unkey API Reference" icon="database" href="/api-reference">
    Learn about our API that helps you manage APIs, keys, ratelimits and analytical data.
  </Card>

  <Card title="SDKs" icon="brackets-curly" href="/libraries">
    Check out our SDKs and how they fit into your Express application.
  </Card>
</CardGroup>


# Hono
Source: https://unkey.com/docs/quickstart/ratelimiting/hono

Ratelimiting endpoints with Hono

## Prerequisites

* Created your [Unkey account](https://app.unkey.com/auth/sign-up)
* Created an [Unkey root key](https://app.unkey.com/settings/root-keys) with `ratelimit.*.create_namespace` and `ratelimit.*.limit` permissions.

<Steps titleSize="h3">
  <Step title="Create Hono Application">
    Run the following command to create your Hono project

    <Tabs>
      <Tab title="npm">
        ```bash
        npm create hono@latest
        ```
      </Tab>

      <Tab title="pnpm">
        ```bash
        pnpm create hono@latest
        ```
      </Tab>

      <Tab title="yarn">
        ```bash
        yarn create hono@latest
        ```
      </Tab>

      <Tab title="bun">
        ```bash
          bun create hono@latest
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Install">
    Now install the `@unkey/ratelimit` package

    <Tabs>
      <Tab title="npm">
        ```bash
          npm install @unkey/ratelimit
        ```
      </Tab>

      <Tab title="pnpm">
        ```bash
          pnpm add @unkey/ratelimit
        ```
      </Tab>

      <Tab title="yarn">
        ```bash
          yarn add @unkey/ratelimit
        ```
      </Tab>

      <Tab title="bun">
        ```bash
          bun install @unkey/ratelimit
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Add Root Key to env">
    Add your root key to your `.env` file

    ```bash
    UNKEY_ROOT_KEY="YOUR_KEY"
    ```
  </Step>

  <Step title="Update index to use our Hono SDK">
    Create a new route and add the following code

    ```ts /src/index.ts
    import { Hono } from "hono";
    import { Ratelimit } from "@unkey/ratelimit";

    const app = new Hono();

    const limiter = new Ratelimit({
    	namespace: "hono-example",
     	limit: 2,
     	duration: "30s",
     	rootKey: process.env.UNKEY_ROOT_KEY
    });

    app.get("/", (c) => {
      const identifier = getUserId(); // or ip or anything else you want
      const ratelimit = await limiter.limit(identifier)
      if (!ratelimit.success){
       return c.status(429).text("Please try again later")
      }
    	return c.text("Hello Hono!");
    });

    export default app;
    ```
  </Step>

  <Step title="Running it">
    <Tabs>
      <Tab title="npm">
        ```bash
          npm run dev
        ```
      </Tab>

      <Tab title="pnpm">
        ```bash
          pnpm run dev
        ```
      </Tab>

      <Tab title="yarn">
        ```bash
          yarn run dev
        ```
      </Tab>

      <Tab title="bun">
        ```bash
          bun run dev
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Try it out">
    ```bash
    curl -XPOST 'http://localhost:8787/'
    ```

    You will need to curl a few times to see the ratelimiting error. Once you do, you, you will need to wait to perform the action again.
  </Step>
</Steps>

## What is next?

Now that you've seen the power of Unkey, check out some resources below to continue your journey.

<CardGroup cols={3}>
  <Card title="Discord" icon="discord" href="https://unkey.com/discord">Join our Discord to chat with us and the community</Card>

  <Card title="Unkey API Reference" icon="database" href="/api-reference">
    Learn about our API that helps you manage APIs, keys, ratelimits and analytical data.
  </Card>

  <Card title="Hono SDK" icon="brackets-curly" href="/libraries/ts/hono">
    Check out our Hono SDK and how they fit into your API.
  </Card>
</CardGroup>


# Next.js
Source: https://unkey.com/docs/quickstart/ratelimiting/nextjs

Ratelimiting endpoints with Next.js

## Prerequisites

* Created your [Unkey account](https://app.unkey.com/auth/sign-up)
* Created an [Unkey root key](https://app.unkey.com/settings/root-keys) with `ratelimit.*.create_namespace` and `ratelimit.*.limit` permissions.

<Steps titleSize="h3">
  <Step title="Create Next.js Application">
    Run the following command to init your Next.js project

    <Tabs>
      <Tab title="npm">
        ```bash
          npx create-next-app@latest
        ```
      </Tab>

      <Tab title="pnpm">
        ```bash
        pnpm create next-app@latest
        ```
      </Tab>

      <Tab title="yarn">
        ```bash
          yarn create-next-app@latest
        ```
      </Tab>

      <Tab title="bun">
        ```bash
          bunx create-next-app
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Install">
    Now install the `@unkey/ratelimit` package

    <Tabs>
      <Tab title="npm">
        ```bash
          npm install @unkey/ratelimit
        ```
      </Tab>

      <Tab title="pnpm">
        ```bash
          pnpm add @unkey/ratelimit
        ```
      </Tab>

      <Tab title="yarn">
        ```bash
          yarn add @unkey/ratelimit
        ```
      </Tab>

      <Tab title="bun">
        ```bash
          bun install @unkey/ratelimit
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Add Root Key to env">
    Add your root key to your `.env` file

    ```bash
    UNKEY_ROOT_KEY="YOUR_KEY"
    ```
  </Step>

  <Step title="Creating a protected route">
    Create a new route and add the following code

    ```ts /app/protected/route.ts
    import { NextResponse } from 'next/server';
    import { Ratelimit } from "@unkey/ratelimit";

    const limiter = new Ratelimit({
      namespace: "next-example",
      limit: 2,
      duration: "30s",
      rootKey: process.env.UNKEY_ROOT_KEY
    });

    export const POST = (async (req) => {
      const identifier = getUserId(); // or ip or anything else you want
      const ratelimit = await limiter.limit(identifier)
      if (!ratelimit.success){
       return new NextResponse("Please try again later", {status: 429});
      }

      return new NextResponse('Hello!');
    });
    ```
  </Step>

  <Step title="Running it">
    <Tabs>
      <Tab title="npm">
        ```bash
          npm run dev
        ```
      </Tab>

      <Tab title="pnpm">
        ```bash
          pnpm run dev
        ```
      </Tab>

      <Tab title="yarn">
        ```bash
          yarn run dev
        ```
      </Tab>

      <Tab title="bun">
        ```bash
          bun run dev
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Try it out">
    Go to [https://app.unkey.com](https://app.unkey.com) and create a new key. Then verify it with our new server:

    ```bash
    curl -XPOST 'http://localhost:3000/protected'
    ```

    You will need to curl a few times to see the ratelimiting error. Once you do, you, you will need to wait to perform the action again.
  </Step>
</Steps>

## What is next?

Now that you've seen the power of Unkey, check out some resources below to continue your journey.

<CardGroup cols={3}>
  <Card title="Discord" icon="discord" href="https://unkey.com/discord">Join our Discord to chat with us and the community</Card>

  <Card title="Unkey API Reference" icon="database" href="/api-reference">
    Learn about our API that helps you manage APIs, keys, ratelimits and analytical data.
  </Card>

  <Card title="Next.js SDK" icon="brackets-curly" href="/libraries/ts/nextjs">
    Check out our Next.js SDK and how they fit into your Next application.
  </Card>
</CardGroup>


# Automated Overrides
Source: https://unkey.com/docs/ratelimiting/automated-overrides

Manage dynamic overrides programmatically

Unkey's ratelimit override API allows you to manage dynamic overrides in response to events in your system.
For example when your customer upgrades to an enterprise plan, you might want to create overrides for them to give them higher quotas.

Let's look at common scenarios and how to implement them using our [@unkey/api SDK](https://www.unkey.com/docs/libraries/ts/sdk/overview).

Our application has a ratelimit namespace called `email.send`, which ratelimits users from sending OTP emails during login.
As identifier we're using their email address.

## Set Override

In this example, we'll set an override for all users of our fictional customer `calendso.com`.

How you detect a change is up to you, typically it's either through a user or admin action, or some form of incoming webhook from your billing or auth provider.

```ts

import { Unkey } from "@unkey/api";

const unkey = new Unkey({
  rootKey: process.env.UNKEY_ROOT_KEY!,
});

await unkey.ratelimits.setOverride({
  namespaceName: "email.send",
  // set the override for all users with this domain
  identifier: "*@calendso.com",
  limit: 10,
  duration: 60_000, // 1 minute
  async: true
})
```

[API Reference ->](/api-reference/ratelimits/set-override)

Now, when we're ratelimiting `tim@calendso.com`, it will use the override settings and ratelimit them to 10 per minute.

## Get Override

Retrieve a single override for an identifier within a namespace.

```ts
import { Unkey } from "@unkey/api";

const unkey = new Unkey({
  rootKey: process.env.UNKEY_ROOT_KEY!,
});

const override = await unkey.ratelimits.getOverride({
  namespaceName: "email.send",
  identifier: "*@customer.com",
})

console.log(override)

{
  "result": {
    "id": "rlor_123",
    "identifier": "*@calendso.com",
    "limit": 10,
    "duration": 60000,
    "async": true
  }
}
```

[API Reference ->](/api-reference/ratelimits/get-override)

## List Overrides

You can list all of the configured overirdes for a namespace to build your own dashboards.

```ts
import { Unkey } from "@unkey/api";

const unkey = new Unkey({
  rootKey: process.env.UNKEY_ROOT_KEY!,
});

const res = await unkey.ratelimits.listOverrides({
  namespaceName: "email.send",
})

console.log(res)

{
  "result": {
    "overrides": [
      {
        "id": "rlor_123",
        "identifier": "*@calendso.com",
        "limit": 10,
        "duration": 60000,
        "async": true
      }
    ],
    "cursor": "eyJrZXkiOiJrZXlfMTIzNCJ9",
    "total": 1
  }
}
```

[API Reference ->](/api-reference/ratelimits/list-overrides)

## Delete Override

Once they downgrade their plan, we can revoke any overrides:

```ts
import { Unkey } from "@unkey/api";

const unkey = new Unkey({
  rootKey: process.env.UNKEY_ROOT_KEY!,
});

await unkey.ratelimits.deleteOverride({
  namespaceName: "email.send",
  identifier: "*@customer.com",
})
```

[API Reference ->](/api-reference/ratelimits/delete-override)


# Overview
Source: https://unkey.com/docs/ratelimiting/introduction

Ratelimit your serverless functions.

Serverless functions offer a ton of benefits but unfortunately make some things much harder too.
Ratelimiting is one of these things as it requires some persistent state to coordinate different limits.

Unkey's ratelimit API provides a global low latency solution to limit your functions and protect
upstream services.

## Get your API key

<Steps>
  <Step title="Go to the dashboard">
    Visit [/app/settings-root-keys/new](https://app.unkey.com/settings/root-keys/new)
  </Step>

  <Step title="Enter a name">
    You can give your key a name to make it easier to find later, but that's optional.
  </Step>

  <Step title="Add permissions">
    Your key needs at least these permissions:

    * `create_namespace`
    * `limit`

    <Frame>
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/ratelimiting/create-root-key-permissions.png" />
    </Frame>

    After selecting both permissions, click `Create New Key` at the bottom of the page and copy the generated key to your `.env` file.
    For security reasons, this key can not be shown again. In case you lose it, you need to create a new one.

    <Frame>
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/ratelimiting/copy-key.png" />
    </Frame>
  </Step>
</Steps>

## Ratelimit your functions

<Info>
  We're currently only offering a Typescript SDK but you can check out the [api reference](/api-reference/ratelimits/limit) and do the network call manually if you are using another language.
  Also please let us know what language you're using, so we can prioritize adding support for it.
</Info>

Please follow the [@unkey/ratelimit](/libraries/ts/ratelimit) documentation for setup and configuration options.


# Consistency vs Latency
Source: https://unkey.com/docs/ratelimiting/modes

Optimize for consistency or latency with different ratelimiting modes.

## Synchronous

The default ratelimiting mode is synchronous, which means that the request will be blocked until the current limit has been confirmed by the origin source of truth. The problem with this is that it can introduce more latency.
We constantly relocate the origin dynamically to the closest edge location of the caller, but there's still a roundtrip to the origin to confirm the limit. And if the same identifier is being used in multiple geographic regions, only one of them is the closest, the remaining ones are likely doing longer network requests across the globe.
The benefit of this mode is that it's absolutely correct, as every single request is checked against the same source of truth.

## Asynchronous

Asynchronous mode is a tradeoff between correctness and latency. It's faster because we don't need to confirm the limit with the origin before returning a decision, but it's also less correct because the limit is checked against the local edge cache and then updated asynchronously in the background. This means that if the same identifier is being used in multiple geographic regions, they might not be aware of each other's usage and could potentially exceed the limit until everything is synchronized to the edge.

<Warning>
  As you might notice, the `remaining` response value is not always accurate in async mode for low frequency requests.
  You should always use the returned `success` value to determine if the request was allowed or not.
</Warning>

## What should I use?

With every request we measure whether our async `success` respones would have matched a synchronous `success` response and we observe 98% accuracy across all of our users.

If you have strict requirements for correctness, you should use the synchronous mode.
In all other cases, we recommend using the asynchronous mode to optimize for latency as that will give you the best performance and lowest latency for your users. Most of the time, your ratelimits will not get reached, so the small tradeoff in correctness is usually worth it for the performance gain. In case your API gets abused, the async mode will sync quickly due to the high frequency of requests and will stop the abuse quickly.

<Info>
  If you're still unsure which mode to use, please join our [Discord](https://unkey.com/discord) and we'll help you decide.
</Info>


# Custom overrides
Source: https://unkey.com/docs/ratelimiting/overrides

Override limits for identifiers without code changes.

The problem with code-defined ratelimits is that managing different limits per user is not really feasable.
You'd need to keep a list of identifiers hardcoded in your code and redeploy your application whenever one of them changes.

With unkey you can add custom overrides dynamically and we'll roll them out to every edge location quickly.

## Overriding limits for an identifier

<Steps>
  <Step title="Head over to your namespace page">
    Click "Ratelimit" in the sidebar > select your namespace > Overrides
  </Step>

  <Step title="Create a new override">
    <Frame>
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/ratelimiting/new-override.png" />
    </Frame>

    Enter the identifier to override, a custom limit and custom duration.
  </Step>

  <Step title="Save">
    Click **Create** to roll out the override globally. It may take up to 60s at most but is usually done in just a few seconds.

    From now on, when the specified identifier gets ratelimited, it'll use the custom limits, rather than what is defined in your code.
  </Step>
</Steps>

## Wildcard Rules

You can use wildcards (`*`) in your override to match multiple identifiers.
Exact override matches take precedence over wildcard matches, but there's no guarantee of order between multiple wildcard matches yet.

**Example:**
Given a base limit of 10/60s and these overrides:

* `*@domain.com`: 20/60s
* `hello@domain.com`: 100/s

This would result in the following applied ratelimits:

| requested identifier | match    | used ratelimit |
| -------------------- | -------- | -------------- |
| `abc@domain.com`     | wildcard | 20/60s         |
| `hello@domain.com`   | exact    | 100/s          |
| `xyz`                | -        | 10/60s         |

Here's an example of setting higher limits for all emails from the `customer.com` domain.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/ratelimiting/wildcard-override.png" />
</Frame>

### Examples

| override        | matches                            |
| --------------- | ---------------------------------- |
| `*@domain.com`  | `1@domain.com`, `hello@domain.com` |
| `invite:*`      | `invite:abc`, `invite:hello world` |
| `prefix*suffix` | `prefixhelloworldsuffix`           |


# GitHub Secret Scanning
Source: https://unkey.com/docs/security/github-scanning

How Unkey protects you from leaked root keys

Unkey has partnered with GitHub to scan repositories for leaked keys.

GitHub Secret Scanning uses regular expressions to scan repositories for keys matching Unkey root keys. If a key is found, GitHub will notify Unkey, and we will validate the key and notify users via email. To ensure the production environment remains up and running, we do not disable the key.

This is a service that is automatic and requires nothing from you to function. However, outside of GitHub, we will not be able to inform you if a key has leaked.

Learn more: [GitHub Secret Scanning](https://docs.github.com/en/code-security/secret-scanning)

## Sources Scanned

* content
* commit
* pull\_request\_title
* pull\_request\_description
* pull\_request\_comment
* issue\_title
* issue\_description
* issue\_comment
* discussion\_title
* discussion\_body
* discussion\_comment
* commit\_comment
* gist\_content
* gist\_comment
* npm
* unknown


# Overview
Source: https://unkey.com/docs/security/overview

How does Unkey work? What security measures are in place?

## Why is Unkey secure? What makes it secure?

Unkey is secure because we never store the API Key in our database. Instead we store a hash of the API Key. This means that even if our database is compromised, your API Keys are safe. You should follow a similar pattern in your own applications by providing the API key to your user and not storing it in your database either.

We manage the keys by using the unique id that each key is given when it is created. This id allows you as developer to update or delete the key, but this id cannot be used to verify the key.

## Where are API keys stored?

We don't store API Keys, we store a hash of the API Key (sha256). This is then stored in our database. When you attempt to verify the API Key, we hash the API Key you provide and compare it to the hash we have stored. If they match, then the API Key is valid.


# Recovering Keys
Source: https://unkey.com/docs/security/recovering-keys

Show keys again after they are created

Best practice is to create a key, show it to your users and never store it yourself. If the user loses the key, they can create a new one. This way you don't have to worry about storing the key securely.
Without recovery, we would generate a new key and only store a hash of it. This way we can check if the key is correct but nobody, not even someone with access to the database, can recover the key.

However there are some reasons why you might want to recover keys and show them again.

* API playgrounds that need the key to call an API
* Better DX for your users, it's annoying to create a new key and update it everywhere

## Vault

Vault is our secure storage for secrets, such as keys. It follows a few principles:

* Secrets are encrypted at rest
* A leak of vaults data does not expose secrets
* A leak of the main database does not expose secrets
* A leak of the main encryption keys does not expose secrets

An attacker would need access to the vault, the main database and the main encryption keys to decrypt the secrets.
In order to make this even harder, we rotate the encryption keys regularly and do not run vault on the same servers as the main database to prevent an attacker from getting access to all the required information at once.

To learn more about how it works under the hood, you can head over to our [engineering docs](https://engineering.unkey.dev/services/vault).

## Opting in

By default we only store key hashes, not encrypted keys.

If you want us to store keys in a way that we can recover them, you need to opt in:

<Steps>
  <Step title="Root key permissions">
    When creating new keys, your root key must have permission to encrypt. Head over to the [dashboard](https://app.unkey.com/settings/root-keys) and make sure the `encrypt_key` permission is enabled.

    Do not skip this step. Otherwise your root key will get rejected when trying to create new keys.
  </Step>

  <Step title="Contact us">
    To opt in to recovery, send us an email at [support@unkey.dev](mailto:support@unkey.dev?subject=Recovery%20Opt%20In).
    Send us the email from the email address associated with your workspace and include the `API ID` that you want to enable recovery for.
  </Step>
</Steps>

<Note>
  Please note that this is not retroactively applied. Existing keys were never stored and cannot be recovered. Only keys created after opting in to recovery can be recovered.
</Note>

## Creating keys

When creating a key, you can set the `recoverable` field to `true`. This will store the key in a way that we can recover it later.

```shell
curl --request POST \
  --url https://api.unkey.dev/v1/keys.createKey \
  --header 'Authorization: Bearer {ROOT_KEY}' \
  --header 'Content-Type: application/json' \
  -d '{
    "apiId": "{API_ID}",
    "recoverable": true
  }'
```

## Recovering plaintext keys

Both the [getKey](/api-reference/keys/get) and [listKeys](/api-reference/apis/list-keys) endpoints accept a `decrypt` query parameter. If you set this to `true`, the key will be decrypted and returned in the response as `plaintext`.

<Warning>
  When recovering keys, your root key must have permission to decrypt. Head over to the [dashboard](https://app.unkey.com/settings/root-keys) and make sure the `decrypt_key` permission is enabled.
</Warning>

```shell
curl --request GET \
  --url https://api.unkey.dev/v1/keys.getKey?keyId={KEY_ID}&decrypt=true \
  --header 'Authorization: Bearer {ROOT_KEY}'
```

```json
{
  // ...
  "plaintext": "your-key-here"
}
```

<Info>
  If you have any questions about recovery, please reach out to us at [support@unkey.dev](mailto:support@unkey.dev).

  For security concerns, please disclose them responsibly by emailing [security@unkey.dev](mailto:security@unkey.dev) instead.
</Info>


# Root Keys
Source: https://unkey.com/docs/security/root-keys

Learn how root keys in the Unkey API work

To interact with the Unkey API to manage resources such as APIs or keys, you need a `root key`.

`Root keys` are scoped per workspace and you can fine tune their access permissions when creating a key or update later on the fly.

<Note>
  It's a good practice to provide as few permissions as possible, to minimize the potential impact of a leaked key.
</Note>

<Steps>
  <Step title="Start">
    Go to [https://app.unkey.com/settings/root-keys/new](https://app.unkey.com/settings/root-keys/new)
  </Step>

  <Step title="Name and Permissions">
    1. Optionally enter a name. This is internal only and not customer facing.
    2. Add your workspace-wide permissions. These permissions affect and override the per-api permissions below.
    3. For each API in your workspace, you can enable fine grained permissions.
    4. Click `Create New Key` at the bottom

    <Frame>
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/images/root-keys/permissions.png" />
    </Frame>
  </Step>

  <Step title="Copy your key">
    <Note>
      Be sure to copy the key before closing the window. There is no way to recover it later
    </Note>

    <Frame>
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/unkey/images/root-keys/copy.png" />
    </Frame>
  </Step>
</Steps>

## What should I do if a root key is leaked?

If you leak a root key - for instance, by accidentally checking it in to version control - you should immediately revoke the root key and replace it with a new, secure key. Root keys are secrets, and should never be exposed publicly.


