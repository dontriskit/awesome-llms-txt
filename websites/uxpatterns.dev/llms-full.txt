# GENERAL: [Books](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/general/books)

A curated list of essential UX books to help developers improve their design and implementation skills.

# UX Books for Developers

A curated list of books to help developers understand and implement better user experiences.

## Essential Reads

| Cover                                                                                | Title                                            | Author                      | Why Developers Should Read It                                                                                                       |
| ------------------------------------------------------------------------------------ | ------------------------------------------------ | --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| ![Don't Make Me Think](https://covers.openlibrary.org/b/isbn/0321965515-M.jpg)       | Don't Make Me Think, Revisited                   | Steve Krug                  | • Practical usability principles<br/>• Developer-friendly approach<br/>• Real-world examples                                        |
| ![UX Fundamentals](/books/ux-fundamentals-non-ux-professionals.jpg)                  | UX Fundamentals for Non-UX Professionals         | Edward Stull                | • Perfect for developers new to UX<br/>• Clear, structured approach<br/>• Focuses on core concepts                                  |
| ![Design of Everyday Things](https://covers.openlibrary.org/b/isbn/0465050654-M.jpg) | The Design of Everyday Things                    | Don Norman                  | • Fundamental design principles<br/>• Understanding user psychology<br/>• Error prevention                                          |
| ![Practical UI](/books/practical-ui.jpg)                                             | [Practical UI](https://www.practical-ui.com/)    | Adham Dannaway              | • Logic-driven approach<br/>• Quick, actionable guidelines<br/>• Includes Figma design system<br/>• Updated in 2024                 |
| ![Refactoring UI](/books/refactoring-ui.jpg)                                         | [Refactoring UI](https://www.refactoringui.com/) | Adam Wathan & Steve Schoger | • Design tactics for developers<br/>• Practical, visual examples<br/>• Component-based approach<br/>• Color & typography guidelines |

## Form Design

| Cover                                                      | Title                                                                                      | Author         | Why Developers Should Read It                                                                                                              |
| ---------------------------------------------------------- | ------------------------------------------------------------------------------------------ | -------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| ![Designing UX: Forms](/books/designing-ux-forms.jpg)      | Designing UX: Forms                                                                        | Jessica Enders | • Deep dive into form design psychology<br/>• Best practices for validation<br/>• Accessibility considerations<br/>• Mobile-first approach |
| ![Form Design Patterns](/books/form-design-patterns.jpg)   | Form Design Patterns                                                                       | Adam Silver    | • Step-by-step implementation guide<br/>• Progressive enhancement techniques<br/>• Accessibility best practices<br/>• Real-world examples  |
| ![Dos and Don'ts for Form Input](/books/do-dont-forms.jpg) | [Dos and Don'ts for Form Input and Selection](https://uxmovement.gumroad.com/l/dodontform) | UX Movement    | • Comprehensive form patterns<br/>• Visual examples<br/>• Practical dos and don'ts<br/>• Regular updates included                          |

## Tools & References

| Cover                                                                          | Title                                                                                                                | Author          | Why Developers Should Read It                                                                                                                             |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------- | --------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![Smart Interface Design Patterns](/books/smart-interface-design-patterns.jpg) | [Smart Interface Design Patterns Checklist Cards](https://www.smashingmagazine.com/2020/08/checklist-cards-release/) | Vitaly Friedman | • 100 ready-to-use checklists<br/>• Covers all common UI components<br/>• Based on usability research<br/>• Perfect for design-implementation discussions |

## Inclusive Design

| Cover                                                              | Title                     | Author           | Why Developers Should Read It                                                                                                                  |
| ------------------------------------------------------------------ | ------------------------- | ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| ![Inclusive Design Patterns](/books/inclusive-design-patterns.jpg) | Inclusive Design Patterns | Heydon Pickering | • Practical accessibility techniques<br/>• ARIA implementation patterns<br/>• Progressive enhancement strategies<br/>• Cross-browser solutions |

## Advanced UX

| Cover                                                                 | Title                                                | Author           | Why Developers Should Read It                                                       |
| --------------------------------------------------------------------- | ---------------------------------------------------- | ---------------- | ----------------------------------------------------------------------------------- |
| ![About Face](https://covers.openlibrary.org/b/isbn/1118766571-M.jpg) | About Face: The Essentials of Interaction Design     | Alan Cooper      | • Interaction design patterns<br/>• User behavior models<br/>• Interface guidelines |
| ![100 Things](https://covers.openlibrary.org/b/isbn/0321767535-M.jpg) | 100 Things Every Designer Needs to Know About People | Susan Weinschenk | • Psychology insights<br/>• Research-based decisions<br/>• Practical applications   |


# GENERAL: [Getting Started](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/general/getting-started)

UX Patterns for Devs is a comprehensive resource that helps developers implement effective, accessible, and usable UI components

# Getting Started

## About UX Patterns for Devs

UX Patterns for Devs is a comprehensive resource that helps developers implement effective, accessible, and usable UI components. Each pattern in our documentation is carefully crafted to provide practical guidance while following best practices for user experience and accessibility.

## How to Use This Documentation

Each pattern in our documentation follows a consistent structure to help you quickly find the information you need:

1. **Overview** - Introduction and use cases for the pattern
2. **Use Cases** - Real-world examples and scenarios where the pattern should be implemented
3. **Benefits** - Key advantages and value propositions of using this pattern
4. **Anatomy** - Detailed breakdown of the component's structure
5. **Best Practices** - Guidelines for implementation, including do's and don'ts
6. **Micro-Interactions & Animations** - Detailed guidance on animations, transitions, and interactive feedback
7. **Tracking & Analytics** - Event tracking implementation and metrics analysis
8. **Localization** - Guidelines for translating and adapting the pattern
9. **Code Examples** - Code examples and technical considerations
10. **Accessibility** - Guidelines for accessibility considerations
11. **SEO** - Search engine optimization considerations and best practices
12. **Browser Support** - Information on browser support for the pattern
13. **Testing** - Guidelines for unit, integration, and accessibility testing
14. **Design Tokens** - Design system variables and customization options
15. **Related Patterns** - Links to similar or complementary patterns
16. **FAQs** - Common questions and detailed answers
17. **Resources** - Additional documentation, articles, libraries...

## Getting Started

To get the most out of this documentation:

1. **Browse Patterns** - Use the sidebar navigation to explore available patterns
2. **Search** - Use the search bar to find specific patterns or concepts
3. **Implementation** - Follow the code examples and guidelines for each pattern
4. **Accessibility** - Pay attention to accessibility requirements for each component
5. **Best Practices** - Review the do's and don'ts before implementing

## How Would We Define "Build Effort"?

Each pattern has a complexity indicator using this simple scale:

| Level     | Description                                                                                                                           |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| 🟢 Low    | Simple implementation, minimal dependencies, little to no JavaScript required (e.g., Tooltip, Expandable Text).                       |
| 🟡 Medium | Requires state management, user interactions, and accessibility considerations (e.g., Load More, Modal).                              |
| 🔴 High   | Complex UI behavior, animations, accessibility, performance optimizations, and multiple edge cases (e.g., Carousel, Infinite Scroll). |

## Contributing

We welcome contributions from the community! Whether you want to:

* Add new patterns
* Improve existing documentation
* Fix bugs
* Suggest improvements

Visit our [GitHub repository](https://github.com/thedaviddias/ux-patterns-for-developers/blob/main/.github/CONTRIBUTING.md) to learn how to contribute.

## Need Help?

If you need assistance or want to report an issue:

* Open a [GitHub issue](https://github.com/thedaviddias/ux-patterns-for-developers/issues/new/choose)
* Join our [Discord community](https://ddias.link/discord)
* Check the pattern's documentation for specific implementation details


# GENERAL: [When To Use What](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/general/when-to-use-what)

Guide for choosing the right UI pattern for your needs

# When to Use What?

This guide helps you choose the most appropriate UI pattern for your needs.

Each pattern includes:

* ✅ Best use cases
* ❌ When to avoid
* 🎯 Key features
* 🔄 Related patterns

## Selection Patterns (Less than 5 options)

| Pattern                              | Best For                                     | Avoid When                           | Key Features    | Related                                            |
| ------------------------------------ | -------------------------------------------- | ------------------------------------ | --------------- | -------------------------------------------------- |
| [Radio](/patterns/forms/radio)       | ✅ Single choice<br/>✅ Visible options        | ❌ Many options<br/>❌ Multiple needed | ✅ Clear choices | [Dropdown](/patterns/forms/selection-input)        |
| [Checkbox](/patterns/forms/checkbox) | ✅ Multiple choices<br/>✅ Independent options | ❌ Single choice<br/>❌ Many options   | ✅ Toggle states | [Multi-select](/patterns/forms/multi-select-input) |
| [Toggle](/patterns/forms/toggle)     | ✅ Binary settings<br/>✅ Immediate effect     | ❌ Multiple states                    | ✅ Quick switch  | [Checkbox](/patterns/forms/checkbox)               |

## Selection Patterns (5 or more options)

| Pattern                                            | Best For                           | Avoid When           | Key Features      | Related                                      |
| -------------------------------------------------- | ---------------------------------- | -------------------- | ----------------- | -------------------------------------------- |
| [Dropdown](/patterns/forms/selection-input)        | ✅ Limited space<br/>✅ 5-15 options | ❌ Multiple selection | ✅ Compact         | [Radio](/patterns/forms/radio)               |
| [Autocomplete](/patterns/forms/autocomplete)       | ✅ Many options<br/>✅ Search needed | ❌ Few options        | ✅ Search & filter | [Search Field](/patterns/forms/search-field) |
| [Multi-select](/patterns/forms/multi-select-input) | ✅ Multiple items<br/>✅ Tags needed | ❌ Single choice      | ✅ Bulk selection  | [Checkbox](/patterns/forms/checkbox)         |

## Text Input Patterns

| Pattern                                       | Best For                            | Avoid When     | Key Features   | Related                                         |
| --------------------------------------------- | ----------------------------------- | -------------- | -------------- | ----------------------------------------------- |
| [Text Field](/patterns/forms/text-field)      | ✅ Short text<br/>✅ Single line      | ❌ Long content | ✅ Simple input | [Rich Text](/patterns/forms/rich-text-editor)   |
| [Rich Text](/patterns/forms/rich-text-editor) | ✅ Formatted text<br/>✅ Long content | ❌ Simple text  | ✅ Formatting   | [Text Field](/patterns/forms/text-field)        |
| [Password](/patterns/forms/password)          | ✅ Secure entry<br/>✅ Credentials    | ❌ Public data  | ✅ Masked input | [Code Input](/patterns/forms/code-confirmation) |
| [Search Field](/patterns/forms/search-field)  | ✅ Content search<br/>✅ Filtering    | ❌ Exact match  | ✅ Quick search | [Autocomplete](/patterns/forms/autocomplete)    |

## Specialized Input Patterns

| Pattern                                         | Best For                             | Avoid When        | Key Features    | Related                                                     |
| ----------------------------------------------- | ------------------------------------ | ----------------- | --------------- | ----------------------------------------------------------- |
| [Currency](/patterns/forms/currency-input)      | ✅ Money values<br/>✅ Formatting      | ❌ Plain numbers   | ✅ Auto-format   | [Text Field](/patterns/forms/text-field)                    |
| [Phone](/patterns/forms/phone-number)           | ✅ Phone numbers<br/>✅ Formatting     | ❌ Plain text      | ✅ Validation    | [Text Field](/patterns/forms/text-field)                    |
| [Color Picker](/patterns/forms/color-picker)    | ✅ Color selection<br/>✅ Visual input | ❌ Text input      | ✅ Visual picker | [Dropdown](/patterns/forms/selection-input)                 |
| [Rating](/patterns/forms/rating-input)          | ✅ User ratings<br/>✅ Quick input     | ❌ Precise numbers | ✅ Star scale    | [Radio](/patterns/forms/radio)                              |
| [Code Input](/patterns/forms/code-confirmation) | ✅ 2FA/OTP<br/>✅ Verification         | ❌ Regular input   | ✅ Auto-advance  | [Password](/patterns/forms/password)                        |
| [File Input](/patterns/forms/file-input)        | ✅ File uploads<br/>✅ Multiple files  | ❌ Text input      | ✅ File select   | [Drag and Drop](/patterns/content-management/drag-and-drop) |

## Date & Time Patterns

| Pattern                                    | Best For                                 | Avoid When      | Key Features   | Related                                    |
| ------------------------------------------ | ---------------------------------------- | --------------- | -------------- | ------------------------------------------ |
| [Date Input](/patterns/forms/date-input)   | ✅ Basic date entry<br/>✅ Known format    | ❌ Visual needed | ✅ Direct entry | [Date Picker](/patterns/forms/date-picker) |
| [Date Picker](/patterns/forms/date-picker) | ✅ Visual dates<br/>✅ Calendar needed     | ❌ Quick entry   | ✅ Calendar UI  | [Date Range](/patterns/forms/date-range)   |
| [Date Range](/patterns/forms/date-range)   | ✅ Period selection<br/>✅ Start/end dates | ❌ Single date   | ✅ Range select | [Date Picker](/patterns/forms/date-picker) |

## Content Management Patterns

| Pattern                                                     | Best For                                  | Avoid When          | Key Features             | Related                                                 |
| ----------------------------------------------------------- | ----------------------------------------- | ------------------- | ------------------------ | ------------------------------------------------------- |
| [Accordion](/patterns/content-management/accordion)         | ✅ Collapsible sections<br/>✅ Space saving | ❌ Always visible    | ✅ Progressive disclosure | [Modal](/patterns/content-management/modal)             |
| [Modal](/patterns/content-management/modal)                 | ✅ Focused tasks<br/>✅ Important actions   | ❌ Frequent access   | ✅ Focus trap             | [Tooltip](/patterns/content-management/tooltip)         |
| [Carousel](/patterns/content-management/carousel)           | ✅ Multiple items<br/>✅ Limited space      | ❌ Comparison needed | ✅ Progressive reveal     | [Infinite Scroll](/patterns/navigation/infinite-scroll) |
| [Tooltip](/patterns/content-management/tooltip)             | ✅ Extra info<br/>✅ Quick help             | ❌ Critical info     | ✅ Context help           | [Modal](/patterns/content-management/modal)             |
| [Drag and Drop](/patterns/content-management/drag-and-drop) | ✅ Reordering<br/>✅ Visual sorting         | ❌ Simple selection  | ✅ Direct manipulation    | [Selection Input](/patterns/forms/selection-input)      |

## Navigation Patterns

| Pattern                                                 | Best For                                                 | Avoid When                                     | Key Features                                 | Related                                                                                                   |
| ------------------------------------------------------- | -------------------------------------------------------- | ---------------------------------------------- | -------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| [Back to Top](/patterns/navigation/back-to-top)         | ✅ Long pages<br/>✅ Quick return                          | ❌ Short content<br/>❌ Mobile-first designs     | ✅ Quick navigation<br/>✅ One-click access    | [Infinite Scroll](/patterns/navigation/infinite-scroll)                                                   |
| [Breadcrumb](/patterns/navigation/breadcrumb)           | ✅ Deep hierarchies<br/>✅ Complex sites<br/>✅ E-commerce  | ❌ Flat structures<br/>❌ Single-level sites     | ✅ Location awareness<br/>✅ Easy backtracking | [Navigation Menu](/patterns/navigation/navigation-menu)                                                   |
| [Infinite Scroll](/patterns/navigation/infinite-scroll) | ✅ Content feeds<br/>✅ Continuous flow<br/>✅ Social media | ❌ Structured content<br/>❌ Goal-oriented tasks | ✅ Auto-loading<br/>✅ Seamless browsing       | [Pagination](/patterns/navigation/pagination)<br/>[Load More](/patterns/navigation/load-more)             |
| [Load More](/patterns/navigation/load-more)             | ✅ Content exploration<br/>✅ User control                 | ❌ Large datasets<br/>❌ Sequential content      | ✅ Manual loading<br/>✅ Performance friendly  | [Infinite Scroll](/patterns/navigation/infinite-scroll)<br/>[Pagination](/patterns/navigation/pagination) |
| [Pagination](/patterns/navigation/pagination)           | ✅ Large datasets<br/>✅ Structured content                | ❌ Short lists<br/>❌ Continuous reading         | ✅ Clear boundaries<br/>✅ Better orientation  | [Load More](/patterns/navigation/load-more)<br/>[Infinite Scroll](/patterns/navigation/infinite-scroll)   |
| [Hamburger Menu](/patterns/navigation/hambuger-menu)    | ✅ Mobile interfaces<br/>✅ Space-saving                   | ❌ Desktop-first<br/>❌ Critical navigation      | ✅ Compact<br/>✅ Expandable                   | [Navigation Menu](/patterns/navigation/navigation-menu)<br/>[Sidebar](/patterns/navigation/sidebar)       |
| [Megamenu](/patterns/navigation/megamenu)               | ✅ Large sites<br/>✅ Complex hierarchies                  | ❌ Simple navigation<br/>❌ Mobile interfaces    | ✅ Rich content<br/>✅ Category overview       | [Navigation Menu](/patterns/navigation/navigation-menu)                                                   |
| [Navigation Menu](/patterns/navigation/navigation-menu) | ✅ Primary navigation<br/>✅ Site structure                | ❌ Deep hierarchies<br/>❌ Complex categories    | ✅ Clear structure<br/>✅ Easy access          | [Megamenu](/patterns/navigation/megamenu)                                                                 |
| [Sidebar](/patterns/navigation/sidebar)                 | ✅ Dashboard layouts<br/>✅ App interfaces                 | ❌ Content-heavy sites<br/>❌ Mobile-first       | ✅ Persistent nav<br/>✅ Context retention     | [Navigation Menu](/patterns/navigation/navigation-menu)                                                   |
| [Tabs](/patterns/navigation/tabs)                       | ✅ Related content<br/>✅ Switching views                  | ❌ Deep hierarchies<br/>❌ Many sections         | ✅ Content grouping<br/>✅ Quick switching     | [Navigation Menu](/patterns/navigation/navigation-menu)                                                   |
|                                                         |                                                          |                                                |                                              |                                                                                                           |

For implementation details and best practices, visit our [Getting Started](/patterns/getting-started) guide.


# CONTENT-MANAGEMENT: [Accordion](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/content-management/accordion)

Create effective accordion components for your web applications. Learn best practices for implementing expandable content sections with proper accessibility and keyboard support.

# Accordion

***(Also called collapsible panels)***

## Overview

An **accordion** is a UI component that consists of a vertically stacked list of headers that can be expanded or collapsed to reveal or hide related content. It helps conserve screen space by displaying content in a structured and interactive way.

Accordions are commonly used for **FAQs, settings panels, and structured content** where users need to access multiple sections without scrolling through all the information at once.

## Use Cases

### When to use:

Use an accordion when you need to present **structured content that benefits from progressive disclosure**.

**Common use cases include:**

* **FAQs (Frequently Asked Questions)** – Helps users find answers quickly.
* **Settings and Preferences** – Organizes options into collapsible categories.
* **Product Details or Features** – Allows users to expand sections they are interested in.
* **Documentation or Guides** – Presents step-by-step content in an organized way.
* **Navigation and Filtering** – Used in sidebars for hierarchical content.

### When not to use:

* If **all content needs to be visible at once** (e.g., comparison tables).
* When **content is too short**—collapsing small amounts of text may reduce usability.
* If frequent **switching between sections is necessary**—a tabbed interface might be better.
* When users need to **view multiple sections at the same time** (e.g., Terms and Conditions) —consider popovers, modals, or side panels instead.
* If content requires **deep nesting of multiple levels**, a structured outline or table of contents may work better.

## Benefits

* **Saves space** by showing only relevant content when needed.
* **Improves readability** by reducing visual clutter.
* **Enhances usability** by grouping related content.
* **Optimizes mobile experiences** by minimizing scroll length.

## Drawbacks

* **Hides content by default**, requiring extra interaction to access information.
* **Can make scanning content harder**, especially if multiple sections are collapsed.
* **May not work well for all content types**, particularly if users need to see multiple sections at once.
* **Can have accessibility issues** if not correctly implemented with ARIA roles.
* **Excessive nesting** of accordions can create a poor user experience.

## Anatomy

```mermaid
graph TD
    A[Accordion] --> B[Accordion Item 1]
    A --> C[Accordion Item 2]

    B --> D[Header Trigger 1]
    B --> E[Accordion Icon 1]
    B --> F[Content Panel 1]

    C --> G[Header Trigger 2]
    C --> H[Accordion Icon 2]
    C --> I[Content Panel 2]
```

### Component Structure

1. **Accordion Container**

* Wraps all the accordion items.
* Handles state management (e.g., open/close behavior).
* Should provide appropriate aria-label for screen reader users.

2. **Accordion Item**

* A single collapsible section consisting of a header (trigger) and a content panel.

3. **Accordion Header (Trigger)**

* The clickable element that expands/collapses the associated content.
* Should be a button element for accessibility.
* Must contain aria-expanded="true|false" to indicate state.

4. **Accordion Icon**

* Provides a visual cue of the accordion state (collapsed or expanded).
* Common examples: chevron icons (▼/▲), plus/minus (+/−).
* Should rotate or change appearance when toggled.
* Must be visually distinguishable and large enough for touch interaction.

5. **Accordion Content Panel**

* The collapsible section that appears when triggered.
* Should be associated with its header via aria-controls and aria-labelledby.
* Must use aria-hidden="true|false" to indicate visibility to screen readers.

#### **Summary of Components**

| Component     | Required? | Purpose                                          |
| ------------- | --------- | ------------------------------------------------ |
| Container     | ✅ Yes     | Wraps all accordion items together.              |
| Item          | ✅ Yes     | Represents an individual expandable section.     |
| Trigger       | ✅ Yes     | Toggles the visibility of the accordion content. |
| Icon          | ✅ Yes     | Indicates open/closed state (e.g., chevron).     |
| Content Panel | ✅ Yes     | Holds the content that expands/collapses.        |

## Best Practices

### Content & Usability

**Do's ✅**

* **Keep headers clear and concise**—they should describe the content inside.
* **Use progressive disclosure**—prioritize showing only essential information first.
* **Ensure logical grouping**—group related items under the same accordion.
* **Maintain consistent styling**—avoid varying sizes or colors for different headers.

**Don'ts ❌**

* **Don't overload sections**—too much content defeats the purpose of an accordion.
* **Avoid unnecessary animations**—fast, smooth transitions improve usability.
* **Don't use accordions for essential content**—ensure users can still access key information easily.

### Default Open Behavior

**Do's ✅**

* **Decide based on user expectations**—if the first section contains critical information, it may be beneficial to start expanded.
* **Keep the first accordion open** in **FAQs, tutorials, or onboarding flows** where users need immediate guidance.
* **Ensure consistency**—if one accordion is open by default, follow the same pattern across the UI.
* **Provide a clear visual indicator** when an accordion is expanded to avoid confusion.

**Don'ts ❌**

* **Don't force the first section open if the content is non-essential**—let users decide what they need.
* **Avoid inconsistent behavior**—mixing some open and some closed sections can be confusing.
* **Don't prevent users from collapsing the first accordion**—they should be able to close it if they want.

### Icon Placement & Behavior

#### **Placement**

**Do's ✅**

* **Place the icon at the beginning of the header** for better usability, especially for users relying on screen magnification.
* **Ensure the icon remains visually distinguishable**—it should not blend into the text.
* **Make sure the icon is keyboard accessible** and updates its state (`aria-expanded`).
* **Test different placements** in usability studies to determine what works best for your audience.

**Don'ts ❌**

* **Avoid placing the icon too far from the trigger text**—users may not associate them.
* **Don't rely solely on the icon** to indicate expansion—ensure there is a visual or textual cue as well.
* **Avoid animations that make the icon movement too subtle**—it should clearly show state changes.

#### **Behavior**

**Do's ✅**

* **Use an intuitive icon** (e.g., `+` → `−`, or chevron pointing up/down).
* **Ensure the icon changes state** when the accordion is expanded or collapsed.
* **Animate icon transitions smoothly** (e.g., rotate chevron instead of abruptly changing it).
* **Make the icon large enough** to be tappable on mobile devices.

**Don'ts ❌**

* **Don't rely only on the icon** to indicate expansion—also update `aria-expanded` and visually differentiate expanded sections.
* **Avoid using icons that do not clearly indicate** expansion and collapse states.
* **Don't use overly complex animations** that slow down interactions.

### Accessibility

**Do's ✅**

* **Use semantic HTML**—accordion triggers should be `button` elements.
* **Implement `aria-expanded`** to indicate open/closed states.
* **Ensure focus management**—moving between sections should be intuitive.
* **Support keyboard navigation**—allow arrow keys for cycling and `Enter` or `Space` to toggle.

**Don'ts ❌**

* **Don't trap focus** inside an expanded panel.
* **Avoid using `display: none;` on content**—instead, use `visibility` or `aria-hidden` for screen readers.

### Layout & Design

**Do's ✅**

* **Ensure clear distinctions** between expanded and collapsed states.
* **Provide smooth animations** (e.g., height transitions) to improve the user experience.
* **Use appropriate spacing** between items to avoid visual clutter.
* **Align icons and headers consistently** to maintain a structured appearance.

**Don'ts ❌**

* **Don't make accordions too small or too large**—users should easily scan headers.
* **Avoid inconsistent alignment**—headers, icons, and content should be visually aligned.
* **Don't place icons too far from the header text**, making it difficult to associate them with the toggle action.

## Tracking

Tracking accordion interactions helps measure user engagement, assess whether users find the hidden content valuable, and determine if sections should be expanded by default. By analyzing user behavior, we can optimize when and how accordions are used.

### Key Tracking Points

Each accordion interaction provides valuable insights into user behavior. Below are the key events that should be tracked:

| **Event Name**           | **Description**                                                       | **Why Track It?**                                          |
| ------------------------ | --------------------------------------------------------------------- | ---------------------------------------------------------- |
| `accordion.view`         | When the accordion component enters the viewport.                     | Determines visibility and content discovery.               |
| `accordion.expand`       | When a user expands an accordion section.                             | Measures engagement and demand for additional information. |
| `accordion.collapse`     | When a user collapses an accordion section.                           | Helps analyze whether users return to a condensed view.    |
| `accordion.auto_expand`  | When a section expands automatically (e.g., pre-expanded by default). | Determines if auto-expansion leads to better engagement.   |
| `accordion.read_time`    | The time a user spends with the expanded content visible.             | Helps measure content consumption.                         |
| `accordion.all_expand`   | When a user expands **all** sections at once (if supported).          | Indicates if users prefer all content visible upfront.     |
| `accordion.all_collapse` | When a user collapses **all** sections at once.                       | Tracks behavior when content is condensed back.            |

### Event Payload Structure

To ensure consistent tracking, here’s a recommended event format:

```json
```

### Key Metrics to Analyze

Once tracking is in place, the following metrics provide actionable insights:

* **Expand Rate** → Percentage of users who expand at least one section.
* **Collapse Rate** → Percentage of users who collapse a section after expanding it.
* **Average Read Time** → How long users keep an expanded section open.
* **Auto-Expand vs. Manual Expand Rate** → Helps assess whether users prefer content pre-expanded or manually triggered.
* **Multi-Expand Rate** → Percentage of users expanding multiple sections in a session.

### Insights & Optimization Based on Tracking

By analyzing tracking data, we can optimize the accordion experience:

* 🚨 **Low Expand Rate?**
  → Users may not notice the accordion sections or find them unnecessary.
  **Optimization:** Improve section titles for clarity, make expansion triggers more prominent, or test making key sections pre-expanded.

* ⏳ **Short Read Time After Expand?**
  → Users may not be engaging with the expanded content.
  **Optimization:** Ensure content is concise, scannable, and well-structured. Test alternative formats such as inline content or tabs.

* 🔄 **High Collapse Rate?**
  → Users might be overwhelmed by too much content or prefer a more condensed view.
  **Optimization:** Reduce section length, highlight key takeaways in the collapsed state, or introduce progressive disclosure.

* 🔁 **High Multi-Expand Rate?**
  → Users frequently expand multiple sections, which may indicate that all content is relevant.
  **Optimization:** Consider whether an **accordion** is the right UI choice, or if a fully expanded layout would improve readability.

* ⚙️ **Auto-Expand Not Leading to Higher Engagement?**
  → Automatically expanded sections may be ignored.
  **Optimization:** A/B test auto-expanded vs. manually triggered content to determine user preference.

By continuously monitoring these metrics, we can refine accordion usability, ensuring users efficiently access necessary information while avoiding unnecessary interactions.

## Code Example

### **Method 1: Using `<button>` and aria-expanded (ARIA Approach and Recommended)**

```html
<section class="accordion">
  <h2 class="accordion-title">Frequently Asked Questions</h2>

  <div class="accordion-item">
    <h3 id="accordion1-heading">What is an accordion?</h3>
    <button
      class="accordion-trigger"
      aria-expanded="false"
      aria-controls="panel1"
      aria-labelledby="accordion1-heading"
    >
      <span class="accordion-icon" aria-hidden="true">▼</span>
    </button>
    <section
      id="panel1"
      role="region"
      aria-labelledby="accordion1-heading"
      class="accordion-content"
      hidden
    >
      <p>
        An accordion is a UI pattern that expands and collapses content
        sections.
      </p>
    </section>
  </div>

  <div class="accordion-item">
    <h3 id="accordion2heading">When should I use an accordion?</h3>
    <button
      class="accordion-trigger"
      aria-expanded="false"
      aria-controls="panel2"
      aria-labelledby="accordion2-heading"
    >
      <span class="accordion-icon" aria-hidden="true">▼</span>
    </button>
    <section
      id="panel2"
      role="region"
      aria-labelledby="accordion2-heading"
      class="accordion-content"
      hidden
    >
      <p>
        Use an accordion when you want to organize content into collapsible
        sections.
      </p>
    </section>
  </div>
</section>

<script>
  document.querySelectorAll(".accordion-trigger").forEach((button) => );
</script>

<style>
  .accordion 

  .accordion-item 

  .accordion-trigger 

  .accordion-content 

  .accordion-trigger[aria-expanded="true"] + .accordion-content 

  .accordion-icon 

  .accordion-trigger[aria-expanded="true"] .accordion-icon 
</style>
```

**Pros ✅**

* Full styling flexibility—no browser-imposed limitations.
* Explicit aria-expanded handling—better screen reader support.
* More customization options—e.g., "only one section open at a time" behavior.

**Cons ❌**

* Requires JavaScript to toggle states.
* More implementation complexity compared to `<details>`.

### **Method 2: Using `<details>` and `<summary>` (Native Approach)**

This approach leverages **native browser behavior** without requiring JavaScript.

```html
<section class="accordion">
  <h2>Frequently Asked Questions</h2>

  <details>
    <summary id="accordion1">What is an accordion?</summary>
    <div id="panel1">
      <p>
        An accordion is a UI component that allows users to expand and collapse
        sections of content.
      </p>
    </div>
  </details>

  <details>
    <summary id="accordion2">How does it improve user experience?</summary>
    <div id="panel2">
      <p>
        Accordions help reduce clutter and make information easier to digest,
        enhancing the overall user experience.
      </p>
    </div>
  </details>
</section>

<style>
  details 

  summary 

  details[open] summary 
</style>
```

**Pros ✅**

* No JavaScript required—fully functional with just HTML & CSS.
* Keyboard accessible by default—users can navigate with Tab and toggle with Enter.
* Simpler implementation with native support.

**Cons ❌**

* Limited styling control—some browsers restrict `<summary>` styling.
* No aria-expanded state by default—some screen readers may not properly announce expansion.
* All items can be expanded at once—doesn't support "only one section open" behavior.

### When to use a tabbed carousel vs grouped carousel?

Use the **decision tree** below to determine the right method:

```mermaid
graph TD
  A[Do you need full control over styling and behavior?] -->|Yes| B[Use Button + ARIA Accordion]
  A -->|No| C[Do you want a native solution with minimal code?]
  C -->|Yes| D[Use Native <details> Accordion]
  C -->|No| B[Use Button + ARIA Accordion]
```

For a detailed breakdown of feature differences, refer to the table below:

| Feature                                     | `<details>` Accordion                         | `<button>` + ARIA Accordion                                 |
| ------------------------------------------- | --------------------------------------------- | ----------------------------------------------------------- |
| **Requires JavaScript?**                    | ❌ No                                          | ✅ Yes (for toggling state and enforcing behavior)           |
| **Supports full styling?**                  | ❌ Limited (some browser-imposed restrictions) | ✅ Yes (full control over appearance)                        |
| **Explicit screen reader support?**         | ❌ No (`aria-expanded` missing by default)     | ✅ Yes (`aria-expanded`, `aria-controls`, `aria-labelledby`) |
| **Supports keeping only one section open?** | ❌ No                                          | ✅ Yes (requires JavaScript)                                 |
| **Keyboard accessibility?**                 | ✅ Built-in (natively accessible)              | ✅ Requires explicit keyboard handling                       |
| **Best for**                                | Simple FAQs or basic collapsible sections     | Custom-designed accordions with more control over behavior  |

## Accessibility

### Keyboard Interaction Pattern

The following table outlines the standard keyboard interactions for accordion components. These interactions ensure that users can navigate and operate accordions effectively using only a keyboard.

| Key                   | Action                                                                                                  |
| --------------------- | ------------------------------------------------------------------------------------------------------- |
| Enter or Space        | • Expand a collapsed panel; collapse all others<br/>• Collapse an expanded panel                        |
| Tab                   | Move focus to the next focusable item in the tab sequence. Focus will progress into an accordion panel. |
| Shift + Tab           | Move focus to the previous focusable item in the tab sequence                                           |
| Down Arrow (Optional) | Move focus to the next accordion header                                                                 |
| Up Arrow (Optional)   | Move focus to the previous accordion header                                                             |
| Home (Optional)       | Move focus to the first accordion header                                                                |
| End (Optional)        | Move focus to the last accordion header                                                                 |

> **Note**: Keys marked as optional may be omitted in some accordion implementations. The example in this documentation implements all optional keys for enhanced accessibility.

## Testing Guidelines

### Functional Testing

**Should ✓**

* [ ] Ensure each accordion section **expands and collapses correctly** when clicked.
* [ ] Verify that only **one section opens at a time**, if the accordion is set to single expansion mode.
* [ ] Confirm that the **content remains readable** and does not overlap when expanded.
* [ ] Ensure that **expanded sections persist when navigating back** (if applicable).
* [ ] Validate that accordion headers **do not shift layout unexpectedly** when toggled.

### Icon Behavior Testing

**Should ✓**

* [ ] Verify that the **accordion icon changes state** when toggling (`+` → `−` or chevron direction flips).
* [ ] Ensure the **icon animation is smooth** and not visually jarring.
* [ ] Confirm that **screen readers announce the icon state correctly** (`aria-expanded` updates accordingly).
* [ ] Ensure the icon is **visually clear and distinguishable** at different sizes and contrast levels.

### Accessibility Testing

**Should ✓**

* [ ] Verify that **screen readers announce expanded and collapsed states** correctly (`aria-expanded` updates).
* [ ] Ensure **keyboard accessibility**—users can navigate with `Tab`, toggle with `Enter`/`Space`, and move between headers using `Arrow Keys`.
* [ ] Check that the **accordion content remains accessible** even when collapsed (`aria-hidden` is handled properly).
* [ ] Test with **reduced motion preferences** to ensure animations do not interfere with usability.
* [ ] Confirm that **accordion icons are not the only indicator** of expansion state—there should be text changes or ARIA attributes as well.

### Visual Testing

**Should ✓**

* [ ] Validate that the **accordion headers are visually distinct** in both collapsed and expanded states.
* [ ] Ensure smooth and **non-jarring animations** when expanding or collapsing.
* [ ] Verify that **content does not clip or overlap** when expanded on different screen sizes.
* [ ] Check **responsive behavior** to ensure the accordion adapts well across breakpoints.
* [ ] Ensure **icon alignment is consistent** across all accordion headers.

### Performance Testing

**Should ✓**

* [ ] Ensure that **accordion interactions are smooth** and do not introduce lag.
* [ ] Confirm that excessive DOM updates **do not slow down rendering**.
* [ ] Verify that accordions **do not cause unnecessary reflows** when toggled.
* [ ] Test large datasets inside the accordion to ensure **acceptable performance**.

## Design Tokens

These design tokens follow the [Design Tokens Format](https://design-tokens.github.io/community-group/format/) specification and can be used with various token transformation tools to generate platform-specific variables.

### Accordion Tokens in DTF Format

```json
{
  "$schema": "https://design-tokens.org/schema.json",
  "accordion": {
    "header": {
      "fontWeight": ,
      "fontSize": ,
      "padding": ,
      "background": ,
      "textColor": 
    },
    "icon": {
      "size": ,
      "color": ,
      "transition": 
    },
    "content": {
      "padding": ,
      "background": ,
      "textColor": ,
      "lineHeight": 
    },
    "border": {
      "width": ,
      "color": ,
      "radius": 
    },
    "transition": 
  }
}
```

## Frequently Asked Questions

for the accordion headers, manage focus states, and implement ARIA attributes such as aria-expanded to indicate the state of each section.",
},
,
,
]}
/>

## Resources

### Articles

* [Accordions on Desktop: When and How to Use - Nielsen Norman Group](https://www.nngroup.com/articles/accordions-on-desktop/)
* [Accordion Icons: Which Signifiers Work Best? - Nielsen Norman Group](https://www.nngroup.com/articles/accordion-icons/)

### Documentation

-[Accordion Pattern | WAI](https://www.w3.org/WAI/ARIA/apg/patterns/accordion/)

### Libraries

* [Accordion - Origin UI](https://originui.com/accordion)


# CONTENT-MANAGEMENT: [Carousel](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/content-management/carousel)

Build effective carousel components for your web applications. Learn best practices for implementing accessible, responsive carousels with proper navigation and touch support.

# Carousel

***(Also called slider, slideshow, image rotator)***

## Overview

A **carousel** is a UI component that displays a set of content or images in a rotating or sliding manner. Users can navigate through the content using arrows, dots, or swipe gestures on touch devices.

Carousels are often used to showcase featured content, promotions, or image galleries in a limited space.

## Use Cases

### When to use:

Use a carousel when you need to display a **series of related content or images in a limited space** while keeping users engaged.

**Common use cases include:**

* Showcasing featured products or services (e.g., homepage promotions)
* Highlighting key messages or storytelling (e.g., step-by-step guides)
* Displaying a portfolio of work or case studies
* Presenting testimonials or customer reviews
* Guiding users through a multi-step process or tutorial
* Featuring news updates or event announcements

### When not to use:

* When the content is critical for users to see or interact with immediately
* If the content doesn't have a clear relationship or narrative flow
* When users need to compare items side-by-side or view all options at once
* If the carousel contains too many items, making navigation cumbersome
* When the content is complex or requires significant reading time

## Benefits

* Maximizes the use of limited screen space for featuring content
* Helps guide users through a series of related items or messages
* Can increase engagement and time spent on a page
* Allows for visual storytelling and brand expression
* Provides an interactive element for users to explore

## Drawbacks

* **Low engagement rates**, as users often ignore or miss slides.
* **Performance-heavy**, especially with large images or auto-rotation.
* **Accessibility issues**, particularly for keyboard and screen reader users.
* **Not ideal for displaying critical content**, as users may not interact with all slides.
* **Auto-rotation can be frustrating**, especially if there is no pause control.

## Anatomy

```mermaid
graph TD
    A[Carousel] --> B[Container]
    B --> C[Content Wrapper]
    B --> D[Navigation Controls]
    B --> E[Pagination]
    B --> P[See All Link]

    C --> F[Slides]
    F --> G[Slide 1]
    F --> H[Slide 2]
    F --> I[Slide n...]

    D --> J[Previous Button]
    D --> K[Next Button]

    E --> L[Pagination Dots]

    G --> M[Image]
    G --> N[Caption]
    G --> O[Content]
```

### Component Structure

1. **Container**

* Wraps the carousel content and controls
* Defines the visible area and overall dimensions of the carousel
* Can have a border, background color, or shadow to visually separate it from other content

2. **Content Wrapper**

* Contains the individual carousel slides or items
* Allows for smooth transitioning between slides
* Often uses CSS transforms or absolute positioning for slide placement

3. **Slides**

* The individual content items displayed within the carousel
* Can contain images, text, videos, or other interactive elements
* Should have consistent dimensions and styling for a cohesive appearance

4. **Navigation Arrows**

* Allow users to manually advance or go back through the carousel slides
* Typically placed on the left and right sides of the carousel
* Should have clear hover and focus states for accessibility

5. **Pagination Dots**

* Indicate the total number of slides and the current active slide
* Allow users to quickly jump to a specific slide
* Often placed below the carousel content for easy access

6. **"See All" Link (Optional)**

* Recommended when the carousel displays a subset of a larger collection (e.g., latest articles, featured products).
* Provides a way for users to access more related content beyond what's shown in the carousel
* Typically placed near the carousel, often below the slides or next to the pagination dots
* Should have a clear and descriptive label indicating where it will take the user (e.g., "See All Products", "View More Cases")
* Should be styled as a text link rather than a button to indicate navigation rather than an action.

7. **Captions (Optional)**

* Provide additional context or information about each slide
* Can be overlaid on the slide image or placed below the slide
* Should be concise and not obstruct the main slide content

#### **Summary of Components**

| Component             | Required? | Purpose                                                 |
| --------------------- | --------- | ------------------------------------------------------- |
| Container             | ✅ Yes     | Wraps the entire carousel component.                    |
| Slides Wrapper        | ✅ Yes     | Contains all slide elements.                            |
| Slide                 | ✅ Yes     | Represents each individual content item.                |
| Navigation Arrows     | ✅ Yes     | Allows users to move between slides.                    |
| Pagination Indicators | ❌ No      | Shows the current position within the carousel.         |
| Autoplay Controls     | ❌ No      | Allows users to start/stop automatic slide transitions. |

## Best Practices

### Content

**Do's ✅**

* **Keep slide content focused and concise** for easy scanning.
* Use **high-quality, visually compelling images** that support the content message.
* Ensure **slide content is mobile-friendly** and legible on smaller screens.
* Provide **meaningful alt text** for slide images.
* **Keep the number of slides manageable** to avoid carousel fatigue.
* **Include a "See All" link** to direct users to a dedicated page with more related content (e.g., "See All Case Studies").

**Don'ts ❌**

* **Don't rely solely on the carousel** to convey critical information.
* Avoid **using too much text** or overly complex layouts within slides.
* **Don't make the carousel autoplay** without also providing pause/stop controls.
* **Don't use the carousel as a primary navigation mechanism** for your site.

***

### Accessibility

**Do's ✅**

* **Ensure all slide content and controls are keyboard accessible**.
* **Provide ARIA labels** for navigation elements and slide content.
* **Allow users to pause or stop auto-rotating carousels**.
* **Give users sufficient time** to read and interact with each slide.
* **Make navigation controls large enough** for easy clicking or tapping.
* **Ensure the "See All" link is keyboard accessible** and has a clear focus state.
* **Provide a meaningful ARIA label** for the "See All" link that describes its purpose.
* **Add `prefers-reduced-motion` to disable animations** for users with motion sensitivity.
* Optionally, **provide a "Reduce Motion" toggle** for users who prefer less movement.

**Don'ts ❌**

* **Don't autoplay content** that contains animation or video without user consent.
* Avoid **carousel designs that trap keyboard focus** within the component.
* **Don't hide navigation controls** or make them difficult to find.
* **Don't change slide content or position** while the user is interacting with it.

***

### Visual Design

**Do's ✅**

* **Use consistent design patterns** and styling for all carousel elements.
* **Provide ample visual contrast** for text and interactive components.
* **Ensure slide transitions are smooth** and not visually jarring.
* **Use navigation indicators** that clearly convey the current slide position.
* **Optimize slide images for fast loading** and performance.

**Don'ts ❌**

* **Don't use overly distracting transition effects** that detract from the content.
* Avoid **low contrast or hard-to-read text** over busy background images.
* **Don't make the carousel unnecessarily large** or overwhelming on the page.

***

### Layout & Positioning

**Do's ✅**

* **Position the carousel in a prominent location** that supports its content purpose.
* **Ensure the carousel scales and adapts responsively** to different screen sizes.
* **Provide ample spacing** between the carousel and surrounding page elements.
* **Left-align slide content** for easier reading and scanning.
* **Place navigation controls in intuitive** and easy-to-reach locations.

**Don'ts ❌**

* **Don't place the carousel too low** on the page where users might miss it.
* Avoid **positioning the carousel in a way that obstructs other important content**.
* **Don't force users to scroll unnecessarily** to view the full carousel on smaller screens.
* **Don't overcrowd the carousel area** with too many competing elements or CTAs.

***

### Performance Optimization

**Do's ✅**

* Use **lazy loading** (`loading="lazy"`) for images to reduce initial page load time.
* Optimize **carousel animations** using GPU-accelerated properties (e.g., `transform` instead of `margin`).
* Minimize **reflows and repaints** by ensuring smooth transitions and avoiding layout shifts.
* Reduce **event listener impact** by throttling or debouncing resize and scroll events.
* Ensure efficient **resource management** to prevent memory leaks and excessive CPU usage.
* Optimize **JavaScript execution** by deferring non-critical scripts and avoiding blocking tasks.

**Don'ts ❌**

* Don't load **off-screen images immediately**—defer loading until they are about to be displayed.
* Avoid **complex animations** that trigger layout recalculations (e.g., changing `width` or `height` dynamically).
* Don't overuse **box shadows and filters**, as they can slow down rendering performance.
* Avoid **large DOM structures**—if the carousel contains many slides, use virtualized rendering.
* Don't use **excessive animations** that could impact performance on lower-powered devices.

### Common Mistakes & Anti-Patterns

#### Auto-Play Without Controls

**❌ What’s Wrong?** Users might not have enough time to read or interact with content, and constantly rotating slides can disorient or frustrate them—especially those using assistive technologies.

**How to Fix It?** Always provide **pause/play controls**. Respect `prefers-reduced-motion` by disabling or slowing auto-rotation for users who prefer less animation.

***

#### No Keyboard or Touch Support

**❌ What’s Wrong?** Carousels often exclude users who rely on keyboard navigation or expect swipe gestures on mobile devices.

**How to Fix It?** Ensure you can navigate slides via `Tab` and arrow keys. Add swipe or drag support for mobile. Test thoroughly across various devices and accessibility tools.

***

#### Hiding Important Content in Later Slides

**❌ What’s Wrong?** Many users never click past the first slide, missing crucial information if it’s hidden further down the carousel.

**How to Fix It?** Place the most essential content **in the first slide**. If the content is critical, consider using a static layout or highlight it differently so users don’t need to scroll or click.

***

#### Lack of Visible Pagination

**❌ What’s Wrong?** Without pagination dots or numbers, users can’t tell how many slides there are or where they are within the sequence.

**How to Fix It?** Provide **clear pagination** (e.g., dots, numeric indicators) and label them properly (e.g., `aria-label="Go to slide 2"`).

***

#### Missing or Incorrect ARIA Labels

**❌ What’s Wrong?** If navigation buttons and slides lack descriptive labels, screen readers can’t convey their function or content.

**How to Fix It?** Use attributes like `aria-label="Next Slide"` on arrows, `role="tabpanel"` for slides, and `aria-roledescription="carousel"` on the container. Include a descriptive `aria-label` (e.g., `"Featured Products Carousel"`) so users know the carousel’s purpose.

***

#### No Clear Focus Indicator

**❌ What’s Wrong?** Keyboard users can lose track of where they are if there’s no visible focus outline on controls or slides.

**How to Fix It?** Ensure buttons, dots, or slide links have a **high-contrast focus style**. Test with keyboard-only navigation to confirm you never lose focus.

***

#### Inconsistent Screen Reader Announcements

**❌ What’s Wrong?** If slide changes aren’t announced, users with screen readers won’t realize content has updated.

**How to Fix It?** Use `aria-live="polite"` regions or update `aria-hidden` states so that each new slide is announced. Label slides accordingly (e.g., `"Slide 2 of 5"`).

***

#### Overloaded Slide Content

**❌ What’s Wrong?** Placing too many interactive elements or large blocks of text in a single slide can overwhelm keyboard or screen reader users.

**How to Fix It?** Keep each slide **focused and concise**. If extra content is necessary, link to a dedicated page or consider an alternative layout that isn’t a carousel.

## Micro-Interactions & Animations

For a carousel component, implement these specific animations to enhance user experience:

* **Slide Transition Animation:**

  * **Effect:** Animate a smooth horizontal (or vertical) slide where the current slide moves out while the next slide slides in.
  * **Timing:** Aim for a 300ms transition with an ease-in-out timing function to create a natural flow.

* **Fade Transition (Optional):**

  * **Effect:** Instead of sliding, optionally fade the outgoing slide out and the incoming slide in, offering a softer transition.
  * **Timing:** Use a fade duration of approximately 300ms for consistency.

* **Navigation Controls (Arrows):**

  * **Hover:** Apply a subtle scale-up (e.g., to 1.05×) or color change when the user hovers over the arrow buttons, clearly indicating interactivity.
  * **Active/Click:** Trigger a brief pulse or slight scale-up effect (completing within 150–200ms) when a navigation arrow is clicked.

* **Indicator Animations:**

  * **Effect:** For carousel indicators (e.g., dots), animate the active state by scaling the active dot slightly or changing its color to visually distinguish it from inactive indicators.
  * **Timing:** Keep the indicator animation brief (around 150–200ms) for immediate feedback.

* **Auto-Play & Swipe Feedback:**

  * **Effect:** For auto-playing carousels or when swiping, ensure that transitions remain smooth and consistent. Provide a responsive drag/swipe animation with a slight resistance effect at the edges.
  * **Timing:** Use the same 300ms transition timing as manual navigation to maintain consistency.

* **Reduced Motion Considerations:**
  * **Implementation:** Detect user preferences (e.g., via the `prefers-reduced-motion` media query) and reduce or disable these animations accordingly to ensure accessibility.

## Tracking

Tracking carousel interactions helps measure engagement, detect usability issues, and optimize content placement. By capturing key user actions, we can analyze how effectively the carousel is driving interaction and whether users engage with slides beyond the first one.

### Key Tracking Points

Each carousel interaction provides valuable insights into user behavior. Below are the key events that should be tracked:

| **Event Name**               | **Description**                                    | **Why Track It?**                                                |
| ---------------------------- | -------------------------------------------------- | ---------------------------------------------------------------- |
| `carousel.view`              | When the carousel first enters the viewport.       | Helps determine if users even see the carousel.                  |
| `carousel.slide_change`      | When a user navigates to a different slide.        | Measures engagement and content interest.                        |
| `carousel.auto_rotate_pause` | When a user **pauses auto-rotation** (if enabled). | Indicates if auto-rotation is frustrating users.                 |
| `carousel.click`             | When a user clicks on a slide.                     | Helps measure which slides attract the most attention.           |
| `carousel.swipe`             | When a user swipes on mobile.                      | Tracks touch engagement separately from clicks.                  |
| `carousel.see_all_click`     | When users click the **"See All"** link.           | Indicates if users want more content than the carousel provides. |

### Event Payload Structure

To ensure consistent tracking, here’s a recommended event format:

```json
```

### Key Metrics to Analyze

Once tracking is in place, the following metrics provide actionable insights:

* Engagement Rate → Percentage of users who interact with the carousel.
* Slide Completion Rate → Percentage of users who view all slides.
* Drop-off Rate → Percentage of users who only see the first slide before leaving.
* Click-Through Rate (CTR) → Percentage of users clicking on any slide.
* Auto-Play Pause Rate → How often users stop auto-rotation (if enabled).

### Insights & Optimization Based on Tracking

By analyzing tracking data, we can optimize the carousel experience:

* 📉 **High Drop-off Rate?**
  → Users might not be interested in later slides. Consider making the first slides more engaging, reducing the number of slides, or testing a different pattern (e.g., a grid or tabbed interface).

* 🔄 **Frequent Auto-Play Pauses?**
  → Users may find auto-rotation too fast or distracting. Slow down transitions, increase delay times, or disable autoplay by default.

* 📊 **Low Click-Through Rate (CTR)?**
  → The slides might not be engaging enough. Test different visuals, headlines, and CTAs to improve interaction.

* 📱 **More Swipes than Clicks?**
  → Mobile users may interact differently than desktop users. Optimize for touch gestures and ensure swipe responsiveness.

* 🚀 **High "See All" Click Rate?**
  → The carousel might not be displaying enough relevant content upfront. Consider making more items visible at once or leading users to a dedicated content hub.

By continuously monitoring these metrics, we can refine the carousel’s effectiveness and improve overall user engagement.

## Localization

The carousel component contains several interactive elements that require localization. This includes visible labels for buttons and controls, as well as ARIA labels for screen readers. The following JSON structure provides a comprehensive set of strings that should be translated for each supported language.

Note that for right-to-left (RTL) languages, you may need to adjust the direction of navigation arrows and content flow accordingly.

```json
{
  "carousel": {
    "next_slide": ,
    "previous_slide": ,
    "pause_autoplay": ,
    "play_autoplay": ,
    "pagination": ,
    "current_slide_indicator": ,
    "see_all": 
  }
}
```

## Code Examples

### Basic Implementation

#### Tabbed Carousel

The Tabbed Carousel provides a clean, tab-style navigation system where users can switch between individual content panels. This pattern is particularly effective when each slide contains detailed information that deserves focused attention.

#### Grouped Carousel

The Grouped Carousel displays multiple items simultaneously, allowing users to browse through collections of related content. This implementation is ideal for showcasing product collections, image galleries, or any scenario where viewing items in groups enhances the user experience.

## Accessibility

When to use a tabbed carousel vs grouped carousel?

**Use a Tabbed Carousel When:**

* ✅ **You have a small number of slides** – Since each slide has a dedicated tab, a large number of slides can clutter the UI.
* ✅ **Users should be able to jump between slides easily** – Tabs allow direct navigation to any slide without needing to cycle through sequentially.
* ✅ **Your slides contain detailed, structured content** – If each slide functions as a self-contained panel (like feature descriptions, product highlights, or news sections), a tabbed interface enhances accessibility.
* ✅ **Users rely on assistive technologies** – Tabs follow a clear WAI-ARIA Tabs Pattern, making them easier to navigate via screen readers and keyboard interactions.
* ✅ **You want a more structured navigation experience** – Since users can visually scan and select a tab, they get a better sense of available content without guessing.

Example Use Cases for Tabbed Carousels:

* Showcasing key product features (e.g., "Performance," "Design," "Battery Life")
* Tabbed tutorials with each step being its own slide
* Multi-category content previews where users need to jump between different sections

**Use a Grouped Carousel When:**

* ✅ **Each "slide" contains multiple grouped items** – This is ideal when slides are made up of sets of images or content blocks rather than a single element.
* ✅ **The focus is on scanning a collection, not individual elements** – A grouped layout is better when users should browse multiple options at once.
* ✅ **You want minimal interaction but more content visible per slide** – Instead of making users navigate one-by-one, grouped carousels allow them to view several options at a glance.
* ✅ **Direct navigation to specific slides isn't a priority** – Unlike tabs, grouped carousels usually rely on "previous" and "next" controls, making them better for sequential browsing.
* ✅ **Keyboard navigation and focus management should be simpler** – Since each button represents a group rather than an individual tab, there are fewer interactive elements in the keyboard tab sequence, reducing accessibility complexity.

Example Use Cases for Grouped Carousels:

* Product galleries displaying multiple related items per slide
* Portfolio showcases with sets of images per section
* Multi-product promotions where multiple items appear in a single frame
* News or blog carousels where grouped articles rotate

Use the **decision tree** below to determine the right carousel type:

```mermaid
graph TD
  A[Do users need direct navigation to specific slides?] -->|Yes| B[Use Tabbed Carousel]
  A -->|No| C[Do slides contain multiple items per group?]
  C -->|Yes| D[Use Grouped Carousel]
  C -->|No| E[Do you need structured, labeled content panels?]
  E -->|Yes| B[Use Tabbed Carousel]
  E -->|No| F[Do users primarily browse sequentially?]
  F -->|Yes| D[Use Grouped Carousel]
  F -->|No| B[Use Tabbed Carousel]
```

For a **detailed breakdown** of feature differences, refer to the table below:

| Feature                   | Tabbed Carousel                                                                      | Grouped Carousel                                             |
| ------------------------- | ------------------------------------------------------------------------------------ | ------------------------------------------------------------ |
| **Direct Navigation**     | Users can pick any slide directly via tabs                                           | Users must cycle through sequentially                        |
| **Content Density**       | Displays one item per slide                                                          | Displays multiple items per slide                            |
| **Keyboard-Friendly**     | Implements full **Tabs Pattern** (`role="tablist"`, `role="tab"`, `role="tabpanel"`) | Simpler button interactions, with fewer interactive elements |
| **Screen Reader Support** | Uses **role="tablist"** for tab navigation and **role="tabpanel"** for content       | Uses **role="group"** for logical grouping of multiple items |
| **Best for**              | Interactive, information-heavy content                                               | Browsing collections of items                                |

### ARIA Attributes

This section outlines the **required ARIA attributes** for carousels, covering both **Tabbed Carousels** (where slides are controlled via tabs) and **Grouped Carousels** (where slides contain multiple items and are controlled by buttons).

***

### **General ARIA Attributes (Applicable to All Carousels)**

* **Carousel container**:

  * Use a `<section>` or `role="region"`\*
  * `aria-label` for a descriptive name\*
  * `aria-roledescription="carousel"`

  \* Alternatively, use `<section>` with `aria-labelledby` to link to the carousel title.

* **Controls group**:

  * `role="group"`
  * `aria-label="Carousel controls"`

* **Individual slides**:

  * `role="group"`
  * `aria-roledescription="slide"`
  * `aria-label` for position information (e.g., `"Slide 2 of 5"`)

* **Pause button**:

  * `aria-pressed="true/false"` to indicate state
  * `aria-label="Pause slide rotation"` (or `"Play slide rotation"` when stopped)

* **Navigation controls (Next/Previous buttons)**:
  * `aria-label="Next slide"` and `aria-label="Previous slide"`
  * Avoid using only icons without labels.

***

### **ARIA Attributes for Tabbed Carousels**

* **Tabs container**:

  * `role="tablist"`
  * `aria-label="Slide controls"`

* **Individual tab buttons**:

  * `role="tab"`
  * `aria-selected="true/false"`
  * `aria-controls="tabpanel-id"`

* **Slide panels (content)**:
  * `role="tabpanel"`
  * `aria-labelledby="tab-id"`
  * `aria-hidden="true/false"` (Hidden when inactive)

***

### **ARIA Attributes for Grouped Carousels**

* **Slide picker controls**:

  * `role="group"` to wrap slide selector buttons
  * `aria-label="Choose slide to display"`

* **Slide selector buttons**:

  * `role="button"`
  * `aria-labelledby="slide-id"` (Associates button with the slide)
  * `aria-disabled="true"` (For currently active slide)

* **Grouped slides**:
  * `role="group"`
  * `aria-label="Slide X of Y"`
  * Each contained item should have appropriate semantic tags (e.g., `<article>`, `<figure>`).

### Focus Management

1. **Focus Order**

The focus order should follow this sequence:

* Pause/Play button
* Slide controls (pagination) - can be visually placed below but should be placed in the DOM before changing the slides
* See All link
* Previous button
* Slides content
* Next button

This order ensures that users can control the carousel's behavior before interacting with its content, with primary navigation controls (Previous/Next) taking precedence over secondary navigation (pagination).

2. **Auto-rotation Behavior**

In most cases, auto-rotation is discourage as it makes more difficult for users to have a complete control over the carousel.

But if you need to support auto-rotation, here's the expected behavior:

* Auto-rotation must pause when:
  * Any element receives focus
  * User hovers over the carousel
  * User interacts with any control
  * Screen reader is actively reading content
* The pause state must persist until user explicitly resumes
* Provide clear visual indication of pause/play state

3. **Focus States**

* All interactive elements must have visible focus indicators with sufficient contrast (3:1 minimum)
* Focus must not move automatically with slide transitions
* Focus should remain on the control that triggered a slide change
* Ensure focus is not trapped within the carousel

### Keyboard Navigation

The carousel must be fully operable with a keyboard. Here's the expected keyboard behavior:

| Key                  | Purpose                                                                                    |
| -------------------- | ------------------------------------------------------------------------------------------ |
| Left Arrow           | Move to previous slide                                                                     |
| Right Arrow          | Move to next slide                                                                         |
| Tab                  | Navigate through interactive elements (navigation arrows, pagination dots, "See All" link) |
| Enter/Space          | Activate buttons, select slides via pagination                                             |
| Escape               | Stop autoplay if enabled                                                                   |
| Page Up (Optional)   | Move to previous slide                                                                     |
| Page Down (Optional) | Move to next slide                                                                         |

> Note: Keys marked as optional may be omitted in some carousel implementations. The core keys (Left/Right Arrow, Tab, Enter/Space, and Escape) should always be supported for proper accessibility.

## Testing Guidelines

### Functional Testing

**Should ✓**

* [ ] Navigate correctly between slides using arrow buttons
* [ ] Show/hide navigation arrows appropriately at first/last slides
* [ ] Update pagination indicators when slides change
* [ ] Handle touch swipe gestures on mobile devices
* [ ] Pause autoplay on hover/focus if enabled
* [ ] Maintain slide position during window resize
* [ ] Reset autoplay timer after manual navigation
* [ ] Handle edge cases (single slide, empty carousel)

### Accessibility Testing

**Should ✓**

* [ ] Support all keyboard interactions listed in Keyboard Navigation
* [ ] Announce slide changes to screen readers
* [ ] Include proper ARIA labels for all controls
* [ ] Maintain focus management during slide transitions
* [ ] Pause autoplay when screen reader is active
* [ ] Provide sufficient color contrast for controls
* [ ] Include alternative text for slide images
* [ ] Support reduced motion preferences

### Visual Testing

**Should ✓**

* [ ] Display smooth transitions between slides
* [ ] Show correct active state for pagination indicators
* [ ] Maintain aspect ratio of slide content
* [ ] Handle different image sizes appropriately
* [ ] Adapt layout responsively across breakpoints
* [ ] Display loading states for lazy-loaded images
* [ ] Show proper hover/focus states for controls
* [ ] Maintain consistent heights during transitions

### Performance Testing

**Should ✓**

* [ ] Lazy load off-screen slides
* [ ] Optimize image loading and caching
* [ ] Maintain smooth animations (60fps)
* [ ] Handle rapid interactions without breaking
* [ ] Manage memory usage with many slides
* [ ] Cleanup event listeners when destroyed
* [ ] Function without JavaScript (graceful degradation)
* [ ] Handle slow network conditions gracefully

## Browser Support

## Design Tokens

These design tokens follow the [Design Tokens Format](https://design-tokens.github.io/community-group/format/) specification and can be used with various token transformation tools to generate platform-specific variables.

### Carousel Tokens in DTF Format

```json
{
  "$schema": "https://design-tokens.org/schema.json",
  "carousel": {
    "container": ,
    "slide": {
      "gap": ,
      "background": 
    },
    "seeAllLink": {
      "fontWeight": ,
      "fontSize": ,
      "color": {
        "default": ,
        "hover": 
      },
      "marginTop": ,
      "marginBottom": ,
      "display": ,
      "position": ,
      "zIndex": 
    },
    "navigation": {
      "arrow": {
        "color": ,
        "background": {
          "default": ,
          "hover": 
        },
        "border": ,
        "size": ,
        "icon": {
          "previous": ,
          "next": 
        },
        "focus": {
          "outline": ,
          "outlineOffset": 
        }
      },
      "pause": {
        "color": ,
        "background": {
          "default": ,
          "hover": ,
          "pressed": 
        },
        "border": ,
        "size": ,
        "icon": {
          "pause": ,
          "play": 
        },
        "focus": {
          "outline": ,
          "outlineOffset": 
        }
      },
      "dot": {
        "spacing": ,
        "size": ,
        "color": {
          "default": ,
          "active": ,
          "hover": 
        },
        "border": ,
        "focus": {
          "outline": ,
          "outlineOffset": 
        }
      }
    },
    "caption": {
      "padding": ,
      "fontSize": ,
      "color": ,
      "background": 
    },
    "transition": {
      "duration": ,
      "timing": 
    }
  }
}
```

## Frequently Asked Questions

## Resources

### Articles

* [A Step-By-Step Guide To Building Accessible Carousels](https://www.smashingmagazine.com/2023/02/guide-building-accessible-carousels/)
* [More Alternatives to Using a Carousel on Your Website - Mightybytes](https://www.mightybytes.com/blog/more-alternatives-to-carousels-on-website/)
* [How to build a more accessible carousel or slider - DEV Community](https://dev.to/jasonwebb/how-to-build-a-more-accessible-carousel-or-slider-35lp)
* [The Unbearable Inaccessibility of Slideshows — SitePointSitePoint](https://www.sitepoint.com/unbearable-accessible-slideshow/)
* [Usability Guidelines For Better Carousels UX — Smashing Magazine](https://www.smashingmagazine.com/2022/04/designing-better-carousel-ux/)
* [How to Test and Improve Carousel Accessibility: A Complete Guide - The A11Y Collective](https://www.a11y-collective.com/blog/accessible-carousel/)

### Documentation

* [Carousels Tutorial - WAI](https://www.w3.org/WAI/tutorials/carousels/)
* [Auto-Rotating Image Carousel Example with Buttons for Slide Control](https://www.w3.org/WAI/ARIA/apg/patterns/carousel/examples/carousel-1-prev-next/)
* [Auto-Rotating Image Carousel with Tabs for Slide Control Example](https://www.w3.org/WAI/ARIA/apg/patterns/carousel/examples/carousel-2-tablist/)


# CONTENT-MANAGEMENT: [Drag And Drop](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/content-management/drag-and-drop)

Build intuitive drag and drop functionality with accessibility and touch support.

# Drag and Drop


# CONTENT-MANAGEMENT: [Expandable Text](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/content-management/expandable-text)

Create expandable text components with progressive disclosure and accessibility features for better content management.

# Expandable Text

***(Also called collapsible text, Read More/Read Less)***

## Overview

**Expandable Text** is a content management pattern that allows users to expand and collapse sections of text. This pattern improves readability by initially hiding non-essential content while keeping it accessible on demand.

Expandable Text is commonly used to manage lengthy descriptions, article summaries, or additional details that are helpful but not immediately necessary. It helps users scan content efficiently while maintaining a clean and minimal interface.

## Use Cases

### When to use:

Use **Expandable Text** when you need to **manage lengthy content while keeping essential information visible**.

**Common scenarios include:**

* **Summarizing content** – Showing a short preview of a longer article, product description, or FAQ answer.
* **Reducing page clutter** – Keeping the interface clean by hiding secondary details.
* **Improving mobile usability** – Managing screen space efficiently on smaller devices.
* **Progressive disclosure** – Revealing additional information only when needed.
* **Enhancing readability** – Preventing information overload while keeping details accessible.

### When not to use:

* **For critical information** – Users should not need to expand content to access essential details, such as pricing, terms, or important warnings.
* **For frequently accessed content** – If most users expand the content, it may be better to display it by default.
* **When full content is needed upfront** – Avoid hiding information that helps users make informed decisions quickly.

## Benefits

* **Improves readability** – Helps users scan and navigate content more efficiently.
* **Enhances user control** – Users can choose to expand or collapse information as needed.
* **Saves space** – Keeps interfaces clean and reduces clutter, especially on mobile.
* **Supports progressive disclosure** – Prioritizes important content while making additional details available.
* **Improves accessibility when properly implemented** – Ensures all users can interact with hidden content.

## Drawbacks

* **Hides important information** that users may need upfront.
* **Requires an extra action** from the user, adding friction to content discovery.
* **Can reduce searchability** since hidden text might not be indexed or easily findable.
* If not implemented properly, it **may not be accessible** to screen readers.
* **Unexpected layout shifts** may occur when expanding content, affecting user experience.

## Anatomy

```mermaid
flowchart TB
    subgraph ExpandableText[Expandable Text Component]
        A[Trigger Button] -->|Collapsed| B[Label + Icon ▾]
        A -->|Expanded| C[Label + Icon ▴]
        A -.->|Toggles State| D[Updates aria-expanded]

        subgraph ContentSection[Content Section]
            E[Hidden Content] -->|Expands| F[Visible Content]
        end
    end
```

### **Component Structure**

1. **Trigger Button**

* Used to **expand or collapse** the text.
* Should be **clearly labeled** (e.g., "Read More" / "Read Less").
* Includes an **icon** (▾ for collapsed, ▴ for expanded) to reinforce expand/collapse state.
* Should indicate the expanded state using **`aria-expanded="true|false"`** for accessibility.
* Must be **keyboard navigable** (activated via `Enter` or `Space` key).

2. **Content Section**

* Contains the **expandable/collapsible** text.
* Remains in the **DOM at all times** to maintain accessibility.
* Should be **visually styled** to clearly indicate expandable behavior.

3. **Hidden Content**

* The part of the text that is **initially collapsed**.
* Should remain in the DOM but hidden using **`aria-hidden="true"`**.
* When expanded:
  * Remove `aria-hidden`.
  * Set `aria-expanded="true"` on the **Trigger Button**.
* Consider using **`max-height` with `overflow: hidden`** instead of `display: none` to ensure screen readers detect changes.

4. **Visual States**

* **Collapsed:** Only a preview of the text is visible, with a "Read More" button.
* **Expanded:** The full content is shown, and the button updates to "Read Less".
* **Hover & Focus:** The button should have a **clear focus indicator** for accessibility.

### **Summary of Components**

| Component            | Required? | Purpose                                           |
| -------------------- | --------- | ------------------------------------------------- |
| Trigger Button       | ✅ Yes     | Expands or collapses the text.                    |
| Content Section      | ✅ Yes     | Contains the expandable/collapsible text.         |
| Hidden Content       | ✅ Yes     | Represents the initially collapsed text.          |
| Expand/Collapse Icon | ❌ No      | Provides a visual cue for expand/collapse states. |
| Hover & Focus States | ✅ Yes     | Ensures proper accessibility and interaction.     |

## Best Practices

### Content

**Do's ✅**

* Use clear and concise labels for the expand/collapse button (e.g., "Read More" / "Read Less").
* Keep the collapsed preview meaningful and informative.
* Ensure expanded content is relevant and enhances the user experience.

**Don'ts ❌**

* Don't hide essential information that users need to make decisions.
* Don't use vague labels like "Click Here" without context.
* Don't force users to expand content just to understand the main point.

### Accessibility

**Do's ✅**

* Use a `<button>` element for the trigger to ensure keyboard accessibility.
* Add `aria-expanded="false"` to the button and update it dynamically.
* Use `aria-controls` to associate the button with the expandable content.
* Maintain logical focus order, ensuring the expanded content follows naturally.

**Don'ts ❌**

* Don't rely on color alone to indicate the expanded state.
* Don't remove focus styles on the trigger button.
* Don't make expandable content difficult to navigate for screen reader users.

### Visual Design

**Do's ✅**

* Use **clear expand/collapse icons** (`▸` / `▾`, `+` / `-`, `►` / `▼`) and ensure they change state when toggled.
* **Pair icons with text labels** (e.g., `Read More ▾` / `Read Less ▴`) for clarity.
* **Place icons consistently**:
  * **Inline text expansion**: Position the icon on the **right** (`Read More ▾`).
  * **List-based or block sections**: Position the icon on the **left** (`▸ Section Title`).
* Provide **smooth animations** for expanding/collapsing content.
* Ensure **text contrast** remains high for readability.

**Don'ts ❌**

* **Don't use unclear icons** (e.g., dots `...` or generic arrows that don't rotate).
* **Don't rely on icons alone**—ensure a text label is present.
* **Don't mix left/right placements** inconsistently within the same interface.
* **Don't make the trigger button too small** or difficult to tap on mobile.
* **Don't create unexpected layout shifts** when expanding content.

### Layout & Positioning

**Do's ✅**

* Place expandable content near the primary text to maintain context.
* Ensure the collapsed content remains visually connected to its trigger.
* Make sure expanded content does not overlap or obscure other UI elements.

**Don'ts ❌**

* Don't place the trigger button far from the expandable content.
* Don't create an inconsistent layout by having some sections expand and others not.

## Tracking

Tracking expandable text interactions helps measure content engagement, assess whether users need additional details, and determine if content should be visible by default. By analyzing user behavior, we can optimize when and how expandable text is used.

### Key Tracking Points

Each expandable text interaction provides valuable insights into user behavior. Below are the key events that should be tracked:

| **Event Name**                | **Description**                                                    | **Why Track It?**                                          |
| ----------------------------- | ------------------------------------------------------------------ | ---------------------------------------------------------- |
| `expandable_text.view`        | When the expandable text component appears in the viewport.        | Determines visibility and content discovery.               |
| `expandable_text.expand`      | When a user expands the content.                                   | Measures engagement and demand for additional information. |
| `expandable_text.collapse`    | When a user collapses the content.                                 | Helps analyze whether users return to a condensed view.    |
| `expandable_text.auto_expand` | When content expands automatically (e.g., based on user behavior). | Determines if automatic expansion improves engagement.     |
| `expandable_text.read_time`   | The time a user spends with the expanded content visible.          | Helps measure content consumption.                         |

### Event Payload Structure

To ensure consistent tracking, here's a recommended event format:

```json
```

### Key Metrics to Analyze

Once tracking is in place, the following metrics provide actionable insights:

* **Expand Rate** → Percentage of users who expand the content.
* **Collapse Rate** → Percentage of users who collapse the content after expanding it.
* **Average Read Time** → How long users keep the expanded content visible.
* **Auto-Expand vs. Manual Expand Rate** → Helps assess whether users prefer content pre-expanded or if manual interaction is better.
* **Re-Expand Rate** → Percentage of users who collapse and then re-expand the content.

### Insights & Optimization Based on Tracking

By analyzing tracking data, we can optimize the expandable text experience:

* 🚨 **Low Expand Rate?**
  → Users may not notice or feel the need to expand content.
  **Optimization:** Adjust design cues (e.g., larger icons, clearer labels like "Read More"), or test making the content visible by default.

* ⏳ **Short Read Time After Expand?**
  → Users might not be engaging with the expanded content.
  **Optimization:** Ensure content is concise and well-structured, and test whether breaking it into sections improves readability.

* 🔄 **High Collapse Rate?**
  → Users may find expanded content overwhelming or unnecessary.
  **Optimization:** Test progressive disclosure (expanding only parts of the content) or improve the summary text.

* 🔁 **High Re-Expand Rate?**
  → Users may be struggling to retain information after collapsing the text.
  **Optimization:** Consider keeping key details visible at all times or providing a "sticky" summary.

* ⚙️ **Auto-Expand Not Leading to Higher Engagement?**
  → Automatically expanded content may be ignored.
  **Optimization:** A/B test auto-expanded vs. manually triggered content to determine user preference.

By continuously monitoring these metrics, we can refine expandable text usability, ensuring users access necessary information without unnecessary friction.

## Code Examples

### Basic Implementation

## Accessibility

### ARIA Attributes

**Required ARIA attributes:**

* `aria-expanded="false"` on the button (updated dynamically).
* `aria-controls="id-of-content"` to link the button to the expandable content.
* `hidden` attribute on the expandable content when collapsed.

### Screen Reader Support

* Ensure that the expanded content is properly announced by screen readers.
* Use `aria-live="polite"` if the content update needs to be announced.

## SEO

* Ensure that expandable text is still **present in the DOM** so search engines can index it.
* Avoid hiding critical content that users or crawlers need upfront.

## Testing Guidelines

### Functional Testing

**Should ✓**

* [ ] Verify that clicking the trigger expands and collapses the content.
* [ ] Ensure the `aria-expanded` attribute updates correctly.
* [ ] Confirm that expanded content is focusable and navigable.
* [ ] Ensure the trigger works when activated via keyboard (`Enter` and `Space` keys).
* [ ] Check that clicking outside the expanded content does not cause unintended collapse (unless designed to do so).
* [ ] Ensure content remains in the DOM when collapsed, and it reappears correctly when expanded.

### Accessibility Testing

**Should ✓**

* [ ] Validate that the trigger button is **focusable** and properly labeled.
* [ ] Test with screen readers to **ensure correct announcement** of expanded content.
* [ ] Verify `aria-controls` properly links the trigger to the expandable content.
* [ ] Ensure `aria-expanded` updates dynamically and is announced correctly.
* [ ] Check that **expanded content is navigable via keyboard** and follows logical tab order.
* [ ] Validate that expandable content does **not rely solely on color** for visual cues.
* [ ] Confirm that **touch targets** meet WCAG guidelines (minimum 44x44px).

### Visual Testing

**Should ✓**

* [ ] Ensure smooth animations and transitions.
* [ ] Verify that expanded content does not break the layout.
* [ ] Ensure that icons properly change direction (`▾` to `▴` or `+` to `-`).
* [ ] Check that expand/collapse actions **do not create layout shifts** affecting surrounding content.
* [ ] Ensure that the transition effect does not make content unreadable.

### Performance Testing

**Should ✓**

* [ ] Test that expansion does not introduce layout shifts (Cumulative Layout Shift - CLS).
* [ ] Verify that expandable content does not trigger **excessive reflows** or repaints.
* [ ] Ensure that animations run at **60 FPS** without jank.
* [ ] Confirm that expanding/collapsing does not introduce memory leaks or excessive DOM updates.

### SEO Testing

**Should ✓**

* [ ] Ensure that **collapsed content is still in the DOM** and indexable by search engines.
* [ ] Verify that search engines **can crawl and access** the hidden content.
* [ ] Check that expandable content is **not blocked by JavaScript** for crawlers.
* [ ] Test using **Google's Mobile-Friendly Test** and **Lighthouse** to ensure SEO impact is minimal.

## Related Patterns

* [Accordion](/patterns/content-management/accordion) – Best for **multi-section collapsible content**, where multiple expandable panels are grouped together (e.g., FAQs or settings menus).
* [Tooltip](/patterns/content-management/tooltip) – Useful for **brief inline explanations**, where additional information is needed on hover or focus, rather than expanding a large content section.
* [Modal](/patterns/content-management/modal) – Ideal when **expanded content requires full attention**, such as confirmations, forms, or important details that should block interaction with the rest of the page.

## Frequently Asked Questions

## Resources

### Articles


# CONTENT-MANAGEMENT: [Modal](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/content-management/modal)

Build accessible modal dialogs with proper focus management, keyboard interactions, and user experience best practices.

# Modal

***(Also called dialog, dialog box, overlay, popup)***

## Overview

A **modal** is an interface element that appears on top of the main application screen, blocking interaction with the rest of the page until the modal is closed.

Modals are used to display important information, request user input, or confirm actions in a focused way.

## Use Cases

### When to use:

Use a modal when you need to **interrupt the user flow** to display important information or require user input before proceeding.

**Common scenarios include:**

* **Confirmation dialogs** – e.g., "Are you sure you want to delete this item?"
* **Critical system messages** – e.g., session expiration warnings, important alerts.
* **Forms requiring user input** – e.g., login, payment, or signup flows.
* **Media previews** – e.g., displaying images or videos in a lightbox overlay.
* **Multi-step processes** – e.g., checkout steps or onboarding flows.
* **Displaying terms and conditions** – e.g., requiring user agreement before proceeding.

### When not to use:

* For non-essential information that doesn't require immediate attention
* When the content or interaction can be displayed inline on the page
* If the same information needs to be accessed frequently
* For large amounts of content that require significant scrolling - use a dedicated page for better user experience and accessibility
* When users need to interact with the main page while the modal is open

## Benefits

* Focuses user attention on important information or actions
* Allows gathering necessary input without losing page context
* Can simplify complex workflows by breaking them into focused steps
* Prevents interaction with the main page until a specific task is completed

## Drawbacks

* **Disrupts user flow**, forcing interaction before continuing with the main content.
* **Can be difficult to dismiss**, especially if there's no clear close button.
* **Accessibility challenges** if focus trapping and keyboard navigation are not well managed.
* **Not ideal for mobile users**, as modals may not fit well on small screens.
* **Overuse can lead to frustration**, particularly if used for non-essential content.

## Anatomy

```mermaid
graph TD
    A[Modal] --> B[Overlay]
    A --> C[Container]
    C --> D[Header]
    C --> E[Content]
    C --> F[Footer]
    D --> G[Title]
    D --> H[Close Button]
    E --> I[Text]
    E --> J[Forms]
    E --> K[Images]
    F --> L[Action Buttons]
    L --> M[Primary Button]
    L --> N[Secondary Button]
```

### Component Structure

1. **Overlay**

* A semi-transparent layer that covers the main page content
* Helps focus attention on the modal content
* Usually fades in/out during modal transitions

2. **Container**

* Wraps the modal content, buttons, and close control
* Often has a visible border or shadow to visually separate it from the page
* Can be centered on the screen or aligned to another element

3. **Header**

* Contains the modal title
* Can include a close button and/or icon
* Helps users understand the modal's purpose, fundamental for accessibility

4. **Content**

* The main content area of the modal
* Can contain text, images, forms, or other interactive elements
* Should be focused and concise

5. **Footer (Optional)**

* Contains action buttons (e.g., "OK", "Cancel")
* Provides confirmation and dismissal options
* Can be omitted for simple, informational modals

6. **Close Button (`button`)**

* Allows users to dismiss the modal without taking an action
* Often an "X" icon in the corner of the modal
* Should be included unless the modal requires a specific action to proceed

#### **Summary of Components**

| Component    | Required? | Purpose                                     |
| ------------ | --------- | ------------------------------------------- |
| Overlay      | ✅ Yes     | Blocks background interactions.             |
| Container    | ✅ Yes     | The main content container of the modal.    |
| Header       | ✅ Yes     | Provides the modal heading.                 |
| Content      | ✅ Yes     | Holds the primary information of the modal. |
| Footer       | ❌ No      | Contains actions (e.g., "Save", "Cancel").  |
| Close Button | ✅ Yes     | Allows users to dismiss the modal.          |

## Best Practices

### Content

**Do's ✅**

* Keep modal content focused and concise
* Use clear, actionable titles that explain the modal's purpose
* Provide obvious confirmation and dismissal options
* Allow users to close the modal by clicking outside the content area
* Ensure the modal content is accessible and responds properly to viewport changes
* Ensure the text is straightforward and free of jargon, avoid technical terms

**Don'ts ❌**

* Don't use modals for frequently accessed or non-essential information
* Avoid long, scrollable content that would be better served by a separate page
* Don't nest modals, as this can be disorienting for users
* Don't overuse modals in your application as it can disrupt user flow
* Avoid ambiguity using vague terms like "Submit" or "Click here"

### Accessibility

**Do's ✅**

* Set `aria-modal="true"` and `role="dialog"` on the modal container
* Focus to the modal container when opening the modal
* Trap focus within the modal container so that tabbing doesn't escape back to the page
* Properly label action buttons and close controls
* Manage keyboard focus and provide intuitive keyboard navigation
* Use an `h2` heading for the modal title
* Ensure the modal can be closed with the Escape key
* Restore focus to the triggering element when the modal is closed
* Use either `aria-labelledby` property to point to the modal title or `aria-label` to provide a label for the modal

**Don'ts ❌**

* Don't make it difficult to find the close button
* Avoid auto-focusing elements like text inputs unless absolutely necessary
* Don't block screen readers from accessing the modal content
* Don't forget to freeze scrolling on the main content while the modal is open

### Visual Design

**Do's ✅**

* Use consistent design patterns for modals throughout your website or web application
* Ensure the modal content contrasts well with the overlay background
* Provide sufficient whitespace and padding within the modal container
* Use a responsive design that adapts well to different screen sizes
* Consider using subtle transitions or animations to help guide user focus
* Provide visual feedback on buttons when an action is processed (e.g. [loading indicator](/patterns/user-feedback/loading-indicator))

**Don'ts ❌**

* Don't make the modal so large that it overwhelms the main page content
* Avoid visually jarring or distracting styles that detract from the content
* Don't use low-contrast text or elements that blend into the overlay background

### Layout & Positioning

**Do's ✅**

* Center modals vertically and horizontally for a balanced layout
* Align modal content to the left for better readability
* Ensure modals have a minimum margin from screen edges on smaller viewports
* Consider placing action buttons in the footer for clear separation

**Don'ts ❌**

* Don't position modals in hard-to-reach areas like the extreme top or bottom of the page
* Avoid modal heights that extend beyond the viewport if possible
* Don't make modals so narrow that the content becomes unnecessarily constrained

### Common Mistakes & Anti-Patterns

#### Forcing Users Into a Modal (No Close Option)

**❌ What's Wrong?** Users feel trapped if they can't exit a modal.

**How to Fix It?** Always provide a clear **close button (X)** and support the `Esc` key for dismissal.

***

#### Triggering Modals on Page Load

**❌ What's Wrong?** Unrequested modals on page load can feel like pop-ups that disrupt user flow.

**How to Fix It?** Only show modals when the user **intentionally** initiates them.

***

#### Disrupting Background Page Focus

**❌ What's Wrong?** Some modals allow interaction with background content while open, causing layered focus.

**How to Fix It?** Add a **focus trap** inside the modal and prevent background interaction until it's closed.

***

#### Modal Closes on Accidental Click

**❌ What's Wrong?** Clicking outside the modal might unintentionally dismiss it, frustrating or confusing users.

**How to Fix It?** Only allow closing on background click if it's non-critical info. For important data, require an explicit close action.

***

#### Missing or Incorrect ARIA Markup (Accessibility)

**❌ What's Wrong?** If the modal isn't announced as a dialog (e.g., missing `role="dialog"`), screen readers might not indicate it properly.

**How to Fix It?** Use `role="dialog"` or the `<dialog>` element with `aria-modal="true"`. Provide a clear heading or label.

***

#### Failing to Return Focus to the Trigger (Accessibility)

**❌ What's Wrong?** When the modal closes, focus can get lost (e.g., jump to the top of the page).

**How to Fix It?** Store the element that triggered the modal and **return focus** to it after closing.

***

#### No Visible Focus States (Accessibility)

**❌ What's Wrong?** Keyboard users can't see where they are if no focus outline is visible on buttons or form fields.

**How to Fix It?** Ensure a **clear, high-contrast focus indicator** is present. Validate you can "Tab" through all interactive elements.

***

#### Overly Complex or Overstuffed Modals (Accessibility)

**❌ What's Wrong?** If a modal presents too much content (long forms, lots of text), users relying on screen readers may be overwhelmed.

**How to Fix It?** Keep modals **brief and to the point**. For more complex workflows, use a dedicated page or a multi-step wizard.

## Tracking

Tracking modal interactions helps measure engagement, detect usability issues, and optimize how modals contribute to user workflows. By capturing key actions, we can determine whether modals improve the user experience or create friction.

### Key Tracking Points

Each modal interaction provides valuable insights into user behavior. Below are the key events that should be tracked:

| **Event Name**                 | **Description**                                                                          | **Why Track It?**                                                      |
| ------------------------------ | ---------------------------------------------------------------------------------------- | ---------------------------------------------------------------------- |
| `modal.view`                   | When the modal first appears on the screen.                                              | Helps measure how often users encounter the modal.                     |
| `modal.open`                   | When a user manually opens the modal (e.g., by clicking a button).                       | Measures user-initiated engagement.                                    |
| `modal.auto_open`              | When the modal opens automatically (e.g., a pop-up triggered by page behavior).          | Helps track modal effectiveness vs. annoyance.                         |
| `modal.close`                  | When a user closes the modal (by clicking an "X", pressing Escape, or clicking outside). | Identifies how users dismiss the modal.                                |
| `modal.dismiss_without_action` | When a user closes the modal without interacting with any content inside it.             | Indicates if the modal is irrelevant or intrusive.                     |
| `modal.primary_action`         | When a user clicks the **primary CTA** (e.g., "Submit", "Confirm", "Continue").          | Tracks conversion and engagement with modal content.                   |
| `modal.secondary_action`       | When a user clicks a **secondary action** (e.g., "Cancel", "Learn More", "Skip").        | Measures alternative user behaviors.                                   |
| `modal.interaction_time`       | The time a user spends interacting with the modal before closing.                        | Helps determine if users are engaging with the content or ignoring it. |

### Event Payload Structure

To ensure consistent tracking, here's a recommended event format:

```json
```

### Key Metrics to Analyze

Once tracking is in place, the following metrics provide actionable insights:

* Open Rate → Percentage of users who see the modal (manual vs. auto-open).
* Engagement Rate → Percentage of users who interact with the modal before closing.
* Dismissal Rate → Percentage of users who close the modal without taking any action.
* Completion Rate → Percentage of users who complete the modal's primary action.
* Time in Modal → Average time users spend inside the modal.

### Insights & Optimization Based on Tracking

By analyzing tracking data, we can optimize the modal experience:

* 🚨 **High Dismissal Rate?**
  → Users may find the modal intrusive or irrelevant.
  **Optimization:** Adjust the timing, trigger conditions, or placement to make it feel more contextual.

* ⏳ **Low Interaction Time?**
  → Users may not be reading the content or may be overwhelmed.
  **Optimization:** Simplify the message, use bullet points, or reduce the amount of required input.

* 📉 **Low Completion Rate?**
  → The primary action may not be compelling enough.
  **Optimization:** Improve CTA wording, adjust positioning, or offer better incentives.

* ⚡ **High "Escape Key" or Click Outside Dismissals?**
  → Users may instinctively close the modal without engaging.
  **Optimization:** Ensure the modal provides clear value upfront and isn't disrupting the user's flow.

* 🔄 **High Auto-Open Close Rate?**
  → If most users dismiss auto-open modals immediately, they may be perceived as annoying.
  **Optimization:** Make them **manual-triggered only**, delay their appearance, or ensure they are only shown when truly relevant.

By continuously monitoring these metrics, we can refine the modal's effectiveness and ensure it enhances, rather than disrupts, the user experience.

## Localization

Modals require careful localization of both visible text and accessibility labels. This includes button labels for actions like close, confirm, and cancel, as well as their corresponding ARIA labels for screen readers.

The following JSON structure provides the essential strings that should be translated to ensure your modal is fully accessible across different languages and cultures.

```json
{
  "modal": 
}
```

## Code Examples

### Method 1: Basic Implementation

**Pros ✅**

* **Full styling control**—can be completely customized with CSS.
* **Supports advanced animations and transitions**.
* **Can include additional behaviors** (e.g., stacking multiple modals, custom scroll locking).
* **Compatible with all browsers**, including older versions.

**Cons ❌**

* **Requires JavaScript**—needs scripting for open/close behavior.
* **Manual focus management needed**—must ensure focus stays within the modal.
* **Must handle accessibility manually**—requires ARIA attributes (`role="dialog"`, `aria-modal="true"`, `aria-labelledby`).
* **Backdrop needs to be implemented separately**.

### Method 2: Native Modal

**Pros ✅**

* **Built-in modal behavior**—prevents interaction with background content.
* **Automatic focus management**—traps focus within the modal when open.
* **Native backdrop support**—automatically applies an overlay.
* **Keyboard accessible by default**—supports `Escape` key to close.
* **Simpler implementation**—requires less JavaScript for basic use.

**Cons ❌**

* **Limited styling control**—some browsers restrict modifications to the native backdrop.
* **Less flexible animations**—difficult to create smooth transitions.
* **Browser inconsistencies**—not fully supported in older browsers.
* **Difficult to integrate with custom UI frameworks**.

### When to use a Native Modal (`<dialog>`) and a Custom Modal?

```mermaid
graph TD
  A[Do you need full control over styling and behavior?] -->|Yes| B[Use Custom Modal with ARIA]
  A -->|No| C[Do you want a native solution with minimal code?]
  C -->|Yes| D[Use Native <dialog> Element]
  C -->|No| B[Use Custom Modal with ARIA]
```

For a detailed breakdown of feature differences, refer to the table below:

| Feature                           | `<dialog>` (Native Modal)                   | Custom Modal with ARIA                                  |
| --------------------------------- | ------------------------------------------- | ------------------------------------------------------- |
| **Requires JavaScript?**          | ❌ No (for basic behavior)                   | ✅ Yes (to manage accessibility and interactions)        |
| **Supports full styling?**        | ❌ Limited (some browser restrictions)       | ✅ Yes (complete control over appearance and animations) |
| **Built-in focus management?**    | ✅ Yes (automatically traps focus)           | ❌ No (must be implemented manually)                     |
| **Screen reader support?**        | ✅ Yes (automatically announces modal state) | ✅ Yes (if correctly implemented with ARIA roles)        |
| **Backdrop and overlay support?** | ✅ Yes (native `<dialog>` styling)           | ✅ Yes (requires manual implementation)                  |
| **Closing behavior?**             | ✅ Supports ESC key, `.close()` method       | ✅ Requires explicit event handling                      |
| **Best for**                      | Simple, native modals with default behavior | Fully custom modals with advanced interactions          |

## Accessibility

### Keyboard Interaction Pattern

The following table outlines the standard keyboard interactions for modal components. These interactions ensure that users can navigate and operate modals effectively using only a keyboard.

| Key         | Action                                                                                               |
| ----------- | ---------------------------------------------------------------------------------------------------- |
| Escape      | Closes the modal                                                                                     |
| Tab         | Moves focus to the next focusable element within the modal. Focus should be trapped within the modal |
| Shift + Tab | Moves focus to the previous focusable element within the modal                                       |
| Enter/Space | Activates the focused button or control                                                              |

> **Note**: When the modal opens, focus should automatically move to the first focusable element within the modal (usually the close button or the first form field). When the modal closes, focus should return to the element that triggered the modal.

## Testing Guidelines

### Functional Testing

**Should ✓**

* [ ] Ensure the modal **opens and closes correctly** when triggered.
* [ ] Verify that **clicking the close button** dismisses the modal.
* [ ] Check that clicking **outside the modal (on the overlay)** closes it, if applicable.
* [ ] Ensure the modal **does not close** when interacting with form fields or selecting text inside.
* [ ] Test modal behavior **when resizing the viewport**—it should remain correctly positioned.
* [ ] Validate that **nested modals** (if supported) do not break functionality.

### Accessibility Testing

**Should ✓**

* [ ] Ensure the modal has **`role="dialog"`** and **`aria-modal="true"`**.
* [ ] Verify that the modal title is **announced by screen readers** using `aria-labelledby` or `aria-label`.
* [ ] Ensure **keyboard navigation is functional**—users can tab through elements inside the modal.
* [ ] Test that focus is **trapped inside the modal** while it is open.
* [ ] Ensure that pressing the **Escape key closes the modal**.
* [ ] Confirm that **focus returns to the triggering element** when the modal closes.
* [ ] Verify that **modals do not interfere with screen reader navigation**.

### Icon & Close Button Testing

**Should ✓**

* [ ] Ensure the **close button is visible and accessible**.
* [ ] Verify that the **icon changes state** if an interactive toggle icon is used.
* [ ] Confirm that **keyboard users can activate the close button**.

### Visual Testing

**Should ✓**

* [ ] Validate that the **modal is positioned correctly** (centered or anchored as intended).
* [ ] Ensure the modal has **sufficient contrast** against the overlay.
* [ ] Check that **action buttons are clearly visible and styled appropriately**.
* [ ] Verify that modal **animations/transitions** (if any) are smooth and non-jarring.
* [ ] Test modal layout across **various screen sizes** to ensure responsiveness.

### Performance Testing

**Should ✓**

* [ ] Verify that modal animations **do not cause lag**.
* [ ] Ensure modals **load efficiently** and do not block page rendering.
* [ ] Test modal performance when **multiple modals are triggered in succession**.
* [ ] Confirm that **closing the modal correctly removes it from the DOM** (if dynamically inserted).

## Browser Support

## Design Tokens

These design tokens follow the [Design Tokens Format](https://design-tokens.github.io/community-group/format/) specification and can be used with various token transformation tools to generate platform-specific variables.

### Modal Tokens in DTF Format

```json
{
  "$schema": "https://design-tokens.org/schema.json",
  "modal": {
    "animation": ,
    "overlay": ,
    "container": {
      "padding": ,
      "background": ,
      "border": ,
      "width": 
    },
    "heading": ,
    "actions": ,
    "close": {
      "size": ,
      "background": ,
      "border": ,
      "icon": ,
      "top": ,
      "right": 
    }
  }
}
```

## Frequently Asked Questions

`or`<div>\` with appropriate ARIA roles. Manage focus by moving it to the modal when it opens and returning it to the triggering element upon closure. Provide keyboard support for navigation and actions within the modal.",
},
,
,
]}
/>

## Resources

### Articles

* [A11y Dialog by Kitty Giraudel](https://a11y-dialog.netlify.app/)
* [Which heading level should dialog modals have](https://medium.com/@web-accessibility-education/which-heading-level-should-dialog-modals-have-7b3df89437f0)

### Documentation

* [Dialog (Modal) Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/)
* [Using the Popover API](https://developer.mozilla.org/en-US/docs/Web/API/Popover_API/Using#dismissing_popovers_automatically_via_a_timer)

### Libraries

* [Dialog - shadcn/ui](https://ui.shadcn.com/docs/components/dialog)
* [Diaglo - OriginUI](https://originui.com/dialogs)
* [React Aria - Modal](https://react-spectrum.adobe.com/react-aria/Modal.html)


# CONTENT-MANAGEMENT: [Popover](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/content-management/popover)

Implement user-friendly popover components in your web applications. Learn best practices for contextual information display, positioning, and accessibility with practical examples.

# Popover

## Overview

**Popovers** are overlay components that appear on top of the main content to provide users with additional information or actions.

They are used to display contextual content while keeping the surrounding page visible.

Unlike modals that block interaction with the rest of the page, popovers provide contextual help or shortcuts while keeping the main interface visible and interactive.

## Use Cases

### When to use:

Use a popover when you need to provide context-specific information or quick actions that complement the main view without requiring full user focus.

**Common scenarios include:**

* Contextual help – e.g., additional details about a data field.
* Quick actions or shortcuts – e.g., editing options or additional buttons.
* Compact toolbars or menus – e.g., filters or settings that appear on demand.
* Preview or supplementary information – e.g., image or text previews on hover/focus.

### When not to use:

* When the information is critical and must be persistently visible.
* For large forms or complex interactions better suited to modals.
* When the context requires a full-page takeover for clarity.

## Benefits

* Enhances user focus by offering context-specific content.
* Keeps the main interface uncluttered.
* Improves discoverability of secondary actions without navigating away.

## Drawbacks

* **Requires precise user interaction**, which may be difficult for some users.
* **Can obstruct other content**, making it harder to interact with the page.
* **Often inaccessible** if not implemented with correct keyboard navigation and focus management.
* **Positioning challenges**, especially if the popover appears off-screen.
* **Risk of accidental dismissal**, leading to frustration if users need the information again.

## Anatomy

```mermaid
flowchart TB
subgraph Popover[Popover Component]
A[Trigger Element] -.->|activates| B[Popover Container]
B --> C[Content Area]
B -.->|optionally displays| D[Arrow]
C --> E[Title]
C --> F[Body Content]

classDef container stroke:#666,stroke-width:2px
class Popover container
end
```

### Component Structure

1. **Trigger Element**

* The interactive element (e.g., button, icon, text) that activates the popover.
* Manages **accessibility attributes** like `aria-haspopup` and `aria-expanded`.
* Should be **focusable** and work with keyboard navigation.

2. **Popover Container**

* The root element that wraps the popover content.
* Manages **positioning relative to the trigger element**.
* Handles **visibility and accessibility considerations**.

3. **Arrow (Optional)**

* A **visual indicator** pointing to the trigger element.
* Helps users understand the relationship between **popover and trigger**.
* Should adjust **based on positioning** (e.g., top, bottom, left, right).

4. **Content Area**

* Contains all the **popover content**.
* Typically includes a **title, body content, and interactive elements**.

5. **Title (Optional)**

* A **brief heading or label** for the popover content.
* Helps users understand **context at a glance**.

6. **Body Content**

* The **main content** of the popover.
* Can include **text, links, or simple interactive elements**.

7. **Close Button (Optional)**

* Allows users to **dismiss the popover manually**.
* Should be **keyboard accessible** and labeled appropriately.
* Helps users who **prefer to close the popover without clicking outside**.

8. **Dismiss Behavior**

* The popover should close when the user:
  * Clicks **outside** of the popover.
  * Presses **Esc** on the keyboard.
  * Navigates away using the **Tab key** (if focus moves outside the popover).
* Ensures **smooth UX and proper accessibility handling**.

#### **Summary of Components**

| Component         | Required? | Purpose                                                    |
| ----------------- | --------- | ---------------------------------------------------------- |
| Trigger Element   | ✅ Yes     | The element that activates the popover.                    |
| Popover Container | ✅ Yes     | Contains the content of the popover.                       |
| Arrow             | ❌ No      | Visually connects the popover to the trigger.              |
| Title             | ❌ No      | Provides a heading for the popover content.                |
| Body Content      | ✅ Yes     | The main content of the popover.                           |
| Close Button      | ❌ No      | Allows users to manually dismiss the popover.              |
| Dismiss Behavior  | ✅ Yes     | Defines how the popover closes (Esc, click outside, etc.). |

## Best Practices

### Content

**Do's ✅**

* Keep content concise and focused.
* Ensure critical actions are easily accessible.
* Use clear labels for any interactive elements.

**Don'ts ❌**

* Avoid overloading with too much information.
* Don't include critical navigation or forms better suited for a modal.
* Do not expect users to scroll through extensive content.

### Accessibility

**Do's ✅**

* Ensure the popover is keyboard navigable (e.g., support Tab and Esc keys).
* Use appropriate ARIA attributes like `aria-haspopup` and `aria-expanded`.
* Manage focus: move focus into the popover when opened and return it when closed.

**Don'ts ❌**

* Rely solely on hover for activation, as it may be inaccessible on touch devices.
* Omit a clear focus indication for interactive elements within the popover.

### Visual Design

**Do's ✅**

* Clearly differentiate the popover from the background with contrasting colors.
* Use subtle shadows and transitions for a smooth appearance.
* Provide a clear pointer or arrow to associate with the trigger element.

**Don'ts ❌**

* Use excessive animations that can distract or slow down the interaction.
* Create styling that blends too closely with the underlying page.

### Layout & Positioning

**Do's ✅**

* Position the popover close to its trigger for clear visual association.
* Ensure the popover does not obscure important page content.
* Consider responsive adjustments to maintain usability on all devices.

**Don'ts ❌**

* Allow the popover to display off-screen; always adjust its placement.
* Fix its position in a way that it overlaps essential navigation elements.

## Code Examples

### Method 1: Custom Popover Implementation

```html
<!-- Trigger Button -->
<button id="popoverTrigger" aria-haspopup="true" aria-expanded="false">
  Open Popover
</button>

<!-- Popover -->
<div
  id="customPopover"
  class="popover"
  role="dialog"
  aria-labelledby="popoverTitle"
  hidden
>
  <div class="popover-content">
    <button type="button" class="popover-close" aria-label="Close popover">
      &times;
    </button>

    <h3 id="popoverTitle">Popover Title</h3>
    <p>Popover content goes here...</p>

    <div class="popover-actions">
      <button type="button" class="button-primary">Action</button>
    </div>
  </div>
</div>

<script>
  const trigger = document.getElementById("popoverTrigger");
  const popover = document.getElementById("customPopover");

  trigger.addEventListener("click", () => );
</script>
```

**Pros ✅**

* **Full styling control**—can be completely customized with CSS.
* **Supports advanced positioning and animations**.
* **Can include complex interactions and behaviors**.
* **Compatible with all browsers**, including older versions.

**Cons ❌**

* **Requires JavaScript**—needs scripting for open/close behavior and positioning.
* **Manual accessibility management**—requires careful implementation of ARIA attributes and keyboard interactions.
* **Positioning challenges**—may require additional libraries or complex logic for proper placement.
* **No built-in light dismiss**—must be implemented manually.

### Method 2: Native Popover API

```html
<!-- Trigger Button -->
<button popovertarget="nativePopover">Open Popover</button>

<!-- Native Popover -->
<div id="nativePopover" popover>
  <h3>Popover Title</h3>
  <p>Popover content goes here...</p>
  <button popovertarget="nativePopover" popovertargetaction="hide">
    Close
  </button>
</div>
```

**Pros ✅**

* **Built-in popover behavior**—handles showing/hiding automatically.
* **Light dismiss support**—closes when clicking outside by default.
* **Keyboard accessible by default**—supports `Escape` key to close.
* **Simpler implementation**—requires minimal JavaScript.
* **Stacking context management**—handles z-index automatically.

**Cons ❌**

* **Limited browser support**—not available in all browsers yet.
* **Less control over positioning**—limited options for custom placement.
* **Styling restrictions**—some default styles may be harder to override.
* **Less flexibility for complex behaviors**—may require additional scripting for advanced use cases.

### When to use Native Popover API vs Custom Popover?

```mermaid
graph TD
  A[Do you need advanced positioning or complex interactions?] -->|Yes| B[Use Custom Popover with ARIA]
  A -->|No| C[Is browser support for Popover API sufficient for your needs?]
  C -->|Yes| D[Use Native Popover API]
  C -->|No| B[Use Custom Popover with ARIA]
```

For a detailed breakdown of feature differences, refer to the table below:

| Feature                   | Native Popover API                          | Custom Popover with ARIA                           |
| ------------------------- | ------------------------------------------- | -------------------------------------------------- |
| **Requires JavaScript?**  | ❌ No (for basic behavior)                   | ✅ Yes (for positioning and interactions)           |
| **Full styling control?** | ❌ Limited (some default styles)             | ✅ Yes (complete control over appearance)           |
| **Positioning options?**  | ❌ Limited (uses default positioning)        | ✅ Flexible (can use custom positioning logic)      |
| **Light dismiss?**        | ✅ Built-in                                  | ❌ Must be implemented manually                     |
| **Browser support?**      | ❌ Limited (newer browsers only)             | ✅ Works in all browsers with JS support            |
| **Accessibility?**        | ✅ Good (but may need enhancements)          | ✅ Can be fully accessible (requires careful impl.) |
| **Complex interactions?** | ❌ Limited (may need additional JS)          | ✅ Supports complex custom behaviors                |
| **Best for**              | Simple popovers with modern browser support | Custom popovers with specific design requirements  |

## Accessibility

### ARIA Attributes

**Required ARIA attributes:**

* `aria-haspopup="true"` on the trigger element.
* `aria-expanded` on the trigger element to reflect open/closed state.
* `role="dialog"` (or `role="menu"` if used as a menu) on the popover container.
* Ensure focus management so that keyboard users receive context.

### Keyboard Interaction Pattern

The following table outlines the standard keyboard interactions for popover components.

| Key | Action                                                    |
| --- | --------------------------------------------------------- |
| Tab | Navigate between focusable items within the popover       |
| Esc | Close the popover and return focus to the trigger element |

## SEO

* Ensure the popover content is not critical for SEO or provide alternate ways for search engines to access the content.
* Use descriptive hidden text if necessary so screen readers can still announce key information.

## Testing Guidelines

### Functional Testing

**Should ✓**

* [ ] Verify that clicking the trigger displays the popover.
* [ ] Ensure that keyboard navigation (Tab, Esc) behaves as expected.
* [ ] Confirm ARIA attributes update correctly when toggling the popover.
* [ ] Ensure focus handling moves into and out of the popover appropriately.

### Accessibility Testing

**Should ✓**

* [ ] Validate that screen reader users are notified when the popover is opened.
* [ ] Test that focus is not lost when navigating through popover content.
* [ ] Ensure the popover closes with the Esc key and returns focus to the trigger.

### Visual Testing

**Should ✓**

* [ ] Confirm that the popover appears near the trigger and does not obscure other critical information.
* [ ] Validate that styling and animations are smooth and non-distracting.
* [ ] Check that the popover remains fully visible on different screen sizes.

### Performance Testing

**Should ✓**

* [ ] Ensure that opening and closing the popover does not induce performance lags.
* [ ] Verify that the dynamic positioning adapts swiftly as the viewport changes.

## Design Tokens

These design tokens follow the [Design Tokens Format](https://design-tokens.github.io/community-group/format/) specification and can be used with various token transformation tools to generate platform-specific variables.

### Popover Tokens in DTF Format

```json:popover.json
{
  "$schema": "https://design-tokens.org/schema.json",
  "popover": {
    "container": {
      "background": ,
      "border": ,
      "shadow": ,
      "padding": 
    },
    "arrow": {
      "size": ,
      "color": 
    },
    "transition": 
  }
}
```

## Related Patterns

Consider these related patterns when implementing popovers:

* [Modal](/patterns/content-management/modal) - Used for critical interactions requiring full focus.
* [Tooltip](/patterns/content-management/tooltip) - Similar in providing contextual information but less interactive.
* [Selection Input / Dropdown](/patterns/forms/selection-input) - Best for more complex navigation menus.

## Frequently Asked Questions

## Resources

### Articles

### Documentation

[popover | MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/popover)

### Libraries

* [Popover - shadcn/ui](https://ui.shadcn.com/docs/components/popover)
* [Popover - OriginUI](https://originui.com/popover)


# CONTENT-MANAGEMENT: [Tooltip](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/content-management/tooltip)

Implement effective tooltip components in your web applications. Learn best practices for contextual help, positioning strategies, and accessibility considerations.

# Tooltip

***(Also called hover hint, info bubble)***

## Overview

A **tooltip** is a small popup that provides additional contextual information when a user hovers over, focuses on, or interacts with an element. It helps clarify elements with **icons, buttons, or text snippets** that may not be self-explanatory.

There are **two types of tooltips**:

* **Simple Tooltips** – Short text descriptions that appear on hover or focus, providing a brief explanation.
* **Rich Tooltips** – Enhanced tooltips that may contain **formatted text, icons, images, or interactive elements**.

Tooltips should be used to enhance understanding without overwhelming the user interface.

## Use Cases

### When to use:

Use a tooltip when you need to provide **additional context or explanations** without taking up extra space in the UI.

**Common use cases include:**

**Simple Tooltips**

* **Clarifying icons or abbreviations** (e.g., a settings cog, currency symbols).
* **Providing additional information** about form fields or table headers.
* **Showing helper text** for complex actions (e.g., "This action is permanent").
* **Explaining disabled elements** when a user cannot interact with them.
* **Providing keyboard shortcuts** when hovering over action buttons.

**Rich Tooltips**

* **Providing in-depth explanations** beyond a brief description.
* **Displaying small images, formatted text, or interactive content**.
* **Presenting additional details about data points in charts**.
* **Showing user profile previews in social apps**.

### When not to use:

* **For critical information** users must read, such as error messages.
* **For content that should remain visible**, like persistent hints or descriptions.
* **When users need to interact** with the tooltip itself.
* **If the tooltip is the only means** of conveying information (accessibility issue).
* **For mobile-first interactions** where hover-based behavior isn't intuitive.

## Benefits

* **Reduces clutter** by providing contextual information without crowding the UI.
* **Improves user understanding** of complex actions or terminology.
* **Enhances accessibility** when used correctly with keyboard and screen reader support.
* **Provides instant feedback** without disrupting the user's flow.

## Drawbacks

* Can be **difficult to trigger** on mobile devices due to the lack of hover interactions.
* Often **overlooked by users**, especially if they don't expect additional information.
* May **interfere with content visibility**, particularly if not positioned well.
* Can cause **accessibility issues** if not properly implemented for keyboard and screen readers.
* If tooltips **disappear too quickly**, users may struggle to read the content.

## Anatomy

## Anatomy

```mermaid
graph TD
    A[Tooltip] --> B[Trigger Element]
    B -->|Hover/Focus| C[Tooltip Box]
    C --> D[Tooltip Content]
    C --> E[Optional Interactive Elements]
```

### Component Structure

1. **Trigger Element**

* The interactive element (e.g., button, icon, text) that activates the tooltip.
* Should have **`aria-describedby`** linking to the tooltip content for accessibility.
* Can be activated by **hover (mouse), focus (keyboard), or tap (touch devices)**.
* Should have a **clear focus indicator** when navigated via keyboard.

2. **Tooltip Box**

* The container that appears when the tooltip is activated.
* Should be **positioned near the trigger element** for contextual relevance.
* Should have **`role="tooltip"`** for proper screen reader support.

3. **Tooltip Content**

* Contains the **explanatory text or information**.
* Should be **short and concise** to avoid overwhelming users.
* Should **not contain interactive elements** like links or buttons in simple tooltips.

4. **Arrow (Optional)**

* A **visual pointer** indicating the tooltip's source.
* Adjusts dynamically **based on the tooltip's position** (e.g., top, bottom, left, right).

5. **Optional Interactive Elements (For Rich Tooltips)**

* Some tooltips allow **links, buttons, or other interactive elements**.
* Requires **`aria-haspopup="true"` and `aria-expanded="true|false"`** for accessibility.
* Should **remain open while interacting** and dismiss only when clicking outside or pressing `Esc`.

6. **Dismiss Behavior**

* Simple tooltips **should disappear on mouse-out, focus loss, or tap elsewhere**.
* Rich tooltips **should remain open until dismissed manually**.

#### **Summary of Components**

| Component            | Required? | Purpose                                        |
| -------------------- | --------- | ---------------------------------------------- |
| Trigger Element      | ✅ Yes     | The element that triggers the tooltip.         |
| Tooltip Box          | ✅ Yes     | Contains the tooltip message.                  |
| Tooltip Content      | ✅ Yes     | Displays a short explanatory message.          |
| Arrow                | ❌ No      | Visually connects the tooltip to the trigger.  |
| Interactive Elements | ❌ No      | Enables links or buttons inside rich tooltips. |
| Dismiss Behavior     | ✅ Yes     | Defines how and when the tooltip should close. |

## Best Practices

### Content

**Do's for Simple Tooltips ✅**

* **Keep concise**—**1-2 sentences max** to provide quick context.
* **Trigger on hover and focus** for accessibility.
* **Position strategically** to **avoid covering nearby elements**.

**Do's for Rich Tooltips ✅**

* **Use when additional context is needed** (e.g., explanations, formatted text).
* **Ensure it remains visible until dismissed**, if interactive.
* **Allow keyboard navigation** if containing buttons or links.

**Don'ts ❌**

* **Avoid tooltips for critical information**—users might miss them.
* **Don't overuse long tooltips**—consider using a popover or [modal](/patterns/content-management/modal).
* **Avoid adding interactive elements** (buttons, links) inside tooltips unless using an accessible popover.

### Accessibility

**Do's for Simple Tooltips ✅**

* **Ensure they appear on `focus` as well as hover**.
* **Use `aria-describedby`** on the trigger element to associate it with the tooltip.
* **Provide `role="tooltip"`** for proper screen reader support.

**Do's for Rich Tooltips ✅**

* **If interactive, use `aria-haspopup="true"`** and **`aria-expanded="true|false"`**.
* **Allow users to dismiss using Escape key**.
* **Ensure users can tab into and out of the tooltip seamlessly**.

**Don'ts ❌**

* **Don't rely only on hover-based activation**—ensure focus also triggers tooltips.
* **Avoid auto-closing tooltips too quickly**, which may frustrate users.
* **Don't position tooltips in a way that obstructs other content**.

### Visual Design

**Do's ✅**

* **Use subtle animations** (fade-in, fade-out) for smooth appearance.
* **Ensure tooltips have readable font sizes** (at least `14px`).
* **Maintain sufficient padding and spacing** for easy readability.
* **Use arrows or indicators** to clearly point to the related element.

**Don'ts ❌**

* **Avoid excessive delays in showing tooltips**—users should see them instantly.
* **Don't use tooltips that disappear too quickly** before users can read them.
* **Avoid distracting animations** that hinder usability.

### Performance Optimization

**Do's ✅**

* **Lazy-load tooltips** to reduce initial page load impact.
* **Use CSS for animations** (`opacity`, `transform`) instead of JavaScript.
* **Minimize reflows and repaints** when tooltips appear or disappear.

**Don'ts ❌**

* **Avoid excessive event listeners** that degrade performance.
* **Don't trigger tooltips on every mouse movement**—use `mouseenter` instead of `mousemove`.

### Common Mistakes & Anti-Patterns

#### Tooltips That Disappear Too Fast

**❌ What’s Wrong?**

Users might not have enough time to read the tooltip before it disappears.

**How to Fix It?**
Ensure tooltips remain visible **for at least 3–5 seconds** or stay open on hover.

***

#### Not Accessible via Keyboard

**❌ What’s Wrong?**

Many tooltips rely only on hover, making them inaccessible to keyboard users.

**How to Fix It?**
Ensure tooltips can be triggered \*\*via focus (`Tab` key)`**. For screen readers, pair `aria-describedby`on the trigger element with`role="tooltip"\` on the tooltip container.

***

#### Blocking Important Content

**❌ What’s Wrong?**

Tooltips that cover input fields or buttons create confusion and may block clicks or taps.

**How to Fix It?**
Position tooltips **away from interactive elements** and use arrow indicators to point from the trigger to the tooltip.

***

#### Overloading with Too Much Text

**❌ What’s Wrong?**

Long tooltips become unreadable, especially for screen readers that have to announce everything at once.

**How to Fix It?**
Keep tooltips **brief (max 2 lines)**. For more details, link to a help page or open a larger popover or modal instead.

***

#### Not Announced by Screen Readers (Accessibility)

**❌ What’s Wrong?**

Tooltips that appear on mouse hover but lack ARIA attributes aren’t announced to screen reader users.

**How to Fix It?**
Use `role="tooltip"` for the tooltip element and link it to the trigger with `aria-describedby="tooltipId"`. Keep the tooltip in the DOM while it’s visible so assistive tech can detect it.

***

#### Insufficient Color Contrast or Tiny Font (Accessibility)

**❌ What’s Wrong?**

Text that’s too small or low-contrast is difficult for users with low vision to read.

**How to Fix It?**
Maintain a **4.5:1** color contrast ratio (minimum) and use a **legible font size** (usually at least 14–16px). Test with browser zoom to ensure the tooltip scales properly.

## Tracking

Tracking tooltip interactions helps measure their effectiveness, determine whether users find them useful, and identify potential usability issues. By analyzing tooltip engagement, we can assess whether tooltips enhance comprehension or if users ignore them.

### Key Tracking Points

Each tooltip interaction provides valuable insights into user behavior. Below are the key events that should be tracked:

| **Event Name**             | **Description**                                                       | **Why Track It?**                                   |
| -------------------------- | --------------------------------------------------------------------- | --------------------------------------------------- |
| `tooltip.view`             | When the tooltip first appears (hover, focus, or auto-triggered).     | Determines how often users see tooltips.            |
| `tooltip.auto_open`        | When a tooltip appears automatically without user action.             | Helps assess if tooltips are too intrusive.         |
| `tooltip.hover_open`       | When a user opens a tooltip by hovering over a trigger element.       | Tracks hover-based interactions.                    |
| `tooltip.focus_open`       | When a tooltip opens via keyboard focus.                              | Ensures accessibility engagement is measured.       |
| `tooltip.click_open`       | When a tooltip opens via a user click (if applicable).                | Measures intentional user engagement.               |
| `tooltip.close`            | When a tooltip is dismissed (moving cursor away, pressing Esc, etc.). | Tracks how users exit tooltips.                     |
| `tooltip.interaction_time` | The time a user spends viewing the tooltip before closing it.         | Helps determine if tooltips are helpful or ignored. |

### Event Payload Structure

To ensure consistent tracking, here’s a recommended event format:

```json
```

### Key Metrics to Analyze

Once tracking is in place, the following metrics provide actionable insights:

* Tooltip View Rate → Percentage of users who trigger a tooltip.
* Hover vs. Focus Activation Rate → Compares how users open tooltips (mouse vs. keyboard).
* Dismissal Rate → Percentage of users who close the tooltip quickly.
* Average Interaction Time → How long users keep the tooltip open.
* Repeated Views Per User → Indicates if users need repeated clarification.

### Insights & Optimization Based on Tracking

By analyzing tracking data, we can optimize tooltip behavior:

* 🚨 **Low Tooltip View Rate?**
  → Users might not notice tooltips or may not need them.
  **Optimization:** Ensure triggers are visually clear, adjust placement, or test if an inline explanation is more effective.

* ⏳ **Short Interaction Time?**
  → Users might be dismissing tooltips too quickly without reading them.
  **Optimization:** Simplify content, increase font size, or extend the display duration before auto-hiding.

* 📉 **High Dismissal Rate?**
  → Tooltips may be appearing at the wrong time, covering important content, or distracting users.
  **Optimization:** Adjust positioning, delay appearance, or use persistent inline text instead of a tooltip.

* 🎯 **Low Focus Activation Rate?**
  → Keyboard users may struggle to access tooltips, indicating accessibility issues.
  **Optimization:** Ensure proper **ARIA attributes** (`aria-describedby`), focus management, and keyboard navigation support.

* 🔄 **Frequent Repeated Views?**
  → Users may not fully understand the tooltip content.
  **Optimization:** Improve clarity, rewrite text concisely, or add supporting visuals like icons or links to more detailed help content.

By continuously monitoring these metrics, we can refine tooltip usability and ensure they provide **real value** rather than unnecessary friction.

## Code Examples

### Basic Implementation

```html
<!-- Tooltip Trigger -->
<button aria-describedby="tooltip-example" class="tooltip-trigger">?</button>

<!-- Tooltip -->
<div id="tooltip-example" role="tooltip" class="tooltip-content">
  This is additional information about the element.
</div>
```

## Accessibility

### Keyboard Interaction Pattern

The following table outlines the standard keyboard interactions for tooltip components. These interactions ensure that users can access and dismiss tooltips effectively using only a keyboard.

| Key         | Action                                                                                           |
| ----------- | ------------------------------------------------------------------------------------------------ |
| Tab         | Moves focus to the element that triggers the tooltip. The tooltip should appear on focus.        |
| Shift + Tab | Moves focus to the previous interactive element. The tooltip should close when focus moves away. |
| Escape      | Dismisses the tooltip manually (if dismissible).                                                 |
| Enter/Space | Activates the tooltip (for tooltips that require explicit activation).                           |

> **Note**: Tooltips should appear when an element **receives focus** (for keyboard users) and **disappear when focus moves away**. If a tooltip is **interactive** (contains links or buttons), it must be dismissible via the `Escape` key.

## Testing Guidelines

### Functional Testing

**Should ✓**

* [ ] Ensure the tooltip **appears on hover, focus, and touch activation**.
* [ ] Verify the tooltip **disappears when focus is removed** or the user moves the cursor away.
* [ ] Test that tooltips **do not obstruct important content** when displayed.
* [ ] Confirm that tooltips **adapt properly on different screen sizes**.
* [ ] Validate that tooltips **do not break layout or cause visual glitches**.

### Accessibility Testing

**Should ✓**

* [ ] Ensure tooltips are **keyboard accessible** (triggered via `Tab` key).
* [ ] Verify that tooltips are **announced by screen readers** when triggered.
* [ ] Confirm `aria-describedby` **correctly links tooltips to their respective elements**.
* [ ] Check that tooltips **persist long enough** for screen reader users to read.
* [ ] Ensure **sufficient color contrast** between tooltip text and background.
* [ ] Test with `prefers-reduced-motion` enabled to ensure animations are minimized.

### Visual Testing

**Should ✓**

* [ ] Confirm tooltip text is **legible across all screen sizes**.
* [ ] Validate **proper spacing and positioning** of tooltips.
* [ ] Test tooltip animations for **smooth appearance and disappearance**.
* [ ] Ensure tooltips **do not overlap critical UI elements**.
* [ ] Verify tooltips **align properly with their trigger elements**.

### Performance Testing

**Should ✓**

* [ ] Measure tooltip render performance to **avoid jank or slow animations**.
* [ ] Ensure tooltips **lazy-load when necessary** to prevent excessive memory usage.
* [ ] Optimize tooltip animations to **use `opacity` and `transform` for smooth rendering**.
* [ ] Test for **efficient event handling** to avoid performance degradation on repeated interactions.

## Design Tokens

These design tokens follow the [Design Tokens Format](https://design-tokens.github.io/community-group/format/) specification and can be used with various token transformation tools to generate platform-specific variables.

### Tooltip Tokens in DTF Format

```json
{
  "$schema": "https://design-tokens.org/schema.json",
  "tooltip": {
    "background": ,
    "textColor": ,
    "padding": ,
    "borderRadius": ,
    "animationDuration": ,
    "maxWidth": ,
    "arrowSize": ,
    "offset": ,
    "shadow": 
  }
}
```

## Related Patterns

Consider these related patterns when implementing tooltips:

* [Modal](/patterns/content-management/modal) - Used for critical interactions requiring full focus.
* [Popover](/patterns/content-management/popover) - Used when the additional content that requires user interaction, such as buttons or form elements, rather than just providing passive information.
* [Selection Input / Dropdown](/patterns/forms/selection-input) - Best for more complex navigation menus.

## Frequently Asked Questions

## Resources

### Articles

* [Tooltip - Nielsen Norman Group](https://www.nngroup.com/articles/tooltip-guidelines/)
* [Designing better tooltips for improved UX - LogRocket Blog](https://blog.logrocket.com/ux-design/designing-better-tooltips-improved-ux/)

### Documentation

* [Tooltip Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/tooltip/)

### Libraries

* [Tooltip - shadcn/ui](https://ui.shadcn.com/docs/components/tooltip)
* [Tooltip - Origin UI](https://originui.com/tooltip)


# FORMS: [Autocomplete](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/autocomplete)

Build user-friendly autocomplete with search suggestions, keyboard navigation, and accessibility features.

# Autocomplete

***(Also called Autosuggest)***

## Overview

The **autocomplete** is an interactive input component that helps users quickly find and select values from a predefined list of options as they type.

They combine the flexibility of [text input](/patterns/forms/text-field) with dropdown-style selection, providing suggestions that match the user's input in real-time. This pattern reduces errors, speeds up data entry, and improves the overall form completion experience.

## Use Cases

### When to use:

* When users need to select from a large set of predefined options (e.g., country selection, airport codes)
* When you want to help users find and select options more quickly than scrolling through a long dropdown
* When you want to reduce errors by guiding users to valid input options
* When the input has a finite set of valid responses that are known in advance
* When you want to combine free text input with suggestion functionality

### When not to use:

* When there are fewer than 10 options (use a standard dropdown/select instead)
* When users need to enter completely free-form text without restrictions
* When all options need to be visible at once for comparison
* When network latency could significantly delay suggestion results
* When the input field requires exact, verbatim text entry (like passwords)

### Common scenarios and examples

* **Searching for products** in an e-commerce catalog
* **Entering city names** for travel or weather applications
* **Looking up user or contact names** in a messaging or collaboration tool

## Benefits

* **Speeds up data entry** by narrowing down possible options in real-time
* **Reduces user frustration** and guesswork by guiding them to valid options
* **Minimizes mistakes** and typos, as suggestions can be confirmed or chosen from a list

## Drawbacks

* **Accessibility challenges** – Requires proper ARIA attributes (`aria-expanded`, `aria-controls`, `aria-activedescendant`) for screen readers.
* **Keyboard navigation complexity** – Users must be able to navigate the suggestions using arrow keys and select options with Enter.
* **Performance issues** – Fetching suggestions dynamically can introduce lag if not optimized with debouncing and caching.
* **Overwhelming for users** – Too many suggestions or unclear results can create cognitive overload.
* **Implementation effort** – Requires handling both filtering logic and managing suggestion visibility correctly.

## Anatomy

### Component Structure

```mermaid
graph TD
    A[Autocomplete] --> B[Container]
    B --> C[Input Field]
    B --> D[Suggestions List]
    B --> E[Clear Button]

    C --> F[Label]
    C --> G[Text Input]
    C --> H[Loading Indicator]

    D --> I[Suggestion Items]
    I --> J[Item 1]
    I --> K[Item 2]
    I --> L[Item n...]

    J --> M[Text Match]
    J --> N[Additional Info]

    E --> O[Clear Icon]
```

1. **Container**

* Wraps the entire autocomplete area, including the input and dropdown
* Handles positioning, sizing, and possible floating layers for the suggestions

2. **Input**

* The text field where users type their query
* Provides real-time updates and triggers suggestion fetching

3. **Label**

* Optional text label describing the input's purpose
* Provides clarity for screen readers and visible context for users

4. **Clear Button**

* Allows users to quickly clear the input field
* Often represented by an "X" or "✕" icon

## Best Practices

### Content

**Do's ✅**

* Provide a descriptive label that indicates the purpose of the Autocomplete field
* Use placeholder text to show example input (e.g., "Start typing a country...")

**Don'ts ❌**

* Don't rely on placeholder text as a replacement for a label
* Don't make your suggestions so vague that it's unclear what the user is selecting

### Accessibility

**Do's ✅**

* Use `aria-controls`, `aria-autocomplete`, and other relevant ARIA attributes to help screen readers
* Include a visually hidden label or descriptive text if you rely on an icon-only clear button
* Add a debounce delay to the input field to avoid triggering a fetch request too often

**Don'ts ❌**

* Don't remove focus outlines without providing alternative focus indicators
* Don't assume all users can use a mouse; ensure keyboard navigation works properly

### Visual Design

**Do's ✅**

* Keep the suggestion list clearly delineated, with sufficient contrast and spacing
* Highlight hovered or focused suggestion items with a distinct visual state

**Don'ts ❌**

* Don't display an overly large list of suggestions (limit it to a reasonable number), use a scroll bar to allow users to scroll through the list.
* Don't create a cluttered or confusing interface by mixing too many design elements

### Layout & Positioning

**Do's ✅**

* Position the dropdown list immediately below the input field
* Ensure suggestions list appears in front of other page elements when open

**Don'ts ❌**

* Don't hide the list behind overlays or modals
* Don't move the dropdown to a completely different area away from the input

## Code Examples

### Basic Implementation

```html
<!-- Basic Autocomplete Markup -->
<div>
  <label for="autocompleteInput">Search for an option</label>
  <input
    type="text"
    id="autocompleteInput"
    name="autocompleteInput"
    aria-autocomplete="list"
    aria-controls="suggestions-list"
    autocomplete="off"
    placeholder="Type to search..."
  />
  <button type="button" aria-label="Clear input">✕</button>
  <ul id="suggestions-list" role="listbox">
    <!-- Dynamically generated suggestions go here -->
  </ul>
</div>
```

## Design Tokens

These design tokens follow the [Design Tokens Format](https://design-tokens.github.io/community-group/format/) specification and can be used with various token transformation tools to generate platform-specific variables.

### Autocomplete Tokens in DTF Format

```json
{
  "$schema": "https://design-tokens.org/schema.json",
  "Autocomplete": {
    "container": {
      "borderRadius": ,
      "background": 
    },
    "input": ,
    "suggestionsList": {
      "maxHeight": ,
      "background": ,
      "itemHoverBg": 
    }
  }
}
```

## Frequently Asked Questions

## Resources

### Articles

* [9 UX Best Practice Design Patterns for Autocomplete Suggestions](https://baymard.com/blog/autocomplete-design) by Baymard Institute
* [Best Practices: Designing autosuggest experiences](https://uxmag.com/articles/best-practices-designing-autosuggest-experiences)

## Documentation

* [WAI-ARIA: Combobox Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/combobox/)


# FORMS: [Button](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/button)

Create accessible and user-friendly buttons with proper states, design patterns, and implementation guidelines.

# Button

## Overview

**Buttons** are interactive elements that trigger actions or events when clicked or interacted with.

## Use Cases

### When to use:

* To trigger an immediate action or event (e.g., "Save", "Delete", "Send")
* To submit a form
* To open or close interactive elements (modals, dialogs, menus)
* To toggle between states (e.g., play/pause, show/hide)
* To download files or content
* To navigate between steps in a multi-step process

### When not to use:

* For navigation between pages (use links instead)
* When the action isn't immediately clear to users
* For text-only content that doesn't trigger an action
* When the interaction would be better served by a different component (e.g., checkbox, toggle switch)
* When multiple conflicting actions are grouped together
* When the action requires additional context that isn't immediately available

### Common scenarios and examples

* Primary actions: "Submit", "Save", "Continue"
* Secondary actions: "Cancel", "Back", "Reset"
* Destructive actions: "Delete", "Remove", "Clear All"
* Toggle actions: "Show More", "Expand/Collapse", "Play/Pause"
* Process actions: "Upload", "Download", "Export"
* Social actions: "Share", "Follow", "Like"

## Benefits

* Provides clear, actionable interactions for users to accomplish tasks
* Maintains consistency in user interface interactions across the application
* Offers visual feedback and states (hover, focus, active, disabled) to enhance usability
* Supports accessibility through keyboard navigation and screen reader compatibility
* Reduces cognitive load by making actions immediately recognizable

## Drawbacks

* **Overuse can lead to UI clutter** – Too many buttons in an interface can confuse users.
* **Styling inconsistencies** – Needs proper theming and responsive considerations for different screen sizes.
* **Click area issues** – If not sized properly, buttons may be difficult to tap on mobile.
* **Lack of clear labels** – Buttons without descriptive text (e.g., just an icon) can cause usability problems.
* **Focus management** – Requires proper `:focus` states for accessibility and keyboard users.

## Anatomy

```mermaid
flowchart TB
subgraph Button
Container[Container Element] -->|contains| Content[Content Area]
Content --> Icon[Icon <optional>]
Content --> Label[Label Text]
Content --> LoadingSpinner[Loading Spinner <optional>]

classDef container stroke:#666,stroke-width:2px
class Button container
end
```

### Component Structure

1. **Container**

* The root button element that wraps all other components
* Handles click events and keyboard interactions
* Manages focus states and accessibility attributes
* Contains variants for different button styles (default, destructive, outline, etc.)

2. **Label Text**

* The button label communicates the action that will occur
* Should be clear, concise, and action-oriented
* Must maintain proper contrast ratio with the background

3. **Icon (Optional)**

* Icons can be added to clarify an action
* Should be the same color as the text
* Placed on the left side of the label by default
* Size should be proportional to text (default 16x16px)
* Should include proper ARIA labels when used alone

4. **Loading State (Optional)**

* Visual indicator for async operations
* Replaces or overlays the button content
* Should maintain the button's original width
* Prevents multiple clicks during loading
* Typically uses a spinner or progress indicator
* Add loading text alongside spinners (e.g., "Saving..." vs just a spinner)

5. **Visual States**

* Default: Normal state
* Hover: Visual feedback on mouse over
* Focus: Keyboard navigation indicator
* Active: Pressed state
* Disabled: Indicates non-interactive state
* Loading: Shows processing state

### **Summary of Components**

| Component     | Required? | Purpose                                                   |
| ------------- | --------- | --------------------------------------------------------- |
| Container     | ✅ Yes     | Wraps all button elements and handles interactions.       |
| Label Text    | ✅ Yes     | Communicates the action that the button performs.         |
| Icon          | ❌ No      | Enhances clarity of the action (typically placed left).   |
| Loading State | ❌ No      | Indicates an ongoing process (e.g., saving, submitting).  |
| Visual States | ✅ Yes     | Defines button interactions (hover, focus, active, etc.). |

## Button Variations

### Content Composition

1. **Text Only**

   ```html
   <button type="button">Button</button>
   ```

2. **Icon Only**

   ```html
   <button type="button" aria-label="Settings">
     <svg aria-hidden="true">...</svg>
   </button>
   ```

3. **Icon + Text**

   * Left Icon

   ```html
   <button type="button">
     <svg aria-hidden="true">...</svg>
     <span>Button</span>
   </button>
   ```

   * Right Icon

   ```html
   <button type="button">
     <span>Button</span>
     <svg aria-hidden="true">...</svg>
   </button>
   ```

4. **Double Icon**

   ```html
   <button type="button">
     <svg aria-hidden="true">...</svg>
     <span>Button</span>
     <svg aria-hidden="true">...</svg>
   </button>
   ```

5. **With Counter/Badge**

   ```html
   <button type="button">
     <span>Messages</span>
     <span class="counter">18</span>
   </button>
   ```

6. **With Command/Shortcut**
   ```html
   <button type="button">
     <span>Print</span>
     <span class="shortcut">⌘P</span>
   </button>
   ```

### Profile Variations

7. **With Avatar**
   ```html
   <button type="button">
     <img src="avatar.jpg" alt="" />
     <span>@username</span>
   </button>
   ```

### Action Groups

8. **Button Groups**

   * Horizontal Group

   ```html
   <div role="group" aria-label="Text alignment">
     <button type="button">Left</button>
     <button type="button">Center</button>
     <button type="button">Right</button>
   </div>
   ```

   * Vertical Group

   ```html
   <div role="group" aria-label="Actions" class="vertical">
     <button type="button">Files</button>
     <button type="button">Media</button>
   </div>
   ```

9. **Split Buttons**
   ```html
   <div class="split-button">
     <button type="button">Action</button>
     <button type="button" aria-label="More options">▼</button>
   </div>
   ```

### State Variations

10. **Loading States**

    ```html
    <button type="button" aria-busy="true">
      <svg class="spinner" aria-hidden="true">...</svg>
      <span>Loading...</span>
    </button>
    ```

11. **Toggle States**
    ```html
    <button type="button" aria-pressed="false">
      <span>Pin</span>
    </button>
    ```

### Social Variations

12. **Social Login**
    ```html
    <button type="button" class="social-login google">
      <svg aria-hidden="true">...</svg>
      <span>Login with Google</span>
    </button>
    ```

### Special Purpose

13. **Upload Button**

    ```html
    <button type="button" class="upload">
      <svg aria-hidden="true">...</svg>
      <span>Upload image</span>
      <span class="status">No image uploaded</span>
    </button>
    ```

14. **Numeric Indicator**
    ```html
    <button type="button">
      <span>Star</span>
      <span class="count">729</span>
    </button>
    ```

Each variation can be combined with different visual styles (primary, secondary, outline, ghost) and sizes (small, medium, large) to create the full range of possible button components.

## Best Practices

### Content

**Do's ✅**

* Use action verbs that describe what the button does (eg: "Save" instead of "Submit")
* Keep button labels concise and clear
* Be consistent with button labeling across the application
* Include loading text when appropriate ("Saving..." vs "Save")
* Use sentence case for button labels (e.g., "Save Changes")

**Don'ts ❌**

* Don't use vague labels like "Click Here" or "Submit"
* Don't use inconsistent terminology
* Don't write overly long button labels
* Don't use technical jargon in button labels
* Don't mix different cases in button labels

### Accessibility

**Do's ✅**

* Use descriptive labels that clearly communicate the action [^describe-buttons]
* Provide visual feedback for all interactive states
* Ensure keyboard navigation works properly
* Include loading states for asynchronous actions
* Don't pass the `disabled` attribute to buttons, instead use `aria-disabled`. You would risk disrupting the keyboard navigation flow as this would reset focus on the button.
* Use descriptive loading states with both text and visual indicators

**Don'ts ❌**

* Don't rely solely on color to communicate button states
* Don't disable browser focus indicators without providing alternatives
* Don't use button elements for navigation (use links instead)
* Don't auto-focus destructive actions
* Don't remove focus styles

### Visual Design

**Do's ✅**

* Use the same button style for the same action throughout the application
* Make buttons finger-friendly for mobile users (minimum 44x44px touch target)
* Use appropriate visual hierarchy (primary, secondary, tertiary buttons)
* Maintain consistent spacing between button groups
* Use appropriate color contrast ratios (WCAG 2.1 AA compliance)
* Include hover and focus states for interactive feedback
* Keep icon and text alignment consistent
* Maintain consistent padding and height across similar buttons
* Scale button size appropriately for different viewport sizes

**Don'ts ❌**

* Don't have more than one primary action button on the screen at a time
* Don't use a [dark pattern](https://www.deceptive.design/) when you don't want users to take a certain action
* Don't mix different button styles for the same action type
* Don't use colors that conflict with your application's color scheme
* Don't make disabled buttons look interactive
* Don't use inconsistent corner radius within button groups
* Avoid having buttons looking like links or vice versa
* Don't use spinners without descriptive text

### Mobile & Touch Considerations

**Do's ✅**

* Place primary actions within thumb-friendly zones
* Use full-width buttons for important actions on mobile
* Implement haptic feedback for touch interactions
* Maintain sufficient spacing between touch targets (minimum 8px)

**Don'ts ❌**

* Don't place critical actions in hard-to-reach corners
* Don't rely solely on hover states for mobile feedback
* Don't make touch targets smaller than 44x44px
* Don't crowd multiple buttons together on mobile views

### Layout & Positioning

**Do's ✅**

* Place primary action buttons in prominent, easily accessible locations
* Align buttons consistently within forms and dialogs
* Group related buttons together
* Consider mobile touch targets (minimum 44x44px)

**Don'ts ❌**

* Don't position buttons where they might be accidentally clicked
* Don't hide important actions behind dropdown menus
* Don't place buttons in unexpected locations (e.g., footer)

## Code Examples

### Basic Implementation

```html
<!-- Small Button -->
<button type="button" class="button-sm">Small</button>

<!-- Default Size Button -->
<button type="button">Default</button>

<!-- Large Button -->
<button type="button" class="button-lg">Large</button>

<!-- Icon-only Button -->
<button type="button" aria-label="Settings">
  <svg aria-hidden="true">
    <use href="#icon-settings" />
  </svg>
</button>
```

### Form Submit Button

```html
<form>
  <!-- Form fields here -->
  <button type="submit" class="button button-primary" data-loading="false">
    <span class="button-text">Submit Form</span>
    <svg class="icon spinner hidden" aria-hidden="true">
      <use href="#icon-loading" />
    </svg>
  </button>
</form>
```

## Accessibility

### ARIA Attributes

**Required ARIA attributes:**

* Use `aria-label` for icon-only buttons
* Use `aria-pressed` for toggle buttons
* Use `aria-expanded` for buttons that control expandable content
* Use `aria-disabled="true"` instead of the `disabled` attribute
* Use `aria-describedby` to associate additional descriptive text

### Screen Reader Support

**Implementation example:**

```html
<!-- Icon-only button with proper ARIA -->
<button type="button" aria-label="Close dialog">
  <svg aria-hidden="true">
    <use href="#icon-close" />
  </svg>
</button>

<!-- Toggle button with ARIA pressed state -->
<button type="button" aria-pressed="false"">
  <span>Dark mode</span>
</button>

<!-- Expandable content button -->
<button type="button" aria-expanded="false" aria-controls="content-1">
  <span>Show more</span>
</button>
```

### Keyboard Navigation

* Buttons must be focusable and activated with both Enter and Space keys
* Focus order should follow a logical sequence
* Focus states must be clearly visible
* Avoid removing focus outlines without providing alternatives
* Maintain focus after interactions (e.g., after closing a modal)

## Testing Guidelines

### Functional Testing

**Should ✓**

* [ ] Show a loader when the button is submitting a form
* [ ] Disable the button during form submission to prevent double submissions
* [ ] Handle click events and trigger the appropriate action
* [ ] Maintain proper visual states (hover, focus, active, disabled)
* [ ] Support keyboard interaction (Enter and Space keys)
* [ ] Preserve button width when switching between normal and loading states
* [ ] Reset to initial state after operation completion

### Accessibility Testing

**Should ✓**

* [ ] Be focusable and have visible focus indicators
* [ ] Have proper ARIA labels, especially for icon-only buttons
* [ ] Maintain sufficient color contrast ratios (WCAG 2.1 AA)
* [ ] Support screen reader announcements of button state changes
* [ ] Be operable with keyboard navigation
* [ ] Communicate loading states to assistive technologies
* [ ] Have appropriate touch target sizes (minimum 44x44px)

### Visual Testing

**Should ✓**

* [ ] Maintain consistent styling across different variants (primary, secondary, destructive)
* [ ] Display icons with correct alignment and spacing
* [ ] Show proper visual feedback for all interactive states
* [ ] Render correctly across different viewport sizes
* [ ] Handle text overflow appropriately
* [ ] Display loading spinners centered within the button
* [ ] Maintain proper padding and margins in all states

### Performance Testing

**Should ✓**

* [ ] Render without layout shifts
* [ ] Handle rapid click events appropriately
* [ ] Maintain smooth transitions between states
* [ ] Load icons and spinners efficiently
* [ ] Function without JavaScript (progressive enhancement)

### Testing Tools

* Accessibility: [WAVE](https://wave.webaim.org/), [aXe](https://www.deque.com/axe/browser-extensions/), or [Lighthouse](https://developer.chrome.com/docs/lighthouse/overview)
* SEO: [Google's Rich Results Test](https://developers.google.com/search/docs/appearance/structured-data)
* Performance: [Chrome DevTools Performance panel](https://developer.chrome.com/docs/devtools/performance/overview)
* Visual Regression: [Percy](https://percy.io/) or [Chromatic](https://www.chromatic.com/)
* Cross-browser: [BrowserStack](https://www.browserstack.com/) or [Sauce Labs](https://saucelabs.com/)

## Browser Support

## Design Tokens

These design tokens follow the [Design Tokens Format](https://design-tokens.github.io/community-group/format/) specification and can be used with various token transformation tools to generate platform-specific variables.

### Button Tokens in DTF Format

```json
{
  "$schema": "https://design-tokens.org/schema.json",
  "button": {
    "sizing": {
      "height": ,
      "paddingX": ,
      "iconSize": ,
      "iconGap": ,
      "touchTarget": 
    },
    "typography": {
      "fontFamily": ,
      "fontWeight": ,
      "fontSize": 
    },
    "border": {
      "radius": ,
      "width": 
    },
    "variants": {
      "primary": {
        "background": {
          "default": ,
          "hover": ,
          "active": ,
          "disabled": 
        },
        "text": {
          "default": ,
          "disabled": 
        }
      },
      "secondary": {
        "background": {
          "default": ,
          "hover": ,
          "active": ,
          "disabled": 
        },
        "text": {
          "default": ,
          "disabled": 
        }
      },
      "destructive": {
        "background": {
          "default": ,
          "hover": ,
          "active": ,
          "disabled": 
        },
        "text": {
          "default": ,
          "disabled": 
        }
      },
      "outline": {
        "border": {
          "default": ,
          "hover": ,
          "active": ,
          "disabled": 
        },
        "text": {
          "default": ,
          "disabled": 
        }
      }
    },
    "states": {
      "focusRing": {
        "width": ,
        "offset": ,
        "color": 
      },
      "loadingSpinner": 
    }
  }
}
```

## Frequently Asked Questions

\` and manage ARIA attributes appropriately.",
},
,
,
]}
/>

## Resources

### Articles

* [button: The Button element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button)

* [I've been doing buttons wrong! Have you?](https://uxplanet.org/ive-been-doing-buttons-wrong-have-you-2117c0066613) by Adham Dannaway

* [A comprehensive guide to buttons](https://uxplanet.org/a-comprehensive-guide-to-buttons-8f3b8a1c6f0d) by UX Planet

* [A comprehensive guide to designing UX buttons](https://www.invisionapp.com/inside-design/comprehensive-guide-designing-ux-buttons/?ref=checklist.design) by InVision

* [Building Accessible Buttons with ARIA: A11y Support Series](https://www.deque.com/blog/accessible-aria-buttons/) by Deque

* [Buttons A11y Styleguide](https://a11y-style-guide.com/style-guide/section-general.html#kssref-general-buttons)

### Design systems

* [Style Dictionary](https://styledictionary.com/)
* [Button (Carbon Design System)](https://carbondesignsystem.com/components/button/usage/)
* [Button (Material Design)](https://m3.material.io/components/all-buttons)

### Libraries

[Button - Origin UI](https://originui.com/button)

### Footnotes

[^describe-buttons]: [Descriptive buttons](https://primer.style/guides/accessibility/descriptive-buttons)


# FORMS: [Checkbox](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/checkbox)

Learn how to implement accessible checkbox inputs in your web applications. Discover best practices for multiple selection controls, states handling, and accessibility.

# Checkbox

## Related components

* Only one selection: [Radio button](/patterns/forms/radio)
* On and Off option [Toggle](/patterns/forms/toggle)


# FORMS: [Code Confirmation](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/code-confirmation)

Implement user-friendly code confirmation inputs for verification codes and OTPs. Learn best practices for segmented inputs, auto-focus behavior, and accessibility.

# Code Confirmation

![2FA Code Confirmation](/patterns/code-confirmation/do/paypal.jpg)
*Good example of 2FA code confirmation screen from PayPal*


# FORMS: [Color Picker](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/color-picker)

Select colors with visual feedback

# Color Picker


# FORMS: [Currency Input](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/currency-input)

Create currency input fields with number formatting and international currency handling.

# Currency Input

### Internationalization Beyond Localization

* **Currency Formatting** → Adapt for region-specific formats (e.g., `$1,299.99 USD` vs. `1.299,99 € EUR`).


# FORMS: [Date Input](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/date-input)

Build date input fields with validation, formatting, and localization features.

# Date Input


# FORMS: [Date Picker](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/date-picker)

Create user-friendly date pickers with calendar interfaces and keyboard navigation.

# Date Picker


# FORMS: [Date Range](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/date-range)

Build date range selection with calendar interfaces and validation features.

# Date Range


# FORMS: [File Input](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/file-input)

Create user-friendly file upload components for your web applications. Learn best practices for file selection, drag-and-drop, progress indicators, and validation.

# File Input


# FORMS: [Form Validation](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/form-validation)

Learn how to implement effective form validation in your web applications. Discover best practices for error handling, real-time validation, and user feedback.

# Form Validation

## Comparison of Required Field Marking Methods

| Alternative                                           | Description                                                              | Pros ✅                                                                                                                               | Cons ❌                                                                                                                                                                                                             |
| ----------------------------------------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **1️⃣ Explicit "Required" Label**                     | Displays **"(Required)"** next to the label.                             | - Works for **all users**, including screen readers and color-blind users.<br/>- No need for extra ARIA attributes.                  | - Takes slightly more space in the UI.                                                                                                                                                                             |
| **2️⃣ Asterisk (\*) with ARIA Explanation**           | Uses **`*`** but adds an `aria-describedby` explanation.                 | - Keeps UI cleaner while maintaining accessibility.<br/>- Screen readers announce **"Fields marked with an asterisk are required."** | - **Requires additional explanation** (`aria-describedby`).<br/>- **Without the extra message, asterisks alone are not accessible**.                                                                               |
| **3️⃣ Required Field with Visually Hidden Text**      | Uses a **hidden label** for screen readers but remains minimal visually. | - **Looks clean visually** while still accessible.<br/>- **Screen readers announce it as "Email Required"**.                         | - **Not visible for sighted users** who rely on visual cues.                                                                                                                                                       |
| **4️⃣ Required Field with an Inline Icon + Tooltip**  | Uses **an asterisk (\*) inside a focusable icon** with a tooltip.        | - **Visually clear** while keeping text minimal.<br/>- Works well when paired with a **tooltip on hover or focus**.                  | - **Requires CSS for styling** (ensuring asterisks are not the only indicator).<br/>- Users **might not see tooltip hints** if they don't hover over the icon.                                                     |
| **5️⃣ Required Field with `required` Attribute Only** | Uses only the `required` attribute without visible markers.              | - Works well for **basic validation**.<br/>- Screen readers **will announce the field as required**.                                 | - No **visible indicator for sighted users** before form submission.<br/>- **Errors only appear after submission**, which may confuse users.<br/>- Some browsers may **not enforce required fields consistently**. |


# FORMS: [Input Selection Guide](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/input-selection-guide)

Learn how to select the most appropriate input types for your web forms. Get guidance on when to use text fields, dropdowns, checkboxes, and other form controls.

# Input Selection Guide

## When to use Different Types of Text Fields?

```mermaid
graph TD
  A[Do users need to enter freeform text?] -->|Yes| B[Does it require a single line?]
  B -->|Yes| C[Use Standard Text Field `<input type="text">`]
  B -->|No| D[Use Textarea `<textarea>` for multi-line input]

  A -->|No| E[Is the input structured or formatted?]
  E -->|Yes| F[Use Specific Input Type]
  E -->|No| C[Use Standard Text Field `<input type="text">`]
```

| Feature                         | Standard Text Field (`<input type="text">`) | Email Field (`<input type="email">`) | Password Field (`<input type="password">`) | Search Field (`<input type="search">`) | Telephone Field (`<input type="tel">`) | Number Field (`<input type="number">`) |
| ------------------------------- | ------------------------------------------- | ------------------------------------ | ------------------------------------------ | -------------------------------------- | -------------------------------------- | -------------------------------------- |
| **Use Case**                    | General text input                          | Email addresses                      | Password entry                             | Search queries                         | Phone numbers                          | Numeric inputs                         |
| **Supports Auto-Validation?**   | ❌ No                                        | ✅ Yes (valid email format)           | ❌ No                                       | ❌ No                                   | ❌ No                                   | ✅ Yes (only numeric input allowed)     |
| **Supports Autofill?**          | ✅ Yes                                       | ✅ Yes                                | ✅ Yes                                      | ✅ Yes                                  | ✅ Yes                                  | ✅ Yes                                  |
| **Masking Support?**            | ❌ No                                        | ❌ No                                 | ✅ Yes (hides input characters)             | ❌ No                                   | ❌ No                                   | ❌ No                                   |
| **Allows Non-Standard Input?**  | ✅ Yes                                       | ❌ No (only valid email formats)      | ✅ Yes (hidden input)                       | ✅ Yes (optimized for search)           | ✅ Yes (any phone number format)        | ❌ No (only numbers allowed)            |
| **Special Keyboard on Mobile?** | ❌ No                                        | ✅ Yes (`@` and `.com` on keyboards)  | ✅ Yes (secure keyboard)                    | ✅ Yes (optimized for searches)         | ✅ Yes (numeric keyboard)               | ✅ Yes (numeric keyboard)               |
| **Supports Pattern Matching?**  | ✅ Yes                                       | ✅ Yes                                | ❌ No                                       | ✅ Yes                                  | ✅ Yes                                  | ✅ Yes                                  |
| **Best For**                    | General-purpose text input                  | Emails                               | Secure password entry                      | Search bars                            | Phone number input                     | Numeric-only input                     |


# FORMS: [Multi Select Input](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/multi-select-input)

Implement multi-select components for multiple item selection in your web applications. Learn best practices for list management, keyboard navigation, and accessibility.

# Multi-select Input


# FORMS: [Password](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/password)

Build secure and user-friendly password fields with validation, strength indicators, and accessibility features.

# Password

## Overview

A **Password Input** is a specialized text field designed to securely collect user passwords. It masks characters to prevent onlookers from reading the input and may include additional security features such as password visibility toggles, strength indicators, and validation requirements.

Password fields are commonly used in **authentication forms, account creation, and security-related input fields** where sensitive data entry is required.

## Use Cases

### When to use:

* **Login and authentication forms** – Securing user access to accounts.
* **Account creation and password updates** – Ensuring users create strong, secure passwords.
* **Two-factor authentication (2FA) or PIN entry** – Protecting access to critical information.
* **Security-sensitive fields** – Protecting data such as encryption keys or private access codes.

### When not to use:

* **For non-sensitive text input** – Use a standard [text field](/patterns/forms/text-field) instead.
* **For one-time codes (OTP) or PINs** – Use the [Code Confirmation](/patterns/forms/code-confirmation) pattern instead.
* **For password confirmation fields** – Use an inline validation approach to avoid user frustration.

## Benefits

* **Enhances security** – Prevents passwords from being visible to onlookers.
* **Reduces accidental exposure** – Masks characters by default.
* **Encourages strong password usage** – Supports strength indicators and validation rules.
* **Supports accessibility** – Allows users to toggle visibility when needed.

## Drawbacks

* **Usability concerns** – Masking can lead to mistyped passwords.
* **Increased cognitive load** – Users may struggle to recall their input without visibility.
* **Potential security trade-offs** – Some password visibility toggles may pose a risk if not well-implemented.

## Best Practices

### Content & Usability

**Do's ✅**

* Provide a **password visibility toggle** to allow users to verify input.
* Display **clear error messages** when password criteria are not met.
* Indicate **password requirements before users type** to prevent frustration.
* Offer **password strength indicators** to encourage secure choices.
* Allow **paste functionality** to support password managers.

**Don'ts ❌**

* Don't enforce **arbitrary complexity rules** (e.g., forcing special characters unnecessarily).
* Avoid disabling **autofill** unless there is a valid security reason.
* Don't store passwords in plaintext or insecurely transmit them.

### Accessibility

**Do's ✅**

* Ensure the password toggle is **keyboard accessible**.
* Use **aria-describedby** to associate password requirements with the input field.
* Maintain **high contrast and clear focus states**.
* Allow users to **verify their input** without compromising security.

**Don'ts ❌**

* Don't rely on placeholder text for password guidance—it disappears when users type.
* Avoid requiring **excessive special characters** that make passwords difficult to remember.
* Don't assume all users can see visual strength indicators—provide **text-based guidance**.

### Security Considerations

**Do's ✅**

* Use **secure hashing algorithms** when storing passwords.
* Enforce **rate-limiting and lockouts** for repeated failed attempts.
* Implement **2FA options** for high-security applications.
* Allow **longer passphrases** for enhanced security.

**Don'ts ❌**

* Don't log passwords in any form.
* Avoid showing **password hints** that expose sensitive information.
* Don't rely solely on client-side validation—perform checks on the server as well.

### Layout & Positioning

**Do's ✅**

* Place password fields **close to their confirmation fields** if applicable.
* Use **inline validation** to inform users of errors in real time.
* Ensure adequate **spacing and alignment** for clarity.

**Don'ts ❌**

* Avoid forcing **password confirmation fields** unless absolutely necessary.
* Don't position error messages far from the field they relate to.

## Testing Guidelines

### Functional Testing

**Should ✓**

* [ ] Verify that the password field **masks input by default**.
* [ ] Ensure the **password visibility toggle works correctly**.
* [ ] Test **autofill and password manager compatibility**.
* [ ] Validate that **password strength indicators update dynamically**.

### Accessibility Testing

**Should ✓**

* [ ] Ensure **screen readers announce password requirements and errors clearly**.
* [ ] Confirm **toggle visibility button is keyboard navigable**.
* [ ] Check for **high contrast between text and background**.

### Security Testing

**Should ✓**

* [ ] Ensure **passwords are encrypted before storage**.
* [ ] Validate that **passwords are never logged or stored in plaintext**.
* [ ] Test **rate-limiting and brute-force protections**.

## Related Patterns

* [Text Field](/patterns/forms/text-field) – Standard input for non-sensitive text.

## Frequently Asked Questions


# FORMS: [Phone Number](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/phone-number)

Create phone number inputs with international format support and validation features.

# Phone Number


# FORMS: [Radio](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/radio)

Implement accessible radio button groups in your web applications. Learn best practices for single-choice selection controls, keyboard navigation, and ARIA attributes.

# Radio


# FORMS: [Rating Input](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/rating-input)

Build user-friendly rating components with star ratings and accessibility features.

# Rating Input


# FORMS: [Rich Text Editor](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/rich-text-editor)

Create accessible rich text editors with text formatting tools and keyboard shortcuts.

# Rich Text Editor


# FORMS: [Search Field](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/search-field)

Learn how to implement effective search fields in your web applications. Discover best practices for search input design, real-time suggestions, and accessibility.

# Search Field

***(Also called search input)***

## Overview

## Usage

A search can be used in the following cases:

* Global search on a website
* Reduce the number of results in a list (ex: dropdown with a list of elements)

Usually used in combinaison with [autocomplete](/patterns/forms/autocomplete)

## Search Field Considerations

* **Use `<input type="search">` instead of `<input type="text">`**—it improves browser behavior for search interactions.
* **Include a "clear" button** in search fields for usability.
* **Consider autocomplete functionality** to help users refine queries faster.
* **Ensure that hitting Enter submits the search** or triggers a relevant action.


# FORMS: [Selection Input](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/selection-input)

Learn how to implement user-friendly selection inputs in your web applications. Discover best practices for dropdowns, comboboxes, and list boxes with accessibility and usability guidelines.

# Selection Input

***(Also called dropdown, select)***

## Overview

A **selection input** is a form control that allows users to choose one option from a predefined list of options.

The selected option is typically displayed in a single-line text field, with the list of options hidden until the user interacts with the control.

## Use Cases

### When to use:

* When users need to select a single option from a list of predefined choices
* When the list of options is relatively short (less than 10-15 items)
* When screen space is limited, and displaying all options at once is not feasible
* When the selected option doesn't need to be visible at all times

### When not to use:

* When users need to select multiple options (use checkboxes or a [multi-select](/patterns/forms/multi-select-input) instead)
* When the list of options is very long (consider using an [autocomplete](/patterns/forms/autocomplete) or a typeahead)
* When users need to input free-form text (use a regular text input instead)
* When the options are complex or require additional information or visual aids

### Common scenarios and examples

* Selecting a country from a list of all countries
* Choosing a preferred language from a list of supported languages
* Selecting a payment method during checkout
* Choosing a size, color, or other product variant on an e-commerce site

## Benefits

* Saves screen space by hiding options until needed
* Provides a clear and concise way to select from predefined options
* Prevents user input errors by limiting choices to valid options
* Allows for easy selection using a mouse, keyboard, or touch input

## Anatomy

### Component Structure

```mermaid
graph TD
    A[Selection Input Container] --> B[Text Field]
    A --> C[Dropdown List]
    B --> B1[Selected Value]
    B --> B2[Caret Icon]
    C --> D1[Option 1]
    C --> D2[Option 2]
    C --> D3[Option 3]
    C --> E[Scrollbar]
```

1. **Container**

   * Wraps the selection input and its associated elements
   * Defines the overall dimensions and positioning of the component

2. **Text Field**

   * Displays the currently selected option
   * Acts as a button to trigger the dropdown list
   * Often includes a caret or arrow icon to indicate the presence of a dropdown

3. **Dropdown List**

   * Contains the list of available options
   * Appears when the text field is clicked or receives focus
   * Can be positioned above or below the text field, depending on available space

4. **Options**

   * Individual items within the dropdown list
   * Represent the available choices for the user
   * Should have a clear and concise label
   * Can include icons, images, or other visual aids if necessary

5. **Scrollbar (Optional)**

   * Allows users to scroll through the list of options if the list is too long to fit within the available space
   * Can be styled to match the overall design of the component

## Best Practices

### Content

**Do's ✅**

* Use clear and concise labels for each option
* Keep the list of options relatively short (less than 10-15 items)
* Order options logically (e.g., alphabetically, by popularity, or by relevance)
* Provide a default or pre-selected option when applicable

**Don'ts ❌**

* Don't use overly long or complex option labels
* Avoid using jargon or technical terms that users may not understand
* Don't include options that are not relevant or applicable to the user's context

### Accessibility

**Do's ✅**

* Ensure the selection input is keyboard accessible (arrow keys to navigate, Enter to select)
* Provide a clear focus state for the text field and individual options
* Use ARIA attributes to communicate the component's state and purpose
* Allow users to filter or search the list of options if the list is long

**Don'ts ❌**

* Don't rely solely on color to convey the state or purpose of the component
* Avoid using auto-selection or auto-submission when an option is highlighted
* Don't change the order or content of options unexpectedly

### Visual Design

**Do's ✅**

* Use a consistent visual style for the text field, dropdown list, and options
* Provide ample whitespace and padding to improve readability and usability
* Use a contrasting color or style to indicate the selected option
* Ensure the dropdown list is visually distinct from the text field

**Don'ts ❌**

* Don't use low-contrast colors or small font sizes that reduce legibility
* Avoid using overly complex or decorative styles that distract from the content
* Don't make the dropdown list too narrow or too wide relative to the text field

### Layout & Positioning

**Do's ✅**

* Position the dropdown list close to the text field for easy association
* Ensure the dropdown list doesn't obstruct other important content or UI elements
* Align the text field and dropdown list with other form controls for a cohesive layout

**Don'ts ❌**

* Don't place the dropdown list too far away from the text field
* Avoid positioning the dropdown list in a way that requires excessive scrolling or mouse movement

## Code Examples

### Basic Implementation

```html
<label for="fruits">Choose a fruit:</label>
<select id="fruits" name="fruits">
  <option value="apple">Apple</option>
  <option value="banana">Banana</option>
  <option value="orange">Orange</option>
  <option value="strawberry">Strawberry</option>
</select>
```

## Browser Support

## Design Tokens

These design tokens follow the [Design Tokens Format](https://design-tokens.github.io/community-group/format/) specification and can be used with various token transformation tools to generate platform-specific variables.

### Selection Input Tokens in DTF Format

```json
{
  "$schema": "https://design-tokens.org/schema.json",
  "selectionInput": {
    "container": ,
    "textField": {
      "padding": ,
      "border": {
        "width": ,
        "color": ,
        "radius": 
      },
      "background": {
        "color": 
      },
      "typography": ,
      "color": {
        "default": ,
        "disabled": 
      },
      "icon": {
        "size": ,
        "color": 
      }
    },
    "dropdownList": {
      "maxHeight": ,
      "border": {
        "width": ,
        "color": 
      },
      "background": {
        "color": 
      },
      "shadow": 
    },
    "option": {
      "padding": ,
      "color": {
        "default": ,
        "hover": ,
        "selected": 
      },
      "background": {
        "default": ,
        "hover": ,
        "selected": 
      }
    }
  }
}
```

## Resources

* [Request for developer feedback: customizable select](https://developer.chrome.com/blog/rfc-customizable-select)

### Articles

* [Designing Drop-Down Menus: Examples and Best Practices](https://www.smashingmagazine.com/2009/03/designing-drop-down-menus-examples-and-best-practices/)
* [Listboxes vs. Dropdown Lists](https://www.nngroup.com/articles/listbox-dropdown/)

## Libraries

* [Select - shadcn/ui](https://ui.shadcn.com/docs/components/select)
* [Select - OriginUI](https://originui.com/selects)


# FORMS: [Signature Pad](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/signature-pad)

Build touch-enabled signature capture with canvas drawing and validation features.

# Signature Pad


# FORMS: [Slider](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/slider)

Learn how to implement accessible range slider inputs in your web applications. Discover best practices for continuous value selection, touch interactions, and accessibility.

# Slider

## Resources

### Articles

* [Designing The Perfect Slider UX](https://www.smashingmagazine.com/2017/07/designing-perfect-slider/) by Smashing Magazine


# FORMS: [Tag Input](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/tag-input)

Create tag input components for dynamic keyword entry with validation and accessibility support.

# Tag Input


# FORMS: [Text Field](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/text-field)

Implement accessible text input fields with validation, error handling, and user experience best practices.

# Text Field

## Overview

A **Text Field** is a fundamental form input component that allows users to enter and edit text-based data. It is commonly used in **forms, search fields, authentication fields, and messaging interfaces**.

Text fields can accept single-line or multi-line input and may include additional features like placeholders, character counters, validation messages, and formatting assistance.

## Use Cases

### When to use:

Use a text field when you need users to input freeform text, such as:

* **Login and authentication fields** – Username, password, email.
* **Search fields** – Query inputs in search bars.
* **Forms and surveys** – Collecting names, addresses, or custom responses.
* **Messaging interfaces** – Chat applications and comment sections.
* **Data entry fields** – User-generated content like tags, descriptions, or reviews.

### When not to use:

* **For pre-defined options** – Use [dropdowns](/patterns/forms/selection-input), [radio](/patterns/forms/radio), or [checkboxes](/patterns/forms/checkbox) instead.
* **For structured data inputs** – Use specialized inputs like [date pickers](/patterns/forms/date-picker) or [currency fields](/patterns/forms/currency-input).
* **For short selections** – Use [auto-complete](/patterns/forms/autocomplete) inputs instead of requiring full text input.
* **When voice input or selections are better** – Consider alternatives for accessibility.

## Benefits

* **Flexible** – Allows users to enter freeform responses.
* **Widely recognized** – Standardized interaction that users expect.
* **Supports real-time validation** – Instant feedback for user input.
* **Can be enhanced** – Custom validation, auto-formatting, and assistance.

## Drawbacks

* **User errors** – Freeform text increases the risk of typos and incorrect formatting.
* **Lack of guidance** – May require placeholders, labels, or tooltips to improve usability.
* **Accessibility concerns** – Must be properly labeled and include validation feedback for screen readers.

## Anatomy

```mermaid
graph TD
  A[Text Field Container] --> B[Label]
  A --> C[Input Field]
  C --> D[Placeholder - optional]
  C --> E[Helper Text - optional]
  C --> F[Validation/Error Message - optional]
  C --> G[Character Counter - optional]
  C --> H[Prefix - optional]
  C --> I[Suffix - optional]
```

### Component Structure

1. **Container (`div` or `fieldset`)**

   * Wraps the entire text field component.
   * Ensures proper spacing and alignment.
   * May include additional styling or group related inputs.

2. **Label (`label`)**

   * Describes the purpose of the input field.
   * Should be visually positioned above the input.
   * Must be **associated with the input** using the `for` attribute.

3. **Input Field (`input[type="text"]`)**

   * The interactive area where users enter text.
   * Supports attributes such as `autocomplete`, `maxlength`, and `required`.
   * Should have proper focus styles for accessibility.

4. **Placeholder (Optional)**

   * Provides a hint before users type.
   * Disappears when input is focused.
   * **Should not replace a label** for accessibility.

5. **Helper Text (`p` or `span`, optional)**

   * Provides additional guidance or formatting instructions.
   * Typically placed **below the input field**.
   * Should be **persistent** and not disappear on focus.

6. **Validation/Error Message (`p` or `span`, optional)**

   * Displays a **clear, specific message** when input is invalid.
   * Should be **associated with the input using `aria-describedby`**.
   * Appears below the input, replacing helper text if necessary.

7. **Character Counter (`p` or `span`, optional)**

   * Displays **remaining or used character count** (e.g., "20/100 characters").
   * Helps users stay within input length limits.
   * Should update dynamically as the user types.

8. **Prefix (`span`, optional)**

   * Static text **before the input** (e.g., `$` for currency, `@` for usernames).
   * Should be **visually distinguishable** from user input.

9. **Suffix (`span`, optional)**
   * Static text **after the input** (e.g., `.com` for domain fields).
   * Helps users understand **expected input formats**.

#### **Summary of Components**

| Component                | Required? | Purpose                                      |
| ------------------------ | --------- | -------------------------------------------- |
| Label                    | ✅ Yes     | Describes the input field's purpose.         |
| Input Field              | ✅ Yes     | The main interactive element for user input. |
| Placeholder              | ❌ No      | Provides a hint but disappears on input.     |
| Helper Text              | ❌ No      | Offers guidance or additional instructions.  |
| Validation/Error Message | ❌ No      | Provides feedback when input is invalid.     |
| Character Counter        | ❌ No      | Tracks remaining/used characters.            |
| Prefix                   | ❌ No      | Displays static text before the input.       |
| Suffix                   | ❌ No      | Displays static text after the input.        |

## Code Examples

### **1️⃣ Best Practice: Explicit "Required" Label**

✅ **Most accessible** – clear for all users, including screen readers.

```html
<label for="username"> Username <span>(Required)</span> </label>
<input type="text" id="username" name="username" required />
```

**Pros ✅**

* Works for **all users**, including screen readers and color-blind users.
* No need for extra ARIA attributes.

**Cons ❌**

* Takes slightly more space in the UI.

### **2️⃣ Alternative: Asterisk (\*) with ARIA Explanation**

✅ **Common practice**, but needs `aria-describedby` for screen reader users.

```html
<label for="username"> Username <span aria-hidden="true">*</span> </label>
<input
  type="text"
  id="username"
  name="username"
  required
  aria-describedby="required-msg"
/>
<p id="required-msg" class="sr-only">
  Fields marked with an asterisk are required.
</p>
```

**Pros ✅**

* Keeps UI cleaner while maintaining accessibility.
* Screen readers will announce **"Fields marked with an asterisk are required."**

**Cons ❌**

* **Requires additional explanation** (`aria-describedby`).
* **Without the extra message, asterisks alone are not accessible**.

### **3️⃣ Alternative: Required Field with Visually Hidden Text**

✅ **Keeps UI minimal while ensuring accessibility.**

```html
<label for="email"> Email <span class="sr-only">(Required)</span> </label>
<input type="email" id="email" name="email" required />
```

**Pros ✅**

* **Looks clean visually** while still accessible.
* **Screen readers announce it as "Email Required"**.

**Cons ❌**

* **Not visible for sighted users** who rely on visual cues.

### **4️⃣ Alternative: Required Field with an Inline Icon + Tooltip**

✅ **More user-friendly**, provides additional guidance.

```html
<label for="phone">
  Phone Number
  <span aria-hidden="true" class="required-icon" tabindex="0"> *</span>
</label>
<input
  type="tel"
  id="phone"
  name="phone"
  required
  aria-describedby="required-msg"
/>
<p id="required-msg" class="sr-only">
  Fields marked with an asterisk are required.
</p>
```

**Pros ✅**

* **Visually clear** while keeping text minimal.
* Works well when paired with a **tooltip on hover or focus**.

**Cons ❌**

* **Requires CSS for styling** (ensuring asterisks are not the only indicator).
* Users **might not see tooltip hints** if they don't hover over the icon.

### **5️⃣ Alternative: Required Field with `required` Attribute Only**

⚠ **Not recommended as a standalone solution!**

```html
<label for="password"> Password </label>
<input type="password" id="password" name="password" required />
```

**Pros ✅**

* Works well for **basic validation**.
* Screen readers **will announce the field as required**.

**Cons ❌**

* No **visible indicator for sighted users** before form submission.
* **Errors only appear after submission**, which may confuse users.
* Some browsers may **not enforce required fields consistently**.

## Best Practices

### **Content & Usability**

**Do's ✅**

* Provide a **clear and descriptive label**.
* Use **placeholder text sparingly** and never as a replacement for a label.
* Indicate **required fields** clearly and provide helpful validation feedback.
* Use **real-time validation** to prevent errors early.
* Ensure sufficient **touch target size** for mobile users.
* Allow users to **copy, paste, and autocomplete** when appropriate.
* **Use input masks sparingly**—they can improve formatting but may frustrate users if too rigid.
* Offer **formatting hints** when users must follow a specific pattern (e.g., phone numbers, dates).
* Provide **default values** when applicable to reduce typing effort.

**Don'ts ❌**

* Don't use placeholder text instead of a visible label.
* Avoid long character limits without a counter.
* Don't require unnecessary or sensitive information without justification.
* Don't enforce **case sensitivity** unless absolutely necessary.
* Avoid disabling **copy-paste** for passwords or sensitive fields, as this can harm usability.

***

### **Accessibility**

**Do's ✅**

* Associate the text field with a `<label>` element for screen readers.
* Use `aria-describedby` to connect inputs to error messages or hints.
* Ensure **high contrast** between text and background.
* Provide **keyboard navigation** and support tabbing.
* Allow **speech-to-text functionality** for accessibility.
* Use `aria-invalid="true"` when a validation error occurs.
* Ensure **error messages appear next to the field** and are **read aloud by screen readers**.

**Don'ts ❌**

* Don't remove focus outlines—they are essential for keyboard users.
* Don't rely solely on color to indicate errors.
* Avoid using `title` attributes for tooltips—use visible descriptions.
* Don't use `placeholder` as the only accessible text—it disappears when users start typing.
* Avoid **dynamic placeholder text changes** that may confuse assistive technologies.

***

### **Visual Design**

**Do's ✅**

* Use **sufficient padding and line height** for readability.
* Maintain a **clear distinction between active, focused, and disabled states**.
* Use **icons (optional)** for additional context (e.g., search icon in a search field).
* Ensure **error states are visually prominent** without being intrusive.
* **Use color contrast** that meets WCAG 2.1 AA standards (e.g., 4.5:1 ratio for text).

**Don'ts ❌**

* Avoid excessive borders or decorative elements.
* Don't make the input field too small, especially on mobile.
* Avoid low contrast text and background combinations.
* Don't rely solely on placeholder text for field instructions.

***

### **Layout & Positioning**

**Do's ✅**

* Align labels **above or beside** the text field for clarity.
* Keep **consistent spacing and alignment** with other form elements.
* Ensure sufficient **spacing between multiple input fields** for easy readability.
* Place **validation messages near the input field** to improve error recognition.

**Don'ts ❌**

* Don't position labels too far from the input.
* Avoid overly narrow text fields that cut off content.
* Don't place validation messages too far from the field.
* Avoid placing multiple fields **on the same line on mobile**, as this reduces readability.

### **Input Description Placement: Above or Below the Text Field?**

#### **Best Practice: Place Input Descriptions Below the Field**

In most cases, **input descriptions (helper text, formatting hints, and additional guidance) should be placed below the text field** for **consistency, readability, and accessibility**.

**✅ Why?**

* **Users scan from top to bottom** – The label is read first, then the input, then any additional help.
* **Aligns with error messages** – Since validation errors appear below the field, keeping all feedback in one place reduces cognitive load.
* **Screen reader order** – Screen readers will naturally announce the description **right after the field** when placed below.
* **Follows industry standards** – Major design systems (Google Material, IBM Carbon, Bootstrap) place helper text below.

***

#### **📍 When to Place Descriptions Above the Field?**

⚠ **There are some exceptions where placing descriptions above is preferable:**

1. **When users must understand something before typing**
   * Example: *"Enter your National Insurance number in the format QQ123456C"*
2. **Password requirements**
   * Example: *"Password must be at least 8 characters and contain a number."*
3. **When there is no error message below the field**
   * Helps avoid excessive space between the input and the next element.

***

#### **Best Practice: Only Show One at a Time**

To avoid overwhelming users:

* **Before an error occurs**, display helper text **below** the input.
* **When an error occurs**, **replace** the helper text with the error message.

✅ **Example (Best Practice)**

```html
<label for="email">Email</label>
<input
  type="email"
  id="email"
  name="email"
  required
  aria-describedby="email-info"
/>
<p id="email-info" class="helper-text">
  We'll never share your email with anyone.
</p>

<!-- Error message replaces helper text when validation fails -->
<p id="email-error" class="error-message" style="display: none;">
  Please enter a valid email.
</p>

<script>
  const emailInput = document.getElementById("email");
  const helperText = document.getElementById("email-info");
  const errorText = document.getElementById("email-error");

  emailInput.addEventListener("input", function () );
</script>
```

### **Final Recommendation for Input Description Placement**

| **Scenario**                                                   | **Where to Place Helper Text?** | **Why?**                                                      |
| -------------------------------------------------------------- | ------------------------------- | ------------------------------------------------------------- |
| **Standard input fields (e.g., email, name, search)**          | **Below**                       | Ensures consistency with error messages & better readability. |
| **Inputs with specific formatting (e.g., date, phone number)** | **Above**                       | Users need to understand format before typing.                |
| **Password fields (with complexity rules)**                    | **Above**                       | Users need guidance before they type.                         |
| **Large forms with minimal UI**                                | **Above** or **Inline**         | To prevent visual clutter.                                    |
| **Error messages**                                             | **Below**                       | Always below, ensuring users immediately see what went wrong. |

## Accessibility

### **Keyboard Interaction Pattern**

Text fields should support **standard keyboard navigation and interactions** to ensure accessibility and usability.

| **Key**                   | **Action**                                                        |
| ------------------------- | ----------------------------------------------------------------- |
| `Tab`                     | Moves focus to the next interactive element.                      |
| `Shift + Tab`             | Moves focus to the previous interactive element.                  |
| `Enter` *(inside a form)* | Submits the form (unless prevented).                              |
| `Arrow Left / Right`      | Moves the text cursor within the input.                           |
| `Arrow Up / Down`         | Moves the cursor within multi-line text fields (`textarea`).      |
| `Esc`                     | If inside a **search field**, clears input *(optional behavior).* |

## **Testing Guidelines**

### **Functional Testing**

**Should ✓**

* [ ] Verify that users can input, edit, and delete text without issues.
* [ ] Ensure character limits work correctly and display remaining characters if applicable.
* [ ] Validate correct error handling and messaging (e.g., required fields, invalid formats).
* [ ] Confirm keyboard navigation and focus behavior, including tab order.
* [ ] Ensure users can **copy, paste, and autofill** without restrictions.
* [ ] Test **input masks and auto-formatting** to confirm they work as expected.
* [ ] Validate that pressing **Enter/Return** behaves as expected (e.g., form submission or moving to the next field).

***

### **Accessibility Testing**

**Should ✓**

* [ ] Ensure text fields have associated **labels (`<label for="id">`)** for screen readers.
* [ ] Validate that error messages are announced by **screen readers (NVDA, JAWS, VoiceOver, TalkBack)**.
* [ ] Confirm that **keyboard users can navigate and interact** effectively using `Tab`, `Shift+Tab`, `Enter`, and `Esc`.
* [ ] Ensure **high contrast between text and background** (meets WCAG 2.1 AA contrast ratio).
* [ ] Check that **focus indicators are visible** when navigating via keyboard.
* [ ] Test with **different screen readers** to confirm field descriptions and validation messages are correctly read.
* [ ] Verify that **speech-to-text functionality works** for users relying on voice input.
* [ ] Ensure **placeholder text is not the only accessible label**, as it disappears when typing.
* [ ] Check for `aria-describedby` and `aria-invalid="true"` usage in error handling scenarios.

***

### **Performance Testing**

**Should ✓**

* [ ] Ensure text input does not **cause delays, freezing, or slow response times**.
* [ ] Validate large text input handling (e.g., pasting 1000+ characters into a field).
* [ ] Check **browser compatibility across different devices** (Chrome, Firefox, Safari, Edge, mobile browsers).
* [ ] Test mobile usability, including **touch input, autocorrect behavior, and focus handling**.
* [ ] Ensure input fields **don't trigger layout shifts** (Cumulative Layout Shift - CLS).
* [ ] Validate **lazy loading and deferred scripts** do not delay field interactions.
* [ ] Check memory usage when dynamically adding or removing fields.

***

### **Security Testing**

**Should ✓**

* [ ] Ensure fields do not store sensitive data in autocomplete history unless necessary (`autocomplete="off"` for sensitive inputs).
* [ ] Validate against **Cross-Site Scripting (XSS) attacks**—inputs should sanitize user-entered data.
* [ ] Verify that error messages do not reveal sensitive details (e.g., don't display "Incorrect email or password" separately).
* [ ] Check that invalid inputs do not break the layout or cause unexpected behavior.

***

### **Mobile & Touch Testing**

**Should ✓**

* [ ] Ensure the **correct keyboard type appears** for each input (e.g., numeric for phone numbers, email keyboard for email fields).
* [ ] Validate touch targets are **large enough (at least 44x44px)** for usability.
* [ ] Test how input behaves in **dark mode** and ensure readability.
* [ ] Check if input fields adjust correctly when the **virtual keyboard opens** (avoiding overlapping content).
* [ ] Ensure users can **easily dismiss the keyboard** after typing (e.g., tapping outside the input).
* [ ] Verify that **autocorrect and autocomplete work properly** without interfering with expected input behavior.
* [ ] Confirm that **multi-line inputs (`textarea`) scroll correctly** without hiding text on smaller screens.

***

### **Error Handling & Validation Testing**

**Should ✓**

* [ ] Ensure validation errors appear **next to the relevant input field** (not in a separate section).
* [ ] Validate that **real-time validation** does not trigger prematurely while typing.
* [ ] Confirm that error messages **persist until fixed**, rather than disappearing too quickly.
* [ ] Ensure errors provide **clear guidance** (e.g., "Enter a valid email" instead of "Invalid input").
* [ ] Check if `aria-live="polite"` announces validation messages dynamically.
* [ ] Test behavior when **submitting an empty required field**—does it highlight correctly?
* [ ] Verify that server-side validation handles **unexpected input** gracefully (e.g., very long strings, special characters).
* [ ] Ensure users can **recover from errors easily** without refreshing the page.

***

### **Edge Case Testing**

**Should ✓**

* [ ] Simulate **slow network conditions** to check if validation messages delay input behavior.
* [ ] Test behavior when **copying and pasting large amounts of text** into a field.
* [ ] Ensure **input remains intact** when navigating away and returning to the form.
* [ ] Check how the field handles **emoji, special characters, and non-Latin alphabets**.
* [ ] Test what happens if a **user pastes an entire paragraph into a single-line text field**.
* [ ] Verify that auto-suggestions do not interfere with manual input.
* [ ] Test behavior when **users press the "back" button on mobile browsers**—does the input persist?
* [ ] Ensure users **can undo accidental deletions** (via `Ctrl+Z` or long press on mobile).

## Frequently Asked Questions

## Related Patterns

* [Autocomplete](/patterns/forms/autocomplete) – Suggests options as users type.
* [Password](/patterns/forms/password) – Specialized text field for secure input.
* [Search Field](/patterns/forms/search-field) – Optimized for search queries.

## Resources

### Libraries

[Input - Origin UI](https://originui.com/input)


# FORMS: [Textarea](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/textarea)

Learn how to implement accessible textarea components for collecting long-form content, comments, and detailed responses. Discover best practices for multi-line text input with proper validation and user experience.

# Textarea


# FORMS: [Time Input](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/time-input)

Build user-friendly time input fields with validation and accessibility features.

# Time Input


# FORMS: [Toggle](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/forms/toggle)

Implement toggle switches for binary state control in your web applications. Learn best practices for toggle buttons, state management, and accessibility.

# Toggle


# NAVIGATION: [Back To Top](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/navigation/back-to-top)

Implement a Back to Top button for enhanced navigation on long pages with best practices for placement and accessibility.

# Back to Top

## Overview

**Back to Top** provides users a quick way to return to the top of the page, especially when they have scrolled through lengthy or [infinite content](/patterns/navigation/infinite-scroll).

Commonly seen as a floating button or link at the bottom-right corner, it improves navigation and overall user experience.

## Use Cases

### When to use:

Use **Back to Top** when you need to **help users quickly return to the top of a long page without excessive scrolling**.

**Common scenarios include:**

* On long or content-heavy pages where the user is likely to scroll far down
* When quick navigation back to the header or navigation menu is essential
* In blogs, documentation pages, or e-commerce category listings with extensive scroll

### When not to use:

* On very short pages where scrolling is minimal or unnecessary
* If your layout or design already provides persistent navigation at the bottom (navigation at the bottom) or top (sticky menus)
* When infinite scrolling is not used (or scrolling is minimal and not an issue)

### Common scenarios and examples

* Long editorial content (articles, guides, and blog posts)
* Content hubs or portals with extensive listings
* FAQ pages with collapsible or expanded sections
* Dashboards or analytics pages containing large data tables
* Infinite scrolling experiences (e.g., social feeds) to let users quickly jump to the top

## Benefits

* Enhances user navigation and usability on long pages
* Improves overall site accessibility by giving a direct route to main navigation
* Reduces scrolling fatigue for mobile users
* Helps maintain a clean UI by hiding controls when not needed, then showing them once the user scrolls down

## Drawbacks

* **Not always necessary** – If pages are short, the button may be redundant.
* **Can be disruptive** – Sudden jumps to the top may disorient users.
* **Visibility control** – Requires logic to appear only after a certain scroll depth.
* **Potential for hidden functionality** – Users may not notice it or understand its purpose.
* **Inconsistent placement** – Can interfere with floating UI elements if not positioned carefully.

## Anatomy

```mermaid
flowchart TB
subgraph BackToTop["Back to Top" Component]
  Container[Container Element] -->|contains| Icon[Icon <optional>]
  Container --> Label[Label Text <optional>]
end
```

### Component Structure

1. **Container**

* A clickable element (usually a button) that triggers scrolling to the top
* Often positioned as a floating element on desktop and mobile
* Manages focus states and accessibility attributes

2. **Icon (Optional)**

* Conveys the action of going to the top (e.g., an up arrow)
* Should be clear and universally recognized
* Must be sized for good readability (16×16px or 24×24px are common)
* Color should contrast with the background

3. **Label Text (Optional)**

* Helps clarify the action for screen readers or when the icon alone isn't sufficient
* Typically hidden for visually oriented users, but available to assistive technology
* Could be visible if design requires additional clarity

4. **Visual States**

* **Default**: Visible when the user scrolls past a certain threshold
* **Hover**: Provides a visual cue (e.g. change in background color)
* **Active**: Pressed or clicked state
* **Focus**: Outline or highlight for keyboard navigation
* **Hidden**: Button is invisible or removed when the user is near the top of the page

#### **Summary of Components**

| Component     | Required? | Purpose                                                     |
| ------------- | --------- | ----------------------------------------------------------- |
| Container     | ✅ Yes     | Clickable element that triggers scrolling to the top.       |
| Icon          | ❌ No      | Visual indicator (e.g., an up arrow) for quick recognition. |
| Label Text    | ❌ No      | Provides additional clarity, especially for screen readers. |
| Visual States | ✅ Yes     | Defines interaction states (hover, active, focus, hidden).  |

## Best Practices

### Content

**Do's ✅**

* Show a clear visual indicator (usually an up arrow icon)
* Display the button only after the user scrolls a predetermined distance
* Hide it when the user is near the top of the page
* Use an accessible label (e.g., `aria-label="Back to top"`) if the text is omitted

**Don'ts ❌**

* Don't make it permanently visible for short pages—it can be distracting
* Don't use vague icons or labels (e.g., a random symbol without context)
* Don't crowd the button with other floating elements
* Don't rely solely on color for states—use shape or text changes if possible

### Accessibility

**Do's ✅**

* Ensure the button is keyboard-focusable and can be activated via Enter or Space
* Provide sufficient color contrast between the button and its background
* Use an appropriate aria-label or descriptive text for screen readers
* Manage focus: after scrolling up, keep the user informed or maintain logical focus

**Don'ts ❌**

* Don't hide it behind complex interactions or animations
* Don't place it in a position that overlaps other important UI elements
* Don't disable focus outlines without providing an alternative focus style

### Visual Design

**Do's ✅**

* Use a large enough icon or label for quick recognition (minimum 16×16px icon)
* Maintain consistent styling with the rest of your UI (color, shape, corners)
* Incorporate hover/focus states that match your design system guidelines
* Place it in a fixed position (often bottom-right) for easy access

**Don'ts ❌**

* Don't block important content with a floating button
* Don't make the button so small that it's hard to tap on mobile
* Don't use misleading icons (ensure the arrow is pointing up)

### Mobile & Touch Considerations

**Do's ✅**

* Use a minimum touch target of 44×44px
* Keep it within thumb-friendly zones at the bottom of the screen
* Make sure it doesn't overlap interactive elements (navigation drawers, chat bubbles)
* Add any necessary spacing from device edges to avoid accidental swipes

**Don'ts ❌**

* Don't place it in corners difficult to reach on large screens
* Don't rely on hover states for mobile users—visual changes should appear on tap/press
* Don't crowd the bottom area with too many floating icons

### Layout & Positioning

**Do's ✅**

* Fix its position to the viewport so it remains visible during scrolling
* Use consistent margin or spacing from edges for aesthetic alignment
* Keep in mind other fixed UI elements such as sticky footers or chat widgets

**Don'ts ❌**

* Don't move it around the page as the user scrolls
* Don't tie it to an element that scrolls out of view

## Code Examples

### Basic Implementation (HTML + minimal JS)

```html
<button type="button" class="js-back-to-top" aria-label="Back to top" hidden>
  ↑
</button>

<script>
  // Basic scroll logic
  const backToTopBtn = document.querySelector(".js-back-to-top");
  const scrollThreshold = 300; // in px

  function backToTop() 

  function scrollToTop() 

  document.addEventListener("scroll", toggleBackToTop);
  backToTopBtn.addEventListener("click", scrollToTop);
</script>
```

## Accessibility

### ARIA Attributes

**Required ARIA attributes:**

* Use `aria-label="Back to top"` if using icon-only buttons
* Use `aria-hidden="true"` on the icon if text is included for screen readers
* Use `hidden` or `aria-hidden="true"` to hide the button when not needed

### Screen Reader Support

```html
<!-- Icon-only button with ARIA label -->
<button type="button" aria-label="Back to top" hidden>
  <svg aria-hidden="true">
    <use href="#icon-arrow-up" />
  </svg>
</button>
```

### Keyboard Navigation

* Must be focusable and activated with both Enter and Space keys
* The user should be able to tab to it if it's visible
* Focus outlines should remain intact for accessibility
* Maintaining focus after click is optional; the scroll event is generally the key feedback

## Testing Guidelines

### Functional Testing

**Should ✓**

* [ ] Show the button after scrolling a set distance
* [ ] Smoothly scroll to top when clicked
* [ ] Hide the button when the user is near the top
* [ ] Maintain correct visible/hidden states on page load and resize
* [ ] Prevent overlapping interactions with other floating components

Accessibility Testing

**Should ✓**

* [ ] Have proper ARIA labels for icon-only implementations
* [ ] Be operable with keyboard (Enter, Space)
* [ ] Maintain a visible focus state when tabbed to
* [ ] Provide enough contrast between button and background
* [ ] Respect user motion preferences (reduce motion if system preferences are set)

Visual Testing

**Should ✓**

* [ ] Float consistently at the chosen position across different viewport sizes
* [ ] Show correct hover, focus, and active states
* [ ] Remain unobtrusive yet visible
* [ ] Align with other design elements and not overlap key UI components

Performance Testing

**Should ✓**

* [ ] Not introduce layout shifts when appearing or disappearing
* [ ] Handle rapid scrolling up/down events effectively
* [ ] Support smooth animations without jank
* [ ] Remain performant on mobile devices

## Browser Support

## Design Tokens

These design tokens follow the [Design Tokens Format](https://design-tokens.github.io/community-group/format/) specification and can be used with various token transformation tools to generate platform-specific variables.

### Button Tokens in DTF Format

```json
{
  "$schema": "https://design-tokens.org/schema.json",
  "backToTop": {
    "position": ,
    "sizing": ,
    "icon": ,
    "border": ,
    "colors": {
      "background": {
        "default": ,
        "hover": ,
        "active": 
      },
      "icon": {
        "default": 
      }
    },
    "states": {
      "focusRing": {
        "width": ,
        "offset": ,
        "color": 
      }
    }
  }
}
```

## Frequently Asked Questions

\` element, provide a descriptive label like 'Back to Top', and implement visible focus indicators for users navigating via keyboard.",
},
,
]}
/>

## Resources

### Articles

* [Back-to-Top Button Design Guidelines](https://www.nngroup.com/articles/back-to-top/)
* [Scroll to Top: Does it Need to be Accessible?](https://www.digitala11y.com/scroll-to-top-does-it-need-to-be-accessible/)


# NAVIGATION: [Breadcrumb](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/navigation/breadcrumb)

Create effective breadcrumb navigation for better site orientation. Learn implementation techniques, accessibility requirements, and design best practices for clear hierarchical navigation.

# Breadcrumb

## Overview

**Breadcrumbs**, often displayed as a horizontal list of links separated by symbols, help users understand their location in a website's hierarchy at a glance.

They are secondary navigation aids that help users understand their current location within a website's hierarchy and provide an easy way to navigate back through parent pages.

They are particularly useful for websites with deep hierarchical structures or complex navigation paths.

## Use Cases

### When to use:

Use **Breadcrumbs** when you need to **show users their location within a website's structure and help them navigate easily**.

**Common scenarios include:**

* Websites with multiple hierarchical levels (e.g., categories, sub-categories)
* Large or complex sites where users often land on deep pages from search engines
* Systems that rely on nested file or document organization (e.g., file explorers, project management tools)
* E-commerce stores with layered product categories

### When not to use:

* Single-level websites with flat structure
* Landing pages or homepages
* Small websites with simple navigation
* When the hierarchy is already evident through other navigation elements
* For single-page applications with modal-based navigation

### Common scenarios and examples

* E-commerce: Home > Electronics > Smartphones > iPhone 15
* Content Management: Dashboard > Projects > Project A > Documents
* File Systems: My Drive > Work > 2024 > Reports

## Benefits

* Reduces the number of actions users need to take to navigate up levels
* Prevents users from feeling lost in complex hierarchies
* Improves SEO by exposing site structure
* Reduces bounce rates for deep-linked pages
* Provides contextual information about current location

## Drawbacks

* **Limited usefulness** – Not always needed if users primarily land on deeper pages from external links.
* **Takes up space** – Can be redundant on small screens or when users don't need hierarchical navigation.
* **Responsive design complexity** – Long breadcrumb trails require truncation or horizontal scrolling.
* **Requires structured data** – Must be correctly implemented for SEO benefits (e.g., schema markup).
* **Misuse in flat hierarchies** – Not beneficial if the site structure doesn't follow a clear depth-based navigation.

## Anatomy

```mermaid
flowchart TB
subgraph Breadcrumb[Breadcrumb Navigation]
A[Home] -.->|separator| B[Parent Page]
B -.->|separator| C[Current Page]

classDef container stroke:#666,stroke-width:2px
class Breadcrumb container
end
```

### Component Structure

1. **Container (`nav`)**

* Wraps the entire breadcrumb navigation.
* Uses **semantic navigation elements** for accessibility.
* Should be properly labeled for **screen readers**.

2. **List (`ol`)**

* Contains the **breadcrumb items** in sequential order.
* Represents the **hierarchical structure** of the page.
* Typically implemented as an **ordered list** to convey structure.

3. **Items (`li`)**

* **Home Link (Optional):** A starting point linking to the homepage.
* **Parent Pages:** Clickable links that represent higher levels of navigation.
* **Current Page:** The final item, which **should not be a link** since it represents the current view.
* **Separators:** Visual dividers (e.g., `/`, `>`), providing clear navigation hierarchy.

#### **Summary of Components**

| Component    | Required? | Purpose                                               |
| ------------ | --------- | ----------------------------------------------------- |
| Container    | ✅ Yes     | Wraps the entire breadcrumb navigation.               |
| List         | ✅ Yes     | Contains the breadcrumb items in order.               |
| Items        | ✅ Yes     | Represents individual breadcrumb links.               |
| Separators   | ✅ Yes     | Visually separates breadcrumb links.                  |
| Home Link    | ❌ No      | Provides an optional shortcut to the homepage.        |
| Current Page | ✅ Yes     | Represents the active page (should not be clickable). |

## Best Practices

### Content

**Do's ✅**

* Use clear, concise labels that match page titles
* Maintain consistent naming conventions
* Show the full hierarchy path

**Don'ts ❌**

* Don't use inconsistent terminology between breadcrumb items and page titles
* Don't truncate breadcrumb items without indicating there's more content

### Accessibility

**Do's ✅**

* Maintain the icon's accessibility by including proper aria-label
* Give users quick confirmation of where they are in the hierarchy
* Use semantic HTML elements

**Don'ts ❌**

* Don't make the current page title clickable
* Don't use a breadcrumb if the user is already at the top level of the hierarchy

### Visual Design

**Do's ✅**

* Make it obvious that the last item is not clickable (through color, cursor type, etc.)
* Use consistent visual styling across all pages
* Ensure sufficient contrast between text and background

**Don'ts ❌**

* Don't use distracting animations or transitions
* Don't make separators too prominent

### Layout & Positioning

**Do's ✅**

* Place the breadcrumb at the top of the page, below the global navigation and above the page title
* Keep the breadcrumb left-aligned
* Consider showing both icon and text on larger screens
* Consider showing a house icon instead of text "Home" on smaller screens

**Don'ts ❌**

* Do not show a breadcrumb if the navigation's hierarchy contains only one level (home page or landing pages for example)
* Do not use an HTML element for separators but prefer using CSS

## Tracking

Tracking breadcrumb interactions helps measure how users navigate through a site, whether they rely on breadcrumbs for backtracking, and if they help reduce friction in multi-level navigation. By analyzing usage patterns, we can optimize the breadcrumb structure and placement.

### Key Tracking Points

Each breadcrumb interaction provides valuable insights into user behavior. Below are the key events that should be tracked:

| **Event Name**           | **Description**                                                    | **Why Track It?**                                                     |
| ------------------------ | ------------------------------------------------------------------ | --------------------------------------------------------------------- |
| `breadcrumb.view`        | When the breadcrumb component enters the viewport.                 | Determines visibility and whether breadcrumbs are available to users. |
| `breadcrumb.click`       | When a user clicks on any breadcrumb link.                         | Measures engagement and breadcrumb-driven navigation.                 |
| `breadcrumb.home_click`  | When a user clicks on the **home** link in the breadcrumb.         | Tracks how often users return to the homepage via breadcrumbs.        |
| `breadcrumb.level_click` | When a user clicks on an intermediate breadcrumb level.            | Helps assess whether users navigate back up the hierarchy.            |
| `breadcrumb.usage`       | Captures breadcrumb interaction data relative to total page views. | Helps measure how often breadcrumbs are used when available.          |

### Event Payload Structure

To ensure consistent tracking, here’s a recommended event format:

```json
```

### Key Metrics to Analyze

Once tracking is in place, the following metrics provide actionable insights:

* **Breadcrumb Usage Rate** → Percentage of page visits where breadcrumbs were interacted with.
* **Breadcrumb Click-Through Rate (CTR)** → Percentage of users who interact with breadcrumbs after seeing them.
* **Navigation Recovery Rate** → How often users navigate up using breadcrumbs instead of the browser back button.
* **Home Click Rate** → Measures how often users return to the homepage via breadcrumbs.
* **Intermediate Level Click Rate** → Tracks how often users use breadcrumbs to navigate back to higher levels.

### Insights & Optimization Based on Tracking

By analyzing tracking data, we can optimize breadcrumb usability:

* 🚨 **Low Breadcrumb Usage Rate?**
  → Users may not notice breadcrumbs or find them unnecessary.
  **Optimization:** Improve visibility, adjust styling for better contrast, or test a more prominent placement.

* ⏳ **Low Breadcrumb Click-Through Rate?**
  → Users see breadcrumbs but don’t interact with them.
  **Optimization:** Consider whether breadcrumbs are necessary in the current navigation structure. They may be redundant if other navigation methods are more intuitive.

* 🔄 **Frequent Home Clicks?**
  → Users might be struggling to find their way back.
  **Optimization:** Review site structure and ensure proper linking between categories.

* 🔁 **More Back Button Usage Than Breadcrumb Clicks?**
  → Users might prefer using browser navigation instead of breadcrumbs.
  **Optimization:** Make breadcrumbs more interactive and clearly indicate their functionality.

* 📉 **Low Intermediate Level Click Rate?**
  → Users are not navigating up through breadcrumbs.
  **Optimization:** Ensure breadcrumbs are relevant for deep hierarchies and not just duplicating the main navigation.

By continuously monitoring these metrics, we can refine breadcrumb effectiveness, ensuring they support seamless navigation and reduce friction in user journeys.

## Code Examples

### Basic Implementation

This example uses semantic HTML to provide a clear structure for the breadcrumb navigation.

```html
<nav aria-label="Breadcrumb">
  <ol>
    <li>
      <a href="https://example.com">
        <span>Home</span>
      </a>
    </li>
    <li>
      <a href="https://example.com/products">
        <span>Products</span>
      </a>
    </li>

    <li>
      <span aria-current="page">Current Page</span>
    </li>
  </ol>
</nav>
```

### JSON-LD Structured Data

This example demonstrates how to dynamically generate the breadcrumb JSON-LD structured Data using JavaScript.

```javascript
const breadcrumbs = [
  ,
  ,
  ,
];

function generateBreadcrumbSchema(breadcrumbs) {
  return {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    itemListElement: breadcrumbs.map((crumb, index) => ),
  };
}
```

## SEO

### Structured Data

* Implement breadcrumb structured data using [Schema.org markup](https://schema.org/BreadcrumbList) to help search engines understand your site's hierarchy
* This improves the way your site appears in search results and helps search engines better understand your content structure
  Example JSON-LD structured data:

```json
```

### Testing & Validation

* Use Google's [Rich Results Test](https://search.google.com/test/rich-results) to validate structured data
* Monitor breadcrumb appearance in search results through Google Search Console
* Check for proper indexing of breadcrumb pages in site architecture
* Verify mobile rendering of breadcrumbs for mobile-first indexing

## Testing Guidelines

### Functional Testing

**Should ✓**

* Navigate to the correct page when clicking each breadcrumb link
* Show the complete hierarchy path from home to current page
* Update breadcrumb trail when navigating through different levels
* Maintain state after page refresh
* Work with browser back/forward navigation

### Accessibility Testing

**Should ✓**

* Be navigable using keyboard (Tab and Enter keys)
* Have proper ARIA labels and roles
* Announce proper hierarchy to screen readers
* Maintain focus state visibility
* Have sufficient color contrast (WCAG 2.1 AA)

### Responsive Testing

**Should ✓**

* Adapt layout for different screen sizes
* Show/hide home icon appropriately
* Handle text overflow gracefully
* Maintain touch target sizes on mobile (minimum 44x44px)
* Preserve functionality across different devices

### SEO Testing

**Should ✓**

* Include proper Schema.org markup
* Have semantic HTML structure
* Maintain consistent URL structure
* Include relevant meta tags
* Follow proper link hierarchy

### Performance Testing

**Should ✓**

* Load without significant delay
* Not cause layout shifts
* Handle large numbers of items efficiently
* Work with dynamic content updates
* Function without JavaScript (progressive enhancement)

## Frequently Asked Questions

' or '/'\n" +
"3. Ensure all items, except the current page, are clickable links\n" +
"4. Be concise and not occupy excessive space\n" +
"5. Be placed near the top of the page, below the main navigation",
},
,
,
]}
/>

## Resources

### Articles

* [Breadcrumbs: 11 Design Guidelines for Desktop and Mobile](https://www.nngroup.com/articles/breadcrumbs/) by Nielsen Norman Group
* [Designing Effective Breadcrumbs Navigation — Smashing Magazine](https://www.smashingmagazine.com/2022/04/breadcrumbs-ux-design/)
* [Breadcrumb Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/breadcrumb/) by W3C
* [Breadcrumbs](https://a11y-style-guide.com/style-guide/section-navigation.html#kssref-navigation-breadcrumbs) - By A11y Style guide

### Libraries

* [Breadcrumb: shadcn/ui](https://ui.shadcn.com/docs/components/breadcrumb)
* [Breadcrumb - Origin UI](https://originui.com/breadcrumb)


# NAVIGATION: [Hambuger Menu](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/navigation/hambuger-menu)

Create accessible mobile menus with smooth animations and touch-friendly interactions.

# Hamburger Menu


# NAVIGATION: [Infinite Scroll](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/navigation/infinite-scroll)

Create seamless content loading with infinite scroll, focusing on performance, accessibility, and user experience best practices.

# Infinite scroll

***(Also called Continuous scrolling)***

## Overview

**Infinite Scroll** is a UI pattern that dynamically loads more content as users scroll down a page, eliminating the need for pagination or manual interaction. It provides a seamless browsing experience by continuously appending new items to the current view.

This pattern is commonly used in **social media feeds, search results, and content-heavy websites** to keep users engaged without interruptions.

## Use Cases

### When to use:

Use Infinite Scroll when you need to dynamically load more content as users scroll without requiring manual pagination.

**Common scenarios include:**

* **Social media feeds** – e.g., Twitter, Instagram, Facebook, where users consume an endless stream of content.
* **News and blog sites** – e.g., showing a continuous stream of articles.
* **E-commerce product listings** – e.g., dynamically loading more items as users explore the catalog.
* **Search results** – e.g., reducing friction in discovering relevant items.
* **Media galleries** – e.g., loading more images/videos as users scroll.

### When not to use:

* **When users need to find specific content quickly** – Paginated results may be more efficient.
* **For structured navigation** – If users need to compare items or revisit previous results, pagination provides better control.
* **If performance is a concern** – Infinite scroll can lead to high memory usage and slow rendering.
* **For content requiring user actions** – If users frequently need to interact with elements (e.g., filling forms), infinite scrolling can be disruptive.
* **When reaching the footer is important** – Users may struggle to access footer content if new items keep loading.

## Benefits

* **Enhances engagement** by providing a seamless browsing experience.
* **Eliminates unnecessary page loads** and reduces navigation friction.
* **Encourages content exploration** by presenting an uninterrupted flow of items.
* **Optimized for touchscreens** where scrolling is more intuitive than clicking pagination buttons.

## Drawbacks

* **Navigation challenges** – Users may struggle to return to a previous position.
* **Performance issues** – Excessive DOM elements can lead to lag and slow rendering.
* **Accessibility concerns** – Keyboard and screen reader users may find it harder to navigate.
* **Disrupts footer visibility** – Users may never reach the footer if content loads indefinitely.

## Anatomy

```mermaid
flowchart TB
    subgraph InfiniteScroll[Infinite Scroll Component]
        A[Content Container] --> B[Trigger Point]
        B --> C[Loading Indicator]
        C --> D[Newly Loaded Content]
        D --> E[Next Trigger Point - Optional]
    end
```

### Component Structure

1. **Content Container**

* Holds the dynamically loaded items.
* Ensures content is structured and visually organized.
* Can be a **list, grid, or other layout structure**.

2. **Trigger Point**

* The detection mechanism that determines **when to load more content**.
* Typically appears when the **user scrolls near the end** of the container.
* Can be based on **viewport visibility, scroll depth, or other triggers**.

3. **Loading Indicator**

* Provides **visual feedback** while content is being retrieved.
* Can be a **spinner, progress bar, or skeleton loader**.
* Should **only be displayed when new content is actively loading**.

4. **Newly Loaded Content**

* The additional items dynamically inserted once new data is fetched.
* Should **seamlessly integrate** with previously loaded content.
* May **fade in or animate** to indicate new content.

5. **Next Trigger Point (Optional)**

* If more content is available, a new **Trigger Point** is added for the next batch.
* Helps manage continuous loading in **long content feeds**.

#### **Summary of Components**

| Component            | Required? | Purpose                                                      |
| -------------------- | --------- | ------------------------------------------------------------ |
| Content Container    | ✅ Yes     | Holds the items being dynamically loaded.                    |
| Trigger Point        | ✅ Yes     | Detects when the user reaches the threshold for new content. |
| Loading Indicator    | ✅ Yes     | Shows that content is being fetched.                         |
| Newly Loaded Content | ✅ Yes     | Represents the new batch of dynamically inserted content.    |
| Next Trigger Point   | ❌ No      | Appears if additional content is available for loading.      |

## Best Practices

### Content & Usability

**Do's ✅**

* **Provide clear loading indicators** to inform users that content is being fetched.
* **Use a 'Load More' button as a fallback** in case auto-loading fails.
* **Allow users to jump back to the top** with a 'Back to Top' button.
* **Save scroll position** so users don't lose their place when navigating back.

**Don'ts ❌**

* **Avoid infinite loops** – Ensure loading stops when all content is fetched.
* **Don't break browser back navigation** – Users should be able to return to previous content states.
* **Avoid excessive memory usage** – Remove off-screen items if necessary to optimize performance.

### Accessibility

**Do's ✅**

* **Ensure content is focusable** – New items should be reachable via keyboard navigation.
* **Announce new content dynamically** using ARIA live regions (`aria-live="polite"`).
* **Provide an alternative to infinite scrolling** – Offer pagination or a "Load More" option.
* **Ensure users can pause or stop loading** – Unexpected content updates can be disorienting.

**Don'ts ❌**

* **Avoid relying solely on scrolling** – Users with assistive technologies may need alternative navigation.
* **Don't change content order unexpectedly** – Screen readers should process content sequentially.

### Visual Design

**Do's ✅**

* **Use smooth transitions** when loading new items to maintain a natural experience.
* **Indicate loading state** – Provide a spinner or skeleton loader while fetching data.
* **Ensure visual continuity** – Keep layout stable to prevent sudden jumps.

**Don'ts ❌**

* **Don't push content down unexpectedly** – New items should append seamlessly without disrupting user flow.
* **Avoid excessive whitespace** – Content should remain readable and well-structured.

### Performance Optimization

**Do's ✅**

* **Implement lazy loading** – Load images and assets only when needed.
* **Use virtualization** – Remove off-screen items from the DOM to improve performance.
* **Optimize API calls** – Fetch only necessary data to reduce network requests.

**Don'ts ❌**

* **Avoid fetching too much data at once** – This can slow down rendering and increase memory usage.
* **Don't re-render the entire list on new data arrival** – Only update necessary elements.

## SEO Considerations

* Ensure **search engines can access all content** by implementing **server-side rendering (SSR)** or an accessible paginated alternative.
* Provide a **static link to all content pages** to ensure crawlers can index them.
* Ensure that critical content is **available without JavaScript**.

## Testing Guidelines

### Functional Testing

**Should ✓**

* [ ] Confirm new content loads properly as the user scrolls.
* [ ] Ensure scroll position remains stable after navigating back to the page.
* [ ] Verify that users can manually load more content if needed.
* [ ] Ensure the feature works across different browsers and devices.

### Accessibility Testing

**Should ✓**

* [ ] Verify that screen readers announce new content properly.
* [ ] Ensure that keyboard users can navigate through dynamically loaded items.
* [ ] Test with reduced motion settings to ensure animations don't cause issues.

### Performance Testing

**Should ✓**

* [ ] Measure memory usage to prevent excessive DOM elements.
* [ ] Ensure API calls are efficient and minimize network overhead.
* [ ] Test scrolling performance on both desktop and mobile devices.

## Related Patterns

* [Pagination](/patterns/navigation/pagination) – A structured alternative to infinite scrolling.
* [Back to Top](/patterns/navigation/back-to-top) – Helps users quickly return to the top of the page.

## Frequently Asked Questions

## Resources

### Articles

### Documentation

### Libraries


# NAVIGATION: [Load More](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/navigation/load-more)

Build efficient content loading with the Load More pattern, focusing on user experience and performance optimization.

# Load More

## Overview

The **Load More** pattern allows users to request additional content dynamically rather than loading everything upfront. It enhances performance and user experience by reducing initial page load times while providing seamless access to more content when needed.

## Use Cases

### When to use:

Use this pattern when you want users to progressively explore content at their own pace without overwhelming them with too many options at once. Unlike infinite scrolling, "Load More" provides clear control over content retrieval and allows users to consciously decide when to view more items.

To improve usability, ensure that the "Load More" button is **removed when all content is loaded** or updated to indicate that no additional items are available (e.g., **"No More Results"**).

**Common scenarios include:**

* When displaying large lists of content (e.g., news feeds, product listings)
* To improve page performance by loading only a subset of data initially
* When users are likely to browse progressively rather than needing all content at once
* To provide an alternative to infinite scrolling, offering more control over content loading

### When not to use:

* When the full content list is small enough to load upfront without performance concerns
* If users need to compare multiple items at once ([pagination](/patterns/navigation/pagination) may be a better alternative)
* When real-time updates or continuous data streaming is required

### Common scenarios and examples

* **E-commerce**: Loading additional products in a grid or list
* **News or blog feeds**: Expanding more articles dynamically
* **Social media feeds**: Loading additional posts without overwhelming users
* **Search results**: Fetching more results upon user request

## Benefits

* **Improves page performance** by reducing initial data load
* **Gives users control** over content consumption, reducing cognitive overload
* **Enhances accessibility** compared to infinite scrolling, ensuring users don't lose track of their position
* **Works well with various devices** by enabling controlled data retrieval
* **Enables footer access** by allowing users to reach the page's footer and access secondary links like return policies, shipping information, and contact details
* **Prevents unnecessary interactions** by **removing the "Load More" button once all content has been loaded** or replacing it with a message like **"No More Results"**.
* **Minimizes layout shifts** by ensuring that newly loaded content seamlessly appears without affecting user position.

## Drawbacks

* **User Effort** – Requires users to take action to reveal more content instead of a seamless experience.
* **Potentially Hidden Content** – Users may not realize more content is available if the button isn't clearly visible.
* **Disrupted Flow** – Clicking **Load More** can break user immersion compared to continuous scrolling.
* **Inconsistent Navigation** – Can make it harder for users to return to previously loaded sections if not implemented correctly.
* **SEO Challenges** – Search engines may not always index dynamically loaded content unless handled properly.
* **Accessibility Concerns** – Requires careful ARIA implementation to ensure screen readers announce newly loaded content.
* **Performance Overhead** – Multiple content fetch requests can impact performance if not optimized properly.

## Anatomy

```mermaid
flowchart TB
    subgraph LoadMore[Load More Component]
        A[Container] --> B[Initial Content List]
        B --> C[Load More Button]
        C --> D[Loading Indicator - Optional]
        C --> E[Additional Content]
        E --> F[Another Load More Button - Optional]
    end
```

### Component Structure

1. **Container**

   * Wraps the entire load more component.
   * Ensures content is properly structured and styled.

2. **Initial Content List**

   * Displays a **limited number of items** to prevent overwhelming users.
   * Defines the default **starting state** before additional content is loaded.

3. **Load More Button**

   * The primary trigger for **loading additional content**.
   * Should provide **clear affordance** that more content is available.
   * May include **ARIA attributes** to indicate loading state.

4. **Loading Indicator (Optional)**

   * Provides **visual feedback** that new content is being fetched.
   * Can be a **spinner, progress bar, or skeleton loader**.

5. **Additional Content**

   * The **newly loaded items** that appear after clicking "Load More".
   * Should integrate **seamlessly** with the initial content list.

6. **Another Load More Button (Optional)**
   * Appears **if more content is available after the first load**.
   * Helps users **incrementally explore content** without scrolling endlessly.

#### **Summary of Components**

| Component                | Required? | Purpose                                                      |
| ------------------------ | --------- | ------------------------------------------------------------ |
| Container                | ✅ Yes     | Wraps the content that will load more items.                 |
| Initial Content List     | ✅ Yes     | Displays a limited set of items to avoid overwhelming users. |
| Load More Button         | ✅ Yes     | Allows users to manually fetch more content.                 |
| Loading Indicator        | ❌ No      | Shows progress while loading more items.                     |
| Additional Content       | ✅ Yes     | The dynamically inserted content after clicking "Load More." |
| Another Load More Button | ❌ No      | Appears if further content can still be loaded.              |

## Best Practices

### Content

**Do's ✅**

* Clearly indicate that more content is available and can be loaded.
* Use concise and meaningful labels like **"Load More"**, **"Show More"**, or **"See More Results"**.
* Ensure a smooth transition when new content loads.

**Don'ts ❌**

* Avoid vague labels like **"Click Here"**.
* Don't load excessive content at once; keep it manageable.
* Don't disrupt the existing layout when inserting new content.

### Accessibility & UX

**Do's ✅**

* Ensure the **Load More** button is keyboard accessible (`tab` and `enter` keys).
* Announce new content to screen readers (`aria-live="polite"`).
* Provide feedback (e.g., loading indicators) to inform users of content retrieval.
* **Maintain keyboard focus** – After clicking "Load More," focus should shift **to the newly loaded content** rather than returning to the button. This ensures a logical navigation flow.
* **Announce new content to assistive technologies** – Use `aria-live="polite"` to notify screen reader users that additional items have been loaded.

**Don'ts ❌**

* Don't remove focus from the **Load More** button after clicking it (don't use `disabled`)
* Avoid infinite scrolling without a **Load More** option as a fallback.
* Don't rely solely on color for action buttons (ensure contrast and readable text).

### Visual Design

**Do's ✅**

* Place the **Load More** button prominently below existing content.
* Ensure clear visual feedback when new content loads (e.g., animations, progress indicators).
* Maintain consistent spacing and alignment with existing content.

**Don'ts ❌**

* Don't make the button too small or difficult to tap on mobile devices.
* Avoid sudden layout shifts when loading new content.

### Layout & Positioning

**Do's ✅**

* Place the **Load More** button at logical breakpoints in the content.
* Ensure loaded content appears immediately following the existing items.
* Retain the user's position in the list after loading more content.

**Don'ts ❌**

* Don't insert new content above the user's current view unless explicitly requested.
* Avoid loading content off-screen without visual confirmation.

### Common Mistakes & Anti-Patterns

#### No Visual Feedback After Clicking "Load More"

**❌ What's Wrong?**

Users may think the button is broken if there's no immediate sign of progress after they click.

**How to Fix It?**
Show a **spinner or loading animation** and possibly disable the button until the new content is fully loaded.

***

#### Loading Too Many Items at Once

**❌ What's Wrong?**

Fetching a large batch of content can slow performance, cause layout shifts, and overwhelm users.

**How to Fix It?**
Load **smaller chunks** (e.g., 10–20 items per click). Provide incremental updates rather than a single large data fetch.

***

#### Forcing Users to Click "Load More" Too Often

**❌ What's Wrong?**

Having users repeatedly click "Load More" leads to frustration and makes the page feel unresponsive.

**How to Fix It?**
Use **auto-loading on scroll** after a few manual loads, or at least increase the batch size once you detect high engagement.

***

#### No Clear End of Content Indicator

**❌ What's Wrong?**

Users can't tell when they've reached the final items, potentially clicking "Load More" with no result.

**How to Fix It?**
Display a "You've reached the end" message or hide the button entirely once there's no more data.

***

#### Not Accessible via Keyboard (Accessibility)

**❌ What's Wrong?**

If the "Load More" button isn't focusable or doesn't respond to keyboard events, users relying on keyboard navigation can't load new content.

**How to Fix It?**
Ensure the button is a proper, focusable element (e.g., `<button>`). Confirm you can press `Tab` to focus and `Enter/Space` to trigger loading.

***

#### No ARIA Updates for New Content (Accessibility)

**❌ What's Wrong?**

Screen reader users may not realize new items appeared if there's no announcement that content was added to the page.

**How to Fix It?**
Wrap your list in a container with `role="region"` or use an `aria-live="polite"` area. Update the live region or add a brief "New content loaded" announcement after each batch is rendered.

***

#### Insufficient Visual Contrast or Feedback (Accessibility)

**❌ What's Wrong?**

If the "Load More" button is low contrast or the loading indicator is hard to see (e.g., small spinner on a cluttered background), low-vision users may struggle to notice it.

**How to Fix It?**
Provide a **high-contrast** button style and a **clear, visible** loading indicator (spinner or progress bar) that stands out from surrounding content.

## Tracking

Tracking "Load More" interactions helps measure how users navigate through content, whether they prefer incremental loading over pagination, and how deep they engage with the content. By analyzing user behavior, we can optimize when and how "Load More" is implemented.

### Key Tracking Points

Each "Load More" interaction provides valuable insights into user behavior. Below are the key events that should be tracked:

| **Event Name**           | **Description**                                                                           | **Why Track It?**                                                            |
| ------------------------ | ----------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| `load_more.view`         | When the "Load More" button enters the viewport.                                          | Determines visibility and whether users see the option to load more content. |
| `load_more.click`        | When a user clicks the "Load More" button.                                                | Measures engagement and intent to see additional content.                    |
| `load_more.auto_trigger` | When more content loads automatically without user action (e.g., lazy loading on scroll). | Helps compare manual clicks vs. auto-triggered loads.                        |
| `load_more.depth`        | The number of times a user loads more content in one session.                             | Indicates how deep users are willing to explore.                             |
| `load_more.scroll_usage` | If infinite scrolling is enabled, tracks when users reach the "Load More" trigger area.   | Helps compare scrolling behavior vs. button clicks.                          |

### Event Payload Structure

To ensure consistent tracking, here's a recommended event format:

```json
```

### Key Metrics to Analyze

Once tracking is in place, the following metrics provide actionable insights:

* **Load More Click Rate** → Percentage of users who click the "Load More" button.
* **Auto-Trigger Rate** → Percentage of users who load more content automatically via scrolling (if enabled).
* **Average Load More Depth** → Number of times users load more content in a session.
* **Completion Rate** → Percentage of users who reach the final batch of content.
* **Scroll vs. Click Engagement** → If both options exist, measures user preference for scrolling vs. manually clicking "Load More."

### Insights & Optimization Based on Tracking

By analyzing tracking data, we can optimize the "Load More" experience:

* 🚨 **Low Load More Click Rate?**
  → Users may not notice or find the "Load More" button unnecessary.
  **Optimization:** Improve visibility, adjust styling, or test auto-loading on scroll.

* ⏳ **High Auto-Trigger Rate?**
  → Users rely more on automatic loading rather than clicking.
  **Optimization:** Consider fully replacing "Load More" with infinite scrolling or adding a "Show More" summary before triggering more content.

* 🔄 **Low Average Load More Depth?**
  → Users stop after one or two loads.
  **Optimization:** Ensure the first few results are engaging enough to encourage further exploration.

* 🔁 **Low Completion Rate?**
  → Users rarely reach the final batch of content.
  **Optimization:** Test reducing content chunk sizes per load or adding preview indicators (e.g., "Showing 20 of 100 results").

* ⚙️ **High Scroll vs. Click Engagement?**
  → Users prefer scrolling over clicking the button.
  **Optimization:** Consider transitioning to infinite scrolling but ensure good performance and usability.

By continuously monitoring these metrics, we can refine the "Load More" pattern, ensuring users efficiently navigate through content without unnecessary friction.

## Accessibility

### ARIA Attributes

**Required ARIA attributes:**

* Use `aria-controls` to associate the **Load More** button with the content being updated.
* Announce loading states with `aria-live="polite"`.
* If the button is removed after loading all content, update its `aria-label` to indicate that no more content is available.

### Screen Reader Support

**Implementation considerations:**

* Users should be informed when new content is added.
* Ensure proper tab focus order when new items appear.
* Use accessible button elements (`<button>` instead of `<div>` or `<span>`).

## SEO

* Ensure content loaded via **Load More** is indexable by search engines.
* Use progressive enhancement to allow content visibility even if JavaScript is disabled.
* Provide a paginated alternative if necessary for deep content navigation.
* Ensure that dynamically loaded content is **crawlable by search engines** by using progressive enhancement techniques or **server-side rendering**.
* If SEO visibility is a priority, consider **implementing paginated URLs** as a fallback to allow search engines to index all content properly.

## Testing Guidelines

### Functional Testing

**Should ✓**

* Verify that the **Load More** button successfully loads additional content when clicked.
* Ensure **smooth transitions** and that new content is **visually distinct** without disrupting the layout.
* Test **multiple clicks on the button** to confirm continuous content retrieval works as expected.
* Ensure the button **disables or disappears** when all content has been loaded.
* Validate that clicking **Load More** does not cause a page refresh or unexpected navigation.
* Confirm that the **user remains in the same scroll position** after loading more content.
* Ensure newly loaded content appears **sequentially** in the correct order.
* Check for **error handling**—simulate network failures to confirm users receive an appropriate message.

***

### Accessibility Testing

**Should ✓**

* Verify that the **Load More** button is fully keyboard accessible\*\* (`Tab` to navigate, `Enter` to activate).
* Ensure that new content is **announced to screen readers** using `aria-live="polite"`.
* Validate that **focus moves to the newly loaded content** rather than back to the button.
* Check that the button has **proper contrast** and is easily readable.
* Confirm that screen readers announce when **no more content is available** after the last load.
* Ensure that `aria-controls` links the button to the dynamically updated content.
* Verify that users can **navigate through the loaded content** using standard keyboard interactions.

***

### Performance Testing

**Should ✓**

* Ensure that **each content load request is optimized** to avoid unnecessary data retrieval.
* Check that **lazy-loading techniques** prevent excessive memory usage.
* Test with **large datasets** to confirm that performance remains smooth.
* Validate that **content loading does not block interactions** with other page elements.
* Measure **network requests and response times** to ensure efficient API calls.
* Check that **animations and transitions** remain smooth without jank.
* Verify that **multiple Load More interactions do not degrade performance** over time.

***

### SEO Testing

**Should ✓**

* Confirm that dynamically loaded content is **indexable by search engines** (e.g., using server-side rendering or progressive enhancement).
* Check that search engines can **crawl and discover** all content, even if JavaScript is disabled.
* Ensure that **important content is not hidden behind JavaScript-only interactions**.
* Run Lighthouse or Google's Mobile-Friendly Test to ensure SEO best practices are met.
* Test the page with JavaScript disabled to confirm that at least some content remains visible.

***

### User Experience Testing

**Should ✓**

* Observe user behavior to determine if the **Load More button is easily discoverable**.
* Ensure that the button **clearly communicates** its function (e.g., "Load More" vs. "Show More Results").
* Test on **mobile devices** to verify tap targets are large enough.
* Confirm that **loading indicators** provide clear feedback during content retrieval.
* Ensure that **content loads fast enough** to avoid user frustration.
* Validate that **users do not get lost** when additional content is inserted.

***

### Edge Case Testing

**Should ✓**

* Simulate a **slow network connection** to test how loading delays affect usability.
* Check behavior when **no more content is available**—the button should be removed or updated.
* Verify how the component behaves if the **API fails** or returns an error.
* Test **rapid multiple clicks** on the button to ensure proper request handling.
* Ensure **back navigation retains loaded content**, preventing users from losing progress.
* Confirm the **component adapts to different screen sizes and orientations**.

## Related Patterns

Consider these related patterns when implementing **Load More**:

* [Infinite Scroll](/patterns/navigation/infinite-scroll) - Automatically loads content as users scroll.
* [Pagination](/patterns/navigation/pagination) - A structured way to navigate large sets of content.
* [Loading Indicator](/patterns/user-feedback/loading-indicator) - Displays feedback when content is loading.

## Frequently Asked Questions


# NAVIGATION: [Megamenu](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/navigation/megamenu)

Build accessible and responsive megamenus with keyboard navigation and mobile-friendly adaptations.

# Megamenu


# NAVIGATION: [Navigation Menu](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/navigation/navigation-menu)

Build effective navigation menus for your website. Learn best practices for creating accessible, responsive navigation with proper keyboard support and mobile-friendly interactions.

# Navigation Menu


# NAVIGATION: [Pagination](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/navigation/pagination)

Learn best practices for building accessible, user-friendly page navigation with clear guidelines for design and performance.

# Pagination

## Overview

**[Pagination](/glossary/pagination)** is a navigation pattern used to divide large collections of content into manageable chunks or pages.
This helps users to navigate through data sets, search results, or product listings without overwhelming the page with too much information at once.

While pagination is a common and effective pattern, it's important to consider alternatives like [infinite scroll](/patterns/navigation/infinite-scroll) or ["Load More"](/patterns/navigation/load-more) buttons for certain types of content. The choice between pagination and infinite scroll depends on factors such as the nature of the content, user behavior, and the goals of the interface.

## Use Cases

### When to use:

Use this pattern when content needs to be progressively revealed or loaded in a structured manner, ensuring a smoother user experience and improved performance.

It helps users navigate large sets of information without overwhelming them.

**Common scenarios include:**

* **Browsing content lists** – e.g., search results, blog archives, or product listings.
* **Improving page performance** – by loading content in smaller, more manageable segments.
* **Enhancing user clarity** – making large data sets easier to understand and navigate.
* **Navigating sequential content** – e.g., multi-page tutorials or articles.

### When not to use:

* When all content is better presented on a single page (e.g., short lists or summaries).
* If [infinite scroll](/patterns/navigation/infinite-scroll) or a ["load more"](/patterns/navigation/load-more) pattern better suits the user experience.
* In scenarios where users need continuous comparison between items on different pages.

## Benefits

* Improves page load times by limiting the amount of content loaded at once
* Enhances user orientation within large datasets
* Provides clear navigation cues for moving through content
* Supports better performance and reduced server load
* Allows for easier bookmarking and sharing of specific pages
* Gives users a sense of the content's scope (total number of pages/items)
* Better suited for goal-oriented tasks compared to infinite scroll

## Drawbacks

* **Can interrupt user flow** – Users must manually click to navigate instead of continuous scrolling.
* **Navigation complexity** – Requires handling of "Previous," "Next," first, and last page navigation.
* **Harder for mobile users** – Small pagination buttons can be difficult to tap on touchscreens.
* **SEO considerations** – Improper implementation can lead to duplicate content issues
* **Page reload delays** – If not dynamically updated, full-page reloads can slow down user experience.

## Anatomy

```mermaid
flowchart TB
  subgraph Pagination[Pagination Component]
    A[Pagination Container] --> B[First Page Button - Optional]
    A --> C[Previous Button]
    A --> D[Pagination Items]
    A --> E[Ellipsis - Optional]
    A --> F[Next Button]
    A --> G[Last Page Button - Optional]
  end
```

### Component Structure

1. **Container**

* The wrapper element that encompasses all pagination controls.
* Manages layout and spacing.
* Ensures proper ARIA labeling and keyboard navigation.

2. **Previous Button**

* Allows users to navigate to the preceding page.
* Typically disabled on the first page to indicate there is no previous content.

3. **Pagination Items**

* Numbered buttons or links for each page.
* Clearly indicate the current page (using visual cues and ARIA attributes).
* May include an ellipsis ("…") for large ranges of pages.

4. **Next Button**

* Allows users to navigate to the next page.
* Disabled on the last page to prevent further navigation.

5. **First & Last Page Buttons (Optional)**

* Provide quick navigation to the **first** and **last** pages.
* Useful when dealing with **long pagination ranges**.

6. **Ellipsis (Optional)**

* Indicates missing page numbers in large paginations.
* Reduces clutter while maintaining navigation clarity.

7. **Visual States**

* **Default:** Normal state with clear labels and clickable elements.
* **Hover and Focus:** Provides visual cues (underline, background change, or border) for interactive elements.
* **Active:** Indicates the currently selected page.
* **Disabled:** Non-interactive controls (e.g., previous on page 1, next on last page).
* **Keyboard Focus:** Ensures proper highlight states for accessibility.
* **ARIA Live Updates:** Announces page changes for screen readers.
* **Loading Indicators (Optional):** Shows progress when paginated content is being fetched asynchronously.

#### **Summary of Components**

| Component               | Required? | Purpose                                          |
| ----------------------- | --------- | ------------------------------------------------ |
| Container               | ✅ Yes     | Wraps the pagination controls.                   |
| Next/Previous Buttons   | ✅ Yes     | Allows users to navigate between pages.          |
| Page List               | ✅ Yes     | Contains the list of page numbers.               |
| Page Item               | ✅ Yes     | Represents each individual page link.            |
| First/Last Page Buttons | ❌ No      | Enables quick navigation to the first/last page. |
| Ellipsis                | ❌ No      | Represents omitted pages in large paginations.   |
| Loading Indicator       | ❌ No      | Displays when fetching new paginated content.    |

## Best Practices

### Content

**Do's ✅**

* Use clear, concise labels for navigation controls
* Provide context (e.g., "Page 5 of 20")
* Consider using ellipsis (...) for large page ranges
* Evaluate whether pagination or infinite scroll is more appropriate for your specific use case and content type
* Show a loading indicator when fetching new content
* Update the URL to reflect the current page number

**Don'ts ❌**

* Don't clutter the interface with too many pagination controls
* Avoid using pagination for very short lists that can be displayed on a single page
* Don't use ambiguous labels that could confuse the user
* Avoid loading unnecessary data or assets that aren't relevant to the current page

### Accessibility

**Do's ✅**

* Use the semantic `<nav>` element to wrap pagination controls
* Label the `<nav>` element with `aria-label="Pagination"` or similar for screen readers
* Ensure each page link is a focusable element and includes clear labels
* Provide a logical keyboard navigation order (e.g., Tab, Enter, Arrow keys)
* Use `aria-current="page"` to indicate the current page
* Automatically scroll to the top of the content area when loading a new page
* Set focus to the main content area or the first item in the new page after loading
* Use ARIA live regions to announce loading status to screen reader users
* Provide a "Skip to content" link that becomes visible on focus for keyboard users

**Don'ts ❌**

* Don't rely solely on color to indicate the current page; also include text or icons
* Avoid complex pagination structures that could confuse keyboard and assistive technology users
* Don't leave the user's scroll position unchanged when loading an entirely new page of content
* Avoid setting focus to the pagination controls after page load, as this can be disorienting

### Visual Design

**Do's ✅**

* Use consistent spacing, typography, and colors to maintain clarity
* Provide clear visual separation between individual pagination items
* Ensure the active state stands out visually
* Consider using subtle hover animations to signal interactivity
* Design for scalability with large numbers of pages (e.g., use abbreviated formats like 1k, 2k for 1000, 2000)
* Implement efficient server-side pagination to minimize load times
* Use smooth scrolling when automatically moving to the top of new content

**Don'ts ❌**

* Don't make interactive elements too small or difficult to tap on mobile devices
* Avoid overly decorative styles that detract from content readability
* Don't block user interaction with the entire page during loading unless absolutely necessary

### Layout & Positioning

**Do's ✅**

* Position the pagination control in a logical location (typically at the bottom of content listings)
* Ensure sufficient contrast between pagination controls and the background
* Use responsive design techniques to maintain usability on various devices
* Consider using progressive loading techniques for images and other media
* Maintain scroll position if only part of the page is being updated (e.g., in a single-page application)

**Don'ts ❌**

* Don't position pagination too far from the actual content, which may force excessive scrolling
* Avoid fixed positioning that could interfere with content readability on small screens
* Don't break the browser's history functionality with custom pagination implementations

### Common Mistakes & Anti-Patterns

#### Too Many Pages (No Page Limiting)

**❌ What's Wrong?**

Users get overwhelmed if there are **dozens of pages** to click through, making it hard to find relevant content.

**How to Fix It?**
Consider using **"Load More"** or **infinite scroll** if the content is suited to continuous exploration. If pagination is necessary, cap the total pages or provide filters to reduce results.

***

#### Hiding Pagination Controls on Mobile

**❌ What's Wrong?**

Some designs remove pagination on smaller screens, forcing mobile users to scroll endlessly or guess how to navigate deeper pages.

**How to Fix It?**
Use a **compact pagination menu** (e.g., next/previous buttons or a limited set of page links) so users can still control navigation on mobile devices.

***

#### Not Remembering the Last Page

**❌ What's Wrong?**

When users navigate away and come back, they lose track of which page they were on, leading to frustration and repetitive browsing.

**How to Fix It?**
Store pagination state in the **URL (e.g., `?page=2`)** or in session/local storage. When users return, restore them to the same page.

***

#### Inconsistent Page Numbers (Jumping Pages)

**❌ What's Wrong?**

Some pagination systems remove or rearrange pages based on dynamic data, confusing users who rely on consistent numbering.

**How to Fix It?**
Maintain a **stable page structure**—if new items appear, consider adding them at the end or updating page counts without shifting existing page numbers unexpectedly.

***

#### No Keyboard Accessibility (Accessibility)

**❌ What's Wrong?**

If pagination links or buttons aren't keyboard-focusable, users relying on the keyboard can't move between pages effectively.

**How to Fix It?**
Use proper interactive elements (`<button>`, `<a href>`). Confirm `Tab` navigation works for each link or control, and that pressing `Enter` or `Space` actually triggers page changes.

***

#### Poorly Labeled Page Links (Accessibility)

**❌ What's Wrong?**

Screen readers can't convey page numbers or next/previous actions if the links have generic text like "..." or "Page."

**How to Fix It?**
Add `aria-label` attributes (e.g., `aria-label="Go to page 2"`) or text that clearly states each page's purpose. For "Next" and "Previous," label them explicitly (e.g., `aria-label="Go to next page"`).

***

#### No Visible Focus Indicator (Accessibility)

**❌ What's Wrong?**

Users can't see where their keyboard focus is if the pagination links have no visible outline or highlight.

**How to Fix It?**
Include a **high-contrast focus style** (outline, underline, etc.) so it's obvious which page or button is selected or about to be selected.

***

#### Unclear Feedback After Page Selection (Accessibility)

**❌ What's Wrong?**

When users click a pagination link, especially if the new page loads asynchronously, they might not realize the content has updated.

**How to Fix It?**
Use an **ARIA live region** or a brief status announcement (e.g., "Page 2 loaded") so screen reader users (and everyone else) know new content has appeared.

## Micro-Interactions & Animations

When building pagination, consider these specific, purpose-driven animations:

* **Button Hover Animation:**

  * **Effect:** On hover, scale the button up to 1.05× its original size and smoothly transition the background color.
  * **Timing:** Use a 200ms ease transition to ensure responsiveness without delay.

* **Focus State Animation:**

  * **Effect:** When a button receives focus (via keyboard or pointer), animate a clear visual indicator—such as a crisp outline or subtle drop-shadow—to emphasize its active state.
  * **Timing:** Apply the effect over 200ms to create a smooth visual cue.

* **Active (Click) Animation:**

  * **Effect:** Upon clicking a pagination button, trigger a brief confirmation animation (for example, a quick pulse or a slight scale up to 1.1×) to signal the selection.
  * **Timing:** The animation should complete within 150–200ms to provide immediate feedback without interrupting the user flow.

* **Content Transition (When Applicable):**

  * **Effect:** If the pagination action triggers a content update (common in SPAs), apply a fade transition where the outgoing content fades out and the incoming content fades in.
  * **Timing:** Transition the content opacity over approximately 250ms to ensure a smooth change without distracting from the overall experience.

* **Reduced Motion Consideration:**
  * **Implementation:** Always check for the user's motion preferences (e.g., via the `prefers-reduced-motion` media query) and disable or minimize animations accordingly to ensure accessibility.

These precise animations provide just enough feedback to guide user interactions and enhance the overall feel of your pagination component without overwhelming the interface.

## Tracking

Tracking pagination interactions helps measure how users navigate through paginated content, whether they prefer clicking through pages sequentially or skipping ahead, and if they reach deeper pages. By analyzing pagination behavior, we can optimize the user experience and improve content discoverability.

### Key Tracking Points

Each pagination interaction provides valuable insights into user behavior. Below are the key events that should be tracked:

| **Event Name**            | **Description**                                                                                            | **Why Track It?**                                                   |
| ------------------------- | ---------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| `pagination.view`         | When the pagination component enters the viewport.                                                         | Determines visibility and whether pagination is available to users. |
| `pagination.next_click`   | When a user clicks the **next page** button.                                                               | Measures sequential navigation behavior.                            |
| `pagination.prev_click`   | When a user clicks the **previous page** button.                                                           | Tracks backward navigation trends.                                  |
| `pagination.page_click`   | When a user clicks a specific numbered page.                                                               | Helps assess whether users jump ahead instead of clicking next.     |
| `pagination.first_click`  | When a user clicks the first page button (if available).                                                   | Measures how often users return to the beginning.                   |
| `pagination.last_click`   | When a user clicks the last page button (if available).                                                    | Indicates if users want to skip directly to the end.                |
| `pagination.page_load`    | When a new paginated page loads (via user interaction or auto-pagination).                                 | Helps measure engagement depth.                                     |
| `pagination.scroll_usage` | If infinite scrolling is enabled, tracks when users reach a pagination trigger (e.g., "Load More" button). | Helps compare pagination click interactions vs. scrolling behavior. |

### Event Payload Structure

To ensure consistent tracking, here's a recommended event format:

```json
```

### Key Metrics to Analyze

Once tracking is in place, the following metrics provide actionable insights:

* **Next Page Click Rate** → Percentage of users who click the "Next" button.
* **Page Jump Rate** → Percentage of users who select a specific page instead of clicking "Next."
* **Backward Navigation Rate** → Percentage of users who click "Previous" or navigate back to earlier pages.
* **Deep Pagination Engagement** → How far users go into paginated content (e.g., do they go past page 3?).
* **First vs. Last Page Access Rate** → How often users jump to the first or last page.
* **Infinite Scroll vs. Pagination Click Rate** → If both options exist, measures preference for clicking pagination vs. scrolling to load more.

### Insights & Optimization Based on Tracking

By analyzing tracking data, we can optimize the pagination experience:

* 🚨 **Low Next Page Click Rate?**
  → Users may not be finding pagination useful or engaging.
  **Optimization:** Improve results per page, add stronger visual cues, or test infinite scrolling.

* ⏳ **High Page Jump Rate?**
  → Users may prefer skipping ahead rather than navigating sequentially.
  **Optimization:** Provide better filtering options or allow users to select results per page.

* 🔄 **Frequent Backward Navigation?**
  → Users might be missing important content on previous pages.
  **Optimization:** Improve sorting and relevance of content on earlier pages.

* 🔁 **Low Deep Pagination Engagement?**
  → Users rarely go beyond the first few pages.
  **Optimization:** Ensure important content isn't buried too deep or test loading more items per page.

* ⚙️ **High Infinite Scroll Usage vs. Clicks?**
  → If users prefer scrolling over clicking pagination, consider testing infinite scrolling as the default option.
  **Optimization:** Ensure infinite scroll doesn't negatively impact performance or usability.

By continuously monitoring these metrics, we can refine pagination usability, ensuring users efficiently navigate through content without frustration.

## Localization

```json
{
  "pagination": {
    "next_page": ,
    "previous_page": ,
    "page_number": ,
    "first_page": ,
    "last_page": 
  }
}
```

## Code Examples

### Basic Implementation

```html
<!-- Pagination Container -->
<nav class="pagination" aria-label="Pagination Navigation">
  <!-- Previous Button -->
  <button
    type="button"
    class="pagination-prev"
    aria-label="Previous page"
    disabled
  >
    Previous
  </button>

  <!-- Pagination Items -->
  <ul class="pagination-list">
    <li>
      <button
        type="button"
        class="pagination-item"
        aria-label="Page 1"
        aria-current="true"
      >
        1
      </button>
    </li>
    <li>
      <button type="button" class="pagination-item" aria-label="Page 2">
        2
      </button>
    </li>
    <li>
      <button type="button" class="pagination-item" aria-label="Page 3">
        3
      </button>
    </li>
    <!-- Ellipsis for additional pages, if needed -->
    <li><span class="pagination-ellipsis">…</span></li>
    <li>
      <button type="button" class="pagination-item" aria-label="Page 10">
        10
      </button>
    </li>
  </ul>

  <!-- Next Button -->
  <button type="button" class="pagination-next" aria-label="Next page">
    Next
  </button>
</nav>
```

## Accessibility

### ARIA Attributes

**Required [ARIA Attributes](/glossary/aria-attributes):**

* The container should use role="navigation" with an appropriate aria-label (e.g., "Pagination Navigation").
* Each pagination item should include aria-labels indicating the respective page number.
* Indicate the current page using aria-current="true".

### Keyboard Interaction Pattern

The following table outlines the standard keyboard interactions for pagination components:

| Key         | Action                                                   |
| ----------- | -------------------------------------------------------- |
| Tab         | Navigate among pagination controls and page buttons      |
| Enter/Space | Activate the focused pagination button                   |
| Arrow Keys  | Optionally, navigate between page items (if implemented) |

## SEO

* Use [semantic HTML](/glossary/semantic-html) (e.g., `<nav>` and lists) to help search engines understand your site structure.
* Ensure that pagination links are crawlable, improving site indexing.
* Consider implementing [progressive loading](/glossary/progressive-loading) for better performance and user experience.

## Testing Guidelines

### Functional Testing

**Should ✓**

* [ ] Verify that the pagination controls render correctly.
* [ ] Ensure clicking the Previous and Next buttons navigates to the correct pages.
* [ ] Test that the active state updates when navigating through pages.
* [ ] Confirm that disabled states (on the first or last page) are correctly implemented.

### Accessibility Testing

**Should ✓**

* [ ] Validate that the pagination container has role="navigation" and an appropriate aria-label.
* [ ] Confirm each pagination item is focusable and properly labeled.
* [ ] Ensure keyboard navigation works seamlessly with the pagination controls.
* [ ] Test that screen readers correctly announce the current page.

### Visual Testing

**Should ✓**

* [ ] Confirm that pagination controls adapt gracefully to different screen sizes.
* [ ] Verify that active and hover states are visually distinct.
* [ ] Check that pagination does not overlap or interfere with other page elements.

### Performance Testing

**Should ✓**

* [ ] Ensure that pagination does not cause significant loading delays.
* [ ] Validate that new page content loads efficiently when navigating.

## Design Tokens

These design tokens follow the [Design Tokens Format](https://design-tokens.github.io/community-group/format/) specification and can be used with various token transformation tools to generate platform-specific variables.

### Pagination Tokens in DTF Format

```json:pagination.json
{
  "$schema": "https://design-tokens.org/schema.json",
  "pagination": {
    "container": {
      "padding": ,
      "background": 
    },
    "item": {
      "size": ,
      "fontSize": ,
      "color": ,
      "activeColor": 
    },
    "button": 
  }
}
```

## Related Patterns

* [Infinite Scroll](/patterns/navigation/infinite-scroll) - An alternative to pagination for certain types of content, particularly suited for content streams or social media feeds
* [Load More](/patterns/navigation/load-more) - A simpler alternative to pagination that gives users manual control over loading additional content

## Frequently Asked Questions

`to denote navigation regions and provide ARIA attributes such as`aria-current\` for the active page. Additionally, consider using a 'Load More' button as an alternative in certain cases—see the [Load More](/patterns/navigation/load-more) pattern for best practices.",
},
,
,
,
]}
/>

## Resources

### Libraries

* [Pagination - shadcn/ui](https://ui.shadcn.com/docs/components/pagination)
* [Pagination - Origin UI](https://originui.com/pagination)


# NAVIGATION: [Sidebar](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/navigation/sidebar)

Build responsive and accessible sidebar navigation with collapsible sections and keyboard navigation support.

# Sidebar


# NAVIGATION: [Tabs](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/navigation/tabs)

Create accessible tab interfaces with keyboard navigation, ARIA attributes, and responsive design patterns.

# Tabs


# USER-FEEDBACK: [Cookie Consent](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/user-feedback/cookie-consent)

Implement effective cookie consent banners in your web applications. Learn best practices for GDPR compliance, user privacy, and consent management.

# Cookie Consent


# USER-FEEDBACK: [Empty States](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/user-feedback/empty-states)

Create effective empty state experiences in your web applications. Learn best practices for handling no-content scenarios with helpful messaging and clear actions.

# Empty States


# USER-FEEDBACK: [Loading Indicator](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/user-feedback/loading-indicator)

Build effective loading indicators for your web applications. Learn best practices for implementing loading states, spinners, and progress feedback with proper accessibility.

# Loading Indicator

***(Also called loader, loading, spinner)***

Not to be confused with [progress indicator](/patterns/user-feedback/progress-indicator).

## Overview

A **loading indicator** is a visual cue that indicates that a task is in progress.


# USER-FEEDBACK: [Notification](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/user-feedback/notification)

Implement effective notification systems in your web applications. Learn best practices for toast messages, alerts, and user notifications with proper timing and accessibility.

# Notification

***(Also called toast)***

## Overview

## Usage

* To inform the user about a change in the application
* To alert the user about an error or warning


# USER-FEEDBACK: [Progress Indicator](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/user-feedback/progress-indicator)

Create effective progress indicators for your web applications. Learn best practices for implementing progress bars, step indicators, and completion feedback with proper accessibility.

# Progress Indicator

Not to be confused with [loading indicator](/patterns/user-feedback/loading-indicator).


# USER-FEEDBACK: [Skeleton](https://ux-patterns-for-developers-khahu0xl3.vercel.app/en/patterns/user-feedback/skeleton)

Build effective skeleton loading states for your web applications. Learn best practices for implementing content placeholders and loading animations with proper accessibility.

# Skeleton
